#ifdef HAVE_OPENCV_VIDEO

// @evision enable_with: video

#ifndef EVISION_VIDEOCAPTURE_H
#define EVISION_VIDEOCAPTURE_H

// @evision c: videoCapture_waitAny,evision_cv_videoCapture_waitAny,1
// @evision nif: def videoCapture_waitAny(_opts \\ []), do: :erlang.nif_error(:undefined)
static ERL_NIF_TERM evision_cv_videoCapture_waitAny(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    int nif_opts_index = 0; // <- autogenerated value 
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    std::vector<cv::Ptr<cv::VideoCapture>> ptr_streams;
    std::vector<int> readyIndex;
    int64 timeoutNs=0;
    bool retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "streams"), ptr_streams, ArgInfo("streams", 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "timeoutNs"), timeoutNs, ArgInfo("timeoutNs", 0x8)) )
    {
        int error_flag = false;
        size_t n = ptr_streams.size();
        std::vector<cv::VideoCapture> streams;
        for (size_t i = 0; i < n; i++) {
            auto& ptr = ptr_streams[i];
            streams.emplace_back(*ptr.get());
        }

        ERRWRAP2(retval = cv::VideoCapture::waitAny(streams, readyIndex, timeoutNs), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, readyIndex);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_term != 0) return error_term;
    else return enif_make_badarg(env);
}

#endif //  EVISION_VIDEOCAPTURE_H

#endif //  HAVE_OPENCV_VIDEO
