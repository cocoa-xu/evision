#include <erl_nif.h>
#include "nif_utils.hpp"
using namespace evision::nif;
static ERL_NIF_TERM evision_cv_enabled_modules(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[]){
    const size_t num_total_modules = 64;
    size_t index = 0;

    ERL_NIF_TERM keys[num_total_modules];
    ERL_NIF_TERM values[num_total_modules];
    keys[index] = evision::nif::atom(env, "calib3d");
#ifdef HAVE_OPENCV_CALIB3D
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "core");
#ifdef HAVE_OPENCV_CORE
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "dnn");
#ifdef HAVE_OPENCV_DNN
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "features2d");
#ifdef HAVE_OPENCV_FEATURES2D
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "flann");
#ifdef HAVE_OPENCV_FLANN
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "highgui");
#ifdef HAVE_OPENCV_HIGHGUI
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "imgcodecs");
#ifdef HAVE_OPENCV_IMGCODECS
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "imgproc");
#ifdef HAVE_OPENCV_IMGPROC
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "ml");
#ifdef HAVE_OPENCV_ML
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "photo");
#ifdef HAVE_OPENCV_PHOTO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "stitching");
#ifdef HAVE_OPENCV_STITCHING
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "ts");
#ifdef HAVE_OPENCV_TS
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "video");
#ifdef HAVE_OPENCV_VIDEO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "videoio");
#ifdef HAVE_OPENCV_VIDEOIO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "gapi");
#ifdef HAVE_OPENCV_GAPI
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "world");
#ifdef HAVE_OPENCV_WORLD
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "python2");
#ifdef HAVE_OPENCV_PYTHON2
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "python3");
#ifdef HAVE_OPENCV_PYTHON3
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "java");
#ifdef HAVE_OPENCV_JAVA
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "aruco");
#ifdef HAVE_OPENCV_ARUCO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "barcode");
#ifdef HAVE_OPENCV_BARCODE
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "bgsegm");
#ifdef HAVE_OPENCV_BGSEGM
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "bioinspired");
#ifdef HAVE_OPENCV_BIOINSPIRED
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "dnn_superres");
#ifdef HAVE_OPENCV_DNN_SUPERRES
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "face");
#ifdef HAVE_OPENCV_FACE
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "hfs");
#ifdef HAVE_OPENCV_HFS
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "img_hash");
#ifdef HAVE_OPENCV_IMG_HASH
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "line_descriptor");
#ifdef HAVE_OPENCV_LINE_DESCRIPTOR
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "mcc");
#ifdef HAVE_OPENCV_MCC
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "plot");
#ifdef HAVE_OPENCV_PLOT
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "quality");
#ifdef HAVE_OPENCV_QUALITY
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "rapid");
#ifdef HAVE_OPENCV_RAPID
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "reg");
#ifdef HAVE_OPENCV_REG
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "rgbd");
#ifdef HAVE_OPENCV_RGBD
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "saliency");
#ifdef HAVE_OPENCV_SALIENCY
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "shape");
#ifdef HAVE_OPENCV_SHAPE
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "stereo");
#ifdef HAVE_OPENCV_STEREO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "structured_light");
#ifdef HAVE_OPENCV_STRUCTURED_LIGHT
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "surface_matching");
#ifdef HAVE_OPENCV_SURFACE_MATCHING
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "text");
#ifdef HAVE_OPENCV_TEXT
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "tracking");
#ifdef HAVE_OPENCV_TRACKING
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "wechat_qrcode");
#ifdef HAVE_OPENCV_WECHAT_QRCODE
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "xfeatures2d");
#ifdef HAVE_OPENCV_XFEATURES2D
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "ximgproc");
#ifdef HAVE_OPENCV_XIMGPROC
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "xphoto");
#ifdef HAVE_OPENCV_XPHOTO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "datasets");
#ifdef HAVE_OPENCV_DATASETS
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "dnn_objdetect");
#ifdef HAVE_OPENCV_DNN_OBJDETECT
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "dpm");
#ifdef HAVE_OPENCV_DPM
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "optflow");
#ifdef HAVE_OPENCV_OPTFLOW
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "sfm");
#ifdef HAVE_OPENCV_SFM
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "videostab");
#ifdef HAVE_OPENCV_VIDEOSTAB
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "xobjdetect");
#ifdef HAVE_OPENCV_XOBJDETECT
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudaarithm");
#ifdef HAVE_OPENCV_CUDAARITHM
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudabgsegm");
#ifdef HAVE_OPENCV_CUDABGSEGM
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudacodec");
#ifdef HAVE_OPENCV_CUDACODEC
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudafeatures2d");
#ifdef HAVE_OPENCV_CUDAFEATURES2D
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudafilters");
#ifdef HAVE_OPENCV_CUDAFILTERS
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudaimgproc");
#ifdef HAVE_OPENCV_CUDAIMGPROC
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudalegacy");
#ifdef HAVE_OPENCV_CUDALEGACY
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudaobjdetect");
#ifdef HAVE_OPENCV_CUDAOBJDETECT
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudaoptflow");
#ifdef HAVE_OPENCV_CUDAOPTFLOW
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudastereo");
#ifdef HAVE_OPENCV_CUDASTEREO
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudawarping");
#ifdef HAVE_OPENCV_CUDAWARPING
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    keys[index] = evision::nif::atom(env, "cudev");
#ifdef HAVE_OPENCV_CUDEV
    values[index] = evision::nif::atom(env, "true");
#else
    values[index] = evision::nif::atom(env, "false");
#endif
    index++;
    ERL_NIF_TERM map;
    if (enif_make_map_from_arrays(env, keys, values, index, &map)) {
        return map;
    } else {
        return evision::nif::error(env, "enif_make_map_from_arrays failed in evision_from_as_map");
    }
}
static ERL_NIF_TERM evision_cv_akaze_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<AKAZE_DescriptorType> descriptor_type=static_cast<std::underlying_type_t<AKAZE_DescriptorType>>(AKAZE::DESCRIPTOR_MLDB);
    int descriptor_size=0;
    int descriptor_channels=3;
    float threshold=0.001f;
    int nOctaves=4;
    int nOctaveLayers=4;
    std::underlying_type_t<KAZE_DiffusivityType> diffusivity=static_cast<std::underlying_type_t<KAZE_DiffusivityType>>(KAZE::DIFF_PM_G2);
    Ptr<AKAZE> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptor_type"), descriptor_type, ArgInfo("descriptor_type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptor_size"), descriptor_size, ArgInfo("descriptor_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptor_channels"), descriptor_channels, ArgInfo("descriptor_channels", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), nOctaves, ArgInfo("nOctaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diffusivity"), diffusivity, ArgInfo("diffusivity", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::AKAZE::create(static_cast<AKAZE_DescriptorType>(descriptor_type), descriptor_size, descriptor_channels, threshold, nOctaves, nOctaveLayers, static_cast<KAZE_DiffusivityType>(diffusivity)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_affineFeature_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Feature2D> backend;
    int maxTilt=5;
    int minTilt=0;
    float tiltStep=1.4142135623730951f;
    float rotateStepBase=72;
    Ptr<AffineFeature> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backend"), backend, ArgInfo("backend", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxTilt"), maxTilt, ArgInfo("maxTilt", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minTilt"), minTilt, ArgInfo("minTilt", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tiltStep"), tiltStep, ArgInfo("tiltStep", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotateStepBase"), rotateStepBase, ArgInfo("rotateStepBase", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::AffineFeature::create(backend, maxTilt, minTilt, tiltStep, rotateStepBase), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_agastFeatureDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int threshold=10;
    bool nonmaxSuppression=true;
    std::underlying_type_t<AgastFeatureDetector_DetectorType> type=static_cast<std::underlying_type_t<AgastFeatureDetector_DetectorType>>(AgastFeatureDetector::OAST_9_16);
    Ptr<AgastFeatureDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonmaxSuppression"), nonmaxSuppression, ArgInfo("nonmaxSuppression", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::AgastFeatureDetector::create(threshold, nonmaxSuppression, static_cast<AgastFeatureDetector_DetectorType>(type)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bfMatcher_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int normType=NORM_L2;
    bool crossCheck=false;
    Ptr<BFMatcher> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crossCheck"), crossCheck, ArgInfo("crossCheck", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::BFMatcher::create(normType, crossCheck), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_brisk_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int thresh;
    int octaves;
    vector_float radiusList;
    vector_int numberList;
    float dMax=5.85f;
    float dMin=8.2f;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radiusList"), radiusList, ArgInfo("radiusList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberList"), numberList, ArgInfo("numberList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMax"), dMax, ArgInfo("dMax", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMin"), dMin, ArgInfo("dMin", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indexChange"), indexChange, ArgInfo("indexChange", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::BRISK::create(thresh, octaves, radiusList, numberList, dMax, dMin, indexChange), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_float radiusList;
    vector_int numberList;
    float dMax=5.85f;
    float dMin=8.2f;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radiusList"), radiusList, ArgInfo("radiusList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberList"), numberList, ArgInfo("numberList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMax"), dMax, ArgInfo("dMax", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dMin"), dMin, ArgInfo("dMin", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "indexChange"), indexChange, ArgInfo("indexChange", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::BRISK::create(radiusList, numberList, dMax, dMin, indexChange), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int thresh=30;
    int octaves=3;
    float patternScale=1.0f;
    Ptr<BRISK> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octaves"), octaves, ArgInfo("octaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternScale"), patternScale, ArgInfo("patternScale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::BRISK::create(thresh, octaves, patternScale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_camShift(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat probImage;
    Rect window;
    TermCriteria criteria;
    RotatedRect retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probImage"), probImage, ArgInfo("probImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window"), window, ArgInfo("window", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::CamShift(probImage, window, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, window));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_probImage;
    Rect window;
    TermCriteria criteria;
    RotatedRect retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probImage"), ptr_probImage, ArgInfo("probImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window"), window, ArgInfo("window", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
            UMat probImage; if (ptr_probImage.get()) { probImage = *ptr_probImage.get(); }
    
        ERRWRAP2(retval = cv::CamShift(probImage, window, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, window));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_canny(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat dx;
    Mat dy;
    Mat edges;
    double threshold1;
    double threshold2;
    bool L2gradient=false;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), edges, ArgInfo("edges", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold1"), threshold1, ArgInfo("threshold1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold2"), threshold2, ArgInfo("threshold2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "l2gradient"), L2gradient, ArgInfo("L2gradient", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::Canny(dx, dy, edges, threshold1, threshold2, L2gradient), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, edges);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_dx;
    Ptr<UMat> ptr_dy;
    Ptr<UMat> ptr_edges;
    double threshold1;
    double threshold2;
    bool L2gradient=false;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), ptr_dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), ptr_dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), ptr_edges, ArgInfo("edges", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold1"), threshold1, ArgInfo("threshold1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold2"), threshold2, ArgInfo("threshold2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "l2gradient"), L2gradient, ArgInfo("L2gradient", 0, 1)) )
    {
        error_flag = false;
            UMat dx; if (ptr_dx.get()) { dx = *ptr_dx.get(); }
        UMat dy; if (ptr_dy.get()) { dy = *ptr_dy.get(); }
        UMat edges; if (ptr_edges.get()) { edges = *ptr_edges.get(); }
    
        ERRWRAP2(cv::Canny(dx, dy, edges, threshold1, threshold2, L2gradient), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, edges);
        }
    }

    }
    

    {
    Mat image;
    Mat edges;
    double threshold1;
    double threshold2;
    int apertureSize=3;
    bool L2gradient=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), edges, ArgInfo("edges", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold1"), threshold1, ArgInfo("threshold1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold2"), threshold2, ArgInfo("threshold2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureSize"), apertureSize, ArgInfo("apertureSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "l2gradient"), L2gradient, ArgInfo("L2gradient", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::Canny(image, edges, threshold1, threshold2, apertureSize, L2gradient), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, edges);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_edges;
    double threshold1;
    double threshold2;
    int apertureSize=3;
    bool L2gradient=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edges"), ptr_edges, ArgInfo("edges", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold1"), threshold1, ArgInfo("threshold1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold2"), threshold2, ArgInfo("threshold2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureSize"), apertureSize, ArgInfo("apertureSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "l2gradient"), L2gradient, ArgInfo("L2gradient", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat edges; if (ptr_edges.get()) { edges = *ptr_edges.get(); }
    
        ERRWRAP2(cv::Canny(image, edges, threshold1, threshold2, apertureSize, L2gradient), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, edges);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cascadeClassifier_convert(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String oldcascade;
    String newcascade;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "oldcascade"), oldcascade, ArgInfo("oldcascade", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newcascade"), newcascade, ArgInfo("newcascade", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::CascadeClassifier::convert(oldcascade, newcascade), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_disOpticalFlow_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int preset=DISOpticalFlow::PRESET_FAST;
    Ptr<DISOpticalFlow> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "preset"), preset, ArgInfo("preset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::DISOpticalFlow::create(preset), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_descriptorMatcher_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    std::underlying_type_t<DescriptorMatcher_MatcherType> matcherType=static_cast<std::underlying_type_t<DescriptorMatcher_MatcherType>>(static_cast<DescriptorMatcher_MatcherType>(0));
    Ptr<DescriptorMatcher> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matcherType"), matcherType, ArgInfo("matcherType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::DescriptorMatcher::create(static_cast<DescriptorMatcher_MatcherType>(matcherType)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String descriptorMatcherType;
    Ptr<DescriptorMatcher> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptorMatcherType"), descriptorMatcherType, ArgInfo("descriptorMatcherType", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::DescriptorMatcher::create(descriptorMatcherType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_emd(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat signature1;
    Mat signature2;
    int distType;
    Mat cost;
    Ptr<float> lowerBound;
    Mat flow;
    float retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signature1"), signature1, ArgInfo("signature1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signature2"), signature2, ArgInfo("signature2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cost"), cost, ArgInfo("cost", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lowerBound"), lowerBound, ArgInfo("lowerBound", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), flow, ArgInfo("flow", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::wrapperEMD(signature1, signature2, distType, cost, lowerBound, flow), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, lowerBound), evision_from(env, flow));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_signature1;
    Ptr<UMat> ptr_signature2;
    int distType;
    Ptr<UMat> ptr_cost;
    Ptr<float> lowerBound;
    Ptr<UMat> ptr_flow;
    float retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signature1"), ptr_signature1, ArgInfo("signature1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signature2"), ptr_signature2, ArgInfo("signature2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cost"), ptr_cost, ArgInfo("cost", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lowerBound"), lowerBound, ArgInfo("lowerBound", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), ptr_flow, ArgInfo("flow", 1, 1)) )
    {
        error_flag = false;
            UMat signature1; if (ptr_signature1.get()) { signature1 = *ptr_signature1.get(); }
        UMat signature2; if (ptr_signature2.get()) { signature2 = *ptr_signature2.get(); }
        UMat cost; if (ptr_cost.get()) { cost = *ptr_cost.get(); }
        UMat flow; if (ptr_flow.get()) { flow = *ptr_flow.get(); }
    
        ERRWRAP2(retval = cv::wrapperEMD(signature1, signature2, distType, cost, lowerBound, flow), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, lowerBound), evision_from(env, flow));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceDetectorYN_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String model;
    String config;
    Size input_size;
    float score_threshold=0.9f;
    float nms_threshold=0.3f;
    int top_k=5000;
    int backend_id=0;
    int target_id=0;
    Ptr<FaceDetectorYN> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input_size"), input_size, ArgInfo("input_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backend_id"), backend_id, ArgInfo("backend_id", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "target_id"), target_id, ArgInfo("target_id", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::FaceDetectorYN::create(model, config, input_size, score_threshold, nms_threshold, top_k, backend_id, target_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_faceRecognizerSF_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String model;
    String config;
    int backend_id=0;
    int target_id=0;
    Ptr<FaceRecognizerSF> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backend_id"), backend_id, ArgInfo("backend_id", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "target_id"), target_id, ArgInfo("target_id", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::FaceRecognizerSF::create(model, config, backend_id, target_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_farnebackOpticalFlow_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int numLevels=5;
    double pyrScale=0.5;
    bool fastPyramids=false;
    int winSize=13;
    int numIters=10;
    int polyN=5;
    double polySigma=1.1;
    int flags=0;
    Ptr<FarnebackOpticalFlow> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numLevels"), numLevels, ArgInfo("numLevels", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyrScale"), pyrScale, ArgInfo("pyrScale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fastPyramids"), fastPyramids, ArgInfo("fastPyramids", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "polyN"), polyN, ArgInfo("polyN", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "polySigma"), polySigma, ArgInfo("polySigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::FarnebackOpticalFlow::create(numLevels, pyrScale, fastPyramids, winSize, numIters, polyN, polySigma, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastFeatureDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int threshold=10;
    bool nonmaxSuppression=true;
    std::underlying_type_t<FastFeatureDetector_DetectorType> type=static_cast<std::underlying_type_t<FastFeatureDetector_DetectorType>>(FastFeatureDetector::TYPE_9_16);
    Ptr<FastFeatureDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonmaxSuppression"), nonmaxSuppression, ArgInfo("nonmaxSuppression", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::FastFeatureDetector::create(threshold, nonmaxSuppression, static_cast<FastFeatureDetector_DetectorType>(type)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flannBasedMatcher_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<FlannBasedMatcher> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::FlannBasedMatcher::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gfttDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int maxCorners;
    double qualityLevel;
    double minDistance;
    int blockSize;
    int gradiantSize;
    bool useHarrisDetector=false;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradiantSize"), gradiantSize, ArgInfo("gradiantSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int maxCorners=1000;
    double qualityLevel=0.01;
    double minDistance=1;
    int blockSize=3;
    bool useHarrisDetector=false;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gaussianBlur(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size ksize;
    double sigmaX;
    double sigmaY=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaX"), sigmaX, ArgInfo("sigmaX", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaY"), sigmaY, ArgInfo("sigmaY", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::GaussianBlur(src, dst, ksize, sigmaX, sigmaY, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size ksize;
    double sigmaX;
    double sigmaY=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaX"), sigmaX, ArgInfo("sigmaX", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaY"), sigmaY, ArgInfo("sigmaY", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::GaussianBlur(src, dst, ksize, sigmaX, sigmaY, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_getDaimlerPeopleDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::vector<float> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::HOGDescriptor::getDaimlerPeopleDetector(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hogDescriptor_getDefaultPeopleDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::vector<float> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::HOGDescriptor::getDefaultPeopleDetector(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_houghCircles(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat circles;
    int method;
    double dp;
    double minDist;
    double param1=100;
    double param2=100;
    int minRadius=0;
    int maxRadius=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "circles"), circles, ArgInfo("circles", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dp"), dp, ArgInfo("dp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDist"), minDist, ArgInfo("minDist", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param1"), param1, ArgInfo("param1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param2"), param2, ArgInfo("param2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minRadius"), minRadius, ArgInfo("minRadius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxRadius"), maxRadius, ArgInfo("maxRadius", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::HoughCircles(image, circles, method, dp, minDist, param1, param2, minRadius, maxRadius), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, circles);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_circles;
    int method;
    double dp;
    double minDist;
    double param1=100;
    double param2=100;
    int minRadius=0;
    int maxRadius=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "circles"), ptr_circles, ArgInfo("circles", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dp"), dp, ArgInfo("dp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDist"), minDist, ArgInfo("minDist", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param1"), param1, ArgInfo("param1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param2"), param2, ArgInfo("param2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minRadius"), minRadius, ArgInfo("minRadius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxRadius"), maxRadius, ArgInfo("maxRadius", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat circles; if (ptr_circles.get()) { circles = *ptr_circles.get(); }
    
        ERRWRAP2(cv::HoughCircles(image, circles, method, dp, minDist, param1, param2, minRadius, maxRadius), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, circles);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_houghLines(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat lines;
    double rho;
    double theta;
    int threshold;
    double srn=0;
    double stn=0;
    double min_theta=0;
    double max_theta=CV_PI;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho"), rho, ArgInfo("rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srn"), srn, ArgInfo("srn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stn"), stn, ArgInfo("stn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_theta"), min_theta, ArgInfo("min_theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_theta"), max_theta, ArgInfo("max_theta", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::HoughLines(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_lines;
    double rho;
    double theta;
    int threshold;
    double srn=0;
    double stn=0;
    double min_theta=0;
    double max_theta=CV_PI;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), ptr_lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho"), rho, ArgInfo("rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srn"), srn, ArgInfo("srn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stn"), stn, ArgInfo("stn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_theta"), min_theta, ArgInfo("min_theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_theta"), max_theta, ArgInfo("max_theta", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat lines; if (ptr_lines.get()) { lines = *ptr_lines.get(); }
    
        ERRWRAP2(cv::HoughLines(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_houghLinesP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat lines;
    double rho;
    double theta;
    int threshold;
    double minLineLength=0;
    double maxLineGap=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho"), rho, ArgInfo("rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minLineLength"), minLineLength, ArgInfo("minLineLength", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLineGap"), maxLineGap, ArgInfo("maxLineGap", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::HoughLinesP(image, lines, rho, theta, threshold, minLineLength, maxLineGap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_lines;
    double rho;
    double theta;
    int threshold;
    double minLineLength=0;
    double maxLineGap=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), ptr_lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho"), rho, ArgInfo("rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minLineLength"), minLineLength, ArgInfo("minLineLength", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLineGap"), maxLineGap, ArgInfo("maxLineGap", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat lines; if (ptr_lines.get()) { lines = *ptr_lines.get(); }
    
        ERRWRAP2(cv::HoughLinesP(image, lines, rho, theta, threshold, minLineLength, maxLineGap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_houghLinesPointSet(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat point;
    Mat lines;
    int lines_max;
    int threshold;
    double min_rho;
    double max_rho;
    double rho_step;
    double min_theta;
    double max_theta;
    double theta_step;

    if( num_kw_args >= 9 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "point"), point, ArgInfo("point", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines_max"), lines_max, ArgInfo("lines_max", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_rho"), min_rho, ArgInfo("min_rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_rho"), max_rho, ArgInfo("max_rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho_step"), rho_step, ArgInfo("rho_step", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_theta"), min_theta, ArgInfo("min_theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_theta"), max_theta, ArgInfo("max_theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta_step"), theta_step, ArgInfo("theta_step", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::HoughLinesPointSet(point, lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_point;
    Ptr<UMat> ptr_lines;
    int lines_max;
    int threshold;
    double min_rho;
    double max_rho;
    double rho_step;
    double min_theta;
    double max_theta;
    double theta_step;

    if( num_kw_args >= 9 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "point"), ptr_point, ArgInfo("point", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), ptr_lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines_max"), lines_max, ArgInfo("lines_max", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_rho"), min_rho, ArgInfo("min_rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_rho"), max_rho, ArgInfo("max_rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho_step"), rho_step, ArgInfo("rho_step", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_theta"), min_theta, ArgInfo("min_theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_theta"), max_theta, ArgInfo("max_theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta_step"), theta_step, ArgInfo("theta_step", 0, 0)) )
    {
        error_flag = false;
            UMat point; if (ptr_point.get()) { point = *ptr_point.get(); }
        UMat lines; if (ptr_lines.get()) { lines = *ptr_lines.get(); }
    
        ERRWRAP2(cv::HoughLinesPointSet(point, lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_houghLinesWithAccumulator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat lines;
    double rho;
    double theta;
    int threshold;
    double srn=0;
    double stn=0;
    double min_theta=0;
    double max_theta=CV_PI;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho"), rho, ArgInfo("rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srn"), srn, ArgInfo("srn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stn"), stn, ArgInfo("stn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_theta"), min_theta, ArgInfo("min_theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_theta"), max_theta, ArgInfo("max_theta", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::HoughLinesWithAccumulator(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_lines;
    double rho;
    double theta;
    int threshold;
    double srn=0;
    double stn=0;
    double min_theta=0;
    double max_theta=CV_PI;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), ptr_lines, ArgInfo("lines", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rho"), rho, ArgInfo("rho", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srn"), srn, ArgInfo("srn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stn"), stn, ArgInfo("stn", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_theta"), min_theta, ArgInfo("min_theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_theta"), max_theta, ArgInfo("max_theta", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat lines; if (ptr_lines.get()) { lines = *ptr_lines.get(); }
    
        ERRWRAP2(cv::HoughLinesWithAccumulator(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_huMoments(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<Moments> ptr_m;
    Mat hu;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_m, ArgInfo("m", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hu"), hu, ArgInfo("hu", 1, 0)) )
    {
        error_flag = false;
            Moments m; if (ptr_m.get()) { m = *ptr_m.get(); }
    
        ERRWRAP2(cv::HuMoments(m, hu), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, hu);
        }
    }

    }
    

    {
    Ptr<Moments> ptr_m;
    Ptr<UMat> ptr_hu;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_m, ArgInfo("m", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hu"), ptr_hu, ArgInfo("hu", 1, 0)) )
    {
        error_flag = false;
            Moments m; if (ptr_m.get()) { m = *ptr_m.get(); }
        UMat hu; if (ptr_hu.get()) { hu = *ptr_hu.get(); }
    
        ERRWRAP2(cv::HuMoments(m, hu), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, hu);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kaze_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool extended=false;
    bool upright=false;
    float threshold=0.001f;
    int nOctaves=4;
    int nOctaveLayers=4;
    std::underlying_type_t<KAZE_DiffusivityType> diffusivity=static_cast<std::underlying_type_t<KAZE_DiffusivityType>>(KAZE::DIFF_PM_G2);
    Ptr<KAZE> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "extended"), extended, ArgInfo("extended", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upright"), upright, ArgInfo("upright", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), nOctaves, ArgInfo("nOctaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diffusivity"), diffusivity, ArgInfo("diffusivity", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::KAZE::create(extended, upright, threshold, nOctaves, nOctaveLayers, static_cast<KAZE_DiffusivityType>(diffusivity)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_keyPoint_convert(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Point2f points2f;
    vector_KeyPoint keypoints;
    float size=1;
    float response=1;
    int octave=0;
    int class_id=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2f"), points2f, ArgInfo("points2f", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "octave"), octave, ArgInfo("octave", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "class_id"), class_id, ArgInfo("class_id", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::KeyPoint::convert(points2f, keypoints, size, response, octave, class_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, keypoints);
        }
    }

    }
    

    {
    vector_KeyPoint keypoints;
    vector_Point2f points2f;
    vector_int keypointIndexes=std::vector<int>();

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypointIndexes"), keypointIndexes, ArgInfo("keypointIndexes", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::KeyPoint::convert(keypoints, points2f, keypointIndexes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points2f);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_keyPoint_overlap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    KeyPoint kp1;
    KeyPoint kp2;
    float retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kp1"), kp1, ArgInfo("kp1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kp2"), kp2, ArgInfo("kp2", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::KeyPoint::overlap(kp1, kp2), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_lut(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat lut;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lut"), lut, ArgInfo("lut", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::LUT(src, lut, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_lut;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lut"), ptr_lut, ArgInfo("lut", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat lut; if (ptr_lut.get()) { lut = *ptr_lut.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::LUT(src, lut, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_laplacian(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    int ksize=1;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::Laplacian(src, dst, ddepth, ksize, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    int ksize=1;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::Laplacian(src, dst, ddepth, ksize, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mser_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int delta=5;
    int min_area=60;
    int max_area=14400;
    double max_variation=0.25;
    double min_diversity=.2;
    int max_evolution=200;
    double area_threshold=1.01;
    double min_margin=0.003;
    int edge_blur_size=5;
    Ptr<MSER> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_area"), min_area, ArgInfo("min_area", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_area"), max_area, ArgInfo("max_area", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_variation"), max_variation, ArgInfo("max_variation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_diversity"), min_diversity, ArgInfo("min_diversity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_evolution"), max_evolution, ArgInfo("max_evolution", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "area_threshold"), area_threshold, ArgInfo("area_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_margin"), min_margin, ArgInfo("min_margin", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edge_blur_size"), edge_blur_size, ArgInfo("edge_blur_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::MSER::create(delta, min_area, max_area, max_variation, min_diversity, max_evolution, area_threshold, min_margin, edge_blur_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mahalanobis(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat v1;
    Mat v2;
    Mat icovar;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "v1"), v1, ArgInfo("v1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "v2"), v2, ArgInfo("v2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "icovar"), icovar, ArgInfo("icovar", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::Mahalanobis(v1, v2, icovar), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_v1;
    Ptr<UMat> ptr_v2;
    Ptr<UMat> ptr_icovar;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "v1"), ptr_v1, ArgInfo("v1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "v2"), ptr_v2, ArgInfo("v2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "icovar"), ptr_icovar, ArgInfo("icovar", 0, 0)) )
    {
        error_flag = false;
            UMat v1; if (ptr_v1.get()) { v1 = *ptr_v1.get(); }
        UMat v2; if (ptr_v2.get()) { v2 = *ptr_v2.get(); }
        UMat icovar; if (ptr_icovar.get()) { icovar = *ptr_icovar.get(); }
    
        ERRWRAP2(retval = cv::Mahalanobis(v1, v2, icovar), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_orb_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nfeatures=500;
    float scaleFactor=1.2f;
    int nlevels=8;
    int edgeThreshold=31;
    int firstLevel=0;
    int WTA_K=2;
    std::underlying_type_t<ORB_ScoreType> scoreType=static_cast<std::underlying_type_t<ORB_ScoreType>>(ORB::HARRIS_SCORE);
    int patchSize=31;
    int fastThreshold=20;
    Ptr<ORB> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleFactor"), scaleFactor, ArgInfo("scaleFactor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nlevels"), nlevels, ArgInfo("nlevels", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "firstLevel"), firstLevel, ArgInfo("firstLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "wTA_K"), WTA_K, ArgInfo("WTA_K", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scoreType"), scoreType, ArgInfo("scoreType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patchSize"), patchSize, ArgInfo("patchSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fastThreshold"), fastThreshold, ArgInfo("fastThreshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ORB::create(nfeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, WTA_K, static_cast<ORB_ScoreType>(scoreType), patchSize, fastThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pcaBackProject(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat data;
    Mat mean;
    Mat eigenvectors;
    Mat result;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::PCABackProject(data, mean, eigenvectors, result), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_eigenvectors;
    Ptr<UMat> ptr_result;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), ptr_result, ArgInfo("result", 1, 0)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
        UMat result; if (ptr_result.get()) { result = *ptr_result.get(); }
    
        ERRWRAP2(cv::PCABackProject(data, mean, eigenvectors, result), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pcaCompute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat data;
    Mat mean;
    Mat eigenvectors;
    double retainedVariance;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "retainedVariance"), retainedVariance, ArgInfo("retainedVariance", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, retainedVariance), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, mean), evision_from(env, eigenvectors));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_eigenvectors;
    double retainedVariance;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "retainedVariance"), retainedVariance, ArgInfo("retainedVariance", 0, 0)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
    
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, retainedVariance), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, mean), evision_from(env, eigenvectors));
        }
    }

    }
    

    {
    Mat data;
    Mat mean;
    Mat eigenvectors;
    int maxComponents=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxComponents"), maxComponents, ArgInfo("maxComponents", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, maxComponents), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, mean), evision_from(env, eigenvectors));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_eigenvectors;
    int maxComponents=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxComponents"), maxComponents, ArgInfo("maxComponents", 0, 1)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
    
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, maxComponents), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, mean), evision_from(env, eigenvectors));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pcaCompute2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat data;
    Mat mean;
    Mat eigenvectors;
    Mat eigenvalues;
    double retainedVariance;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "retainedVariance"), retainedVariance, ArgInfo("retainedVariance", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, eigenvalues, retainedVariance), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, mean), evision_from(env, eigenvectors), evision_from(env, eigenvalues));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_eigenvectors;
    Ptr<UMat> ptr_eigenvalues;
    double retainedVariance;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), ptr_eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "retainedVariance"), retainedVariance, ArgInfo("retainedVariance", 0, 0)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
        UMat eigenvalues; if (ptr_eigenvalues.get()) { eigenvalues = *ptr_eigenvalues.get(); }
    
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, eigenvalues, retainedVariance), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, mean), evision_from(env, eigenvectors), evision_from(env, eigenvalues));
        }
    }

    }
    

    {
    Mat data;
    Mat mean;
    Mat eigenvectors;
    Mat eigenvalues;
    int maxComponents=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxComponents"), maxComponents, ArgInfo("maxComponents", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, eigenvalues, maxComponents), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, mean), evision_from(env, eigenvectors), evision_from(env, eigenvalues));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_eigenvectors;
    Ptr<UMat> ptr_eigenvalues;
    int maxComponents=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), ptr_eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxComponents"), maxComponents, ArgInfo("maxComponents", 0, 1)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
        UMat eigenvalues; if (ptr_eigenvalues.get()) { eigenvalues = *ptr_eigenvalues.get(); }
    
        ERRWRAP2(cv::PCACompute(data, mean, eigenvectors, eigenvalues, maxComponents), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, mean), evision_from(env, eigenvectors), evision_from(env, eigenvalues));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pcaProject(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat data;
    Mat mean;
    Mat eigenvectors;
    Mat result;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::PCAProject(data, mean, eigenvectors, result), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_eigenvectors;
    Ptr<UMat> ptr_result;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), ptr_result, ArgInfo("result", 1, 0)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
        UMat result; if (ptr_result.get()) { result = *ptr_result.get(); }
    
        ERRWRAP2(cv::PCAProject(data, mean, eigenvectors, result), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_psnr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    double R=255.;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::PSNR(src1, src2, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    double R=255.;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
    
        ERRWRAP2(retval = cv::PSNR(src1, src2, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_qrCodeEncoder_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    QRCodeEncoder::Params parameters=QRCodeEncoder::Params();
    Ptr<QRCodeEncoder> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::QRCodeEncoder::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rqDecomp3x3(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat mtxR;
    Mat mtxQ;
    Mat Qx;
    Mat Qy;
    Mat Qz;
    Vec3d retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtxR"), mtxR, ArgInfo("mtxR", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtxQ"), mtxQ, ArgInfo("mtxQ", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qx"), Qx, ArgInfo("Qx", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qy"), Qy, ArgInfo("Qy", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qz"), Qz, ArgInfo("Qz", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::RQDecomp3x3(src, mtxR, mtxQ, Qx, Qy, Qz), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple6(env, evision_from(env, retval), evision_from(env, mtxR), evision_from(env, mtxQ), evision_from(env, Qx), evision_from(env, Qy), evision_from(env, Qz));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_mtxR;
    Ptr<UMat> ptr_mtxQ;
    Ptr<UMat> ptr_Qx;
    Ptr<UMat> ptr_Qy;
    Ptr<UMat> ptr_Qz;
    Vec3d retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtxR"), ptr_mtxR, ArgInfo("mtxR", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtxQ"), ptr_mtxQ, ArgInfo("mtxQ", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qx"), ptr_Qx, ArgInfo("Qx", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qy"), ptr_Qy, ArgInfo("Qy", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qz"), ptr_Qz, ArgInfo("Qz", 1, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mtxR; if (ptr_mtxR.get()) { mtxR = *ptr_mtxR.get(); }
        UMat mtxQ; if (ptr_mtxQ.get()) { mtxQ = *ptr_mtxQ.get(); }
        UMat Qx; if (ptr_Qx.get()) { Qx = *ptr_Qx.get(); }
        UMat Qy; if (ptr_Qy.get()) { Qy = *ptr_Qy.get(); }
        UMat Qz; if (ptr_Qz.get()) { Qz = *ptr_Qz.get(); }
    
        ERRWRAP2(retval = cv::RQDecomp3x3(src, mtxR, mtxQ, Qx, Qy, Qz), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple6(env, evision_from(env, retval), evision_from(env, mtxR), evision_from(env, mtxQ), evision_from(env, Qx), evision_from(env, Qy), evision_from(env, Qz));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rodrigues(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat jacobian;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), jacobian, ArgInfo("jacobian", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::Rodrigues(src, dst, jacobian), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, jacobian));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_jacobian;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), ptr_jacobian, ArgInfo("jacobian", 1, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat jacobian; if (ptr_jacobian.get()) { jacobian = *ptr_jacobian.get(); }
    
        ERRWRAP2(cv::Rodrigues(src, dst, jacobian), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, jacobian));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sift_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int nfeatures;
    int nOctaveLayers;
    double contrastThreshold;
    double edgeThreshold;
    double sigma;
    int descriptorType;
    bool enable_precise_upscale=false;
    Ptr<SIFT> retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contrastThreshold"), contrastThreshold, ArgInfo("contrastThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "descriptorType"), descriptorType, ArgInfo("descriptorType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "enable_precise_upscale"), enable_precise_upscale, ArgInfo("enable_precise_upscale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, descriptorType, enable_precise_upscale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int nfeatures=0;
    int nOctaveLayers=3;
    double contrastThreshold=0.04;
    double edgeThreshold=10;
    double sigma=1.6;
    bool enable_precise_upscale=false;
    Ptr<SIFT> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contrastThreshold"), contrastThreshold, ArgInfo("contrastThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "enable_precise_upscale"), enable_precise_upscale, ArgInfo("enable_precise_upscale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, enable_precise_upscale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_svBackSubst(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat w;
    Mat u;
    Mat vt;
    Mat rhs;
    Mat dst;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "w"), w, ArgInfo("w", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "u"), u, ArgInfo("u", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vt"), vt, ArgInfo("vt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rhs"), rhs, ArgInfo("rhs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::SVBackSubst(w, u, vt, rhs, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_w;
    Ptr<UMat> ptr_u;
    Ptr<UMat> ptr_vt;
    Ptr<UMat> ptr_rhs;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "w"), ptr_w, ArgInfo("w", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "u"), ptr_u, ArgInfo("u", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vt"), ptr_vt, ArgInfo("vt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rhs"), ptr_rhs, ArgInfo("rhs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat w; if (ptr_w.get()) { w = *ptr_w.get(); }
        UMat u; if (ptr_u.get()) { u = *ptr_u.get(); }
        UMat vt; if (ptr_vt.get()) { vt = *ptr_vt.get(); }
        UMat rhs; if (ptr_rhs.get()) { rhs = *ptr_rhs.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::SVBackSubst(w, u, vt, rhs, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_svdDecomp(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat w;
    Mat u;
    Mat vt;
    int flags=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "w"), w, ArgInfo("w", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "u"), u, ArgInfo("u", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vt"), vt, ArgInfo("vt", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::SVDecomp(src, w, u, vt, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, w), evision_from(env, u), evision_from(env, vt));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_w;
    Ptr<UMat> ptr_u;
    Ptr<UMat> ptr_vt;
    int flags=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "w"), ptr_w, ArgInfo("w", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "u"), ptr_u, ArgInfo("u", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vt"), ptr_vt, ArgInfo("vt", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat w; if (ptr_w.get()) { w = *ptr_w.get(); }
        UMat u; if (ptr_u.get()) { u = *ptr_u.get(); }
        UMat vt; if (ptr_vt.get()) { vt = *ptr_vt.get(); }
    
        ERRWRAP2(cv::SVDecomp(src, w, u, vt, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, w), evision_from(env, u), evision_from(env, vt));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_scharr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    int dx;
    int dy;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    int dx;
    int dy;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_simpleBlobDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params();
    Ptr<SimpleBlobDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::SimpleBlobDetector::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sobel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    int dx;
    int dy;
    int ksize=3;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::Sobel(src, dst, ddepth, dx, dy, ksize, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    int dx;
    int dy;
    int ksize=3;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::Sobel(src, dst, ddepth, dx, dy, ksize, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sparsePyrLKOpticalFlow_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Size winSize=Size(21, 21);
    int maxLevel=3;
    TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    int flags=0;
    double minEigThreshold=1e-4;
    Ptr<SparsePyrLKOpticalFlow> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crit"), crit, ArgInfo("crit", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minEigThreshold"), minEigThreshold, ArgInfo("minEigThreshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::SparsePyrLKOpticalFlow::create(winSize, maxLevel, crit, flags, minEigThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoBM_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int numDisparities=0;
    int blockSize=21;
    Ptr<StereoBM> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::StereoBM::create(numDisparities, blockSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoSGBM_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int minDisparity=0;
    int numDisparities=16;
    int blockSize=3;
    int P1=0;
    int P2=0;
    int disp12MaxDiff=0;
    int preFilterCap=0;
    int uniquenessRatio=0;
    int speckleWindowSize=0;
    int speckleRange=0;
    int mode=StereoSGBM::MODE_SGBM;
    Ptr<StereoSGBM> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDiff"), disp12MaxDiff, ArgInfo("disp12MaxDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "preFilterCap"), preFilterCap, ArgInfo("preFilterCap", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "uniquenessRatio"), uniquenessRatio, ArgInfo("uniquenessRatio", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleWindowSize"), speckleWindowSize, ArgInfo("speckleWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "speckleRange"), speckleRange, ArgInfo("speckleRange", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::StereoSGBM::create(minDisparity, numDisparities, blockSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stitcher_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mode mode=Stitcher::PANORAMA;
    Ptr<Stitcher> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::Stitcher::create(mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerCSRT_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TrackerCSRT_Params parameters=TrackerCSRT::Params();
    Ptr<TrackerCSRT> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::TrackerCSRT::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerDaSiamRPN_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TrackerDaSiamRPN_Params parameters=TrackerDaSiamRPN::Params();
    Ptr<TrackerDaSiamRPN> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::TrackerDaSiamRPN::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerGOTURN_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TrackerGOTURN_Params parameters=TrackerGOTURN::Params();
    Ptr<TrackerGOTURN> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::TrackerGOTURN::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerKCF_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TrackerKCF_Params parameters=TrackerKCF::Params();
    Ptr<TrackerKCF> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::TrackerKCF::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerMIL_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TrackerMIL_Params parameters=TrackerMIL::Params();
    Ptr<TrackerMIL> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::TrackerMIL::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trackerNano_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TrackerNano_Params parameters=TrackerNano::Params();
    Ptr<TrackerNano> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::TrackerNano::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_context(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    void* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv_UMat_context(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_uMat_queue(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    void* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv_UMat_queue(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_variationalRefinement_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<VariationalRefinement> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::VariationalRefinement::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoWriter_fourcc(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    char c1;
    char c2;
    char c3;
    char c4;
    int retval;

    if( num_kw_args >= 4 && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c1"), &c1, ArgInfo("c1", 0, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c2"), &c2, ArgInfo("c2", 0, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c3"), &c3, ArgInfo("c3", 0, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "c4"), &c4, ArgInfo("c4", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::VideoWriter::fourcc(c1, c2, c3, c4), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_absdiff(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::absdiff(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::absdiff(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_accumulate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::accumulate(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::accumulate(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_accumulateProduct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::accumulateProduct(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::accumulateProduct(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_accumulateSquare(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::accumulateSquare(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::accumulateSquare(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_accumulateWeighted(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double alpha;
    Mat mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::accumulateWeighted(src, dst, alpha, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double alpha;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::accumulateWeighted(src, dst, alpha, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_adaptiveThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double maxValue;
    int adaptiveMethod;
    int thresholdType;
    int blockSize;
    double C;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxValue"), maxValue, ArgInfo("maxValue", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "adaptiveMethod"), adaptiveMethod, ArgInfo("adaptiveMethod", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresholdType"), thresholdType, ArgInfo("thresholdType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c"), C, ArgInfo("C", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double maxValue;
    int adaptiveMethod;
    int thresholdType;
    int blockSize;
    double C;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxValue"), maxValue, ArgInfo("maxValue", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "adaptiveMethod"), adaptiveMethod, ArgInfo("adaptiveMethod", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresholdType"), thresholdType, ArgInfo("thresholdType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c"), C, ArgInfo("C", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_add(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    Mat mask;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::add(src1, src2, dst, mask, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::add(src1, src2, dst, mask, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_addText(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat img;
    String text;
    Point org;
    String nameFont;
    int pointSize=-1;
    Scalar color=Scalar::all(0);
    int weight=QT_FONT_NORMAL;
    int style=QT_STYLE_NORMAL;
    int spacing=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "text"), text, ArgInfo("text", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "org"), org, ArgInfo("org", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nameFont"), nameFont, ArgInfo("nameFont", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointSize"), pointSize, ArgInfo("pointSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight"), weight, ArgInfo("weight", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "style"), style, ArgInfo("style", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "spacing"), spacing, ArgInfo("spacing", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::addText(img, text, org, nameFont, pointSize, color, weight, style, spacing), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_addWeighted(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    double alpha;
    Mat src2;
    double beta;
    double gamma;
    Mat dst;
    int dtype=-1;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::addWeighted(src1, alpha, src2, beta, gamma, dst, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    double alpha;
    Ptr<UMat> ptr_src2;
    double beta;
    double gamma;
    Ptr<UMat> ptr_dst;
    int dtype=-1;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::addWeighted(src1, alpha, src2, beta, gamma, dst, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_applyColorMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat userColor;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "userColor"), userColor, ArgInfo("userColor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::applyColorMap(src, dst, userColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat src;
    Mat dst;
    int colormap;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colormap"), colormap, ArgInfo("colormap", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::applyColorMap(src, dst, colormap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_userColor;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "userColor"), ptr_userColor, ArgInfo("userColor", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat userColor; if (ptr_userColor.get()) { userColor = *ptr_userColor.get(); }
    
        ERRWRAP2(cv::applyColorMap(src, dst, userColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int colormap;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colormap"), colormap, ArgInfo("colormap", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::applyColorMap(src, dst, colormap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_approxPolyDP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat curve;
    Mat approxCurve;
    double epsilon;
    bool closed;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "curve"), curve, ArgInfo("curve", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "approxCurve"), approxCurve, ArgInfo("approxCurve", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "epsilon"), epsilon, ArgInfo("epsilon", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "closed"), closed, ArgInfo("closed", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::approxPolyDP(curve, approxCurve, epsilon, closed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, approxCurve);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_curve;
    Ptr<UMat> ptr_approxCurve;
    double epsilon;
    bool closed;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "curve"), ptr_curve, ArgInfo("curve", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "approxCurve"), ptr_approxCurve, ArgInfo("approxCurve", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "epsilon"), epsilon, ArgInfo("epsilon", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "closed"), closed, ArgInfo("closed", 0, 0)) )
    {
        error_flag = false;
            UMat curve; if (ptr_curve.get()) { curve = *ptr_curve.get(); }
        UMat approxCurve; if (ptr_approxCurve.get()) { approxCurve = *ptr_approxCurve.get(); }
    
        ERRWRAP2(cv::approxPolyDP(curve, approxCurve, epsilon, closed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, approxCurve);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_arcLength(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat curve;
    bool closed;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "curve"), curve, ArgInfo("curve", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "closed"), closed, ArgInfo("closed", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::arcLength(curve, closed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_curve;
    bool closed;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "curve"), ptr_curve, ArgInfo("curve", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "closed"), closed, ArgInfo("closed", 0, 0)) )
    {
        error_flag = false;
            UMat curve; if (ptr_curve.get()) { curve = *ptr_curve.get(); }
    
        ERRWRAP2(retval = cv::arcLength(curve, closed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_arrowedLine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Point pt1;
    Point pt2;
    Scalar color;
    int thickness=1;
    int line_type=8;
    int shift=0;
    double tipLength=0.1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "line_type"), line_type, ArgInfo("line_type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tipLength"), tipLength, ArgInfo("tipLength", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::arrowedLine(img, pt1, pt2, color, thickness, line_type, shift, tipLength), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Point pt1;
    Point pt2;
    Scalar color;
    int thickness=1;
    int line_type=8;
    int shift=0;
    double tipLength=0.1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "line_type"), line_type, ArgInfo("line_type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tipLength"), tipLength, ArgInfo("tipLength", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::arrowedLine(img, pt1, pt2, color, thickness, line_type, shift, tipLength), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_batchDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dist;
    int dtype;
    Mat nidx;
    int normType=NORM_L2;
    int K=0;
    Mat mask;
    int update=0;
    bool crosscheck=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist"), dist, ArgInfo("dist", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nidx"), nidx, ArgInfo("nidx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "update"), update, ArgInfo("update", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crosscheck"), crosscheck, ArgInfo("crosscheck", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::batchDistance(src1, src2, dist, dtype, nidx, normType, K, mask, update, crosscheck), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dist), evision_from(env, nidx));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dist;
    int dtype;
    Ptr<UMat> ptr_nidx;
    int normType=NORM_L2;
    int K=0;
    Ptr<UMat> ptr_mask;
    int update=0;
    bool crosscheck=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist"), ptr_dist, ArgInfo("dist", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nidx"), ptr_nidx, ArgInfo("nidx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "update"), update, ArgInfo("update", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crosscheck"), crosscheck, ArgInfo("crosscheck", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dist; if (ptr_dist.get()) { dist = *ptr_dist.get(); }
        UMat nidx; if (ptr_nidx.get()) { nidx = *ptr_nidx.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::batchDistance(src1, src2, dist, dtype, nidx, normType, K, mask, update, crosscheck), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dist), evision_from(env, nidx));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bilateralFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int d;
    double sigmaColor;
    double sigmaSpace;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpace"), sigmaSpace, ArgInfo("sigmaSpace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int d;
    double sigmaColor;
    double sigmaSpace;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpace"), sigmaSpace, ArgInfo("sigmaSpace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bitwise_and(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::bitwise_and(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::bitwise_and(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bitwise_not(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::bitwise_not(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::bitwise_not(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bitwise_or(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::bitwise_or(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::bitwise_or(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bitwise_xor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::bitwise_xor(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::bitwise_xor(src1, src2, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_blendLinear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat weights1;
    Mat weights2;
    Mat dst;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weights1"), weights1, ArgInfo("weights1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weights2"), weights2, ArgInfo("weights2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::blendLinear(src1, src2, weights1, weights2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_weights1;
    Ptr<UMat> ptr_weights2;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weights1"), ptr_weights1, ArgInfo("weights1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weights2"), ptr_weights2, ArgInfo("weights2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat weights1; if (ptr_weights1.get()) { weights1 = *ptr_weights1.get(); }
        UMat weights2; if (ptr_weights2.get()) { weights2 = *ptr_weights2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::blendLinear(src1, src2, weights1, weights2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_blur(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size ksize;
    Point anchor=Point(-1,-1);
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::blur(src, dst, ksize, anchor, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size ksize;
    Point anchor=Point(-1,-1);
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::blur(src, dst, ksize, anchor, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_borderInterpolate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int p;
    int len;
    int borderType;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), p, ArgInfo("p", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::borderInterpolate(p, len, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_boundingRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat array;
    Rect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "array"), array, ArgInfo("array", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::boundingRect(array), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_array;
    Rect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "array"), ptr_array, ArgInfo("array", 0, 0)) )
    {
        error_flag = false;
            UMat array; if (ptr_array.get()) { array = *ptr_array.get(); }
    
        ERRWRAP2(retval = cv::boundingRect(array), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_boxFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    Size ksize;
    Point anchor=Point(-1,-1);
    bool normalize=true;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normalize"), normalize, ArgInfo("normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    Size ksize;
    Point anchor=Point(-1,-1);
    bool normalize=true;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normalize"), normalize, ArgInfo("normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_boxPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    RotatedRect box;
    Mat points;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "box"), box, ArgInfo("box", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::boxPoints(box, points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points);
        }
    }

    }
    

    {
    RotatedRect box;
    Ptr<UMat> ptr_points;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "box"), box, ArgInfo("box", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 1, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(cv::boxPoints(box, points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_buildOpticalFlowPyramid(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    vector_Mat pyramid;
    Size winSize;
    int maxLevel;
    bool withDerivatives=true;
    int pyrBorder=BORDER_REFLECT_101;
    int derivBorder=BORDER_CONSTANT;
    bool tryReuseInputImage=true;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyramid"), pyramid, ArgInfo("pyramid", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "withDerivatives"), withDerivatives, ArgInfo("withDerivatives", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyrBorder"), pyrBorder, ArgInfo("pyrBorder", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "derivBorder"), derivBorder, ArgInfo("derivBorder", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tryReuseInputImage"), tryReuseInputImage, ArgInfo("tryReuseInputImage", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::buildOpticalFlowPyramid(img, pyramid, winSize, maxLevel, withDerivatives, pyrBorder, derivBorder, tryReuseInputImage), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pyramid));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    vector_UMat pyramid;
    Size winSize;
    int maxLevel;
    bool withDerivatives=true;
    int pyrBorder=BORDER_REFLECT_101;
    int derivBorder=BORDER_CONSTANT;
    bool tryReuseInputImage=true;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyramid"), pyramid, ArgInfo("pyramid", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "withDerivatives"), withDerivatives, ArgInfo("withDerivatives", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyrBorder"), pyrBorder, ArgInfo("pyrBorder", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "derivBorder"), derivBorder, ArgInfo("derivBorder", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tryReuseInputImage"), tryReuseInputImage, ArgInfo("tryReuseInputImage", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(retval = cv::buildOpticalFlowPyramid(img, pyramid, winSize, maxLevel, withDerivatives, pyrBorder, derivBorder, tryReuseInputImage), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, pyramid));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calcBackProject(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat images;
    vector_int channels;
    Mat hist;
    Mat dst;
    vector_float ranges;
    double scale;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channels"), channels, ArgInfo("channels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hist"), hist, ArgInfo("hist", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ranges"), ranges, ArgInfo("ranges", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calcBackProject(images, channels, hist, dst, ranges, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_int channels;
    Ptr<UMat> ptr_hist;
    Ptr<UMat> ptr_dst;
    vector_float ranges;
    double scale;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channels"), channels, ArgInfo("channels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hist"), ptr_hist, ArgInfo("hist", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ranges"), ranges, ArgInfo("ranges", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 0)) )
    {
        error_flag = false;
            UMat hist; if (ptr_hist.get()) { hist = *ptr_hist.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::calcBackProject(images, channels, hist, dst, ranges, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calcCovarMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat samples;
    Mat covar;
    Mat mean;
    int flags;
    int ctype=CV_64F;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "covar"), covar, ArgInfo("covar", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctype"), ctype, ArgInfo("ctype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calcCovarMatrix(samples, covar, mean, flags, ctype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, covar), evision_from(env, mean));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_samples;
    Ptr<UMat> ptr_covar;
    Ptr<UMat> ptr_mean;
    int flags;
    int ctype=CV_64F;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), ptr_samples, ArgInfo("samples", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "covar"), ptr_covar, ArgInfo("covar", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctype"), ctype, ArgInfo("ctype", 0, 1)) )
    {
        error_flag = false;
            UMat samples; if (ptr_samples.get()) { samples = *ptr_samples.get(); }
        UMat covar; if (ptr_covar.get()) { covar = *ptr_covar.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
    
        ERRWRAP2(cv::calcCovarMatrix(samples, covar, mean, flags, ctype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, covar), evision_from(env, mean));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calcHist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat images;
    vector_int channels;
    Mat mask;
    Mat hist;
    vector_int histSize;
    vector_float ranges;
    bool accumulate=false;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channels"), channels, ArgInfo("channels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hist"), hist, ArgInfo("hist", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histSize"), histSize, ArgInfo("histSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ranges"), ranges, ArgInfo("ranges", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "accumulate"), accumulate, ArgInfo("accumulate", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calcHist(images, channels, mask, hist, histSize, ranges, accumulate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, hist);
        }
    }

    }
    

    {
    vector_UMat images;
    vector_int channels;
    Ptr<UMat> ptr_mask;
    Ptr<UMat> ptr_hist;
    vector_int histSize;
    vector_float ranges;
    bool accumulate=false;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channels"), channels, ArgInfo("channels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hist"), ptr_hist, ArgInfo("hist", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histSize"), histSize, ArgInfo("histSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ranges"), ranges, ArgInfo("ranges", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "accumulate"), accumulate, ArgInfo("accumulate", 0, 1)) )
    {
        error_flag = false;
            UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat hist; if (ptr_hist.get()) { hist = *ptr_hist.get(); }
    
        ERRWRAP2(cv::calcHist(images, channels, mask, hist, histSize, ranges, accumulate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, hist);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calcOpticalFlowFarneback(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat prev;
    Mat next;
    Mat flow;
    double pyr_scale;
    int levels;
    int winsize;
    int iterations;
    int poly_n;
    double poly_sigma;
    int flags;

    if( num_kw_args >= 10 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prev"), prev, ArgInfo("prev", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "next"), next, ArgInfo("next", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), flow, ArgInfo("flow", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr_scale"), pyr_scale, ArgInfo("pyr_scale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "levels"), levels, ArgInfo("levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winsize"), winsize, ArgInfo("winsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "poly_n"), poly_n, ArgInfo("poly_n", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "poly_sigma"), poly_sigma, ArgInfo("poly_sigma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, flow);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_prev;
    Ptr<UMat> ptr_next;
    Ptr<UMat> ptr_flow;
    double pyr_scale;
    int levels;
    int winsize;
    int iterations;
    int poly_n;
    double poly_sigma;
    int flags;

    if( num_kw_args >= 10 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prev"), ptr_prev, ArgInfo("prev", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "next"), ptr_next, ArgInfo("next", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), ptr_flow, ArgInfo("flow", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr_scale"), pyr_scale, ArgInfo("pyr_scale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "levels"), levels, ArgInfo("levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winsize"), winsize, ArgInfo("winsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "poly_n"), poly_n, ArgInfo("poly_n", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "poly_sigma"), poly_sigma, ArgInfo("poly_sigma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat prev; if (ptr_prev.get()) { prev = *ptr_prev.get(); }
        UMat next; if (ptr_next.get()) { next = *ptr_next.get(); }
        UMat flow; if (ptr_flow.get()) { flow = *ptr_flow.get(); }
    
        ERRWRAP2(cv::calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, flow);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calcOpticalFlowPyrLK(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat prevImg;
    Mat nextImg;
    Mat prevPts;
    Mat nextPts;
    Mat status;
    Mat err;
    Size winSize=Size(21,21);
    int maxLevel=3;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    int flags=0;
    double minEigThreshold=1e-4;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prevImg"), prevImg, ArgInfo("prevImg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextImg"), nextImg, ArgInfo("nextImg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prevPts"), prevPts, ArgInfo("prevPts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextPts"), nextPts, ArgInfo("nextPts", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "status"), status, ArgInfo("status", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "err"), err, ArgInfo("err", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minEigThreshold"), minEigThreshold, ArgInfo("minEigThreshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, err, winSize, maxLevel, criteria, flags, minEigThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, nextPts), evision_from(env, status), evision_from(env, err));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_prevImg;
    Ptr<UMat> ptr_nextImg;
    Ptr<UMat> ptr_prevPts;
    Ptr<UMat> ptr_nextPts;
    Ptr<UMat> ptr_status;
    Ptr<UMat> ptr_err;
    Size winSize=Size(21,21);
    int maxLevel=3;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    int flags=0;
    double minEigThreshold=1e-4;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prevImg"), ptr_prevImg, ArgInfo("prevImg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextImg"), ptr_nextImg, ArgInfo("nextImg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prevPts"), ptr_prevPts, ArgInfo("prevPts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nextPts"), ptr_nextPts, ArgInfo("nextPts", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "status"), ptr_status, ArgInfo("status", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "err"), ptr_err, ArgInfo("err", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minEigThreshold"), minEigThreshold, ArgInfo("minEigThreshold", 0, 1)) )
    {
        error_flag = false;
            UMat prevImg; if (ptr_prevImg.get()) { prevImg = *ptr_prevImg.get(); }
        UMat nextImg; if (ptr_nextImg.get()) { nextImg = *ptr_nextImg.get(); }
        UMat prevPts; if (ptr_prevPts.get()) { prevPts = *ptr_prevPts.get(); }
        UMat nextPts; if (ptr_nextPts.get()) { nextPts = *ptr_nextPts.get(); }
        UMat status; if (ptr_status.get()) { status = *ptr_status.get(); }
        UMat err; if (ptr_err.get()) { err = *ptr_err.get(); }
    
        ERRWRAP2(cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, err, winSize, maxLevel, criteria, flags, minEigThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, nextPts), evision_from(env, status), evision_from(env, err));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCamera(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size imageSize;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size imageSize;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
    
        ERRWRAP2(retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCameraExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size imageSize;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    Mat stdDeviationsIntrinsics;
    Mat stdDeviationsExtrinsics;
    Mat perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple8(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, stdDeviationsIntrinsics), evision_from(env, stdDeviationsExtrinsics), evision_from(env, perViewErrors));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size imageSize;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    Ptr<UMat> ptr_stdDeviationsIntrinsics;
    Ptr<UMat> ptr_stdDeviationsExtrinsics;
    Ptr<UMat> ptr_perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), ptr_stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), ptr_stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), ptr_perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat stdDeviationsIntrinsics; if (ptr_stdDeviationsIntrinsics.get()) { stdDeviationsIntrinsics = *ptr_stdDeviationsIntrinsics.get(); }
        UMat stdDeviationsExtrinsics; if (ptr_stdDeviationsExtrinsics.get()) { stdDeviationsExtrinsics = *ptr_stdDeviationsExtrinsics.get(); }
        UMat perViewErrors; if (ptr_perViewErrors.get()) { perViewErrors = *ptr_perViewErrors.get(); }
    
        ERRWRAP2(retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple8(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, stdDeviationsIntrinsics), evision_from(env, stdDeviationsExtrinsics), evision_from(env, perViewErrors));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCameraRO(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size imageSize;
    int iFixedPoint;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    Mat newObjPoints;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iFixedPoint"), iFixedPoint, ArgInfo("iFixedPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newObjPoints"), newObjPoints, ArgInfo("newObjPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple6(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, newObjPoints));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size imageSize;
    int iFixedPoint;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    Ptr<UMat> ptr_newObjPoints;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iFixedPoint"), iFixedPoint, ArgInfo("iFixedPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newObjPoints"), ptr_newObjPoints, ArgInfo("newObjPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat newObjPoints; if (ptr_newObjPoints.get()) { newObjPoints = *ptr_newObjPoints.get(); }
    
        ERRWRAP2(retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple6(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, newObjPoints));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateCameraROExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size imageSize;
    int iFixedPoint;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    Mat newObjPoints;
    Mat stdDeviationsIntrinsics;
    Mat stdDeviationsExtrinsics;
    Mat stdDeviationsObjPoints;
    Mat perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iFixedPoint"), iFixedPoint, ArgInfo("iFixedPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newObjPoints"), newObjPoints, ArgInfo("newObjPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsObjPoints"), stdDeviationsObjPoints, ArgInfo("stdDeviationsObjPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, cameraMatrix),
                evision_from(env, distCoeffs),
                evision_from(env, rvecs),
                evision_from(env, tvecs),
                evision_from(env, newObjPoints),
                evision_from(env, stdDeviationsIntrinsics),
                evision_from(env, stdDeviationsExtrinsics),
                evision_from(env, stdDeviationsObjPoints),
                evision_from(env, perViewErrors)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size imageSize;
    int iFixedPoint;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    Ptr<UMat> ptr_newObjPoints;
    Ptr<UMat> ptr_stdDeviationsIntrinsics;
    Ptr<UMat> ptr_stdDeviationsExtrinsics;
    Ptr<UMat> ptr_stdDeviationsObjPoints;
    Ptr<UMat> ptr_perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iFixedPoint"), iFixedPoint, ArgInfo("iFixedPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newObjPoints"), ptr_newObjPoints, ArgInfo("newObjPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), ptr_stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), ptr_stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsObjPoints"), ptr_stdDeviationsObjPoints, ArgInfo("stdDeviationsObjPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), ptr_perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat newObjPoints; if (ptr_newObjPoints.get()) { newObjPoints = *ptr_newObjPoints.get(); }
        UMat stdDeviationsIntrinsics; if (ptr_stdDeviationsIntrinsics.get()) { stdDeviationsIntrinsics = *ptr_stdDeviationsIntrinsics.get(); }
        UMat stdDeviationsExtrinsics; if (ptr_stdDeviationsExtrinsics.get()) { stdDeviationsExtrinsics = *ptr_stdDeviationsExtrinsics.get(); }
        UMat stdDeviationsObjPoints; if (ptr_stdDeviationsObjPoints.get()) { stdDeviationsObjPoints = *ptr_stdDeviationsObjPoints.get(); }
        UMat perViewErrors; if (ptr_perViewErrors.get()) { perViewErrors = *ptr_perViewErrors.get(); }
    
        ERRWRAP2(retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, cameraMatrix),
                evision_from(env, distCoeffs),
                evision_from(env, rvecs),
                evision_from(env, tvecs),
                evision_from(env, newObjPoints),
                evision_from(env, stdDeviationsIntrinsics),
                evision_from(env, stdDeviationsExtrinsics),
                evision_from(env, stdDeviationsObjPoints),
                evision_from(env, perViewErrors)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateHandEye(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat R_gripper2base;
    vector_Mat t_gripper2base;
    vector_Mat R_target2cam;
    vector_Mat t_target2cam;
    Mat R_cam2gripper;
    Mat t_cam2gripper;
    std::underlying_type_t<HandEyeCalibrationMethod> method=static_cast<std::underlying_type_t<HandEyeCalibrationMethod>>(CALIB_HAND_EYE_TSAI);

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_gripper2base"), R_gripper2base, ArgInfo("R_gripper2base", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_gripper2base"), t_gripper2base, ArgInfo("t_gripper2base", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_target2cam"), R_target2cam, ArgInfo("R_target2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_target2cam"), t_target2cam, ArgInfo("t_target2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_cam2gripper"), R_cam2gripper, ArgInfo("R_cam2gripper", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_cam2gripper"), t_cam2gripper, ArgInfo("t_cam2gripper", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam, R_cam2gripper, t_cam2gripper, static_cast<HandEyeCalibrationMethod>(method)), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, R_cam2gripper), evision_from(env, t_cam2gripper));
        }
    }

    }
    

    {
    vector_UMat R_gripper2base;
    vector_UMat t_gripper2base;
    vector_UMat R_target2cam;
    vector_UMat t_target2cam;
    Ptr<UMat> ptr_R_cam2gripper;
    Ptr<UMat> ptr_t_cam2gripper;
    std::underlying_type_t<HandEyeCalibrationMethod> method=static_cast<std::underlying_type_t<HandEyeCalibrationMethod>>(CALIB_HAND_EYE_TSAI);

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_gripper2base"), R_gripper2base, ArgInfo("R_gripper2base", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_gripper2base"), t_gripper2base, ArgInfo("t_gripper2base", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_target2cam"), R_target2cam, ArgInfo("R_target2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_target2cam"), t_target2cam, ArgInfo("t_target2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_cam2gripper"), ptr_R_cam2gripper, ArgInfo("R_cam2gripper", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_cam2gripper"), ptr_t_cam2gripper, ArgInfo("t_cam2gripper", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
            UMat R_cam2gripper; if (ptr_R_cam2gripper.get()) { R_cam2gripper = *ptr_R_cam2gripper.get(); }
        UMat t_cam2gripper; if (ptr_t_cam2gripper.get()) { t_cam2gripper = *ptr_t_cam2gripper.get(); }
    
        ERRWRAP2(cv::calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam, R_cam2gripper, t_cam2gripper, static_cast<HandEyeCalibrationMethod>(method)), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, R_cam2gripper), evision_from(env, t_cam2gripper));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrateRobotWorldHandEye(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat R_world2cam;
    vector_Mat t_world2cam;
    vector_Mat R_base2gripper;
    vector_Mat t_base2gripper;
    Mat R_base2world;
    Mat t_base2world;
    Mat R_gripper2cam;
    Mat t_gripper2cam;
    std::underlying_type_t<RobotWorldHandEyeCalibrationMethod> method=static_cast<std::underlying_type_t<RobotWorldHandEyeCalibrationMethod>>(CALIB_ROBOT_WORLD_HAND_EYE_SHAH);

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_world2cam"), R_world2cam, ArgInfo("R_world2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_world2cam"), t_world2cam, ArgInfo("t_world2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_base2gripper"), R_base2gripper, ArgInfo("R_base2gripper", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_base2gripper"), t_base2gripper, ArgInfo("t_base2gripper", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_base2world"), R_base2world, ArgInfo("R_base2world", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_base2world"), t_base2world, ArgInfo("t_base2world", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_gripper2cam"), R_gripper2cam, ArgInfo("R_gripper2cam", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_gripper2cam"), t_gripper2cam, ArgInfo("t_gripper2cam", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper, R_base2world, t_base2world, R_gripper2cam, t_gripper2cam, static_cast<RobotWorldHandEyeCalibrationMethod>(method)), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, R_base2world), evision_from(env, t_base2world), evision_from(env, R_gripper2cam), evision_from(env, t_gripper2cam));
        }
    }

    }
    

    {
    vector_UMat R_world2cam;
    vector_UMat t_world2cam;
    vector_UMat R_base2gripper;
    vector_UMat t_base2gripper;
    Ptr<UMat> ptr_R_base2world;
    Ptr<UMat> ptr_t_base2world;
    Ptr<UMat> ptr_R_gripper2cam;
    Ptr<UMat> ptr_t_gripper2cam;
    std::underlying_type_t<RobotWorldHandEyeCalibrationMethod> method=static_cast<std::underlying_type_t<RobotWorldHandEyeCalibrationMethod>>(CALIB_ROBOT_WORLD_HAND_EYE_SHAH);

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_world2cam"), R_world2cam, ArgInfo("R_world2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_world2cam"), t_world2cam, ArgInfo("t_world2cam", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_base2gripper"), R_base2gripper, ArgInfo("R_base2gripper", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_base2gripper"), t_base2gripper, ArgInfo("t_base2gripper", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_base2world"), ptr_R_base2world, ArgInfo("R_base2world", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_base2world"), ptr_t_base2world, ArgInfo("t_base2world", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r_gripper2cam"), ptr_R_gripper2cam, ArgInfo("R_gripper2cam", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t_gripper2cam"), ptr_t_gripper2cam, ArgInfo("t_gripper2cam", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
            UMat R_base2world; if (ptr_R_base2world.get()) { R_base2world = *ptr_R_base2world.get(); }
        UMat t_base2world; if (ptr_t_base2world.get()) { t_base2world = *ptr_t_base2world.get(); }
        UMat R_gripper2cam; if (ptr_R_gripper2cam.get()) { R_gripper2cam = *ptr_R_gripper2cam.get(); }
        UMat t_gripper2cam; if (ptr_t_gripper2cam.get()) { t_gripper2cam = *ptr_t_gripper2cam.get(); }
    
        ERRWRAP2(cv::calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper, R_base2world, t_base2world, R_gripper2cam, t_gripper2cam, static_cast<RobotWorldHandEyeCalibrationMethod>(method)), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, R_base2world), evision_from(env, t_base2world), evision_from(env, R_gripper2cam), evision_from(env, t_gripper2cam));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_calibrationMatrixValues(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix;
    Size imageSize;
    double apertureWidth;
    double apertureHeight;
    double fovx;
    double fovy;
    double focalLength;
    Point2d principalPoint;
    double aspectRatio;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureWidth"), apertureWidth, ArgInfo("apertureWidth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureHeight"), apertureHeight, ArgInfo("apertureHeight", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight, fovx, fovy, focalLength, principalPoint, aspectRatio), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, fovx), evision_from(env, fovy), evision_from(env, focalLength), evision_from(env, principalPoint), evision_from(env, aspectRatio));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix;
    Size imageSize;
    double apertureWidth;
    double apertureHeight;
    double fovx;
    double fovy;
    double focalLength;
    Point2d principalPoint;
    double aspectRatio;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureWidth"), apertureWidth, ArgInfo("apertureWidth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "apertureHeight"), apertureHeight, ArgInfo("apertureHeight", 0, 0)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
    
        ERRWRAP2(cv::calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight, fovx, fovy, focalLength, principalPoint, aspectRatio), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, fovx), evision_from(env, fovy), evision_from(env, focalLength), evision_from(env, principalPoint), evision_from(env, aspectRatio));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cartToPolar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat x;
    Mat y;
    Mat magnitude;
    Mat angle;
    bool angleInDegrees=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "magnitude"), magnitude, ArgInfo("magnitude", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleInDegrees"), angleInDegrees, ArgInfo("angleInDegrees", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cartToPolar(x, y, magnitude, angle, angleInDegrees), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, magnitude), evision_from(env, angle));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_x;
    Ptr<UMat> ptr_y;
    Ptr<UMat> ptr_magnitude;
    Ptr<UMat> ptr_angle;
    bool angleInDegrees=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), ptr_x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), ptr_y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "magnitude"), ptr_magnitude, ArgInfo("magnitude", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), ptr_angle, ArgInfo("angle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleInDegrees"), angleInDegrees, ArgInfo("angleInDegrees", 0, 1)) )
    {
        error_flag = false;
            UMat x; if (ptr_x.get()) { x = *ptr_x.get(); }
        UMat y; if (ptr_y.get()) { y = *ptr_y.get(); }
        UMat magnitude; if (ptr_magnitude.get()) { magnitude = *ptr_magnitude.get(); }
        UMat angle; if (ptr_angle.get()) { angle = *ptr_angle.get(); }
    
        ERRWRAP2(cv::cartToPolar(x, y, magnitude, angle, angleInDegrees), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, magnitude), evision_from(env, angle));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_checkChessboard(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Size size;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::checkChessboard(img, size), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Size size;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(retval = cv::checkChessboard(img, size), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_checkHardwareSupport(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int feature;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "feature"), feature, ArgInfo("feature", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::checkHardwareSupport(feature), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_checkRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat a;
    bool quiet=true;
    Point pos;
    double minVal=-DBL_MAX;
    double maxVal=DBL_MAX;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "quiet"), quiet, ArgInfo("quiet", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minVal"), minVal, ArgInfo("minVal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxVal"), maxVal, ArgInfo("maxVal", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::checkRange(a, quiet, &pos, minVal, maxVal), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, pos);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_a;
    bool quiet=true;
    Point pos;
    double minVal=-DBL_MAX;
    double maxVal=DBL_MAX;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), ptr_a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "quiet"), quiet, ArgInfo("quiet", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minVal"), minVal, ArgInfo("minVal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxVal"), maxVal, ArgInfo("maxVal", 0, 1)) )
    {
        error_flag = false;
            UMat a; if (ptr_a.get()) { a = *ptr_a.get(); }
    
        ERRWRAP2(retval = cv::checkRange(a, quiet, &pos, minVal, maxVal), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, pos);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_circle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Point center;
    int radius;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::circle(img, center, radius, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Point center;
    int radius;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::circle(img, center, radius, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_clipLine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Rect imgRect;
    Point pt1;
    Point pt2;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgRect"), imgRect, ArgInfo("imgRect", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::clipLine(imgRect, pt1, pt2), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, pt1), evision_from(env, pt2));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_colorChange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat mask;
    Mat dst;
    float red_mul=1.0f;
    float green_mul=1.0f;
    float blue_mul=1.0f;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "red_mul"), red_mul, ArgInfo("red_mul", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "green_mul"), green_mul, ArgInfo("green_mul", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blue_mul"), blue_mul, ArgInfo("blue_mul", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::colorChange(src, mask, dst, red_mul, green_mul, blue_mul), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_mask;
    Ptr<UMat> ptr_dst;
    float red_mul=1.0f;
    float green_mul=1.0f;
    float blue_mul=1.0f;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "red_mul"), red_mul, ArgInfo("red_mul", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "green_mul"), green_mul, ArgInfo("green_mul", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blue_mul"), blue_mul, ArgInfo("blue_mul", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::colorChange(src, mask, dst, red_mul, green_mul, blue_mul), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_compare(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    int cmpop;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmpop"), cmpop, ArgInfo("cmpop", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::compare(src1, src2, dst, cmpop), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    int cmpop;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmpop"), cmpop, ArgInfo("cmpop", 0, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::compare(src1, src2, dst, cmpop), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_compareHist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat H1;
    Mat H2;
    int method;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h1"), H1, ArgInfo("H1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h2"), H2, ArgInfo("H2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::compareHist(H1, H2, method), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_H1;
    Ptr<UMat> ptr_H2;
    int method;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h1"), ptr_H1, ArgInfo("H1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h2"), ptr_H2, ArgInfo("H2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) )
    {
        error_flag = false;
            UMat H1; if (ptr_H1.get()) { H1 = *ptr_H1.get(); }
        UMat H2; if (ptr_H2.get()) { H2 = *ptr_H2.get(); }
    
        ERRWRAP2(retval = cv::compareHist(H1, H2, method), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_completeSymm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat m;
    bool lowerToUpper=false;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lowerToUpper"), lowerToUpper, ArgInfo("lowerToUpper", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::completeSymm(m, lowerToUpper), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, m);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_m;
    bool lowerToUpper=false;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_m, ArgInfo("m", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lowerToUpper"), lowerToUpper, ArgInfo("lowerToUpper", 0, 1)) )
    {
        error_flag = false;
            UMat m; if (ptr_m.get()) { m = *ptr_m.get(); }
    
        ERRWRAP2(cv::completeSymm(m, lowerToUpper), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, m);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_composeRT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat rvec1;
    Mat tvec1;
    Mat rvec2;
    Mat tvec2;
    Mat rvec3;
    Mat tvec3;
    Mat dr3dr1;
    Mat dr3dt1;
    Mat dr3dr2;
    Mat dr3dt2;
    Mat dt3dr1;
    Mat dt3dt1;
    Mat dt3dr2;
    Mat dt3dt2;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec1"), rvec1, ArgInfo("rvec1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec1"), tvec1, ArgInfo("tvec1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec2"), rvec2, ArgInfo("rvec2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec2"), tvec2, ArgInfo("tvec2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec3"), rvec3, ArgInfo("rvec3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec3"), tvec3, ArgInfo("tvec3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dr1"), dr3dr1, ArgInfo("dr3dr1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dt1"), dr3dt1, ArgInfo("dr3dt1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dr2"), dr3dr2, ArgInfo("dr3dr2", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dt2"), dr3dt2, ArgInfo("dr3dt2", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dr1"), dt3dr1, ArgInfo("dt3dr1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dt1"), dt3dt1, ArgInfo("dt3dt1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dr2"), dt3dr2, ArgInfo("dt3dr2", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dt2"), dt3dt2, ArgInfo("dt3dt2", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::composeRT(rvec1, tvec1, rvec2, tvec2, rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, rvec3),
                evision_from(env, tvec3),
                evision_from(env, dr3dr1),
                evision_from(env, dr3dt1),
                evision_from(env, dr3dr2),
                evision_from(env, dr3dt2),
                evision_from(env, dt3dr1),
                evision_from(env, dt3dt1),
                evision_from(env, dt3dr2),
                evision_from(env, dt3dt2)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_rvec1;
    Ptr<UMat> ptr_tvec1;
    Ptr<UMat> ptr_rvec2;
    Ptr<UMat> ptr_tvec2;
    Ptr<UMat> ptr_rvec3;
    Ptr<UMat> ptr_tvec3;
    Ptr<UMat> ptr_dr3dr1;
    Ptr<UMat> ptr_dr3dt1;
    Ptr<UMat> ptr_dr3dr2;
    Ptr<UMat> ptr_dr3dt2;
    Ptr<UMat> ptr_dt3dr1;
    Ptr<UMat> ptr_dt3dt1;
    Ptr<UMat> ptr_dt3dr2;
    Ptr<UMat> ptr_dt3dt2;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec1"), ptr_rvec1, ArgInfo("rvec1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec1"), ptr_tvec1, ArgInfo("tvec1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec2"), ptr_rvec2, ArgInfo("rvec2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec2"), ptr_tvec2, ArgInfo("tvec2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec3"), ptr_rvec3, ArgInfo("rvec3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec3"), ptr_tvec3, ArgInfo("tvec3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dr1"), ptr_dr3dr1, ArgInfo("dr3dr1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dt1"), ptr_dr3dt1, ArgInfo("dr3dt1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dr2"), ptr_dr3dr2, ArgInfo("dr3dr2", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dr3dt2"), ptr_dr3dt2, ArgInfo("dr3dt2", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dr1"), ptr_dt3dr1, ArgInfo("dt3dr1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dt1"), ptr_dt3dt1, ArgInfo("dt3dt1", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dr2"), ptr_dt3dr2, ArgInfo("dt3dr2", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dt3dt2"), ptr_dt3dt2, ArgInfo("dt3dt2", 1, 1)) )
    {
        error_flag = false;
            UMat rvec1; if (ptr_rvec1.get()) { rvec1 = *ptr_rvec1.get(); }
        UMat tvec1; if (ptr_tvec1.get()) { tvec1 = *ptr_tvec1.get(); }
        UMat rvec2; if (ptr_rvec2.get()) { rvec2 = *ptr_rvec2.get(); }
        UMat tvec2; if (ptr_tvec2.get()) { tvec2 = *ptr_tvec2.get(); }
        UMat rvec3; if (ptr_rvec3.get()) { rvec3 = *ptr_rvec3.get(); }
        UMat tvec3; if (ptr_tvec3.get()) { tvec3 = *ptr_tvec3.get(); }
        UMat dr3dr1; if (ptr_dr3dr1.get()) { dr3dr1 = *ptr_dr3dr1.get(); }
        UMat dr3dt1; if (ptr_dr3dt1.get()) { dr3dt1 = *ptr_dr3dt1.get(); }
        UMat dr3dr2; if (ptr_dr3dr2.get()) { dr3dr2 = *ptr_dr3dr2.get(); }
        UMat dr3dt2; if (ptr_dr3dt2.get()) { dr3dt2 = *ptr_dr3dt2.get(); }
        UMat dt3dr1; if (ptr_dt3dr1.get()) { dt3dr1 = *ptr_dt3dr1.get(); }
        UMat dt3dt1; if (ptr_dt3dt1.get()) { dt3dt1 = *ptr_dt3dt1.get(); }
        UMat dt3dr2; if (ptr_dt3dr2.get()) { dt3dr2 = *ptr_dt3dr2.get(); }
        UMat dt3dt2; if (ptr_dt3dt2.get()) { dt3dt2 = *ptr_dt3dt2.get(); }
    
        ERRWRAP2(cv::composeRT(rvec1, tvec1, rvec2, tvec2, rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, rvec3),
                evision_from(env, tvec3),
                evision_from(env, dr3dr1),
                evision_from(env, dr3dt1),
                evision_from(env, dr3dr2),
                evision_from(env, dr3dt2),
                evision_from(env, dt3dr1),
                evision_from(env, dt3dt1),
                evision_from(env, dt3dr2),
                evision_from(env, dt3dt2)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_computeCorrespondEpilines(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    int whichImage;
    Mat F;
    Mat lines;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "whichImage"), whichImage, ArgInfo("whichImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), lines, ArgInfo("lines", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::computeCorrespondEpilines(points, whichImage, F, lines), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    int whichImage;
    Ptr<UMat> ptr_F;
    Ptr<UMat> ptr_lines;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "whichImage"), whichImage, ArgInfo("whichImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lines"), ptr_lines, ArgInfo("lines", 1, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
        UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
        UMat lines; if (ptr_lines.get()) { lines = *ptr_lines.get(); }
    
        ERRWRAP2(cv::computeCorrespondEpilines(points, whichImage, F, lines), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, lines);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_computeECC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat templateImage;
    Mat inputImage;
    Mat inputMask;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateImage"), templateImage, ArgInfo("templateImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputImage"), inputImage, ArgInfo("inputImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputMask"), inputMask, ArgInfo("inputMask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::computeECC(templateImage, inputImage, inputMask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_templateImage;
    Ptr<UMat> ptr_inputImage;
    Ptr<UMat> ptr_inputMask;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateImage"), ptr_templateImage, ArgInfo("templateImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputImage"), ptr_inputImage, ArgInfo("inputImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputMask"), ptr_inputMask, ArgInfo("inputMask", 0, 1)) )
    {
        error_flag = false;
            UMat templateImage; if (ptr_templateImage.get()) { templateImage = *ptr_templateImage.get(); }
        UMat inputImage; if (ptr_inputImage.get()) { inputImage = *ptr_inputImage.get(); }
        UMat inputMask; if (ptr_inputMask.get()) { inputMask = *ptr_inputMask.get(); }
    
        ERRWRAP2(retval = cv::computeECC(templateImage, inputImage, inputMask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_connectedComponents(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat labels;
    int connectivity=8;
    int ltype=CV_32S;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::connectedComponents(image, labels, connectivity, ltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, labels));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_labels;
    int connectivity=8;
    int ltype=CV_32S;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), ptr_labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat labels; if (ptr_labels.get()) { labels = *ptr_labels.get(); }
    
        ERRWRAP2(retval = cv::connectedComponents(image, labels, connectivity, ltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, labels));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_connectedComponentsWithAlgorithm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat labels;
    int connectivity;
    int ltype;
    int ccltype;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ccltype"), ccltype, ArgInfo("ccltype", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::connectedComponents(image, labels, connectivity, ltype, ccltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, labels));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_labels;
    int connectivity;
    int ltype;
    int ccltype;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), ptr_labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ccltype"), ccltype, ArgInfo("ccltype", 0, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat labels; if (ptr_labels.get()) { labels = *ptr_labels.get(); }
    
        ERRWRAP2(retval = cv::connectedComponents(image, labels, connectivity, ltype, ccltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, labels));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_connectedComponentsWithStats(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat labels;
    Mat stats;
    Mat centroids;
    int connectivity=8;
    int ltype=CV_32S;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stats"), stats, ArgInfo("stats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centroids"), centroids, ArgInfo("centroids", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, labels), evision_from(env, stats), evision_from(env, centroids));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_labels;
    Ptr<UMat> ptr_stats;
    Ptr<UMat> ptr_centroids;
    int connectivity=8;
    int ltype=CV_32S;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), ptr_labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stats"), ptr_stats, ArgInfo("stats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centroids"), ptr_centroids, ArgInfo("centroids", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat labels; if (ptr_labels.get()) { labels = *ptr_labels.get(); }
        UMat stats; if (ptr_stats.get()) { stats = *ptr_stats.get(); }
        UMat centroids; if (ptr_centroids.get()) { centroids = *ptr_centroids.get(); }
    
        ERRWRAP2(retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, labels), evision_from(env, stats), evision_from(env, centroids));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_connectedComponentsWithStatsWithAlgorithm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat labels;
    Mat stats;
    Mat centroids;
    int connectivity;
    int ltype;
    int ccltype;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stats"), stats, ArgInfo("stats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centroids"), centroids, ArgInfo("centroids", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ccltype"), ccltype, ArgInfo("ccltype", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype, ccltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, labels), evision_from(env, stats), evision_from(env, centroids));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_labels;
    Ptr<UMat> ptr_stats;
    Ptr<UMat> ptr_centroids;
    int connectivity;
    int ltype;
    int ccltype;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), ptr_labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stats"), ptr_stats, ArgInfo("stats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centroids"), ptr_centroids, ArgInfo("centroids", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "connectivity"), connectivity, ArgInfo("connectivity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ltype"), ltype, ArgInfo("ltype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ccltype"), ccltype, ArgInfo("ccltype", 0, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat labels; if (ptr_labels.get()) { labels = *ptr_labels.get(); }
        UMat stats; if (ptr_stats.get()) { stats = *ptr_stats.get(); }
        UMat centroids; if (ptr_centroids.get()) { centroids = *ptr_centroids.get(); }
    
        ERRWRAP2(retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype, ccltype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, labels), evision_from(env, stats), evision_from(env, centroids));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_contourArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat contour;
    bool oriented=false;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), contour, ArgInfo("contour", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "oriented"), oriented, ArgInfo("oriented", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::contourArea(contour, oriented), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_contour;
    bool oriented=false;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), ptr_contour, ArgInfo("contour", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "oriented"), oriented, ArgInfo("oriented", 0, 1)) )
    {
        error_flag = false;
            UMat contour; if (ptr_contour.get()) { contour = *ptr_contour.get(); }
    
        ERRWRAP2(retval = cv::contourArea(contour, oriented), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convertFp16(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convertFp16(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::convertFp16(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convertMaps(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat map1;
    Mat map2;
    Mat dstmap1;
    Mat dstmap2;
    int dstmap1type;
    bool nninterpolation=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstmap1"), dstmap1, ArgInfo("dstmap1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstmap2"), dstmap2, ArgInfo("dstmap2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstmap1type"), dstmap1type, ArgInfo("dstmap1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nninterpolation"), nninterpolation, ArgInfo("nninterpolation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convertMaps(map1, map2, dstmap1, dstmap2, dstmap1type, nninterpolation), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dstmap1), evision_from(env, dstmap2));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_map1;
    Ptr<UMat> ptr_map2;
    Ptr<UMat> ptr_dstmap1;
    Ptr<UMat> ptr_dstmap2;
    int dstmap1type;
    bool nninterpolation=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), ptr_map1, ArgInfo("map1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), ptr_map2, ArgInfo("map2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstmap1"), ptr_dstmap1, ArgInfo("dstmap1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstmap2"), ptr_dstmap2, ArgInfo("dstmap2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstmap1type"), dstmap1type, ArgInfo("dstmap1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nninterpolation"), nninterpolation, ArgInfo("nninterpolation", 0, 1)) )
    {
        error_flag = false;
            UMat map1; if (ptr_map1.get()) { map1 = *ptr_map1.get(); }
        UMat map2; if (ptr_map2.get()) { map2 = *ptr_map2.get(); }
        UMat dstmap1; if (ptr_dstmap1.get()) { dstmap1 = *ptr_dstmap1.get(); }
        UMat dstmap2; if (ptr_dstmap2.get()) { dstmap2 = *ptr_dstmap2.get(); }
    
        ERRWRAP2(cv::convertMaps(map1, map2, dstmap1, dstmap2, dstmap1type, nninterpolation), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dstmap1), evision_from(env, dstmap2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convertPointsFromHomogeneous(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convertPointsFromHomogeneous(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::convertPointsFromHomogeneous(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convertPointsToHomogeneous(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convertPointsToHomogeneous(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::convertPointsToHomogeneous(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convertScaleAbs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double alpha=1;
    double beta=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convertScaleAbs(src, dst, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double alpha=1;
    double beta=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::convertScaleAbs(src, dst, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convexHull(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    Mat hull;
    bool clockwise=false;
    bool returnPoints=true;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hull"), hull, ArgInfo("hull", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "clockwise"), clockwise, ArgInfo("clockwise", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "returnPoints"), returnPoints, ArgInfo("returnPoints", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convexHull(points, hull, clockwise, returnPoints), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, hull);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    Ptr<UMat> ptr_hull;
    bool clockwise=false;
    bool returnPoints=true;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hull"), ptr_hull, ArgInfo("hull", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "clockwise"), clockwise, ArgInfo("clockwise", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "returnPoints"), returnPoints, ArgInfo("returnPoints", 0, 1)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
        UMat hull; if (ptr_hull.get()) { hull = *ptr_hull.get(); }
    
        ERRWRAP2(cv::convexHull(points, hull, clockwise, returnPoints), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, hull);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_convexityDefects(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat contour;
    Mat convexhull;
    Mat convexityDefects;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), contour, ArgInfo("contour", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "convexhull"), convexhull, ArgInfo("convexhull", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "convexityDefects"), convexityDefects, ArgInfo("convexityDefects", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::convexityDefects(contour, convexhull, convexityDefects), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, convexityDefects);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_contour;
    Ptr<UMat> ptr_convexhull;
    Ptr<UMat> ptr_convexityDefects;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), ptr_contour, ArgInfo("contour", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "convexhull"), ptr_convexhull, ArgInfo("convexhull", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "convexityDefects"), ptr_convexityDefects, ArgInfo("convexityDefects", 1, 0)) )
    {
        error_flag = false;
            UMat contour; if (ptr_contour.get()) { contour = *ptr_contour.get(); }
        UMat convexhull; if (ptr_convexhull.get()) { convexhull = *ptr_convexhull.get(); }
        UMat convexityDefects; if (ptr_convexityDefects.get()) { convexityDefects = *ptr_convexityDefects.get(); }
    
        ERRWRAP2(cv::convexityDefects(contour, convexhull, convexityDefects), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, convexityDefects);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_copyMakeBorder(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int top;
    int bottom;
    int left;
    int right;
    int borderType;
    Scalar value;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top"), top, ArgInfo("top", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bottom"), bottom, ArgInfo("bottom", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::copyMakeBorder(src, dst, top, bottom, left, right, borderType, value), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int top;
    int bottom;
    int left;
    int right;
    int borderType;
    Scalar value;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top"), top, ArgInfo("top", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bottom"), bottom, ArgInfo("bottom", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "left"), left, ArgInfo("left", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "right"), right, ArgInfo("right", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::copyMakeBorder(src, dst, top, bottom, left, right, borderType, value), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_copyTo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::copyTo(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::copyTo(src, dst, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cornerEigenValsAndVecs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int blockSize;
    int ksize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cornerEigenValsAndVecs(src, dst, blockSize, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int blockSize;
    int ksize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::cornerEigenValsAndVecs(src, dst, blockSize, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cornerHarris(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int blockSize;
    int ksize;
    double k;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cornerHarris(src, dst, blockSize, ksize, k, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int blockSize;
    int ksize;
    double k;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::cornerHarris(src, dst, blockSize, ksize, k, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cornerMinEigenVal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int blockSize;
    int ksize=3;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cornerMinEigenVal(src, dst, blockSize, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int blockSize;
    int ksize=3;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::cornerMinEigenVal(src, dst, blockSize, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cornerSubPix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat corners;
    Size winSize;
    Size zeroZone;
    TermCriteria criteria;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "zeroZone"), zeroZone, ArgInfo("zeroZone", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cornerSubPix(image, corners, winSize, zeroZone, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, corners);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_corners;
    Size winSize;
    Size zeroZone;
    TermCriteria criteria;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "zeroZone"), zeroZone, ArgInfo("zeroZone", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
    
        ERRWRAP2(cv::cornerSubPix(image, corners, winSize, zeroZone, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, corners);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_correctMatches(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat F;
    Mat points1;
    Mat points2;
    Mat newPoints1;
    Mat newPoints2;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newPoints1"), newPoints1, ArgInfo("newPoints1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newPoints2"), newPoints2, ArgInfo("newPoints2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::correctMatches(F, points1, points2, newPoints1, newPoints2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, newPoints1), evision_from(env, newPoints2));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_F;
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_newPoints1;
    Ptr<UMat> ptr_newPoints2;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newPoints1"), ptr_newPoints1, ArgInfo("newPoints1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newPoints2"), ptr_newPoints2, ArgInfo("newPoints2", 1, 0)) )
    {
        error_flag = false;
            UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
        UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat newPoints1; if (ptr_newPoints1.get()) { newPoints1 = *ptr_newPoints1.get(); }
        UMat newPoints2; if (ptr_newPoints2.get()) { newPoints2 = *ptr_newPoints2.get(); }
    
        ERRWRAP2(cv::correctMatches(F, points1, points2, newPoints1, newPoints2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, newPoints1), evision_from(env, newPoints2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_countNonZero(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::countNonZero(src), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
    
        ERRWRAP2(retval = cv::countNonZero(src), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createAffineTransformer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool fullAffine;
    Ptr<AffineTransformer> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fullAffine"), fullAffine, ArgInfo("fullAffine", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createAffineTransformer(fullAffine), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createAlignMTB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int max_bits=6;
    int exclude_range=4;
    bool cut=true;
    Ptr<AlignMTB> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "max_bits"), max_bits, ArgInfo("max_bits", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "exclude_range"), exclude_range, ArgInfo("exclude_range", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cut"), cut, ArgInfo("cut", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createAlignMTB(max_bits, exclude_range, cut), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createBackgroundSubtractorKNN(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int history=500;
    double dist2Threshold=400.0;
    bool detectShadows=true;
    Ptr<BackgroundSubtractorKNN> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "history"), history, ArgInfo("history", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist2Threshold"), dist2Threshold, ArgInfo("dist2Threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectShadows"), detectShadows, ArgInfo("detectShadows", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createBackgroundSubtractorKNN(history, dist2Threshold, detectShadows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createBackgroundSubtractorMOG2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int history=500;
    double varThreshold=16;
    bool detectShadows=true;
    Ptr<BackgroundSubtractorMOG2> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "history"), history, ArgInfo("history", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varThreshold"), varThreshold, ArgInfo("varThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectShadows"), detectShadows, ArgInfo("detectShadows", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createBackgroundSubtractorMOG2(history, varThreshold, detectShadows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createCLAHE(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double clipLimit=40.0;
    Size tileGridSize=Size(8, 8);
    Ptr<CLAHE> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "clipLimit"), clipLimit, ArgInfo("clipLimit", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tileGridSize"), tileGridSize, ArgInfo("tileGridSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createCLAHE(clipLimit, tileGridSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createCalibrateDebevec(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int samples=70;
    float lambda=10.0f;
    bool random=false;
    Ptr<CalibrateDebevec> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "random"), random, ArgInfo("random", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createCalibrateDebevec(samples, lambda, random), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createCalibrateRobertson(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int max_iter=30;
    float threshold=0.01f;
    Ptr<CalibrateRobertson> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "max_iter"), max_iter, ArgInfo("max_iter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createCalibrateRobertson(max_iter, threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createChiHistogramCostExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nDummies=25;
    float defaultCost=0.2f;
    Ptr<HistogramCostExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nDummies"), nDummies, ArgInfo("nDummies", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "defaultCost"), defaultCost, ArgInfo("defaultCost", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createChiHistogramCostExtractor(nDummies, defaultCost), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createEMDHistogramCostExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int flag=DIST_L2;
    int nDummies=25;
    float defaultCost=0.2f;
    Ptr<HistogramCostExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nDummies"), nDummies, ArgInfo("nDummies", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "defaultCost"), defaultCost, ArgInfo("defaultCost", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createEMDHistogramCostExtractor(flag, nDummies, defaultCost), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createEMDL1HistogramCostExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nDummies=25;
    float defaultCost=0.2f;
    Ptr<HistogramCostExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nDummies"), nDummies, ArgInfo("nDummies", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "defaultCost"), defaultCost, ArgInfo("defaultCost", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createEMDL1HistogramCostExtractor(nDummies, defaultCost), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createGeneralizedHoughBallard(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<GeneralizedHoughBallard> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createGeneralizedHoughBallard(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createGeneralizedHoughGuil(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<GeneralizedHoughGuil> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createGeneralizedHoughGuil(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createHanningWindow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat dst;
    Size winSize;
    int type;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::createHanningWindow(dst, winSize, type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_dst;
    Size winSize;
    int type;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winSize"), winSize, ArgInfo("winSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::createHanningWindow(dst, winSize, type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createHausdorffDistanceExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int distanceFlag=cv::NORM_L2;
    float rankProp=0.6f;
    Ptr<HausdorffDistanceExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceFlag"), distanceFlag, ArgInfo("distanceFlag", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rankProp"), rankProp, ArgInfo("rankProp", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createHausdorffDistanceExtractor(distanceFlag, rankProp), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createLineSegmentDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int refine=LSD_REFINE_STD;
    double scale=0.8;
    double sigma_scale=0.6;
    double quant=2.0;
    double ang_th=22.5;
    double log_eps=0;
    double density_th=0.7;
    int n_bins=1024;
    Ptr<LineSegmentDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "refine"), refine, ArgInfo("refine", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_scale"), sigma_scale, ArgInfo("sigma_scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "quant"), quant, ArgInfo("quant", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ang_th"), ang_th, ArgInfo("ang_th", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "log_eps"), log_eps, ArgInfo("log_eps", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "density_th"), density_th, ArgInfo("density_th", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "n_bins"), n_bins, ArgInfo("n_bins", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createLineSegmentDetector(refine, scale, sigma_scale, quant, ang_th, log_eps, density_th, n_bins), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createMergeDebevec(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<MergeDebevec> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createMergeDebevec(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createMergeMertens(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float contrast_weight=1.0f;
    float saturation_weight=1.0f;
    float exposure_weight=0.0f;
    Ptr<MergeMertens> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "contrast_weight"), contrast_weight, ArgInfo("contrast_weight", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation_weight"), saturation_weight, ArgInfo("saturation_weight", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "exposure_weight"), exposure_weight, ArgInfo("exposure_weight", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createMergeMertens(contrast_weight, saturation_weight, exposure_weight), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createMergeRobertson(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<MergeRobertson> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createMergeRobertson(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createNormHistogramCostExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int flag=DIST_L2;
    int nDummies=25;
    float defaultCost=0.2f;
    Ptr<HistogramCostExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nDummies"), nDummies, ArgInfo("nDummies", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "defaultCost"), defaultCost, ArgInfo("defaultCost", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createNormHistogramCostExtractor(flag, nDummies, defaultCost), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createShapeContextDistanceExtractor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nAngularBins=12;
    int nRadialBins=4;
    float innerRadius=0.2f;
    float outerRadius=2;
    int iterations=3;
    Ptr<HistogramCostExtractor> comparer=createChiHistogramCostExtractor();
    Ptr<ShapeTransformer> transformer=createThinPlateSplineShapeTransformer();
    Ptr<ShapeContextDistanceExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nAngularBins"), nAngularBins, ArgInfo("nAngularBins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nRadialBins"), nRadialBins, ArgInfo("nRadialBins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "innerRadius"), innerRadius, ArgInfo("innerRadius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outerRadius"), outerRadius, ArgInfo("outerRadius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "comparer"), comparer, ArgInfo("comparer", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformer"), transformer, ArgInfo("transformer", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createShapeContextDistanceExtractor(nAngularBins, nRadialBins, innerRadius, outerRadius, iterations, comparer, transformer), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createThinPlateSplineShapeTransformer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double regularizationParameter=0;
    Ptr<ThinPlateSplineShapeTransformer> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "regularizationParameter"), regularizationParameter, ArgInfo("regularizationParameter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createThinPlateSplineShapeTransformer(regularizationParameter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createTonemap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float gamma=1.0f;
    Ptr<Tonemap> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createTonemap(gamma), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createTonemapDrago(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float gamma=1.0f;
    float saturation=1.0f;
    float bias=0.85f;
    Ptr<TonemapDrago> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation"), saturation, ArgInfo("saturation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bias"), bias, ArgInfo("bias", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createTonemapDrago(gamma, saturation, bias), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createTonemapMantiuk(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float gamma=1.0f;
    float scale=0.7f;
    float saturation=1.0f;
    Ptr<TonemapMantiuk> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation"), saturation, ArgInfo("saturation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createTonemapMantiuk(gamma, scale, saturation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_createTonemapReinhard(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float gamma=1.0f;
    float intensity=0.0f;
    float light_adapt=1.0f;
    float color_adapt=0.0f;
    Ptr<TonemapReinhard> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "intensity"), intensity, ArgInfo("intensity", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "light_adapt"), light_adapt, ArgInfo("light_adapt", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color_adapt"), color_adapt, ArgInfo("color_adapt", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::createTonemapReinhard(gamma, intensity, light_adapt, color_adapt), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cubeRoot(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float val;
    float retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cubeRoot(val), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cvtColor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int code;
    int dstCn=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstCn"), dstCn, ArgInfo("dstCn", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cvtColor(src, dst, code, dstCn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int code;
    int dstCn=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstCn"), dstCn, ArgInfo("dstCn", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::cvtColor(src, dst, code, dstCn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cvtColorTwoPlane(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    int code;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cvtColorTwoPlane(src1, src2, dst, code), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    int code;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::cvtColorTwoPlane(src1, src2, dst, code), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dct(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::dct(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_decolor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat grayscale;
    Mat color_boost;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "grayscale"), grayscale, ArgInfo("grayscale", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color_boost"), color_boost, ArgInfo("color_boost", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::decolor(src, grayscale, color_boost), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, grayscale), evision_from(env, color_boost));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_grayscale;
    Ptr<UMat> ptr_color_boost;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "grayscale"), ptr_grayscale, ArgInfo("grayscale", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color_boost"), ptr_color_boost, ArgInfo("color_boost", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat grayscale; if (ptr_grayscale.get()) { grayscale = *ptr_grayscale.get(); }
        UMat color_boost; if (ptr_color_boost.get()) { color_boost = *ptr_color_boost.get(); }
    
        ERRWRAP2(cv::decolor(src, grayscale, color_boost), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, grayscale), evision_from(env, color_boost));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_decomposeEssentialMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat E;
    Mat R1;
    Mat R2;
    Mat t;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::decomposeEssentialMat(E, R1, R2, t), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, R1), evision_from(env, R2), evision_from(env, t));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_R1;
    Ptr<UMat> ptr_R2;
    Ptr<UMat> ptr_t;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), ptr_R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), ptr_R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_t, ArgInfo("t", 1, 0)) )
    {
        error_flag = false;
            UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat R1; if (ptr_R1.get()) { R1 = *ptr_R1.get(); }
        UMat R2; if (ptr_R2.get()) { R2 = *ptr_R2.get(); }
        UMat t; if (ptr_t.get()) { t = *ptr_t.get(); }
    
        ERRWRAP2(cv::decomposeEssentialMat(E, R1, R2, t), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, R1), evision_from(env, R2), evision_from(env, t));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_decomposeHomographyMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat H;
    Mat K;
    vector_Mat rotations;
    vector_Mat translations;
    vector_Mat normals;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), H, ArgInfo("H", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotations"), rotations, ArgInfo("rotations", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "translations"), translations, ArgInfo("translations", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normals"), normals, ArgInfo("normals", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::decomposeHomographyMat(H, K, rotations, translations, normals), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, rotations), evision_from(env, translations), evision_from(env, normals));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_H;
    Ptr<UMat> ptr_K;
    vector_UMat rotations;
    vector_UMat translations;
    vector_UMat normals;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), ptr_H, ArgInfo("H", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), ptr_K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotations"), rotations, ArgInfo("rotations", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "translations"), translations, ArgInfo("translations", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normals"), normals, ArgInfo("normals", 1, 0)) )
    {
        error_flag = false;
            UMat H; if (ptr_H.get()) { H = *ptr_H.get(); }
        UMat K; if (ptr_K.get()) { K = *ptr_K.get(); }
    
        ERRWRAP2(retval = cv::decomposeHomographyMat(H, K, rotations, translations, normals), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, rotations), evision_from(env, translations), evision_from(env, normals));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_decomposeProjectionMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat projMatrix;
    Mat cameraMatrix;
    Mat rotMatrix;
    Mat transVect;
    Mat rotMatrixX;
    Mat rotMatrixY;
    Mat rotMatrixZ;
    Mat eulerAngles;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projMatrix"), projMatrix, ArgInfo("projMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrix"), rotMatrix, ArgInfo("rotMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transVect"), transVect, ArgInfo("transVect", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrixX"), rotMatrixX, ArgInfo("rotMatrixX", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrixY"), rotMatrixY, ArgInfo("rotMatrixY", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrixZ"), rotMatrixZ, ArgInfo("rotMatrixZ", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eulerAngles"), eulerAngles, ArgInfo("eulerAngles", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::decomposeProjectionMatrix(projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, cameraMatrix), evision_from(env, rotMatrix), evision_from(env, transVect), evision_from(env, rotMatrixX), evision_from(env, rotMatrixY), evision_from(env, rotMatrixZ), evision_from(env, eulerAngles));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_projMatrix;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_rotMatrix;
    Ptr<UMat> ptr_transVect;
    Ptr<UMat> ptr_rotMatrixX;
    Ptr<UMat> ptr_rotMatrixY;
    Ptr<UMat> ptr_rotMatrixZ;
    Ptr<UMat> ptr_eulerAngles;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projMatrix"), ptr_projMatrix, ArgInfo("projMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrix"), ptr_rotMatrix, ArgInfo("rotMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transVect"), ptr_transVect, ArgInfo("transVect", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrixX"), ptr_rotMatrixX, ArgInfo("rotMatrixX", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrixY"), ptr_rotMatrixY, ArgInfo("rotMatrixY", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotMatrixZ"), ptr_rotMatrixZ, ArgInfo("rotMatrixZ", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eulerAngles"), ptr_eulerAngles, ArgInfo("eulerAngles", 1, 1)) )
    {
        error_flag = false;
            UMat projMatrix; if (ptr_projMatrix.get()) { projMatrix = *ptr_projMatrix.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat rotMatrix; if (ptr_rotMatrix.get()) { rotMatrix = *ptr_rotMatrix.get(); }
        UMat transVect; if (ptr_transVect.get()) { transVect = *ptr_transVect.get(); }
        UMat rotMatrixX; if (ptr_rotMatrixX.get()) { rotMatrixX = *ptr_rotMatrixX.get(); }
        UMat rotMatrixY; if (ptr_rotMatrixY.get()) { rotMatrixY = *ptr_rotMatrixY.get(); }
        UMat rotMatrixZ; if (ptr_rotMatrixZ.get()) { rotMatrixZ = *ptr_rotMatrixZ.get(); }
        UMat eulerAngles; if (ptr_eulerAngles.get()) { eulerAngles = *ptr_eulerAngles.get(); }
    
        ERRWRAP2(cv::decomposeProjectionMatrix(projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, cameraMatrix), evision_from(env, rotMatrix), evision_from(env, transVect), evision_from(env, rotMatrixX), evision_from(env, rotMatrixY), evision_from(env, rotMatrixZ), evision_from(env, eulerAngles));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_demosaicing(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int code;
    int dstCn=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstCn"), dstCn, ArgInfo("dstCn", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::demosaicing(src, dst, code, dstCn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int code;
    int dstCn=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstCn"), dstCn, ArgInfo("dstCn", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::demosaicing(src, dst, code, dstCn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_denoise_TVL1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Mat observations;
    Mat result;
    double lambda=1.0;
    int niters=30;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "observations"), observations, ArgInfo("observations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "niters"), niters, ArgInfo("niters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::denoise_TVL1(observations, result, lambda, niters), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detailEnhance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    float sigma_s=10;
    float sigma_r=0.15f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detailEnhance(src, dst, sigma_s, sigma_r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    float sigma_s=10;
    float sigma_r=0.15f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::detailEnhance(src, dst, sigma_s, sigma_r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_determinant(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat mtx;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtx"), mtx, ArgInfo("mtx", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::determinant(mtx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_mtx;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtx"), ptr_mtx, ArgInfo("mtx", 0, 0)) )
    {
        error_flag = false;
            UMat mtx; if (ptr_mtx.get()) { mtx = *ptr_mtx.get(); }
    
        ERRWRAP2(retval = cv::determinant(mtx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dft(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags=0;
    int nonzeroRows=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonzeroRows"), nonzeroRows, ArgInfo("nonzeroRows", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dft(src, dst, flags, nonzeroRows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags=0;
    int nonzeroRows=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonzeroRows"), nonzeroRows, ArgInfo("nonzeroRows", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::dft(src, dst, flags, nonzeroRows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dilate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat kernel;
    Point anchor=Point(-1,-1);
    int iterations=1;
    int borderType=BORDER_CONSTANT;
    Scalar borderValue=morphologyDefaultBorderValue();

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dilate(src, dst, kernel, anchor, iterations, borderType, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_kernel;
    Point anchor=Point(-1,-1);
    int iterations=1;
    int borderType=BORDER_CONSTANT;
    Scalar borderValue=morphologyDefaultBorderValue();

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), ptr_kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat kernel; if (ptr_kernel.get()) { kernel = *ptr_kernel.get(); }
    
        ERRWRAP2(cv::dilate(src, dst, kernel, anchor, iterations, borderType, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_displayOverlay(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    String text;
    int delayms=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "text"), text, ArgInfo("text", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delayms"), delayms, ArgInfo("delayms", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::displayOverlay(winname, text, delayms), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_displayStatusBar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    String text;
    int delayms=0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "text"), text, ArgInfo("text", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delayms"), delayms, ArgInfo("delayms", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::displayStatusBar(winname, text, delayms), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_distanceTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int distanceType;
    int maskSize;
    int dstType=CV_32F;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceType"), distanceType, ArgInfo("distanceType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maskSize"), maskSize, ArgInfo("maskSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstType"), dstType, ArgInfo("dstType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::distanceTransform(src, dst, distanceType, maskSize, dstType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int distanceType;
    int maskSize;
    int dstType=CV_32F;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceType"), distanceType, ArgInfo("distanceType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maskSize"), maskSize, ArgInfo("maskSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstType"), dstType, ArgInfo("dstType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::distanceTransform(src, dst, distanceType, maskSize, dstType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_distanceTransformWithLabels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat labels;
    int distanceType;
    int maskSize;
    int labelType=DIST_LABEL_CCOMP;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceType"), distanceType, ArgInfo("distanceType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maskSize"), maskSize, ArgInfo("maskSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labelType"), labelType, ArgInfo("labelType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::distanceTransform(src, dst, labels, distanceType, maskSize, labelType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, labels));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_labels;
    int distanceType;
    int maskSize;
    int labelType=DIST_LABEL_CCOMP;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labels"), ptr_labels, ArgInfo("labels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceType"), distanceType, ArgInfo("distanceType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maskSize"), maskSize, ArgInfo("maskSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "labelType"), labelType, ArgInfo("labelType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat labels; if (ptr_labels.get()) { labels = *ptr_labels.get(); }
    
        ERRWRAP2(cv::distanceTransform(src, dst, labels, distanceType, maskSize, labelType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst), evision_from(env, labels));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_divSpectrums(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat a;
    Mat b;
    Mat c;
    int flags;
    bool conjB=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c"), c, ArgInfo("c", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "conjB"), conjB, ArgInfo("conjB", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::divSpectrums(a, b, c, flags, conjB), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, c);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_a;
    Ptr<UMat> ptr_b;
    Ptr<UMat> ptr_c;
    int flags;
    bool conjB=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), ptr_a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), ptr_b, ArgInfo("b", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c"), ptr_c, ArgInfo("c", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "conjB"), conjB, ArgInfo("conjB", 0, 1)) )
    {
        error_flag = false;
            UMat a; if (ptr_a.get()) { a = *ptr_a.get(); }
        UMat b; if (ptr_b.get()) { b = *ptr_b.get(); }
        UMat c; if (ptr_c.get()) { c = *ptr_c.get(); }
    
        ERRWRAP2(cv::divSpectrums(a, b, c, flags, conjB), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, c);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_divide(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    double scale;
    Mat src2;
    Mat dst;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::divide(scale, src2, dst, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat src1;
    Mat src2;
    Mat dst;
    double scale=1;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::divide(src1, src2, dst, scale, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    double scale;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::divide(scale, src2, dst, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    double scale=1;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::divide(src1, src2, dst, scale, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawChessboardCorners(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patternSize;
    Mat corners;
    bool patternWasFound;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternWasFound"), patternWasFound, ArgInfo("patternWasFound", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawChessboardCorners(image, patternSize, corners, patternWasFound), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_corners;
    bool patternWasFound;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternWasFound"), patternWasFound, ArgInfo("patternWasFound", 0, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
    
        ERRWRAP2(cv::drawChessboardCorners(image, patternSize, corners, patternWasFound), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawContours(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    vector_Mat contours;
    int contourIdx;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    Mat hierarchy;
    int maxLevel=INT_MAX;
    Point offset;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contours"), contours, ArgInfo("contours", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contourIdx"), contourIdx, ArgInfo("contourIdx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hierarchy"), hierarchy, ArgInfo("hierarchy", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    vector_UMat contours;
    int contourIdx;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    Ptr<UMat> ptr_hierarchy;
    int maxLevel=INT_MAX;
    Point offset;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contours"), contours, ArgInfo("contours", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contourIdx"), contourIdx, ArgInfo("contourIdx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hierarchy"), ptr_hierarchy, ArgInfo("hierarchy", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat hierarchy; if (ptr_hierarchy.get()) { hierarchy = *ptr_hierarchy.get(); }
    
        ERRWRAP2(cv::drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawFrameAxes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    float length;
    int thickness=3;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "length"), length, ArgInfo("length", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, thickness), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    float length;
    int thickness=3;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "length"), length, ArgInfo("length", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
    
        ERRWRAP2(cv::drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, thickness), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawKeypoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    vector_KeyPoint keypoints;
    Mat outImage;
    Scalar color=Scalar::all(-1);
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImage"), outImage, ArgInfo("outImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawKeypoints(image, keypoints, outImage, color, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImage);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    vector_KeyPoint keypoints;
    Ptr<UMat> ptr_outImage;
    Scalar color=Scalar::all(-1);
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints"), keypoints, ArgInfo("keypoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImage"), ptr_outImage, ArgInfo("outImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat outImage; if (ptr_outImage.get()) { outImage = *ptr_outImage.get(); }
    
        ERRWRAP2(cv::drawKeypoints(image, keypoints, outImage, color, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImage);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawMarker(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Point position;
    Scalar color;
    int markerType=MARKER_CROSS;
    int markerSize=20;
    int thickness=1;
    int line_type=8;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "position"), position, ArgInfo("position", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerType"), markerType, ArgInfo("markerType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerSize"), markerSize, ArgInfo("markerSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "line_type"), line_type, ArgInfo("line_type", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawMarker(img, position, color, markerType, markerSize, thickness, line_type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Point position;
    Scalar color;
    int markerType=MARKER_CROSS;
    int markerSize=20;
    int thickness=1;
    int line_type=8;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "position"), position, ArgInfo("position", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerType"), markerType, ArgInfo("markerType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerSize"), markerSize, ArgInfo("markerSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "line_type"), line_type, ArgInfo("line_type", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::drawMarker(img, position, color, markerType, markerSize, thickness, line_type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawMatches(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img1;
    vector_KeyPoint keypoints1;
    Mat img2;
    vector_KeyPoint keypoints2;
    vector_DMatch matches1to2;
    Mat outImg;
    int matchesThickness;
    Scalar matchColor=Scalar::all(-1);
    Scalar singlePointColor=Scalar::all(-1);
    vector_char matchesMask=std::vector<char>();
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesThickness"), matchesThickness, ArgInfo("matchesThickness", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singlePointColor"), singlePointColor, ArgInfo("singlePointColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness, matchColor, singlePointColor, matchesMask, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img1;
    vector_KeyPoint keypoints1;
    Ptr<UMat> ptr_img2;
    vector_KeyPoint keypoints2;
    vector_DMatch matches1to2;
    Ptr<UMat> ptr_outImg;
    int matchesThickness;
    Scalar matchColor=Scalar::all(-1);
    Scalar singlePointColor=Scalar::all(-1);
    vector_char matchesMask=std::vector<char>();
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), ptr_img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), ptr_img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), ptr_outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesThickness"), matchesThickness, ArgInfo("matchesThickness", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singlePointColor"), singlePointColor, ArgInfo("singlePointColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat img1; if (ptr_img1.get()) { img1 = *ptr_img1.get(); }
        UMat img2; if (ptr_img2.get()) { img2 = *ptr_img2.get(); }
        UMat outImg; if (ptr_outImg.get()) { outImg = *ptr_outImg.get(); }
    
        ERRWRAP2(cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness, matchColor, singlePointColor, matchesMask, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    }
    

    {
    Mat img1;
    vector_KeyPoint keypoints1;
    Mat img2;
    vector_KeyPoint keypoints2;
    vector_DMatch matches1to2;
    Mat outImg;
    Scalar matchColor=Scalar::all(-1);
    Scalar singlePointColor=Scalar::all(-1);
    vector_char matchesMask=std::vector<char>();
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singlePointColor"), singlePointColor, ArgInfo("singlePointColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img1;
    vector_KeyPoint keypoints1;
    Ptr<UMat> ptr_img2;
    vector_KeyPoint keypoints2;
    vector_DMatch matches1to2;
    Ptr<UMat> ptr_outImg;
    Scalar matchColor=Scalar::all(-1);
    Scalar singlePointColor=Scalar::all(-1);
    vector_char matchesMask=std::vector<char>();
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), ptr_img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), ptr_img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), ptr_outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singlePointColor"), singlePointColor, ArgInfo("singlePointColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat img1; if (ptr_img1.get()) { img1 = *ptr_img1.get(); }
        UMat img2; if (ptr_img2.get()) { img2 = *ptr_img2.get(); }
        UMat outImg; if (ptr_outImg.get()) { outImg = *ptr_outImg.get(); }
    
        ERRWRAP2(cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_drawMatchesKnn(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img1;
    vector_KeyPoint keypoints1;
    Mat img2;
    vector_KeyPoint keypoints2;
    vector_vector_DMatch matches1to2;
    Mat outImg;
    Scalar matchColor=Scalar::all(-1);
    Scalar singlePointColor=Scalar::all(-1);
    vector_vector_char matchesMask=std::vector<std::vector<char> >();
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singlePointColor"), singlePointColor, ArgInfo("singlePointColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img1;
    vector_KeyPoint keypoints1;
    Ptr<UMat> ptr_img2;
    vector_KeyPoint keypoints2;
    vector_vector_DMatch matches1to2;
    Ptr<UMat> ptr_outImg;
    Scalar matchColor=Scalar::all(-1);
    Scalar singlePointColor=Scalar::all(-1);
    vector_vector_char matchesMask=std::vector<std::vector<char> >();
    std::underlying_type_t<DrawMatchesFlags> flags=static_cast<std::underlying_type_t<DrawMatchesFlags>>(DrawMatchesFlags::DEFAULT);

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), ptr_img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), ptr_img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), ptr_outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singlePointColor"), singlePointColor, ArgInfo("singlePointColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat img1; if (ptr_img1.get()) { img1 = *ptr_img1.get(); }
        UMat img2; if (ptr_img2.get()) { img2 = *ptr_img2.get(); }
        UMat outImg; if (ptr_outImg.get()) { outImg = *ptr_outImg.get(); }
    
        ERRWRAP2(cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, static_cast<DrawMatchesFlags>(flags)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_edgePreservingFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags=1;
    float sigma_s=60;
    float sigma_r=0.4f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::edgePreservingFilter(src, dst, flags, sigma_s, sigma_r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags=1;
    float sigma_s=60;
    float sigma_r=0.4f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::edgePreservingFilter(src, dst, flags, sigma_s, sigma_r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_eigen(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat eigenvalues;
    Mat eigenvectors;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::eigen(src, eigenvalues, eigenvectors), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, eigenvalues), evision_from(env, eigenvectors));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_eigenvalues;
    Ptr<UMat> ptr_eigenvectors;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), ptr_eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 1, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat eigenvalues; if (ptr_eigenvalues.get()) { eigenvalues = *ptr_eigenvalues.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
    
        ERRWRAP2(retval = cv::eigen(src, eigenvalues, eigenvectors), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, eigenvalues), evision_from(env, eigenvectors));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_eigenNonSymmetric(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat eigenvalues;
    Mat eigenvectors;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), eigenvectors, ArgInfo("eigenvectors", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::eigenNonSymmetric(src, eigenvalues, eigenvectors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, eigenvalues), evision_from(env, eigenvectors));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_eigenvalues;
    Ptr<UMat> ptr_eigenvectors;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvalues"), ptr_eigenvalues, ArgInfo("eigenvalues", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eigenvectors"), ptr_eigenvectors, ArgInfo("eigenvectors", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat eigenvalues; if (ptr_eigenvalues.get()) { eigenvalues = *ptr_eigenvalues.get(); }
        UMat eigenvectors; if (ptr_eigenvectors.get()) { eigenvectors = *ptr_eigenvectors.get(); }
    
        ERRWRAP2(cv::eigenNonSymmetric(src, eigenvalues, eigenvectors), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, eigenvalues), evision_from(env, eigenvectors));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ellipse(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Point center;
    Size axes;
    double angle;
    double startAngle;
    double endAngle;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axes"), axes, ArgInfo("axes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "startAngle"), startAngle, ArgInfo("startAngle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "endAngle"), endAngle, ArgInfo("endAngle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Point center;
    Size axes;
    double angle;
    double startAngle;
    double endAngle;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axes"), axes, ArgInfo("axes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "startAngle"), startAngle, ArgInfo("startAngle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "endAngle"), endAngle, ArgInfo("endAngle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Mat img;
    RotatedRect box;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "box"), box, ArgInfo("box", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ellipse(img, box, color, thickness, lineType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    RotatedRect box;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "box"), box, ArgInfo("box", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::ellipse(img, box, color, thickness, lineType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ellipse2Poly(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Point center;
    Size axes;
    int angle;
    int arcStart;
    int arcEnd;
    int delta;
    vector_Point pts;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axes"), axes, ArgInfo("axes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arcStart"), arcStart, ArgInfo("arcStart", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arcEnd"), arcEnd, ArgInfo("arcEnd", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta, pts), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pts);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_equalizeHist(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::equalizeHist(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::equalizeHist(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_erode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat kernel;
    Point anchor=Point(-1,-1);
    int iterations=1;
    int borderType=BORDER_CONSTANT;
    Scalar borderValue=morphologyDefaultBorderValue();

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::erode(src, dst, kernel, anchor, iterations, borderType, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_kernel;
    Point anchor=Point(-1,-1);
    int iterations=1;
    int borderType=BORDER_CONSTANT;
    Scalar borderValue=morphologyDefaultBorderValue();

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), ptr_kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat kernel; if (ptr_kernel.get()) { kernel = *ptr_kernel.get(); }
    
        ERRWRAP2(cv::erode(src, dst, kernel, anchor, iterations, borderType, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_estimateAffine2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat pts1;
    Mat pts2;
    Mat inliers;
    UsacParams params;
    cv::Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts1"), pts1, ArgInfo("pts1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts2"), pts2, ArgInfo("pts2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateAffine2D(pts1, pts2, inliers, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, inliers));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_pts1;
    Ptr<UMat> ptr_pts2;
    Ptr<UMat> ptr_inliers;
    UsacParams params;
    cv::Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts1"), ptr_pts1, ArgInfo("pts1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts2"), ptr_pts2, ArgInfo("pts2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
            UMat pts1; if (ptr_pts1.get()) { pts1 = *ptr_pts1.get(); }
        UMat pts2; if (ptr_pts2.get()) { pts2 = *ptr_pts2.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::estimateAffine2D(pts1, pts2, inliers, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, inliers));
        }
    }

    }
    

    {
    Mat from;
    Mat to;
    Mat inliers;
    int method=RANSAC;
    double ransacReprojThreshold=3;
    size_t maxIters=2000;
    double confidence=0.99;
    size_t refineIters=10;
    cv::Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "from"), from, ArgInfo("from", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "to"), to, ArgInfo("to", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "refineIters"), refineIters, ArgInfo("refineIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateAffine2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, inliers));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_from;
    Ptr<UMat> ptr_to;
    Ptr<UMat> ptr_inliers;
    int method=RANSAC;
    double ransacReprojThreshold=3;
    size_t maxIters=2000;
    double confidence=0.99;
    size_t refineIters=10;
    cv::Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "from"), ptr_from, ArgInfo("from", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "to"), ptr_to, ArgInfo("to", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "refineIters"), refineIters, ArgInfo("refineIters", 0, 1)) )
    {
        error_flag = false;
            UMat from; if (ptr_from.get()) { from = *ptr_from.get(); }
        UMat to; if (ptr_to.get()) { to = *ptr_to.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::estimateAffine2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, inliers));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_estimateAffine3D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat out;
    Mat inliers;
    double ransacThreshold=3;
    double confidence=0.99;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacThreshold"), ransacThreshold, ArgInfo("ransacThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateAffine3D(src, dst, out, inliers, ransacThreshold, confidence), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, out), evision_from(env, inliers));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_out;
    Ptr<UMat> ptr_inliers;
    double ransacThreshold=3;
    double confidence=0.99;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), ptr_out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacThreshold"), ransacThreshold, ArgInfo("ransacThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat out; if (ptr_out.get()) { out = *ptr_out.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::estimateAffine3D(src, dst, out, inliers, ransacThreshold, confidence), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, out), evision_from(env, inliers));
        }
    }

    }
    

    {
    Mat src;
    Mat dst;
    double scale;
    bool force_rotation=true;
    cv::Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "force_rotation"), force_rotation, ArgInfo("force_rotation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateAffine3D(src, dst, &scale, force_rotation), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, scale));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double scale;
    bool force_rotation=true;
    cv::Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "force_rotation"), force_rotation, ArgInfo("force_rotation", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(retval = cv::estimateAffine3D(src, dst, &scale, force_rotation), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, scale));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_estimateAffinePartial2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat from;
    Mat to;
    Mat inliers;
    int method=RANSAC;
    double ransacReprojThreshold=3;
    size_t maxIters=2000;
    double confidence=0.99;
    size_t refineIters=10;
    cv::Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "from"), from, ArgInfo("from", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "to"), to, ArgInfo("to", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "refineIters"), refineIters, ArgInfo("refineIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateAffinePartial2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, inliers));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_from;
    Ptr<UMat> ptr_to;
    Ptr<UMat> ptr_inliers;
    int method=RANSAC;
    double ransacReprojThreshold=3;
    size_t maxIters=2000;
    double confidence=0.99;
    size_t refineIters=10;
    cv::Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "from"), ptr_from, ArgInfo("from", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "to"), ptr_to, ArgInfo("to", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "refineIters"), refineIters, ArgInfo("refineIters", 0, 1)) )
    {
        error_flag = false;
            UMat from; if (ptr_from.get()) { from = *ptr_from.get(); }
        UMat to; if (ptr_to.get()) { to = *ptr_to.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::estimateAffinePartial2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, inliers));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_estimateChessboardSharpness(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patternSize;
    Mat corners;
    float rise_distance=0.8F;
    bool vertical=false;
    Mat sharpness;
    Scalar retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rise_distance"), rise_distance, ArgInfo("rise_distance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vertical"), vertical, ArgInfo("vertical", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sharpness"), sharpness, ArgInfo("sharpness", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateChessboardSharpness(image, patternSize, corners, rise_distance, vertical, sharpness), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, sharpness));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_corners;
    float rise_distance=0.8F;
    bool vertical=false;
    Ptr<UMat> ptr_sharpness;
    Scalar retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rise_distance"), rise_distance, ArgInfo("rise_distance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vertical"), vertical, ArgInfo("vertical", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sharpness"), ptr_sharpness, ArgInfo("sharpness", 1, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
        UMat sharpness; if (ptr_sharpness.get()) { sharpness = *ptr_sharpness.get(); }
    
        ERRWRAP2(retval = cv::estimateChessboardSharpness(image, patternSize, corners, rise_distance, vertical, sharpness), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, sharpness));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_estimateTranslation3D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat out;
    Mat inliers;
    double ransacThreshold=3;
    double confidence=0.99;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacThreshold"), ransacThreshold, ArgInfo("ransacThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::estimateTranslation3D(src, dst, out, inliers, ransacThreshold, confidence), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, out), evision_from(env, inliers));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_out;
    Ptr<UMat> ptr_inliers;
    double ransacThreshold=3;
    double confidence=0.99;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), ptr_out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacThreshold"), ransacThreshold, ArgInfo("ransacThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat out; if (ptr_out.get()) { out = *ptr_out.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::estimateTranslation3D(src, dst, out, inliers, ransacThreshold, confidence), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, out), evision_from(env, inliers));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_exp(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::exp(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::exp(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_extractChannel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int coi;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coi"), coi, ArgInfo("coi", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::extractChannel(src, dst, coi), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int coi;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coi"), coi, ArgInfo("coi", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::extractChannel(src, dst, coi), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastAtan2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float y;
    float x;
    float retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fastAtan2(y, x), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastNlMeansDenoising(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    vector_float h;
    int templateWindowSize=7;
    int searchWindowSize=21;
    int normType=NORM_L2;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize, normType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    vector_float h;
    int templateWindowSize=7;
    int searchWindowSize=21;
    int normType=NORM_L2;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize, normType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat src;
    Mat dst;
    float h=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    float h=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastNlMeansDenoisingColored(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    float h=3;
    float hColor=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hColor"), hColor, ArgInfo("hColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fastNlMeansDenoisingColored(src, dst, h, hColor, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    float h=3;
    float hColor=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hColor"), hColor, ArgInfo("hColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::fastNlMeansDenoisingColored(src, dst, h, hColor, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastNlMeansDenoisingColoredMulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat srcImgs;
    Mat dst;
    int imgToDenoiseIndex;
    int temporalWindowSize;
    float h=3;
    float hColor=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgs"), srcImgs, ArgInfo("srcImgs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgToDenoiseIndex"), imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "temporalWindowSize"), temporalWindowSize, ArgInfo("temporalWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hColor"), hColor, ArgInfo("hColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fastNlMeansDenoisingColoredMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, hColor, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat srcImgs;
    Ptr<UMat> ptr_dst;
    int imgToDenoiseIndex;
    int temporalWindowSize;
    float h=3;
    float hColor=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgs"), srcImgs, ArgInfo("srcImgs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgToDenoiseIndex"), imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "temporalWindowSize"), temporalWindowSize, ArgInfo("temporalWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hColor"), hColor, ArgInfo("hColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::fastNlMeansDenoisingColoredMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, hColor, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fastNlMeansDenoisingMulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat srcImgs;
    Mat dst;
    int imgToDenoiseIndex;
    int temporalWindowSize;
    vector_float h;
    int templateWindowSize=7;
    int searchWindowSize=21;
    int normType=NORM_L2;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgs"), srcImgs, ArgInfo("srcImgs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgToDenoiseIndex"), imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "temporalWindowSize"), temporalWindowSize, ArgInfo("temporalWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize, normType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat srcImgs;
    Ptr<UMat> ptr_dst;
    int imgToDenoiseIndex;
    int temporalWindowSize;
    vector_float h;
    int templateWindowSize=7;
    int searchWindowSize=21;
    int normType=NORM_L2;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgs"), srcImgs, ArgInfo("srcImgs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgToDenoiseIndex"), imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "temporalWindowSize"), temporalWindowSize, ArgInfo("temporalWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize, normType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_Mat srcImgs;
    Mat dst;
    int imgToDenoiseIndex;
    int temporalWindowSize;
    float h=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgs"), srcImgs, ArgInfo("srcImgs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgToDenoiseIndex"), imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "temporalWindowSize"), temporalWindowSize, ArgInfo("temporalWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat srcImgs;
    Ptr<UMat> ptr_dst;
    int imgToDenoiseIndex;
    int temporalWindowSize;
    float h=3;
    int templateWindowSize=7;
    int searchWindowSize=21;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgs"), srcImgs, ArgInfo("srcImgs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgToDenoiseIndex"), imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "temporalWindowSize"), temporalWindowSize, ArgInfo("temporalWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fillConvexPoly(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat points;
    Scalar color;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fillConvexPoly(img, points, color, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Ptr<UMat> ptr_points;
    Scalar color;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
        UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(cv::fillConvexPoly(img, points, color, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fillPoly(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    vector_Mat pts;
    Scalar color;
    int lineType=LINE_8;
    int shift=0;
    Point offset;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts"), pts, ArgInfo("pts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fillPoly(img, pts, color, lineType, shift, offset), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    vector_UMat pts;
    Scalar color;
    int lineType=LINE_8;
    int shift=0;
    Point offset;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts"), pts, ArgInfo("pts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::fillPoly(img, pts, color, lineType, shift, offset), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_filter2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    Mat kernel;
    Point anchor=Point(-1,-1);
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::filter2D(src, dst, ddepth, kernel, anchor, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    Ptr<UMat> ptr_kernel;
    Point anchor=Point(-1,-1);
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), ptr_kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat kernel; if (ptr_kernel.get()) { kernel = *ptr_kernel.get(); }
    
        ERRWRAP2(cv::filter2D(src, dst, ddepth, kernel, anchor, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_filterHomographyDecompByVisibleRefpoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat rotations;
    vector_Mat normals;
    Mat beforePoints;
    Mat afterPoints;
    Mat possibleSolutions;
    Mat pointsMask;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotations"), rotations, ArgInfo("rotations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normals"), normals, ArgInfo("normals", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beforePoints"), beforePoints, ArgInfo("beforePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "afterPoints"), afterPoints, ArgInfo("afterPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "possibleSolutions"), possibleSolutions, ArgInfo("possibleSolutions", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointsMask"), pointsMask, ArgInfo("pointsMask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, possibleSolutions, pointsMask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, possibleSolutions);
        }
    }

    }
    

    {
    vector_UMat rotations;
    vector_UMat normals;
    Ptr<UMat> ptr_beforePoints;
    Ptr<UMat> ptr_afterPoints;
    Ptr<UMat> ptr_possibleSolutions;
    Ptr<UMat> ptr_pointsMask;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotations"), rotations, ArgInfo("rotations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normals"), normals, ArgInfo("normals", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beforePoints"), ptr_beforePoints, ArgInfo("beforePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "afterPoints"), ptr_afterPoints, ArgInfo("afterPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "possibleSolutions"), ptr_possibleSolutions, ArgInfo("possibleSolutions", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointsMask"), ptr_pointsMask, ArgInfo("pointsMask", 0, 1)) )
    {
        error_flag = false;
            UMat beforePoints; if (ptr_beforePoints.get()) { beforePoints = *ptr_beforePoints.get(); }
        UMat afterPoints; if (ptr_afterPoints.get()) { afterPoints = *ptr_afterPoints.get(); }
        UMat possibleSolutions; if (ptr_possibleSolutions.get()) { possibleSolutions = *ptr_possibleSolutions.get(); }
        UMat pointsMask; if (ptr_pointsMask.get()) { pointsMask = *ptr_pointsMask.get(); }
    
        ERRWRAP2(cv::filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, possibleSolutions, pointsMask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, possibleSolutions);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_filterSpeckles(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    double newVal;
    int maxSpeckleSize;
    double maxDiff;
    Mat buf;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newVal"), newVal, ArgInfo("newVal", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSpeckleSize"), maxSpeckleSize, ArgInfo("maxSpeckleSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDiff"), maxDiff, ArgInfo("maxDiff", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buf"), buf, ArgInfo("buf", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, buf), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, img), evision_from(env, buf));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    double newVal;
    int maxSpeckleSize;
    double maxDiff;
    Ptr<UMat> ptr_buf;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newVal"), newVal, ArgInfo("newVal", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSpeckleSize"), maxSpeckleSize, ArgInfo("maxSpeckleSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDiff"), maxDiff, ArgInfo("maxDiff", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buf"), ptr_buf, ArgInfo("buf", 1, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
        UMat buf; if (ptr_buf.get()) { buf = *ptr_buf.get(); }
    
        ERRWRAP2(cv::filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, buf), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, img), evision_from(env, buf));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_find4QuadCornerSubpix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat corners;
    Size region_size;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "region_size"), region_size, ArgInfo("region_size", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::find4QuadCornerSubpix(img, corners, region_size), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, corners);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Ptr<UMat> ptr_corners;
    Size region_size;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "region_size"), region_size, ArgInfo("region_size", 0, 0)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
    
        ERRWRAP2(retval = cv::find4QuadCornerSubpix(img, corners, region_size), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, corners);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findChessboardCorners(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patternSize;
    Mat corners;
    int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findChessboardCorners(image, patternSize, corners, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, corners);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_corners;
    int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
    
        ERRWRAP2(retval = cv::findChessboardCorners(image, patternSize, corners, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, corners);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findChessboardCornersSB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patternSize;
    Mat corners;
    int flags=0;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findChessboardCornersSB(image, patternSize, corners, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, corners);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_corners;
    int flags=0;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
    
        ERRWRAP2(retval = cv::findChessboardCornersSB(image, patternSize, corners, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, corners);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findChessboardCornersSBWithMeta(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patternSize;
    Mat corners;
    int flags;
    Mat meta;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "meta"), meta, ArgInfo("meta", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findChessboardCornersSB(image, patternSize, corners, flags, meta), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, corners), evision_from(env, meta));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_corners;
    int flags;
    Ptr<UMat> ptr_meta;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "meta"), ptr_meta, ArgInfo("meta", 1, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
        UMat meta; if (ptr_meta.get()) { meta = *ptr_meta.get(); }
    
        ERRWRAP2(retval = cv::findChessboardCornersSB(image, patternSize, corners, flags, meta), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, corners), evision_from(env, meta));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findCirclesGrid(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patternSize;
    Mat centers;
    int flags;
    Ptr<FeatureDetector> blobDetector;
    CirclesGridFinderParameters parameters;
    bool retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centers"), centers, ArgInfo("centers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blobDetector"), blobDetector, ArgInfo("blobDetector", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector, parameters), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, centers);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_centers;
    int flags;
    Ptr<FeatureDetector> blobDetector;
    CirclesGridFinderParameters parameters;
    bool retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centers"), ptr_centers, ArgInfo("centers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blobDetector"), blobDetector, ArgInfo("blobDetector", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat centers; if (ptr_centers.get()) { centers = *ptr_centers.get(); }
    
        ERRWRAP2(retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector, parameters), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, centers);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat image;
    Size patternSize;
    Mat centers;
    int flags=CALIB_CB_SYMMETRIC_GRID;
    Ptr<FeatureDetector> blobDetector=SimpleBlobDetector::create();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centers"), centers, ArgInfo("centers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blobDetector"), blobDetector, ArgInfo("blobDetector", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, centers);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patternSize;
    Ptr<UMat> ptr_centers;
    int flags=CALIB_CB_SYMMETRIC_GRID;
    Ptr<FeatureDetector> blobDetector=SimpleBlobDetector::create();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternSize"), patternSize, ArgInfo("patternSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centers"), ptr_centers, ArgInfo("centers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blobDetector"), blobDetector, ArgInfo("blobDetector", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat centers; if (ptr_centers.get()) { centers = *ptr_centers.get(); }
    
        ERRWRAP2(retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, centers);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findContours(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    vector_Mat contours;
    Mat hierarchy;
    int mode;
    int method;
    Point offset;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contours"), contours, ArgInfo("contours", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hierarchy"), hierarchy, ArgInfo("hierarchy", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::findContours(image, contours, hierarchy, mode, method, offset), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, contours), evision_from(env, hierarchy));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    vector_UMat contours;
    Ptr<UMat> ptr_hierarchy;
    int mode;
    int method;
    Point offset;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contours"), contours, ArgInfo("contours", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hierarchy"), ptr_hierarchy, ArgInfo("hierarchy", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat hierarchy; if (ptr_hierarchy.get()) { hierarchy = *ptr_hierarchy.get(); }
    
        ERRWRAP2(cv::findContours(image, contours, hierarchy, mode, method, offset), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, contours), evision_from(env, hierarchy));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findEssentialMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points1;
    Mat points2;
    Mat cameraMatrix1;
    Mat cameraMatrix2;
    Mat dist_coeff1;
    Mat dist_coeff2;
    Mat mask;
    UsacParams params;
    Mat retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist_coeff1"), dist_coeff1, ArgInfo("dist_coeff1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist_coeff2"), dist_coeff2, ArgInfo("dist_coeff2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, mask, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_dist_coeff1;
    Ptr<UMat> ptr_dist_coeff2;
    Ptr<UMat> ptr_mask;
    UsacParams params;
    Mat retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist_coeff1"), ptr_dist_coeff1, ArgInfo("dist_coeff1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dist_coeff2"), ptr_dist_coeff2, ArgInfo("dist_coeff2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat dist_coeff1; if (ptr_dist_coeff1.get()) { dist_coeff1 = *ptr_dist_coeff1.get(); }
        UMat dist_coeff2; if (ptr_dist_coeff2.get()) { dist_coeff2 = *ptr_dist_coeff2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, mask, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat points1;
    Mat points2;
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    int method=RANSAC;
    double prob=0.999;
    double threshold=1.0;
    Mat mask;
    Mat retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, method, prob, threshold, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    int method=RANSAC;
    double prob=0.999;
    double threshold=1.0;
    Ptr<UMat> ptr_mask;
    Mat retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, method, prob, threshold, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat points1;
    Mat points2;
    Mat cameraMatrix;
    int method=RANSAC;
    double prob=0.999;
    double threshold=1.0;
    int maxIters=1000;
    Mat mask;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, cameraMatrix, method, prob, threshold, maxIters, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_cameraMatrix;
    int method=RANSAC;
    double prob=0.999;
    double threshold=1.0;
    int maxIters=1000;
    Ptr<UMat> ptr_mask;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, cameraMatrix, method, prob, threshold, maxIters, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat points1;
    Mat points2;
    double focal=1.0;
    Point2d pp=Point2d(0, 0);
    int method=RANSAC;
    double prob=0.999;
    double threshold=1.0;
    int maxIters=1000;
    Mat mask;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "focal"), focal, ArgInfo("focal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pp"), pp, ArgInfo("pp", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, focal, pp, method, prob, threshold, maxIters, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    double focal=1.0;
    Point2d pp=Point2d(0, 0);
    int method=RANSAC;
    double prob=0.999;
    double threshold=1.0;
    int maxIters=1000;
    Ptr<UMat> ptr_mask;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "focal"), focal, ArgInfo("focal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pp"), pp, ArgInfo("pp", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findEssentialMat(points1, points2, focal, pp, method, prob, threshold, maxIters, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findFundamentalMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points1;
    Mat points2;
    int method;
    double ransacReprojThreshold;
    double confidence;
    int maxIters;
    Mat mask;
    Mat retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    int method;
    double ransacReprojThreshold;
    double confidence;
    int maxIters;
    Ptr<UMat> ptr_mask;
    Mat retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat points1;
    Mat points2;
    Mat mask;
    UsacParams params;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findFundamentalMat(points1, points2, mask, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_mask;
    UsacParams params;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findFundamentalMat(points1, points2, mask, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat points1;
    Mat points2;
    int method=FM_RANSAC;
    double ransacReprojThreshold=3.;
    double confidence=0.99;
    Mat mask;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    int method=FM_RANSAC;
    double ransacReprojThreshold=3.;
    double confidence=0.99;
    Ptr<UMat> ptr_mask;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findHomography(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat srcPoints;
    Mat dstPoints;
    Mat mask;
    UsacParams params;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcPoints"), srcPoints, ArgInfo("srcPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstPoints"), dstPoints, ArgInfo("dstPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findHomography(srcPoints, dstPoints, mask, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_srcPoints;
    Ptr<UMat> ptr_dstPoints;
    Ptr<UMat> ptr_mask;
    UsacParams params;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcPoints"), ptr_srcPoints, ArgInfo("srcPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstPoints"), ptr_dstPoints, ArgInfo("dstPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
            UMat srcPoints; if (ptr_srcPoints.get()) { srcPoints = *ptr_srcPoints.get(); }
        UMat dstPoints; if (ptr_dstPoints.get()) { dstPoints = *ptr_dstPoints.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findHomography(srcPoints, dstPoints, mask, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat srcPoints;
    Mat dstPoints;
    int method=0;
    double ransacReprojThreshold=3;
    Mat mask;
    int maxIters=2000;
    double confidence=0.995;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcPoints"), srcPoints, ArgInfo("srcPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstPoints"), dstPoints, ArgInfo("dstPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findHomography(srcPoints, dstPoints, method, ransacReprojThreshold, mask, maxIters, confidence), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_srcPoints;
    Ptr<UMat> ptr_dstPoints;
    int method=0;
    double ransacReprojThreshold=3;
    Ptr<UMat> ptr_mask;
    int maxIters=2000;
    double confidence=0.995;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcPoints"), ptr_srcPoints, ArgInfo("srcPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstPoints"), ptr_dstPoints, ArgInfo("dstPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ransacReprojThreshold"), ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) )
    {
        error_flag = false;
            UMat srcPoints; if (ptr_srcPoints.get()) { srcPoints = *ptr_srcPoints.get(); }
        UMat dstPoints; if (ptr_dstPoints.get()) { dstPoints = *ptr_dstPoints.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::findHomography(srcPoints, dstPoints, method, ransacReprojThreshold, mask, maxIters, confidence), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, mask));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findNonZero(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat idx;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::findNonZero(src, idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, idx);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_idx;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), ptr_idx, ArgInfo("idx", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat idx; if (ptr_idx.get()) { idx = *ptr_idx.get(); }
    
        ERRWRAP2(cv::findNonZero(src, idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, idx);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_findTransformECC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat templateImage;
    Mat inputImage;
    Mat warpMatrix;
    int motionType;
    TermCriteria criteria;
    Mat inputMask;
    int gaussFiltSize;
    double retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateImage"), templateImage, ArgInfo("templateImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputImage"), inputImage, ArgInfo("inputImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpMatrix"), warpMatrix, ArgInfo("warpMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "motionType"), motionType, ArgInfo("motionType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputMask"), inputMask, ArgInfo("inputMask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gaussFiltSize"), gaussFiltSize, ArgInfo("gaussFiltSize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, warpMatrix));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_templateImage;
    Ptr<UMat> ptr_inputImage;
    Ptr<UMat> ptr_warpMatrix;
    int motionType;
    TermCriteria criteria;
    Ptr<UMat> ptr_inputMask;
    int gaussFiltSize;
    double retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateImage"), ptr_templateImage, ArgInfo("templateImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputImage"), ptr_inputImage, ArgInfo("inputImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpMatrix"), ptr_warpMatrix, ArgInfo("warpMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "motionType"), motionType, ArgInfo("motionType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputMask"), ptr_inputMask, ArgInfo("inputMask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gaussFiltSize"), gaussFiltSize, ArgInfo("gaussFiltSize", 0, 0)) )
    {
        error_flag = false;
            UMat templateImage; if (ptr_templateImage.get()) { templateImage = *ptr_templateImage.get(); }
        UMat inputImage; if (ptr_inputImage.get()) { inputImage = *ptr_inputImage.get(); }
        UMat warpMatrix; if (ptr_warpMatrix.get()) { warpMatrix = *ptr_warpMatrix.get(); }
        UMat inputMask; if (ptr_inputMask.get()) { inputMask = *ptr_inputMask.get(); }
    
        ERRWRAP2(retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, warpMatrix));
        }
    }

    }
    

    {
    Mat templateImage;
    Mat inputImage;
    Mat warpMatrix;
    int motionType=MOTION_AFFINE;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001);
    Mat inputMask;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateImage"), templateImage, ArgInfo("templateImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputImage"), inputImage, ArgInfo("inputImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpMatrix"), warpMatrix, ArgInfo("warpMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "motionType"), motionType, ArgInfo("motionType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputMask"), inputMask, ArgInfo("inputMask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, warpMatrix));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_templateImage;
    Ptr<UMat> ptr_inputImage;
    Ptr<UMat> ptr_warpMatrix;
    int motionType=MOTION_AFFINE;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001);
    Ptr<UMat> ptr_inputMask;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateImage"), ptr_templateImage, ArgInfo("templateImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputImage"), ptr_inputImage, ArgInfo("inputImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpMatrix"), ptr_warpMatrix, ArgInfo("warpMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "motionType"), motionType, ArgInfo("motionType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputMask"), ptr_inputMask, ArgInfo("inputMask", 0, 1)) )
    {
        error_flag = false;
            UMat templateImage; if (ptr_templateImage.get()) { templateImage = *ptr_templateImage.get(); }
        UMat inputImage; if (ptr_inputImage.get()) { inputImage = *ptr_inputImage.get(); }
        UMat warpMatrix; if (ptr_warpMatrix.get()) { warpMatrix = *ptr_warpMatrix.get(); }
        UMat inputMask; if (ptr_inputMask.get()) { inputMask = *ptr_inputMask.get(); }
    
        ERRWRAP2(retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, warpMatrix));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fitEllipse(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fitEllipse(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(retval = cv::fitEllipse(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fitEllipseAMS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fitEllipseAMS(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(retval = cv::fitEllipseAMS(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fitEllipseDirect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fitEllipseDirect(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(retval = cv::fitEllipseDirect(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fitLine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    Mat line;
    int distType;
    double param;
    double reps;
    double aeps;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "line"), line, ArgInfo("line", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reps"), reps, ArgInfo("reps", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aeps"), aeps, ArgInfo("aeps", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fitLine(points, line, distType, param, reps, aeps), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, line);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    Ptr<UMat> ptr_line;
    int distType;
    double param;
    double reps;
    double aeps;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "line"), ptr_line, ArgInfo("line", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distType"), distType, ArgInfo("distType", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reps"), reps, ArgInfo("reps", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aeps"), aeps, ArgInfo("aeps", 0, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
        UMat line; if (ptr_line.get()) { line = *ptr_line.get(); }
    
        ERRWRAP2(cv::fitLine(points, line, distType, param, reps, aeps), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, line);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flip(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flipCode;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flipCode"), flipCode, ArgInfo("flipCode", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::flip(src, dst, flipCode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flipCode;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flipCode"), flipCode, ArgInfo("flipCode", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::flip(src, dst, flipCode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_flipND(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int axis;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axis"), axis, ArgInfo("axis", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::flipND(src, dst, axis), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int axis;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axis"), axis, ArgInfo("axis", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::flipND(src, dst, axis), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_floodFill(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat mask;
    Point seedPoint;
    Scalar newVal;
    Rect rect;
    Scalar loDiff;
    Scalar upDiff;
    int flags=4;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "seedPoint"), seedPoint, ArgInfo("seedPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newVal"), newVal, ArgInfo("newVal", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "loDiff"), loDiff, ArgInfo("loDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upDiff"), upDiff, ArgInfo("upDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::floodFill(image, mask, seedPoint, newVal, &rect, loDiff, upDiff, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, image), evision_from(env, mask), evision_from(env, rect));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_mask;
    Point seedPoint;
    Scalar newVal;
    Rect rect;
    Scalar loDiff;
    Scalar upDiff;
    int flags=4;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "seedPoint"), seedPoint, ArgInfo("seedPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newVal"), newVal, ArgInfo("newVal", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "loDiff"), loDiff, ArgInfo("loDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upDiff"), upDiff, ArgInfo("upDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::floodFill(image, mask, seedPoint, newVal, &rect, loDiff, upDiff, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, image), evision_from(env, mask), evision_from(env, rect));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_gemm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    double alpha;
    Mat src3;
    double beta;
    Mat dst;
    int flags=0;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src3"), src3, ArgInfo("src3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::gemm(src1, src2, alpha, src3, beta, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    double alpha;
    Ptr<UMat> ptr_src3;
    double beta;
    Ptr<UMat> ptr_dst;
    int flags=0;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src3"), ptr_src3, ArgInfo("src3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat src3; if (ptr_src3.get()) { src3 = *ptr_src3.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::gemm(src1, src2, alpha, src3, beta, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getAffineTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getAffineTransform(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(retval = cv::getAffineTransform(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getBuildInformation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getBuildInformation(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getCPUFeaturesLine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getCPUFeaturesLine(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getCPUTickCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int64 retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getCPUTickCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getDefaultNewCameraMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix;
    Size imgsize;
    bool centerPrincipalPoint=false;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgsize"), imgsize, ArgInfo("imgsize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centerPrincipalPoint"), centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getDefaultNewCameraMatrix(cameraMatrix, imgsize, centerPrincipalPoint), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix;
    Size imgsize;
    bool centerPrincipalPoint=false;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgsize"), imgsize, ArgInfo("imgsize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centerPrincipalPoint"), centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
    
        ERRWRAP2(retval = cv::getDefaultNewCameraMatrix(cameraMatrix, imgsize, centerPrincipalPoint), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getDerivKernels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat kx;
    Mat ky;
    int dx;
    int dy;
    int ksize;
    bool normalize=false;
    int ktype=CV_32F;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kx"), kx, ArgInfo("kx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ky"), ky, ArgInfo("ky", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normalize"), normalize, ArgInfo("normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ktype"), ktype, ArgInfo("ktype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::getDerivKernels(kx, ky, dx, dy, ksize, normalize, ktype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, kx), evision_from(env, ky));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_kx;
    Ptr<UMat> ptr_ky;
    int dx;
    int dy;
    int ksize;
    bool normalize=false;
    int ktype=CV_32F;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kx"), ptr_kx, ArgInfo("kx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ky"), ptr_ky, ArgInfo("ky", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normalize"), normalize, ArgInfo("normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ktype"), ktype, ArgInfo("ktype", 0, 1)) )
    {
        error_flag = false;
            UMat kx; if (ptr_kx.get()) { kx = *ptr_kx.get(); }
        UMat ky; if (ptr_ky.get()) { ky = *ptr_ky.get(); }
    
        ERRWRAP2(cv::getDerivKernels(kx, ky, dx, dy, ksize, normalize, ktype), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, kx), evision_from(env, ky));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getFontScaleFromHeight(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int fontFace;
    int pixelHeight;
    int thickness=1;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontFace"), fontFace, ArgInfo("fontFace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pixelHeight"), pixelHeight, ArgInfo("pixelHeight", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getFontScaleFromHeight(fontFace, pixelHeight, thickness), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getGaborKernel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Size ksize;
    double sigma;
    double theta;
    double lambd;
    double gamma;
    double psi=CV_PI*0.5;
    int ktype=CV_64F;
    Mat retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambd"), lambd, ArgInfo("lambd", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "psi"), psi, ArgInfo("psi", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ktype"), ktype, ArgInfo("ktype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getGaborKernel(ksize, sigma, theta, lambd, gamma, psi, ktype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getGaussianKernel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int ksize;
    double sigma;
    int ktype=CV_64F;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ktype"), ktype, ArgInfo("ktype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getGaussianKernel(ksize, sigma, ktype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getHardwareFeatureName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int feature;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "feature"), feature, ArgInfo("feature", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getHardwareFeatureName(feature), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getLogLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getLogLevel(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getNumThreads(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getNumThreads(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getNumberOfCPUs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getNumberOfCPUs(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getOptimalDFTSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int vecsize;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vecsize"), vecsize, ArgInfo("vecsize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getOptimalDFTSize(vecsize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getOptimalNewCameraMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix;
    Mat distCoeffs;
    Size imageSize;
    double alpha;
    Size newImgSize;
    Rect validPixROI;
    bool centerPrincipalPoint=false;
    Mat retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImgSize"), newImgSize, ArgInfo("newImgSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centerPrincipalPoint"), centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, &validPixROI, centerPrincipalPoint), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, validPixROI));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Size imageSize;
    double alpha;
    Size newImgSize;
    Rect validPixROI;
    bool centerPrincipalPoint=false;
    Mat retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImgSize"), newImgSize, ArgInfo("newImgSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centerPrincipalPoint"), centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
    
        ERRWRAP2(retval = cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, &validPixROI, centerPrincipalPoint), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, validPixROI));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getPerspectiveTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int solveMethod=DECOMP_LU;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "solveMethod"), solveMethod, ArgInfo("solveMethod", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getPerspectiveTransform(src, dst, solveMethod), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int solveMethod=DECOMP_LU;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "solveMethod"), solveMethod, ArgInfo("solveMethod", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(retval = cv::getPerspectiveTransform(src, dst, solveMethod), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getRectSubPix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Size patchSize;
    Point2f center;
    Mat patch;
    int patchType=-1;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patchSize"), patchSize, ArgInfo("patchSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patch"), patch, ArgInfo("patch", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patchType"), patchType, ArgInfo("patchType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::getRectSubPix(image, patchSize, center, patch, patchType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, patch);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Size patchSize;
    Point2f center;
    Ptr<UMat> ptr_patch;
    int patchType=-1;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patchSize"), patchSize, ArgInfo("patchSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patch"), ptr_patch, ArgInfo("patch", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patchType"), patchType, ArgInfo("patchType", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat patch; if (ptr_patch.get()) { patch = *ptr_patch.get(); }
    
        ERRWRAP2(cv::getRectSubPix(image, patchSize, center, patch, patchType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, patch);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getRotationMatrix2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Point2f center;
    double angle;
    double scale;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getRotationMatrix2D(center, angle, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getStructuringElement(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int shape;
    Size ksize;
    Point anchor=Point(-1,-1);
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shape"), shape, ArgInfo("shape", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getStructuringElement(shape, ksize, anchor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getTextSize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String text;
    int fontFace;
    double fontScale;
    int thickness;
    int baseLine;
    Size retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "text"), text, ArgInfo("text", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontFace"), fontFace, ArgInfo("fontFace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontScale"), fontScale, ArgInfo("fontScale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getTextSize(text, fontFace, fontScale, thickness, &baseLine), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, baseLine));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getThreadNum(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getThreadNum(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getTickCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int64 retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getTickCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getTickFrequency(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getTickFrequency(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getTrackbarPos(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String trackbarname;
    String winname;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trackbarname"), trackbarname, ArgInfo("trackbarname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getTrackbarPos(trackbarname, winname), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getValidDisparityROI(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Rect roi1;
    Rect roi2;
    int minDisparity;
    int numberOfDisparities;
    int blockSize;
    Rect retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roi1"), roi1, ArgInfo("roi1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roi2"), roi2, ArgInfo("roi2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberOfDisparities"), numberOfDisparities, ArgInfo("numberOfDisparities", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, blockSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getVersionMajor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getVersionMajor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getVersionMinor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getVersionMinor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getVersionRevision(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getVersionRevision(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getVersionString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getVersionString(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getWindowImageRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    Rect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getWindowImageRect(winname), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_getWindowProperty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    int prop_id;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prop_id"), prop_id, ArgInfo("prop_id", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::getWindowProperty(winname, prop_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_goodFeaturesToTrack(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat corners;
    int maxCorners;
    double qualityLevel;
    double minDistance;
    Mat mask;
    int blockSize;
    int gradientSize;
    bool useHarrisDetector=false;
    double k=0.04;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradientSize"), gradientSize, ArgInfo("gradientSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, corners);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_corners;
    int maxCorners;
    double qualityLevel;
    double minDistance;
    Ptr<UMat> ptr_mask;
    int blockSize;
    int gradientSize;
    bool useHarrisDetector=false;
    double k=0.04;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradientSize"), gradientSize, ArgInfo("gradientSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, corners);
        }
    }

    }
    

    {
    Mat image;
    Mat corners;
    int maxCorners;
    double qualityLevel;
    double minDistance;
    Mat mask;
    int blockSize=3;
    bool useHarrisDetector=false;
    double k=0.04;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, corners);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_corners;
    int maxCorners;
    double qualityLevel;
    double minDistance;
    Ptr<UMat> ptr_mask;
    int blockSize=3;
    bool useHarrisDetector=false;
    double k=0.04;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, corners);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_goodFeaturesToTrackWithQuality(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat corners;
    int maxCorners;
    double qualityLevel;
    double minDistance;
    Mat mask;
    Mat cornersQuality;
    int blockSize=3;
    int gradientSize=3;
    bool useHarrisDetector=false;
    double k=0.04;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cornersQuality"), cornersQuality, ArgInfo("cornersQuality", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradientSize"), gradientSize, ArgInfo("gradientSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, cornersQuality, blockSize, gradientSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, corners), evision_from(env, cornersQuality));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_corners;
    int maxCorners;
    double qualityLevel;
    double minDistance;
    Ptr<UMat> ptr_mask;
    Ptr<UMat> ptr_cornersQuality;
    int blockSize=3;
    int gradientSize=3;
    bool useHarrisDetector=false;
    double k=0.04;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), ptr_corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityLevel"), qualityLevel, ArgInfo("qualityLevel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDistance"), minDistance, ArgInfo("minDistance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cornersQuality"), ptr_cornersQuality, ArgInfo("cornersQuality", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gradientSize"), gradientSize, ArgInfo("gradientSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHarrisDetector"), useHarrisDetector, ArgInfo("useHarrisDetector", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat corners; if (ptr_corners.get()) { corners = *ptr_corners.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat cornersQuality; if (ptr_cornersQuality.get()) { cornersQuality = *ptr_cornersQuality.get(); }
    
        ERRWRAP2(cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, cornersQuality, blockSize, gradientSize, useHarrisDetector, k), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, corners), evision_from(env, cornersQuality));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_grabCut(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat mask;
    Rect rect;
    Mat bgdModel;
    Mat fgdModel;
    int iterCount;
    int mode=GC_EVAL;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect"), rect, ArgInfo("rect", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bgdModel"), bgdModel, ArgInfo("bgdModel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fgdModel"), fgdModel, ArgInfo("fgdModel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterCount"), iterCount, ArgInfo("iterCount", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, mode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, mask), evision_from(env, bgdModel), evision_from(env, fgdModel));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Ptr<UMat> ptr_mask;
    Rect rect;
    Ptr<UMat> ptr_bgdModel;
    Ptr<UMat> ptr_fgdModel;
    int iterCount;
    int mode=GC_EVAL;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect"), rect, ArgInfo("rect", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bgdModel"), ptr_bgdModel, ArgInfo("bgdModel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fgdModel"), ptr_fgdModel, ArgInfo("fgdModel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterCount"), iterCount, ArgInfo("iterCount", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat bgdModel; if (ptr_bgdModel.get()) { bgdModel = *ptr_bgdModel.get(); }
        UMat fgdModel; if (ptr_fgdModel.get()) { fgdModel = *ptr_fgdModel.get(); }
    
        ERRWRAP2(cv::grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, mode), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, mask), evision_from(env, bgdModel), evision_from(env, fgdModel));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_groupRectangles(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Rect rectList;
    vector_int weights;
    int groupThreshold;
    double eps=0.2;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rectList"), rectList, ArgInfo("rectList", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupThreshold"), groupThreshold, ArgInfo("groupThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eps"), eps, ArgInfo("eps", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::groupRectangles(rectList, weights, groupThreshold, eps), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, rectList), evision_from(env, weights));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hasNonZero(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::hasNonZero(src), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
    
        ERRWRAP2(retval = cv::hasNonZero(src), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_haveImageReader(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::haveImageReader(filename), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_haveImageWriter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::haveImageWriter(filename), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_haveOpenVX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::haveOpenVX(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hconcat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::hconcat(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::hconcat(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_idct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::idct(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::idct(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_idft(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags=0;
    int nonzeroRows=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonzeroRows"), nonzeroRows, ArgInfo("nonzeroRows", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::idft(src, dst, flags, nonzeroRows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags=0;
    int nonzeroRows=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonzeroRows"), nonzeroRows, ArgInfo("nonzeroRows", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::idft(src, dst, flags, nonzeroRows), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_illuminationChange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat mask;
    Mat dst;
    float alpha=0.2f;
    float beta=0.4f;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::illuminationChange(src, mask, dst, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_mask;
    Ptr<UMat> ptr_dst;
    float alpha=0.2f;
    float beta=0.4f;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::illuminationChange(src, mask, dst, alpha, beta), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imcount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    int flags=IMREAD_ANYCOLOR;
    size_t retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imcount(filename, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imdecodemulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat buf;
    int flags;
    vector_Mat mats;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buf"), buf, ArgInfo("buf", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mats"), mats, ArgInfo("mats", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imdecodemulti(buf, flags, mats), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, mats);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_buf;
    int flags;
    vector_Mat mats;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buf"), ptr_buf, ArgInfo("buf", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mats"), mats, ArgInfo("mats", 1, 0)) )
    {
        error_flag = false;
            UMat buf; if (ptr_buf.get()) { buf = *ptr_buf.get(); }
    
        ERRWRAP2(retval = cv::imdecodemulti(buf, flags, mats), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, mats);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imencode(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String ext;
    Mat img;
    vector_uchar buf;
    vector_int params=std::vector<int>();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ext"), ext, ArgInfo("ext", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imencode(ext, img, buf, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                bool success = false;
                ERL_NIF_TERM binary_erl_term = evision_from_as_binary(env, buf, success);
                if (success) {
                    return binary_erl_term;
                } else {
                    return evision::nif::error(env, "out of memory");
                }
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String ext;
    Ptr<UMat> ptr_img;
    vector_uchar buf;
    vector_int params=std::vector<int>();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ext"), ext, ArgInfo("ext", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(retval = cv::imencode(ext, img, buf, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                bool success = false;
                ERL_NIF_TERM binary_erl_term = evision_from_as_binary(env, buf, success);
                if (success) {
                    return binary_erl_term;
                } else {
                    return evision::nif::error(env, "out of memory");
                }
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imread(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    int flags=IMREAD_COLOR;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imread(filename, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imreadmulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    vector_Mat mats;
    int start;
    int count;
    int flags=IMREAD_ANYCOLOR;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mats"), mats, ArgInfo("mats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "start"), start, ArgInfo("start", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "count"), count, ArgInfo("count", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imreadmulti(filename, mats, start, count, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, mats);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    vector_Mat mats;
    int flags=IMREAD_ANYCOLOR;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mats"), mats, ArgInfo("mats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imreadmulti(filename, mats, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, mats);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imwrite(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    Mat img;
    vector_int params=std::vector<int>();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imwrite(filename, img, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    Ptr<UMat> ptr_img;
    vector_int params=std::vector<int>();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(retval = cv::imwrite(filename, img, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_imwritemulti(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    vector_Mat img;
    vector_int params=std::vector<int>();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imwritemulti(filename, img, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    vector_UMat img;
    vector_int params=std::vector<int>();
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::imwritemulti(filename, img, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_inRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat lowerb;
    Mat upperb;
    Mat dst;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lowerb"), lowerb, ArgInfo("lowerb", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upperb"), upperb, ArgInfo("upperb", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::inRange(src, lowerb, upperb, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_lowerb;
    Ptr<UMat> ptr_upperb;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lowerb"), ptr_lowerb, ArgInfo("lowerb", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upperb"), ptr_upperb, ArgInfo("upperb", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat lowerb; if (ptr_lowerb.get()) { lowerb = *ptr_lowerb.get(); }
        UMat upperb; if (ptr_upperb.get()) { upperb = *ptr_upperb.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::inRange(src, lowerb, upperb, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_initCameraMatrix2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size imageSize;
    double aspectRatio=1.0;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aspectRatio"), aspectRatio, ArgInfo("aspectRatio", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::initCameraMatrix2D(objectPoints, imagePoints, imageSize, aspectRatio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size imageSize;
    double aspectRatio=1.0;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aspectRatio"), aspectRatio, ArgInfo("aspectRatio", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::initCameraMatrix2D(objectPoints, imagePoints, imageSize, aspectRatio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_initInverseRectificationMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat R;
    Mat newCameraMatrix;
    Size size;
    int m1type;
    Mat map1;
    Mat map2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newCameraMatrix"), newCameraMatrix, ArgInfo("newCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_newCameraMatrix;
    Size size;
    int m1type;
    Ptr<UMat> ptr_map1;
    Ptr<UMat> ptr_map2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newCameraMatrix"), ptr_newCameraMatrix, ArgInfo("newCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), ptr_map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), ptr_map2, ArgInfo("map2", 1, 0)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat newCameraMatrix; if (ptr_newCameraMatrix.get()) { newCameraMatrix = *ptr_newCameraMatrix.get(); }
        UMat map1; if (ptr_map1.get()) { map1 = *ptr_map1.get(); }
        UMat map2; if (ptr_map2.get()) { map2 = *ptr_map2.get(); }
    
        ERRWRAP2(cv::initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_initUndistortRectifyMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat R;
    Mat newCameraMatrix;
    Size size;
    int m1type;
    Mat map1;
    Mat map2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newCameraMatrix"), newCameraMatrix, ArgInfo("newCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_newCameraMatrix;
    Size size;
    int m1type;
    Ptr<UMat> ptr_map1;
    Ptr<UMat> ptr_map2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newCameraMatrix"), ptr_newCameraMatrix, ArgInfo("newCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), ptr_map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), ptr_map2, ArgInfo("map2", 1, 0)) )
    {
        error_flag = false;
            UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat newCameraMatrix; if (ptr_newCameraMatrix.get()) { newCameraMatrix = *ptr_newCameraMatrix.get(); }
        UMat map1; if (ptr_map1.get()) { map1 = *ptr_map1.get(); }
        UMat map2; if (ptr_map2.get()) { map2 = *ptr_map2.get(); }
    
        ERRWRAP2(cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_inpaint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat inpaintMask;
    Mat dst;
    double inpaintRadius;
    int flags;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inpaintMask"), inpaintMask, ArgInfo("inpaintMask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inpaintRadius"), inpaintRadius, ArgInfo("inpaintRadius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::inpaint(src, inpaintMask, dst, inpaintRadius, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_inpaintMask;
    Ptr<UMat> ptr_dst;
    double inpaintRadius;
    int flags;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inpaintMask"), ptr_inpaintMask, ArgInfo("inpaintMask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inpaintRadius"), inpaintRadius, ArgInfo("inpaintRadius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat inpaintMask; if (ptr_inpaintMask.get()) { inpaintMask = *ptr_inpaintMask.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::inpaint(src, inpaintMask, dst, inpaintRadius, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_insertChannel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int coi;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coi"), coi, ArgInfo("coi", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::insertChannel(src, dst, coi), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int coi;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coi"), coi, ArgInfo("coi", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::insertChannel(src, dst, coi), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_integral(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat sum;
    int sdepth=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sum"), sum, ArgInfo("sum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sdepth"), sdepth, ArgInfo("sdepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::integral(src, sum, sdepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, sum);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_sum;
    int sdepth=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sum"), ptr_sum, ArgInfo("sum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sdepth"), sdepth, ArgInfo("sdepth", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat sum; if (ptr_sum.get()) { sum = *ptr_sum.get(); }
    
        ERRWRAP2(cv::integral(src, sum, sdepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, sum);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_integral2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat sum;
    Mat sqsum;
    int sdepth=-1;
    int sqdepth=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sum"), sum, ArgInfo("sum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqsum"), sqsum, ArgInfo("sqsum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sdepth"), sdepth, ArgInfo("sdepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqdepth"), sqdepth, ArgInfo("sqdepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::integral(src, sum, sqsum, sdepth, sqdepth), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, sum), evision_from(env, sqsum));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_sum;
    Ptr<UMat> ptr_sqsum;
    int sdepth=-1;
    int sqdepth=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sum"), ptr_sum, ArgInfo("sum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqsum"), ptr_sqsum, ArgInfo("sqsum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sdepth"), sdepth, ArgInfo("sdepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqdepth"), sqdepth, ArgInfo("sqdepth", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat sum; if (ptr_sum.get()) { sum = *ptr_sum.get(); }
        UMat sqsum; if (ptr_sqsum.get()) { sqsum = *ptr_sqsum.get(); }
    
        ERRWRAP2(cv::integral(src, sum, sqsum, sdepth, sqdepth), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, sum), evision_from(env, sqsum));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_integral3(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat sum;
    Mat sqsum;
    Mat tilted;
    int sdepth=-1;
    int sqdepth=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sum"), sum, ArgInfo("sum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqsum"), sqsum, ArgInfo("sqsum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tilted"), tilted, ArgInfo("tilted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sdepth"), sdepth, ArgInfo("sdepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqdepth"), sqdepth, ArgInfo("sqdepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::integral(src, sum, sqsum, tilted, sdepth, sqdepth), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, sum), evision_from(env, sqsum), evision_from(env, tilted));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_sum;
    Ptr<UMat> ptr_sqsum;
    Ptr<UMat> ptr_tilted;
    int sdepth=-1;
    int sqdepth=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sum"), ptr_sum, ArgInfo("sum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqsum"), ptr_sqsum, ArgInfo("sqsum", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tilted"), ptr_tilted, ArgInfo("tilted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sdepth"), sdepth, ArgInfo("sdepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sqdepth"), sqdepth, ArgInfo("sqdepth", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat sum; if (ptr_sum.get()) { sum = *ptr_sum.get(); }
        UMat sqsum; if (ptr_sqsum.get()) { sqsum = *ptr_sqsum.get(); }
        UMat tilted; if (ptr_tilted.get()) { tilted = *ptr_tilted.get(); }
    
        ERRWRAP2(cv::integral(src, sum, sqsum, tilted, sdepth, sqdepth), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, sum), evision_from(env, sqsum), evision_from(env, tilted));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intersectConvexConvex(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat p1;
    Mat p2;
    Mat p12;
    bool handleNested=true;
    float retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), p1, ArgInfo("p1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), p2, ArgInfo("p2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p12"), p12, ArgInfo("p12", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "handleNested"), handleNested, ArgInfo("handleNested", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::intersectConvexConvex(p1, p2, p12, handleNested), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, p12));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_p1;
    Ptr<UMat> ptr_p2;
    Ptr<UMat> ptr_p12;
    bool handleNested=true;
    float retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), ptr_p1, ArgInfo("p1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), ptr_p2, ArgInfo("p2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p12"), ptr_p12, ArgInfo("p12", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "handleNested"), handleNested, ArgInfo("handleNested", 0, 1)) )
    {
        error_flag = false;
            UMat p1; if (ptr_p1.get()) { p1 = *ptr_p1.get(); }
        UMat p2; if (ptr_p2.get()) { p2 = *ptr_p2.get(); }
        UMat p12; if (ptr_p12.get()) { p12 = *ptr_p12.get(); }
    
        ERRWRAP2(retval = cv::intersectConvexConvex(p1, p2, p12, handleNested), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, p12));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_invert(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags=DECOMP_LU;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::invert(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags=DECOMP_LU;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(retval = cv::invert(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_invertAffineTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat M;
    Mat iM;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iM"), iM, ArgInfo("iM", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::invertAffineTransform(M, iM), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, iM);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_M;
    Ptr<UMat> ptr_iM;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iM"), ptr_iM, ArgInfo("iM", 1, 0)) )
    {
        error_flag = false;
            UMat M; if (ptr_M.get()) { M = *ptr_M.get(); }
        UMat iM; if (ptr_iM.get()) { iM = *ptr_iM.get(); }
    
        ERRWRAP2(cv::invertAffineTransform(M, iM), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, iM);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_isContourConvex(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat contour;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), contour, ArgInfo("contour", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::isContourConvex(contour), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_contour;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), ptr_contour, ArgInfo("contour", 0, 0)) )
    {
        error_flag = false;
            UMat contour; if (ptr_contour.get()) { contour = *ptr_contour.get(); }
    
        ERRWRAP2(retval = cv::isContourConvex(contour), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kmeans(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat data;
    int K;
    Mat bestLabels;
    TermCriteria criteria;
    int attempts;
    int flags;
    Mat centers;
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bestLabels"), bestLabels, ArgInfo("bestLabels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "attempts"), attempts, ArgInfo("attempts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centers"), centers, ArgInfo("centers", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kmeans(data, K, bestLabels, criteria, attempts, flags, centers), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, bestLabels), evision_from(env, centers));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_data;
    int K;
    Ptr<UMat> ptr_bestLabels;
    TermCriteria criteria;
    int attempts;
    int flags;
    Ptr<UMat> ptr_centers;
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), ptr_data, ArgInfo("data", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bestLabels"), ptr_bestLabels, ArgInfo("bestLabels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "attempts"), attempts, ArgInfo("attempts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centers"), ptr_centers, ArgInfo("centers", 1, 1)) )
    {
        error_flag = false;
            UMat data; if (ptr_data.get()) { data = *ptr_data.get(); }
        UMat bestLabels; if (ptr_bestLabels.get()) { bestLabels = *ptr_bestLabels.get(); }
        UMat centers; if (ptr_centers.get()) { centers = *ptr_centers.get(); }
    
        ERRWRAP2(retval = cv::kmeans(data, K, bestLabels, criteria, attempts, flags, centers), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, bestLabels), evision_from(env, centers));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_line(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Point pt1;
    Point pt2;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::line(img, pt1, pt2, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Point pt1;
    Point pt2;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::line(img, pt1, pt2, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linearPolar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Point2f center;
    double maxRadius;
    int flags;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxRadius"), maxRadius, ArgInfo("maxRadius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::linearPolar(src, dst, center, maxRadius, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Point2f center;
    double maxRadius;
    int flags;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxRadius"), maxRadius, ArgInfo("maxRadius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::linearPolar(src, dst, center, maxRadius, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_log(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::log(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::log(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_logPolar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Point2f center;
    double M;
    int flags;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::logPolar(src, dst, center, M, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Point2f center;
    double M;
    int flags;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::logPolar(src, dst, center, M, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_magnitude(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat x;
    Mat y;
    Mat magnitude;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "magnitude"), magnitude, ArgInfo("magnitude", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::magnitude(x, y, magnitude), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, magnitude);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_x;
    Ptr<UMat> ptr_y;
    Ptr<UMat> ptr_magnitude;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), ptr_x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), ptr_y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "magnitude"), ptr_magnitude, ArgInfo("magnitude", 1, 0)) )
    {
        error_flag = false;
            UMat x; if (ptr_x.get()) { x = *ptr_x.get(); }
        UMat y; if (ptr_y.get()) { y = *ptr_y.get(); }
        UMat magnitude; if (ptr_magnitude.get()) { magnitude = *ptr_magnitude.get(); }
    
        ERRWRAP2(cv::magnitude(x, y, magnitude), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, magnitude);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_matMulDeriv(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat A;
    Mat B;
    Mat dABdA;
    Mat dABdB;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), A, ArgInfo("A", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), B, ArgInfo("B", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dABdA"), dABdA, ArgInfo("dABdA", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dABdB"), dABdB, ArgInfo("dABdB", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::matMulDeriv(A, B, dABdA, dABdB), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dABdA), evision_from(env, dABdB));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_A;
    Ptr<UMat> ptr_B;
    Ptr<UMat> ptr_dABdA;
    Ptr<UMat> ptr_dABdB;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), ptr_A, ArgInfo("A", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), ptr_B, ArgInfo("B", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dABdA"), ptr_dABdA, ArgInfo("dABdA", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dABdB"), ptr_dABdB, ArgInfo("dABdB", 1, 0)) )
    {
        error_flag = false;
            UMat A; if (ptr_A.get()) { A = *ptr_A.get(); }
        UMat B; if (ptr_B.get()) { B = *ptr_B.get(); }
        UMat dABdA; if (ptr_dABdA.get()) { dABdA = *ptr_dABdA.get(); }
        UMat dABdB; if (ptr_dABdB.get()) { dABdB = *ptr_dABdB.get(); }
    
        ERRWRAP2(cv::matMulDeriv(A, B, dABdA, dABdB), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dABdA), evision_from(env, dABdB));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_matchShapes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat contour1;
    Mat contour2;
    int method;
    double parameter;
    double retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour1"), contour1, ArgInfo("contour1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour2"), contour2, ArgInfo("contour2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameter"), parameter, ArgInfo("parameter", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::matchShapes(contour1, contour2, method, parameter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_contour1;
    Ptr<UMat> ptr_contour2;
    int method;
    double parameter;
    double retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour1"), ptr_contour1, ArgInfo("contour1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour2"), ptr_contour2, ArgInfo("contour2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameter"), parameter, ArgInfo("parameter", 0, 0)) )
    {
        error_flag = false;
            UMat contour1; if (ptr_contour1.get()) { contour1 = *ptr_contour1.get(); }
        UMat contour2; if (ptr_contour2.get()) { contour2 = *ptr_contour2.get(); }
    
        ERRWRAP2(retval = cv::matchShapes(contour1, contour2, method, parameter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_matchTemplate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat templ;
    Mat result;
    int method;
    Mat mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templ"), templ, ArgInfo("templ", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::matchTemplate(image, templ, result, method, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_templ;
    Ptr<UMat> ptr_result;
    int method;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templ"), ptr_templ, ArgInfo("templ", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), ptr_result, ArgInfo("result", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat templ; if (ptr_templ.get()) { templ = *ptr_templ.get(); }
        UMat result; if (ptr_result.get()) { result = *ptr_result.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::matchTemplate(image, templ, result, method, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_max(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::max(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::max(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mean(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat mask;
    Scalar retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::mean(src, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_mask;
    Scalar retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::mean(src, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_meanShift(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat probImage;
    Rect window;
    TermCriteria criteria;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probImage"), probImage, ArgInfo("probImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window"), window, ArgInfo("window", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::meanShift(probImage, window, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, window));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_probImage;
    Rect window;
    TermCriteria criteria;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "probImage"), ptr_probImage, ArgInfo("probImage", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window"), window, ArgInfo("window", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
            UMat probImage; if (ptr_probImage.get()) { probImage = *ptr_probImage.get(); }
    
        ERRWRAP2(retval = cv::meanShift(probImage, window, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, window));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_meanStdDev(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat mean;
    Mat stddev;
    Mat mask;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stddev"), stddev, ArgInfo("stddev", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::meanStdDev(src, mean, stddev, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, mean), evision_from(env, stddev));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_stddev;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stddev"), ptr_stddev, ArgInfo("stddev", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat stddev; if (ptr_stddev.get()) { stddev = *ptr_stddev.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::meanStdDev(src, mean, stddev, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, mean), evision_from(env, stddev));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_medianBlur(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ksize;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::medianBlur(src, dst, ksize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ksize;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::medianBlur(src, dst, ksize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_merge(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat mv;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mv"), mv, ArgInfo("mv", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::merge(mv, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat mv;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mv"), mv, ArgInfo("mv", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::merge(mv, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_min(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::min(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::min(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_minAreaRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::minAreaRect(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    RotatedRect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(retval = cv::minAreaRect(points), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_minEnclosingCircle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    Point2f center;
    float radius;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::minEnclosingCircle(points, center, radius), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, center), evision_from(env, radius));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    Point2f center;
    float radius;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
    
        ERRWRAP2(cv::minEnclosingCircle(points, center, radius), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, center), evision_from(env, radius));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_minEnclosingTriangle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points;
    Mat triangle;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "triangle"), triangle, ArgInfo("triangle", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::minEnclosingTriangle(points, triangle), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, triangle));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points;
    Ptr<UMat> ptr_triangle;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), ptr_points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "triangle"), ptr_triangle, ArgInfo("triangle", 1, 0)) )
    {
        error_flag = false;
            UMat points; if (ptr_points.get()) { points = *ptr_points.get(); }
        UMat triangle; if (ptr_triangle.get()) { triangle = *ptr_triangle.get(); }
    
        ERRWRAP2(retval = cv::minEnclosingTriangle(points, triangle), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, triangle));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_minMaxLoc(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    double minVal;
    double maxVal;
    Point minLoc;
    Point maxLoc;
    Mat mask;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::minMaxLoc(src, &minVal, &maxVal, &minLoc, &maxLoc, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, minVal), evision_from(env, maxVal), evision_from(env, minLoc), evision_from(env, maxLoc));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    double minVal;
    double maxVal;
    Point minLoc;
    Point maxLoc;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::minMaxLoc(src, &minVal, &maxVal, &minLoc, &maxLoc, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, minVal), evision_from(env, maxVal), evision_from(env, minLoc), evision_from(env, maxLoc));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mixChannels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat src;
    vector_Mat dst;
    vector_int fromTo;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromTo"), fromTo, ArgInfo("fromTo", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::mixChannels(src, dst, fromTo), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    vector_UMat dst;
    vector_int fromTo;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromTo"), fromTo, ArgInfo("fromTo", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::mixChannels(src, dst, fromTo), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_moments(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat array;
    bool binaryImage=false;
    Moments retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "array"), array, ArgInfo("array", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "binaryImage"), binaryImage, ArgInfo("binaryImage", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::moments(array, binaryImage), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_array;
    bool binaryImage=false;
    Moments retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "array"), ptr_array, ArgInfo("array", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "binaryImage"), binaryImage, ArgInfo("binaryImage", 0, 1)) )
    {
        error_flag = false;
            UMat array; if (ptr_array.get()) { array = *ptr_array.get(); }
    
        ERRWRAP2(retval = cv::moments(array, binaryImage), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_morphologyEx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int op;
    Mat kernel;
    Point anchor=Point(-1,-1);
    int iterations=1;
    int borderType=BORDER_CONSTANT;
    Scalar borderValue=morphologyDefaultBorderValue();

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::morphologyEx(src, dst, op, kernel, anchor, iterations, borderType, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int op;
    Ptr<UMat> ptr_kernel;
    Point anchor=Point(-1,-1);
    int iterations=1;
    int borderType=BORDER_CONSTANT;
    Scalar borderValue=morphologyDefaultBorderValue();

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), ptr_kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterations"), iterations, ArgInfo("iterations", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat kernel; if (ptr_kernel.get()) { kernel = *ptr_kernel.get(); }
    
        ERRWRAP2(cv::morphologyEx(src, dst, op, kernel, anchor, iterations, borderType, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_moveWindow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    int x;
    int y;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::moveWindow(winname, x, y), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mulSpectrums(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat a;
    Mat b;
    Mat c;
    int flags;
    bool conjB=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c"), c, ArgInfo("c", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "conjB"), conjB, ArgInfo("conjB", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::mulSpectrums(a, b, c, flags, conjB), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, c);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_a;
    Ptr<UMat> ptr_b;
    Ptr<UMat> ptr_c;
    int flags;
    bool conjB=false;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), ptr_a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), ptr_b, ArgInfo("b", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c"), ptr_c, ArgInfo("c", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "conjB"), conjB, ArgInfo("conjB", 0, 1)) )
    {
        error_flag = false;
            UMat a; if (ptr_a.get()) { a = *ptr_a.get(); }
        UMat b; if (ptr_b.get()) { b = *ptr_b.get(); }
        UMat c; if (ptr_c.get()) { c = *ptr_c.get(); }
    
        ERRWRAP2(cv::mulSpectrums(a, b, c, flags, conjB), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, c);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mulTransposed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    bool aTa;
    Mat delta;
    double scale=1;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aTa"), aTa, ArgInfo("aTa", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::mulTransposed(src, dst, aTa, delta, scale, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    bool aTa;
    Ptr<UMat> ptr_delta;
    double scale=1;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aTa"), aTa, ArgInfo("aTa", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), ptr_delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat delta; if (ptr_delta.get()) { delta = *ptr_delta.get(); }
    
        ERRWRAP2(cv::mulTransposed(src, dst, aTa, delta, scale, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_multiply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    double scale=1;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::multiply(src1, src2, dst, scale, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    double scale=1;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::multiply(src1, src2, dst, scale, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_namedWindow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    int flags=WINDOW_AUTOSIZE;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::namedWindow(winname, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_norm(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    int normType=NORM_L2;
    Mat mask;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::norm(src1, src2, normType, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    int normType=NORM_L2;
    Ptr<UMat> ptr_mask;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::norm(src1, src2, normType, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Mat src1;
    int normType=NORM_L2;
    Mat mask;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::norm(src1, normType, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    int normType=NORM_L2;
    Ptr<UMat> ptr_mask;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::norm(src1, normType, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_normalize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double alpha=1;
    double beta=0;
    int norm_type=NORM_L2;
    int dtype=-1;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "norm_type"), norm_type, ArgInfo("norm_type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::normalize(src, dst, alpha, beta, norm_type, dtype, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double alpha=1;
    double beta=0;
    int norm_type=NORM_L2;
    int dtype=-1;
    Ptr<UMat> ptr_mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "norm_type"), norm_type, ArgInfo("norm_type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::normalize(src, dst, alpha, beta, norm_type, dtype, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_patchNaNs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat a;
    double val=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::patchNaNs(a, val), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, a);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_a;
    double val=0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), ptr_a, ArgInfo("a", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "val"), val, ArgInfo("val", 0, 1)) )
    {
        error_flag = false;
            UMat a; if (ptr_a.get()) { a = *ptr_a.get(); }
    
        ERRWRAP2(cv::patchNaNs(a, val), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, a);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pencilSketch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst1;
    Mat dst2;
    float sigma_s=60;
    float sigma_r=0.07f;
    float shade_factor=0.02f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst1"), dst1, ArgInfo("dst1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst2"), dst2, ArgInfo("dst2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shade_factor"), shade_factor, ArgInfo("shade_factor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::pencilSketch(src, dst1, dst2, sigma_s, sigma_r, shade_factor), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst1), evision_from(env, dst2));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst1;
    Ptr<UMat> ptr_dst2;
    float sigma_s=60;
    float sigma_r=0.07f;
    float shade_factor=0.02f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst1"), ptr_dst1, ArgInfo("dst1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst2"), ptr_dst2, ArgInfo("dst2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shade_factor"), shade_factor, ArgInfo("shade_factor", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst1; if (ptr_dst1.get()) { dst1 = *ptr_dst1.get(); }
        UMat dst2; if (ptr_dst2.get()) { dst2 = *ptr_dst2.get(); }
    
        ERRWRAP2(cv::pencilSketch(src, dst1, dst2, sigma_s, sigma_r, shade_factor), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dst1), evision_from(env, dst2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_perspectiveTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat m;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::perspectiveTransform(src, dst, m), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_m;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_m, ArgInfo("m", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat m; if (ptr_m.get()) { m = *ptr_m.get(); }
    
        ERRWRAP2(cv::perspectiveTransform(src, dst, m), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_phase(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat x;
    Mat y;
    Mat angle;
    bool angleInDegrees=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleInDegrees"), angleInDegrees, ArgInfo("angleInDegrees", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::phase(x, y, angle, angleInDegrees), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, angle);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_x;
    Ptr<UMat> ptr_y;
    Ptr<UMat> ptr_angle;
    bool angleInDegrees=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), ptr_x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), ptr_y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), ptr_angle, ArgInfo("angle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleInDegrees"), angleInDegrees, ArgInfo("angleInDegrees", 0, 1)) )
    {
        error_flag = false;
            UMat x; if (ptr_x.get()) { x = *ptr_x.get(); }
        UMat y; if (ptr_y.get()) { y = *ptr_y.get(); }
        UMat angle; if (ptr_angle.get()) { angle = *ptr_angle.get(); }
    
        ERRWRAP2(cv::phase(x, y, angle, angleInDegrees), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, angle);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_phaseCorrelate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat window;
    double response;
    Point2d retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window"), window, ArgInfo("window", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::phaseCorrelate(src1, src2, window, &response), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, response));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_window;
    double response;
    Point2d retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window"), ptr_window, ArgInfo("window", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat window; if (ptr_window.get()) { window = *ptr_window.get(); }
    
        ERRWRAP2(retval = cv::phaseCorrelate(src1, src2, window, &response), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, response));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pointPolygonTest(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat contour;
    Point2f pt;
    bool measureDist;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), contour, ArgInfo("contour", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "measureDist"), measureDist, ArgInfo("measureDist", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::pointPolygonTest(contour, pt, measureDist), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_contour;
    Point2f pt;
    bool measureDist;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contour"), ptr_contour, ArgInfo("contour", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt"), pt, ArgInfo("pt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "measureDist"), measureDist, ArgInfo("measureDist", 0, 0)) )
    {
        error_flag = false;
            UMat contour; if (ptr_contour.get()) { contour = *ptr_contour.get(); }
    
        ERRWRAP2(retval = cv::pointPolygonTest(contour, pt, measureDist), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_polarToCart(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat magnitude;
    Mat angle;
    Mat x;
    Mat y;
    bool angleInDegrees=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "magnitude"), magnitude, ArgInfo("magnitude", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleInDegrees"), angleInDegrees, ArgInfo("angleInDegrees", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::polarToCart(magnitude, angle, x, y, angleInDegrees), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, x), evision_from(env, y));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_magnitude;
    Ptr<UMat> ptr_angle;
    Ptr<UMat> ptr_x;
    Ptr<UMat> ptr_y;
    bool angleInDegrees=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "magnitude"), ptr_magnitude, ArgInfo("magnitude", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), ptr_angle, ArgInfo("angle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), ptr_x, ArgInfo("x", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), ptr_y, ArgInfo("y", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleInDegrees"), angleInDegrees, ArgInfo("angleInDegrees", 0, 1)) )
    {
        error_flag = false;
            UMat magnitude; if (ptr_magnitude.get()) { magnitude = *ptr_magnitude.get(); }
        UMat angle; if (ptr_angle.get()) { angle = *ptr_angle.get(); }
        UMat x; if (ptr_x.get()) { x = *ptr_x.get(); }
        UMat y; if (ptr_y.get()) { y = *ptr_y.get(); }
    
        ERRWRAP2(cv::polarToCart(magnitude, angle, x, y, angleInDegrees), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, x), evision_from(env, y));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pollKey(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::pollKey(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_polylines(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    vector_Mat pts;
    bool isClosed;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts"), pts, ArgInfo("pts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isClosed"), isClosed, ArgInfo("isClosed", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::polylines(img, pts, isClosed, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    vector_UMat pts;
    bool isClosed;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts"), pts, ArgInfo("pts", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isClosed"), isClosed, ArgInfo("isClosed", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::polylines(img, pts, isClosed, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    double power;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "power"), power, ArgInfo("power", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::pow(src, power, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    double power;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "power"), power, ArgInfo("power", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::pow(src, power, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_preCornerDetect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ksize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::preCornerDetect(src, dst, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ksize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::preCornerDetect(src, dst, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_projectPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat rvec;
    Mat tvec;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat imagePoints;
    Mat jacobian;
    double aspectRatio=0;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), jacobian, ArgInfo("jacobian", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aspectRatio"), aspectRatio, ArgInfo("aspectRatio", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, jacobian, aspectRatio), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, imagePoints), evision_from(env, jacobian));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_jacobian;
    double aspectRatio=0;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), ptr_jacobian, ArgInfo("jacobian", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "aspectRatio"), aspectRatio, ArgInfo("aspectRatio", 0, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat jacobian; if (ptr_jacobian.get()) { jacobian = *ptr_jacobian.get(); }
    
        ERRWRAP2(cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, jacobian, aspectRatio), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, imagePoints), evision_from(env, jacobian));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_putText(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    String text;
    Point org;
    int fontFace;
    double fontScale;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    bool bottomLeftOrigin=false;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "text"), text, ArgInfo("text", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "org"), org, ArgInfo("org", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontFace"), fontFace, ArgInfo("fontFace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontScale"), fontScale, ArgInfo("fontScale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bottomLeftOrigin"), bottomLeftOrigin, ArgInfo("bottomLeftOrigin", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    String text;
    Point org;
    int fontFace;
    double fontScale;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    bool bottomLeftOrigin=false;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "text"), text, ArgInfo("text", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "org"), org, ArgInfo("org", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontFace"), fontFace, ArgInfo("fontFace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fontScale"), fontScale, ArgInfo("fontScale", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bottomLeftOrigin"), bottomLeftOrigin, ArgInfo("bottomLeftOrigin", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyrDown(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size dstsize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstsize"), dstsize, ArgInfo("dstsize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::pyrDown(src, dst, dstsize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size dstsize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstsize"), dstsize, ArgInfo("dstsize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::pyrDown(src, dst, dstsize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyrMeanShiftFiltering(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double sp;
    double sr;
    int maxLevel=1;
    TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sp"), sp, ArgInfo("sp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sr"), sr, ArgInfo("sr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "termcrit"), termcrit, ArgInfo("termcrit", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::pyrMeanShiftFiltering(src, dst, sp, sr, maxLevel, termcrit), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double sp;
    double sr;
    int maxLevel=1;
    TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sp"), sp, ArgInfo("sp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sr"), sr, ArgInfo("sr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxLevel"), maxLevel, ArgInfo("maxLevel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "termcrit"), termcrit, ArgInfo("termcrit", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::pyrMeanShiftFiltering(src, dst, sp, sr, maxLevel, termcrit), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_pyrUp(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size dstsize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstsize"), dstsize, ArgInfo("dstsize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::pyrUp(src, dst, dstsize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size dstsize;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstsize"), dstsize, ArgInfo("dstsize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::pyrUp(src, dst, dstsize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_randShuffle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat dst;
    double iterFactor=1.;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterFactor"), iterFactor, ArgInfo("iterFactor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::randShuffle(dst, iterFactor, 0), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_dst;
    double iterFactor=1.;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterFactor"), iterFactor, ArgInfo("iterFactor", 0, 1)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::randShuffle(dst, iterFactor, 0), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_randn(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat dst;
    Mat mean;
    Mat stddev;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stddev"), stddev, ArgInfo("stddev", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::randn(dst, mean, stddev), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mean;
    Ptr<UMat> ptr_stddev;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), ptr_mean, ArgInfo("mean", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stddev"), ptr_stddev, ArgInfo("stddev", 0, 0)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mean; if (ptr_mean.get()) { mean = *ptr_mean.get(); }
        UMat stddev; if (ptr_stddev.get()) { stddev = *ptr_stddev.get(); }
    
        ERRWRAP2(cv::randn(dst, mean, stddev), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_randu(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat dst;
    Mat low;
    Mat high;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "low"), low, ArgInfo("low", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "high"), high, ArgInfo("high", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::randu(dst, low, high), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_low;
    Ptr<UMat> ptr_high;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "low"), ptr_low, ArgInfo("low", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "high"), ptr_high, ArgInfo("high", 0, 0)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat low; if (ptr_low.get()) { low = *ptr_low.get(); }
        UMat high; if (ptr_high.get()) { high = *ptr_high.get(); }
    
        ERRWRAP2(cv::randu(dst, low, high), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_readOpticalFlow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String path;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "path"), path, ArgInfo("path", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::readOpticalFlow(path), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_recoverPose(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points1;
    Mat points2;
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    Mat E;
    Mat R;
    Mat t;
    int method=cv::RANSAC;
    double prob=0.999;
    double threshold=1.0;
    Mat mask;
    int retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, method, prob, threshold, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, E), evision_from(env, R), evision_from(env, t), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_t;
    int method=cv::RANSAC;
    double prob=0.999;
    double threshold=1.0;
    Ptr<UMat> ptr_mask;
    int retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prob"), prob, ArgInfo("prob", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat t; if (ptr_t.get()) { t = *ptr_t.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, method, prob, threshold, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, E), evision_from(env, R), evision_from(env, t), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat E;
    Mat points1;
    Mat points2;
    Mat cameraMatrix;
    Mat R;
    Mat t;
    double distanceThresh;
    Mat mask;
    Mat triangulatedPoints;
    int retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceThresh"), distanceThresh, ArgInfo("distanceThresh", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "triangulatedPoints"), triangulatedPoints, ArgInfo("triangulatedPoints", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, distanceThresh, mask, triangulatedPoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, R), evision_from(env, t), evision_from(env, mask), evision_from(env, triangulatedPoints));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_t;
    double distanceThresh;
    Ptr<UMat> ptr_mask;
    Ptr<UMat> ptr_triangulatedPoints;
    int retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceThresh"), distanceThresh, ArgInfo("distanceThresh", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "triangulatedPoints"), ptr_triangulatedPoints, ArgInfo("triangulatedPoints", 1, 1)) )
    {
        error_flag = false;
            UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat t; if (ptr_t.get()) { t = *ptr_t.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat triangulatedPoints; if (ptr_triangulatedPoints.get()) { triangulatedPoints = *ptr_triangulatedPoints.get(); }
    
        ERRWRAP2(retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, distanceThresh, mask, triangulatedPoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, R), evision_from(env, t), evision_from(env, mask), evision_from(env, triangulatedPoints));
        }
    }

    }
    

    {
    Mat E;
    Mat points1;
    Mat points2;
    Mat cameraMatrix;
    Mat R;
    Mat t;
    Mat mask;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, R), evision_from(env, t), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_t;
    Ptr<UMat> ptr_mask;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat t; if (ptr_t.get()) { t = *ptr_t.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, R), evision_from(env, t), evision_from(env, mask));
        }
    }

    }
    

    {
    Mat E;
    Mat points1;
    Mat points2;
    Mat R;
    Mat t;
    double focal=1.0;
    Point2d pp=Point2d(0, 0);
    Mat mask;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "focal"), focal, ArgInfo("focal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pp"), pp, ArgInfo("pp", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::recoverPose(E, points1, points2, R, t, focal, pp, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, R), evision_from(env, t), evision_from(env, mask));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_t;
    double focal=1.0;
    Point2d pp=Point2d(0, 0);
    Ptr<UMat> ptr_mask;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_t, ArgInfo("t", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "focal"), focal, ArgInfo("focal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pp"), pp, ArgInfo("pp", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 1, 1)) )
    {
        error_flag = false;
            UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat t; if (ptr_t.get()) { t = *ptr_t.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(retval = cv::recoverPose(E, points1, points2, R, t, focal, pp, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, R), evision_from(env, t), evision_from(env, mask));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rectangle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Point pt1;
    Point pt2;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rectangle(img, pt1, pt2, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Point pt1;
    Point pt2;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::rectangle(img, pt1, pt2, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Mat img;
    Rect rec;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rec"), rec, ArgInfo("rec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rectangle(img, rec, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    Rect rec;
    Scalar color;
    int thickness=1;
    int lineType=LINE_8;
    int shift=0;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rec"), rec, ArgInfo("rec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineType"), lineType, ArgInfo("lineType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "shift"), shift, ArgInfo("shift", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::rectangle(img, rec, color, thickness, lineType, shift), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rectangleIntersectionArea(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Rect2d a;
    Rect2d b;
    double retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rectangleIntersectionArea(a, b), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rectify3Collinear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    Mat cameraMatrix3;
    Mat distCoeffs3;
    vector_Mat imgpt1;
    vector_Mat imgpt3;
    Size imageSize;
    Mat R12;
    Mat T12;
    Mat R13;
    Mat T13;
    Mat R1;
    Mat R2;
    Mat R3;
    Mat P1;
    Mat P2;
    Mat P3;
    Mat Q;
    double alpha;
    Size newImgSize;
    Rect roi1;
    Rect roi2;
    int flags;
    float retval;

    if( num_kw_args >= 16 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix3"), cameraMatrix3, ArgInfo("cameraMatrix3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs3"), distCoeffs3, ArgInfo("distCoeffs3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgpt1"), imgpt1, ArgInfo("imgpt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgpt3"), imgpt3, ArgInfo("imgpt3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r12"), R12, ArgInfo("R12", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t12"), T12, ArgInfo("T12", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r13"), R13, ArgInfo("R13", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t13"), T13, ArgInfo("T13", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r3"), R3, ArgInfo("R3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p3"), P3, ArgInfo("P3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), Q, ArgInfo("Q", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImgSize"), newImgSize, ArgInfo("newImgSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, &roi1, &roi2, flags), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, R1),
                evision_from(env, R2),
                evision_from(env, R3),
                evision_from(env, P1),
                evision_from(env, P2),
                evision_from(env, P3),
                evision_from(env, Q),
                evision_from(env, roi1),
                evision_from(env, roi2)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    Ptr<UMat> ptr_cameraMatrix3;
    Ptr<UMat> ptr_distCoeffs3;
    vector_UMat imgpt1;
    vector_UMat imgpt3;
    Size imageSize;
    Ptr<UMat> ptr_R12;
    Ptr<UMat> ptr_T12;
    Ptr<UMat> ptr_R13;
    Ptr<UMat> ptr_T13;
    Ptr<UMat> ptr_R1;
    Ptr<UMat> ptr_R2;
    Ptr<UMat> ptr_R3;
    Ptr<UMat> ptr_P1;
    Ptr<UMat> ptr_P2;
    Ptr<UMat> ptr_P3;
    Ptr<UMat> ptr_Q;
    double alpha;
    Size newImgSize;
    Rect roi1;
    Rect roi2;
    int flags;
    float retval;

    if( num_kw_args >= 16 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix3"), ptr_cameraMatrix3, ArgInfo("cameraMatrix3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs3"), ptr_distCoeffs3, ArgInfo("distCoeffs3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgpt1"), imgpt1, ArgInfo("imgpt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgpt3"), imgpt3, ArgInfo("imgpt3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r12"), ptr_R12, ArgInfo("R12", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t12"), ptr_T12, ArgInfo("T12", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r13"), ptr_R13, ArgInfo("R13", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t13"), ptr_T13, ArgInfo("T13", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), ptr_R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), ptr_R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r3"), ptr_R3, ArgInfo("R3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), ptr_P1, ArgInfo("P1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), ptr_P2, ArgInfo("P2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p3"), ptr_P3, ArgInfo("P3", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), ptr_Q, ArgInfo("Q", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImgSize"), newImgSize, ArgInfo("newImgSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat cameraMatrix3; if (ptr_cameraMatrix3.get()) { cameraMatrix3 = *ptr_cameraMatrix3.get(); }
        UMat distCoeffs3; if (ptr_distCoeffs3.get()) { distCoeffs3 = *ptr_distCoeffs3.get(); }
        UMat R12; if (ptr_R12.get()) { R12 = *ptr_R12.get(); }
        UMat T12; if (ptr_T12.get()) { T12 = *ptr_T12.get(); }
        UMat R13; if (ptr_R13.get()) { R13 = *ptr_R13.get(); }
        UMat T13; if (ptr_T13.get()) { T13 = *ptr_T13.get(); }
        UMat R1; if (ptr_R1.get()) { R1 = *ptr_R1.get(); }
        UMat R2; if (ptr_R2.get()) { R2 = *ptr_R2.get(); }
        UMat R3; if (ptr_R3.get()) { R3 = *ptr_R3.get(); }
        UMat P1; if (ptr_P1.get()) { P1 = *ptr_P1.get(); }
        UMat P2; if (ptr_P2.get()) { P2 = *ptr_P2.get(); }
        UMat P3; if (ptr_P3.get()) { P3 = *ptr_P3.get(); }
        UMat Q; if (ptr_Q.get()) { Q = *ptr_Q.get(); }
    
        ERRWRAP2(retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, &roi1, &roi2, flags), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, R1),
                evision_from(env, R2),
                evision_from(env, R3),
                evision_from(env, P1),
                evision_from(env, P2),
                evision_from(env, P3),
                evision_from(env, Q),
                evision_from(env, roi1),
                evision_from(env, roi2)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reduce(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int dim;
    int rtype;
    int dtype=-1;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dim"), dim, ArgInfo("dim", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::reduce(src, dst, dim, rtype, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int dim;
    int rtype;
    int dtype=-1;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dim"), dim, ArgInfo("dim", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rtype"), rtype, ArgInfo("rtype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::reduce(src, dst, dim, rtype, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reduceArgMax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int axis;
    bool lastIndex=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axis"), axis, ArgInfo("axis", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lastIndex"), lastIndex, ArgInfo("lastIndex", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::reduceArgMax(src, dst, axis, lastIndex), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int axis;
    bool lastIndex=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axis"), axis, ArgInfo("axis", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lastIndex"), lastIndex, ArgInfo("lastIndex", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::reduceArgMax(src, dst, axis, lastIndex), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reduceArgMin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int axis;
    bool lastIndex=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axis"), axis, ArgInfo("axis", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lastIndex"), lastIndex, ArgInfo("lastIndex", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::reduceArgMin(src, dst, axis, lastIndex), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int axis;
    bool lastIndex=false;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "axis"), axis, ArgInfo("axis", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lastIndex"), lastIndex, ArgInfo("lastIndex", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::reduceArgMin(src, dst, axis, lastIndex), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_remap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat map1;
    Mat map2;
    int interpolation;
    int borderMode=BORDER_CONSTANT;
    Scalar borderValue;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interpolation"), interpolation, ArgInfo("interpolation", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::remap(src, dst, map1, map2, interpolation, borderMode, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_map1;
    Ptr<UMat> ptr_map2;
    int interpolation;
    int borderMode=BORDER_CONSTANT;
    Scalar borderValue;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), ptr_map1, ArgInfo("map1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), ptr_map2, ArgInfo("map2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interpolation"), interpolation, ArgInfo("interpolation", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat map1; if (ptr_map1.get()) { map1 = *ptr_map1.get(); }
        UMat map2; if (ptr_map2.get()) { map2 = *ptr_map2.get(); }
    
        ERRWRAP2(cv::remap(src, dst, map1, map2, interpolation, borderMode, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_repeat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    int ny;
    int nx;
    Mat dst;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ny"), ny, ArgInfo("ny", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nx"), nx, ArgInfo("nx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::repeat(src, ny, nx, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    int ny;
    int nx;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ny"), ny, ArgInfo("ny", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nx"), nx, ArgInfo("nx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::repeat(src, ny, nx, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reprojectImageTo3D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat disparity;
    Mat _3dImage;
    Mat Q;
    bool handleMissingValues=false;
    int ddepth=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "3dImage"), _3dImage, ArgInfo("_3dImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), Q, ArgInfo("Q", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "handleMissingValues"), handleMissingValues, ArgInfo("handleMissingValues", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::reprojectImageTo3D(disparity, _3dImage, Q, handleMissingValues, ddepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, _3dImage);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_disparity;
    Ptr<UMat> ptr__3dImage;
    Ptr<UMat> ptr_Q;
    bool handleMissingValues=false;
    int ddepth=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), ptr_disparity, ArgInfo("disparity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "3dImage"), ptr__3dImage, ArgInfo("_3dImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), ptr_Q, ArgInfo("Q", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "handleMissingValues"), handleMissingValues, ArgInfo("handleMissingValues", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) )
    {
        error_flag = false;
            UMat disparity; if (ptr_disparity.get()) { disparity = *ptr_disparity.get(); }
        UMat _3dImage; if (ptr__3dImage.get()) { _3dImage = *ptr__3dImage.get(); }
        UMat Q; if (ptr_Q.get()) { Q = *ptr_Q.get(); }
    
        ERRWRAP2(cv::reprojectImageTo3D(disparity, _3dImage, Q, handleMissingValues, ddepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, _3dImage);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_resize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size dsize;
    double fx=0;
    double fy=0;
    int interpolation=INTER_LINEAR;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fx"), fx, ArgInfo("fx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fy"), fy, ArgInfo("fy", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interpolation"), interpolation, ArgInfo("interpolation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::resize(src, dst, dsize, fx, fy, interpolation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size dsize;
    double fx=0;
    double fy=0;
    int interpolation=INTER_LINEAR;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fx"), fx, ArgInfo("fx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fy"), fy, ArgInfo("fy", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interpolation"), interpolation, ArgInfo("interpolation", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::resize(src, dst, dsize, fx, fy, interpolation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_resizeWindow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String winname;
    int width;
    int height;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::resizeWindow(winname, width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    }
    

    {
    String winname;
    Size size;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::resizeWindow(winname, size), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rotate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int rotateCode;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotateCode"), rotateCode, ArgInfo("rotateCode", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rotate(src, dst, rotateCode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int rotateCode;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotateCode"), rotateCode, ArgInfo("rotateCode", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::rotate(src, dst, rotateCode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rotatedRectangleIntersection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    RotatedRect rect1;
    RotatedRect rect2;
    Mat intersectingRegion;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect1"), rect1, ArgInfo("rect1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect2"), rect2, ArgInfo("rect2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "intersectingRegion"), intersectingRegion, ArgInfo("intersectingRegion", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rotatedRectangleIntersection(rect1, rect2, intersectingRegion), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, intersectingRegion));
        }
    }

    }
    

    {
    RotatedRect rect1;
    RotatedRect rect2;
    Ptr<UMat> ptr_intersectingRegion;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect1"), rect1, ArgInfo("rect1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect2"), rect2, ArgInfo("rect2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "intersectingRegion"), ptr_intersectingRegion, ArgInfo("intersectingRegion", 1, 0)) )
    {
        error_flag = false;
            UMat intersectingRegion; if (ptr_intersectingRegion.get()) { intersectingRegion = *ptr_intersectingRegion.get(); }
    
        ERRWRAP2(retval = cv::rotatedRectangleIntersection(rect1, rect2, intersectingRegion), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, intersectingRegion));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sampsonDistance(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat pt1;
    Mat pt2;
    Mat F;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::sampsonDistance(pt1, pt2, F), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_pt1;
    Ptr<UMat> ptr_pt2;
    Ptr<UMat> ptr_F;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt1"), ptr_pt1, ArgInfo("pt1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pt2"), ptr_pt2, ArgInfo("pt2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 0, 0)) )
    {
        error_flag = false;
            UMat pt1; if (ptr_pt1.get()) { pt1 = *ptr_pt1.get(); }
        UMat pt2; if (ptr_pt2.get()) { pt2 = *ptr_pt2.get(); }
        UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
    
        ERRWRAP2(retval = cv::sampsonDistance(pt1, pt2, F), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_scaleAdd(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    double alpha;
    Mat src2;
    Mat dst;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::scaleAdd(src1, alpha, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    double alpha;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::scaleAdd(src1, alpha, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_seamlessClone(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat mask;
    Point p;
    Mat blend;
    int flags;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), p, ArgInfo("p", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blend"), blend, ArgInfo("blend", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::seamlessClone(src, dst, mask, p, blend, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, blend);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;
    Point p;
    Ptr<UMat> ptr_blend;
    int flags;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), p, ArgInfo("p", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blend"), ptr_blend, ArgInfo("blend", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat blend; if (ptr_blend.get()) { blend = *ptr_blend.get(); }
    
        ERRWRAP2(cv::seamlessClone(src, dst, mask, p, blend, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, blend);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_selectROI(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String windowName;
    Mat img;
    bool showCrosshair=true;
    bool fromCenter=false;
    bool printNotice=true;
    Rect retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowName"), windowName, ArgInfo("windowName", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "showCrosshair"), showCrosshair, ArgInfo("showCrosshair", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromCenter"), fromCenter, ArgInfo("fromCenter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "printNotice"), printNotice, ArgInfo("printNotice", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::selectROI(windowName, img, showCrosshair, fromCenter, printNotice), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String windowName;
    Ptr<UMat> ptr_img;
    bool showCrosshair=true;
    bool fromCenter=false;
    bool printNotice=true;
    Rect retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowName"), windowName, ArgInfo("windowName", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "showCrosshair"), showCrosshair, ArgInfo("showCrosshair", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromCenter"), fromCenter, ArgInfo("fromCenter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "printNotice"), printNotice, ArgInfo("printNotice", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(retval = cv::selectROI(windowName, img, showCrosshair, fromCenter, printNotice), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Mat img;
    bool showCrosshair=true;
    bool fromCenter=false;
    bool printNotice=true;
    Rect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "showCrosshair"), showCrosshair, ArgInfo("showCrosshair", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromCenter"), fromCenter, ArgInfo("fromCenter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "printNotice"), printNotice, ArgInfo("printNotice", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::selectROI(img, showCrosshair, fromCenter, printNotice), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_img;
    bool showCrosshair=true;
    bool fromCenter=false;
    bool printNotice=true;
    Rect retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "showCrosshair"), showCrosshair, ArgInfo("showCrosshair", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromCenter"), fromCenter, ArgInfo("fromCenter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "printNotice"), printNotice, ArgInfo("printNotice", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(retval = cv::selectROI(img, showCrosshair, fromCenter, printNotice), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_selectROIs(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String windowName;
    Mat img;
    vector_Rect boundingBoxes;
    bool showCrosshair=true;
    bool fromCenter=false;
    bool printNotice=true;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowName"), windowName, ArgInfo("windowName", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "showCrosshair"), showCrosshair, ArgInfo("showCrosshair", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromCenter"), fromCenter, ArgInfo("fromCenter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "printNotice"), printNotice, ArgInfo("printNotice", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::selectROIs(windowName, img, boundingBoxes, showCrosshair, fromCenter, printNotice), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, boundingBoxes);
        }
    }

    }
    

    {
    String windowName;
    Ptr<UMat> ptr_img;
    vector_Rect boundingBoxes;
    bool showCrosshair=true;
    bool fromCenter=false;
    bool printNotice=true;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowName"), windowName, ArgInfo("windowName", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), ptr_img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "showCrosshair"), showCrosshair, ArgInfo("showCrosshair", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fromCenter"), fromCenter, ArgInfo("fromCenter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "printNotice"), printNotice, ArgInfo("printNotice", 0, 1)) )
    {
        error_flag = false;
            UMat img; if (ptr_img.get()) { img = *ptr_img.get(); }
    
        ERRWRAP2(cv::selectROIs(windowName, img, boundingBoxes, showCrosshair, fromCenter, printNotice), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, boundingBoxes);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sepFilter2D(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    Mat kernelX;
    Mat kernelY;
    Point anchor=Point(-1,-1);
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernelX"), kernelX, ArgInfo("kernelX", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernelY"), kernelY, ArgInfo("kernelY", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::sepFilter2D(src, dst, ddepth, kernelX, kernelY, anchor, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    Ptr<UMat> ptr_kernelX;
    Ptr<UMat> ptr_kernelY;
    Point anchor=Point(-1,-1);
    double delta=0;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernelX"), ptr_kernelX, ArgInfo("kernelX", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernelY"), ptr_kernelY, ArgInfo("kernelY", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat kernelX; if (ptr_kernelX.get()) { kernelX = *ptr_kernelX.get(); }
        UMat kernelY; if (ptr_kernelY.get()) { kernelY = *ptr_kernelY.get(); }
    
        ERRWRAP2(cv::sepFilter2D(src, dst, ddepth, kernelX, kernelY, anchor, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setIdentity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat mtx;
    Scalar s=Scalar(1);

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtx"), mtx, ArgInfo("mtx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setIdentity(mtx, s), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, mtx);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_mtx;
    Scalar s=Scalar(1);

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtx"), ptr_mtx, ArgInfo("mtx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s"), s, ArgInfo("s", 0, 1)) )
    {
        error_flag = false;
            UMat mtx; if (ptr_mtx.get()) { mtx = *ptr_mtx.get(); }
    
        ERRWRAP2(cv::setIdentity(mtx, s), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, mtx);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setLogLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int level;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "level"), level, ArgInfo("level", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::setLogLevel(level), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setNumThreads(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nthreads;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nthreads"), nthreads, ArgInfo("nthreads", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setNumThreads(nthreads), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setRNGSeed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int seed;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "seed"), seed, ArgInfo("seed", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setRNGSeed(seed), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setTrackbarMax(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String trackbarname;
    String winname;
    int maxval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trackbarname"), trackbarname, ArgInfo("trackbarname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxval"), maxval, ArgInfo("maxval", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setTrackbarMax(trackbarname, winname, maxval), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setTrackbarMin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String trackbarname;
    String winname;
    int minval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trackbarname"), trackbarname, ArgInfo("trackbarname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minval"), minval, ArgInfo("minval", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setTrackbarMin(trackbarname, winname, minval), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setTrackbarPos(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String trackbarname;
    String winname;
    int pos;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trackbarname"), trackbarname, ArgInfo("trackbarname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pos"), pos, ArgInfo("pos", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setTrackbarPos(trackbarname, winname, pos), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setUseOpenVX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool flag;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setUseOpenVX(flag), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setUseOptimized(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool onoff;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "onoff"), onoff, ArgInfo("onoff", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setUseOptimized(onoff), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setWindowProperty(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    int prop_id;
    double prop_value;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prop_id"), prop_id, ArgInfo("prop_id", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prop_value"), prop_value, ArgInfo("prop_value", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setWindowProperty(winname, prop_id, prop_value), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_setWindowTitle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String winname;
    String title;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "winname"), winname, ArgInfo("winname", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "title"), title, ArgInfo("title", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::setWindowTitle(winname, title), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solve(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    int flags=DECOMP_LU;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solve(src1, src2, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, dst);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    int flags=DECOMP_LU;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(retval = cv::solve(src1, src2, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, dst);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solveCubic(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat coeffs;
    Mat roots;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coeffs"), coeffs, ArgInfo("coeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roots"), roots, ArgInfo("roots", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solveCubic(coeffs, roots), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, roots));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_coeffs;
    Ptr<UMat> ptr_roots;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coeffs"), ptr_coeffs, ArgInfo("coeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roots"), ptr_roots, ArgInfo("roots", 1, 0)) )
    {
        error_flag = false;
            UMat coeffs; if (ptr_coeffs.get()) { coeffs = *ptr_coeffs.get(); }
        UMat roots; if (ptr_roots.get()) { roots = *ptr_roots.get(); }
    
        ERRWRAP2(retval = cv::solveCubic(coeffs, roots), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, roots));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solveLP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat Func;
    Mat Constr;
    Mat z;
    double constr_eps;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "func"), Func, ArgInfo("Func", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "constr"), Constr, ArgInfo("Constr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "z"), z, ArgInfo("z", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "constr_eps"), constr_eps, ArgInfo("constr_eps", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solveLP(Func, Constr, z, constr_eps), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, z));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_Func;
    Ptr<UMat> ptr_Constr;
    Ptr<UMat> ptr_z;
    double constr_eps;
    int retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "func"), ptr_Func, ArgInfo("Func", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "constr"), ptr_Constr, ArgInfo("Constr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "z"), ptr_z, ArgInfo("z", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "constr_eps"), constr_eps, ArgInfo("constr_eps", 0, 0)) )
    {
        error_flag = false;
            UMat Func; if (ptr_Func.get()) { Func = *ptr_Func.get(); }
        UMat Constr; if (ptr_Constr.get()) { Constr = *ptr_Constr.get(); }
        UMat z; if (ptr_z.get()) { z = *ptr_z.get(); }
    
        ERRWRAP2(retval = cv::solveLP(Func, Constr, z, constr_eps), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, z));
        }
    }

    }
    

    {
    Mat Func;
    Mat Constr;
    Mat z;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "func"), Func, ArgInfo("Func", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "constr"), Constr, ArgInfo("Constr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "z"), z, ArgInfo("z", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solveLP(Func, Constr, z), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, z));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_Func;
    Ptr<UMat> ptr_Constr;
    Ptr<UMat> ptr_z;
    int retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "func"), ptr_Func, ArgInfo("Func", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "constr"), ptr_Constr, ArgInfo("Constr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "z"), ptr_z, ArgInfo("z", 1, 0)) )
    {
        error_flag = false;
            UMat Func; if (ptr_Func.get()) { Func = *ptr_Func.get(); }
        UMat Constr; if (ptr_Constr.get()) { Constr = *ptr_Constr.get(); }
        UMat z; if (ptr_z.get()) { z = *ptr_z.get(); }
    
        ERRWRAP2(retval = cv::solveLP(Func, Constr, z), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, z));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solveP3P(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags;
    int retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags;
    int retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
    
        ERRWRAP2(retval = cv::solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solvePnP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    bool useExtrinsicGuess=false;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    bool useExtrinsicGuess=false;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
    
        ERRWRAP2(retval = cv::solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solvePnPGeneric(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    bool useExtrinsicGuess=false;
    std::underlying_type_t<SolvePnPMethod> flags=static_cast<std::underlying_type_t<SolvePnPMethod>>(SOLVEPNP_ITERATIVE);
    Mat rvec;
    Mat tvec;
    Mat reprojectionError;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reprojectionError"), reprojectionError, ArgInfo("reprojectionError", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, useExtrinsicGuess, static_cast<SolvePnPMethod>(flags), rvec, tvec, reprojectionError), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, reprojectionError));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    bool useExtrinsicGuess=false;
    std::underlying_type_t<SolvePnPMethod> flags=static_cast<std::underlying_type_t<SolvePnPMethod>>(SOLVEPNP_ITERATIVE);
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    Ptr<UMat> ptr_reprojectionError;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reprojectionError"), ptr_reprojectionError, ArgInfo("reprojectionError", 1, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
        UMat reprojectionError; if (ptr_reprojectionError.get()) { reprojectionError = *ptr_reprojectionError.get(); }
    
        ERRWRAP2(retval = cv::solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, useExtrinsicGuess, static_cast<SolvePnPMethod>(flags), rvec, tvec, reprojectionError), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, reprojectionError));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solvePnPRansac(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    Mat inliers;
    UsacParams params;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, inliers, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple4(env, evision_from(env, cameraMatrix), evision_from(env, rvec), evision_from(env, tvec), evision_from(env, inliers));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    Ptr<UMat> ptr_inliers;
    UsacParams params;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, inliers, params), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple4(env, evision_from(env, cameraMatrix), evision_from(env, rvec), evision_from(env, tvec), evision_from(env, inliers));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    bool useExtrinsicGuess=false;
    int iterationsCount=100;
    float reprojectionError=8.0;
    double confidence=0.99;
    Mat inliers;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterationsCount"), iterationsCount, ArgInfo("iterationsCount", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reprojectionError"), reprojectionError, ArgInfo("reprojectionError", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), inliers, ArgInfo("inliers", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, rvec), evision_from(env, tvec), evision_from(env, inliers));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    bool useExtrinsicGuess=false;
    int iterationsCount=100;
    float reprojectionError=8.0;
    double confidence=0.99;
    Ptr<UMat> ptr_inliers;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterationsCount"), iterationsCount, ArgInfo("iterationsCount", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reprojectionError"), reprojectionError, ArgInfo("reprojectionError", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inliers"), ptr_inliers, ArgInfo("inliers", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
        UMat inliers; if (ptr_inliers.get()) { inliers = *ptr_inliers.get(); }
    
        ERRWRAP2(retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers, flags), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple3(env, evision_from(env, rvec), evision_from(env, tvec), evision_from(env, inliers));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solvePnPRefineLM(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
    
        ERRWRAP2(cv::solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solvePnPRefineVVS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);
    double VVSlambda=1;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vVSlambda"), VVSlambda, ArgInfo("VVSlambda", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria, VVSlambda), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_objectPoints;
    Ptr<UMat> ptr_imagePoints;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_rvec;
    Ptr<UMat> ptr_tvec;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);
    double VVSlambda=1;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), ptr_objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), ptr_imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), ptr_rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), ptr_tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vVSlambda"), VVSlambda, ArgInfo("VVSlambda", 0, 1)) )
    {
        error_flag = false;
            UMat objectPoints; if (ptr_objectPoints.get()) { objectPoints = *ptr_objectPoints.get(); }
        UMat imagePoints; if (ptr_imagePoints.get()) { imagePoints = *ptr_imagePoints.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat rvec; if (ptr_rvec.get()) { rvec = *ptr_rvec.get(); }
        UMat tvec; if (ptr_tvec.get()) { tvec = *ptr_tvec.get(); }
    
        ERRWRAP2(cv::solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria, VVSlambda), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_solvePoly(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat coeffs;
    Mat roots;
    int maxIters=300;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coeffs"), coeffs, ArgInfo("coeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roots"), roots, ArgInfo("roots", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::solvePoly(coeffs, roots, maxIters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, roots));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_coeffs;
    Ptr<UMat> ptr_roots;
    int maxIters=300;
    double retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "coeffs"), ptr_coeffs, ArgInfo("coeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roots"), ptr_roots, ArgInfo("roots", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxIters"), maxIters, ArgInfo("maxIters", 0, 1)) )
    {
        error_flag = false;
            UMat coeffs; if (ptr_coeffs.get()) { coeffs = *ptr_coeffs.get(); }
        UMat roots; if (ptr_roots.get()) { roots = *ptr_roots.get(); }
    
        ERRWRAP2(retval = cv::solvePoly(coeffs, roots, maxIters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, roots));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sort(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::sort(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::sort(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sortIdx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int flags;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::sortIdx(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int flags;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::sortIdx(src, dst, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_spatialGradient(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dx;
    Mat dy;
    int ksize=3;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::spatialGradient(src, dx, dy, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dx), evision_from(env, dy));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dx;
    Ptr<UMat> ptr_dy;
    int ksize=3;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), ptr_dx, ArgInfo("dx", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), ptr_dy, ArgInfo("dy", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dx; if (ptr_dx.get()) { dx = *ptr_dx.get(); }
        UMat dy; if (ptr_dy.get()) { dy = *ptr_dy.get(); }
    
        ERRWRAP2(cv::spatialGradient(src, dx, dy, ksize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dx), evision_from(env, dy));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_split(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat m;
    vector_Mat mv;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mv"), mv, ArgInfo("mv", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::split(m, mv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, mv);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_m;
    vector_UMat mv;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_m, ArgInfo("m", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mv"), mv, ArgInfo("mv", 1, 0)) )
    {
        error_flag = false;
            UMat m; if (ptr_m.get()) { m = *ptr_m.get(); }
    
        ERRWRAP2(cv::split(m, mv), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, mv);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sqrBoxFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int ddepth;
    Size ksize;
    Point anchor=Point(-1, -1);
    bool normalize=true;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normalize"), normalize, ArgInfo("normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::sqrBoxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    int ddepth;
    Size ksize;
    Point anchor=Point(-1, -1);
    bool normalize=true;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "anchor"), anchor, ArgInfo("anchor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normalize"), normalize, ArgInfo("normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::sqrBoxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sqrt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::sqrt(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::sqrt(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stackBlur(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size ksize;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::stackBlur(src, dst, ksize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size ksize;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::stackBlur(src, dst, ksize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_startWindowThread(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::startWindowThread(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoCalibrate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints1;
    vector_Mat imagePoints2;
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    Size imageSize;
    Mat R;
    Mat T;
    Mat E;
    Mat F;
    Mat perViewErrors;
    int flags=CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    if( num_kw_args >= 10 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, cameraMatrix1),
                evision_from(env, distCoeffs1),
                evision_from(env, cameraMatrix2),
                evision_from(env, distCoeffs2),
                evision_from(env, R),
                evision_from(env, T),
                evision_from(env, E),
                evision_from(env, F),
                evision_from(env, perViewErrors)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints1;
    vector_UMat imagePoints2;
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    Size imageSize;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_T;
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_F;
    Ptr<UMat> ptr_perViewErrors;
    int flags=CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    if( num_kw_args >= 10 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), ptr_perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat T; if (ptr_T.get()) { T = *ptr_T.get(); }
        UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
        UMat perViewErrors; if (ptr_perViewErrors.get()) { perViewErrors = *ptr_perViewErrors.get(); }
    
        ERRWRAP2(retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, cameraMatrix1),
                evision_from(env, distCoeffs1),
                evision_from(env, cameraMatrix2),
                evision_from(env, distCoeffs2),
                evision_from(env, R),
                evision_from(env, T),
                evision_from(env, E),
                evision_from(env, F),
                evision_from(env, perViewErrors)};
            return enif_make_tuple_from_array(env, arr, 10);
        }
    }

    }
    

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints1;
    vector_Mat imagePoints2;
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    Size imageSize;
    Mat R;
    Mat T;
    Mat E;
    Mat F;
    int flags=CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple9(env, evision_from(env, retval), evision_from(env, cameraMatrix1), evision_from(env, distCoeffs1), evision_from(env, cameraMatrix2), evision_from(env, distCoeffs2), evision_from(env, R), evision_from(env, T), evision_from(env, E), evision_from(env, F));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints1;
    vector_UMat imagePoints2;
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    Size imageSize;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_T;
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_F;
    int flags=CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat T; if (ptr_T.get()) { T = *ptr_T.get(); }
        UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
    
        ERRWRAP2(retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple9(env, evision_from(env, retval), evision_from(env, cameraMatrix1), evision_from(env, distCoeffs1), evision_from(env, cameraMatrix2), evision_from(env, distCoeffs2), evision_from(env, R), evision_from(env, T), evision_from(env, E), evision_from(env, F));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoCalibrateExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints1;
    vector_Mat imagePoints2;
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    Size imageSize;
    Mat R;
    Mat T;
    Mat E;
    Mat F;
    vector_Mat rvecs;
    vector_Mat tvecs;
    Mat perViewErrors;
    int flags=CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    if( num_kw_args >= 10 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, rvecs, tvecs, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, cameraMatrix1),
                evision_from(env, distCoeffs1),
                evision_from(env, cameraMatrix2),
                evision_from(env, distCoeffs2),
                evision_from(env, R),
                evision_from(env, T),
                evision_from(env, E),
                evision_from(env, F),
                evision_from(env, rvecs),
                evision_from(env, tvecs),
                evision_from(env, perViewErrors)};
            return enif_make_tuple_from_array(env, arr, 12);
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints1;
    vector_UMat imagePoints2;
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    Size imageSize;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_T;
    Ptr<UMat> ptr_E;
    Ptr<UMat> ptr_F;
    vector_UMat rvecs;
    vector_UMat tvecs;
    Ptr<UMat> ptr_perViewErrors;
    int flags=CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    if( num_kw_args >= 10 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "e"), ptr_E, ArgInfo("E", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), ptr_perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat T; if (ptr_T.get()) { T = *ptr_T.get(); }
        UMat E; if (ptr_E.get()) { E = *ptr_E.get(); }
        UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
        UMat perViewErrors; if (ptr_perViewErrors.get()) { perViewErrors = *ptr_perViewErrors.get(); }
    
        ERRWRAP2(retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, rvecs, tvecs, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, cameraMatrix1),
                evision_from(env, distCoeffs1),
                evision_from(env, cameraMatrix2),
                evision_from(env, distCoeffs2),
                evision_from(env, R),
                evision_from(env, T),
                evision_from(env, E),
                evision_from(env, F),
                evision_from(env, rvecs),
                evision_from(env, tvecs),
                evision_from(env, perViewErrors)};
            return enif_make_tuple_from_array(env, arr, 12);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoRectify(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cameraMatrix1;
    Mat distCoeffs1;
    Mat cameraMatrix2;
    Mat distCoeffs2;
    Size imageSize;
    Mat R;
    Mat T;
    Mat R1;
    Mat R2;
    Mat P1;
    Mat P2;
    Mat Q;
    int flags=CALIB_ZERO_DISPARITY;
    double alpha=-1;
    Size newImageSize;
    Rect validPixROI1;
    Rect validPixROI2;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), Q, ArgInfo("Q", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImageSize"), newImageSize, ArgInfo("newImageSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize, &validPixROI1, &validPixROI2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, R1), evision_from(env, R2), evision_from(env, P1), evision_from(env, P2), evision_from(env, Q), evision_from(env, validPixROI1), evision_from(env, validPixROI2));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_cameraMatrix1;
    Ptr<UMat> ptr_distCoeffs1;
    Ptr<UMat> ptr_cameraMatrix2;
    Ptr<UMat> ptr_distCoeffs2;
    Size imageSize;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_T;
    Ptr<UMat> ptr_R1;
    Ptr<UMat> ptr_R2;
    Ptr<UMat> ptr_P1;
    Ptr<UMat> ptr_P2;
    Ptr<UMat> ptr_Q;
    int flags=CALIB_ZERO_DISPARITY;
    double alpha=-1;
    Size newImageSize;
    Rect validPixROI1;
    Rect validPixROI2;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix1"), ptr_cameraMatrix1, ArgInfo("cameraMatrix1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs1"), ptr_distCoeffs1, ArgInfo("distCoeffs1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix2"), ptr_cameraMatrix2, ArgInfo("cameraMatrix2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs2"), ptr_distCoeffs2, ArgInfo("distCoeffs2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), ptr_T, ArgInfo("T", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), ptr_R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), ptr_R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), ptr_P1, ArgInfo("P1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), ptr_P2, ArgInfo("P2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), ptr_Q, ArgInfo("Q", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImageSize"), newImageSize, ArgInfo("newImageSize", 0, 1)) )
    {
        error_flag = false;
            UMat cameraMatrix1; if (ptr_cameraMatrix1.get()) { cameraMatrix1 = *ptr_cameraMatrix1.get(); }
        UMat distCoeffs1; if (ptr_distCoeffs1.get()) { distCoeffs1 = *ptr_distCoeffs1.get(); }
        UMat cameraMatrix2; if (ptr_cameraMatrix2.get()) { cameraMatrix2 = *ptr_cameraMatrix2.get(); }
        UMat distCoeffs2; if (ptr_distCoeffs2.get()) { distCoeffs2 = *ptr_distCoeffs2.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat T; if (ptr_T.get()) { T = *ptr_T.get(); }
        UMat R1; if (ptr_R1.get()) { R1 = *ptr_R1.get(); }
        UMat R2; if (ptr_R2.get()) { R2 = *ptr_R2.get(); }
        UMat P1; if (ptr_P1.get()) { P1 = *ptr_P1.get(); }
        UMat P2; if (ptr_P2.get()) { P2 = *ptr_P2.get(); }
        UMat Q; if (ptr_Q.get()) { Q = *ptr_Q.get(); }
    
        ERRWRAP2(cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize, &validPixROI1, &validPixROI2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, R1), evision_from(env, R2), evision_from(env, P1), evision_from(env, P2), evision_from(env, Q), evision_from(env, validPixROI1), evision_from(env, validPixROI2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereoRectifyUncalibrated(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat points1;
    Mat points2;
    Mat F;
    Size imgSize;
    Mat H1;
    Mat H2;
    double threshold=5;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), F, ArgInfo("F", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgSize"), imgSize, ArgInfo("imgSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h1"), H1, ArgInfo("H1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h2"), H2, ArgInfo("H2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::stereoRectifyUncalibrated(points1, points2, F, imgSize, H1, H2, threshold), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, H1), evision_from(env, H2));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<UMat> ptr_points1;
    Ptr<UMat> ptr_points2;
    Ptr<UMat> ptr_F;
    Size imgSize;
    Ptr<UMat> ptr_H1;
    Ptr<UMat> ptr_H2;
    double threshold=5;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points1"), ptr_points1, ArgInfo("points1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points2"), ptr_points2, ArgInfo("points2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f"), ptr_F, ArgInfo("F", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgSize"), imgSize, ArgInfo("imgSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h1"), ptr_H1, ArgInfo("H1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h2"), ptr_H2, ArgInfo("H2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
            UMat points1; if (ptr_points1.get()) { points1 = *ptr_points1.get(); }
        UMat points2; if (ptr_points2.get()) { points2 = *ptr_points2.get(); }
        UMat F; if (ptr_F.get()) { F = *ptr_F.get(); }
        UMat H1; if (ptr_H1.get()) { H1 = *ptr_H1.get(); }
        UMat H2; if (ptr_H2.get()) { H2 = *ptr_H2.get(); }
    
        ERRWRAP2(retval = cv::stereoRectifyUncalibrated(points1, points2, F, imgSize, H1, H2, threshold), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, H1), evision_from(env, H2));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stylization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    float sigma_s=60;
    float sigma_r=0.45f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::stylization(src, dst, sigma_s, sigma_r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    float sigma_s=60;
    float sigma_r=0.45f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::stylization(src, dst, sigma_s, sigma_r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_subtract(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;
    Mat mask;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::subtract(src1, src2, dst, mask, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src1;
    Ptr<UMat> ptr_src2;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_mask;
    int dtype=-1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), ptr_src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), ptr_src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 1)) )
    {
        error_flag = false;
            UMat src1; if (ptr_src1.get()) { src1 = *ptr_src1.get(); }
        UMat src2; if (ptr_src2.get()) { src2 = *ptr_src2.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
    
        ERRWRAP2(cv::subtract(src1, src2, dst, mask, dtype), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_sumElems(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Scalar retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::sum(src), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Scalar retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
    
        ERRWRAP2(retval = cv::sum(src), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_textureFlattening(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat mask;
    Mat dst;
    float low_threshold=30;
    float high_threshold=45;
    int kernel_size=3;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "low_threshold"), low_threshold, ArgInfo("low_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "high_threshold"), high_threshold, ArgInfo("high_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel_size"), kernel_size, ArgInfo("kernel_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::textureFlattening(src, mask, dst, low_threshold, high_threshold, kernel_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_mask;
    Ptr<UMat> ptr_dst;
    float low_threshold=30;
    float high_threshold=45;
    int kernel_size=3;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), ptr_mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "low_threshold"), low_threshold, ArgInfo("low_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "high_threshold"), high_threshold, ArgInfo("high_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel_size"), kernel_size, ArgInfo("kernel_size", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat mask; if (ptr_mask.get()) { mask = *ptr_mask.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::textureFlattening(src, mask, dst, low_threshold, high_threshold, kernel_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_threshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double thresh;
    double maxval;
    int type;
    double retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxval"), maxval, ArgInfo("maxval", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::threshold(src, dst, thresh, maxval, type), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    double thresh;
    double maxval;
    int type;
    double retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxval"), maxval, ArgInfo("maxval", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(retval = cv::threshold(src, dst, thresh, maxval, type), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_trace(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat mtx;
    Scalar retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtx"), mtx, ArgInfo("mtx", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::trace(mtx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_mtx;
    Scalar retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mtx"), ptr_mtx, ArgInfo("mtx", 0, 0)) )
    {
        error_flag = false;
            UMat mtx; if (ptr_mtx.get()) { mtx = *ptr_mtx.get(); }
    
        ERRWRAP2(retval = cv::trace(mtx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_transform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat m;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::transform(src, dst, m), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_m;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_m, ArgInfo("m", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat m; if (ptr_m.get()) { m = *ptr_m.get(); }
    
        ERRWRAP2(cv::transform(src, dst, m), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_transpose(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::transpose(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::transpose(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_transposeND(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    vector_int order;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "order"), order, ArgInfo("order", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::transposeND(src, order, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    vector_int order;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "order"), order, ArgInfo("order", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::transposeND(src, order, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_triangulatePoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat projMatr1;
    Mat projMatr2;
    Mat projPoints1;
    Mat projPoints2;
    Mat points4D;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projMatr1"), projMatr1, ArgInfo("projMatr1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projMatr2"), projMatr2, ArgInfo("projMatr2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projPoints1"), projPoints1, ArgInfo("projPoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projPoints2"), projPoints2, ArgInfo("projPoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points4D"), points4D, ArgInfo("points4D", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, points4D), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points4D);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_projMatr1;
    Ptr<UMat> ptr_projMatr2;
    Ptr<UMat> ptr_projPoints1;
    Ptr<UMat> ptr_projPoints2;
    Ptr<UMat> ptr_points4D;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projMatr1"), ptr_projMatr1, ArgInfo("projMatr1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projMatr2"), ptr_projMatr2, ArgInfo("projMatr2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projPoints1"), ptr_projPoints1, ArgInfo("projPoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "projPoints2"), ptr_projPoints2, ArgInfo("projPoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points4D"), ptr_points4D, ArgInfo("points4D", 1, 0)) )
    {
        error_flag = false;
            UMat projMatr1; if (ptr_projMatr1.get()) { projMatr1 = *ptr_projMatr1.get(); }
        UMat projMatr2; if (ptr_projMatr2.get()) { projMatr2 = *ptr_projMatr2.get(); }
        UMat projPoints1; if (ptr_projPoints1.get()) { projPoints1 = *ptr_projPoints1.get(); }
        UMat projPoints2; if (ptr_projPoints2.get()) { projPoints2 = *ptr_projPoints2.get(); }
        UMat points4D; if (ptr_points4D.get()) { points4D = *ptr_points4D.get(); }
    
        ERRWRAP2(cv::triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, points4D), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points4D);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_undistort(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat newCameraMatrix;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newCameraMatrix"), newCameraMatrix, ArgInfo("newCameraMatrix", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::undistort(src, dst, cameraMatrix, distCoeffs, newCameraMatrix), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_newCameraMatrix;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newCameraMatrix"), ptr_newCameraMatrix, ArgInfo("newCameraMatrix", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat newCameraMatrix; if (ptr_newCameraMatrix.get()) { newCameraMatrix = *ptr_newCameraMatrix.get(); }
    
        ERRWRAP2(cv::undistort(src, dst, cameraMatrix, distCoeffs, newCameraMatrix), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_undistortImagePoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat cameraMatrix;
    Mat distCoeffs;
    TermCriteria arg1=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::undistortImagePoints(src, dst, cameraMatrix, distCoeffs, arg1), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    TermCriteria arg1=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arg1"), arg1, ArgInfo("arg1", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
    
        ERRWRAP2(cv::undistortImagePoints(src, dst, cameraMatrix, distCoeffs, arg1), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_undistortPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat R;
    Mat P;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_P;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), ptr_P, ArgInfo("P", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat P; if (ptr_P.get()) { P = *ptr_P.get(); }
    
        ERRWRAP2(cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_undistortPointsIter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat R;
    Mat P;
    TermCriteria criteria;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_cameraMatrix;
    Ptr<UMat> ptr_distCoeffs;
    Ptr<UMat> ptr_R;
    Ptr<UMat> ptr_P;
    TermCriteria criteria;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), ptr_cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), ptr_distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), ptr_R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), ptr_P, ArgInfo("P", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat cameraMatrix; if (ptr_cameraMatrix.get()) { cameraMatrix = *ptr_cameraMatrix.get(); }
        UMat distCoeffs; if (ptr_distCoeffs.get()) { distCoeffs = *ptr_distCoeffs.get(); }
        UMat R; if (ptr_R.get()) { R = *ptr_R.get(); }
        UMat P; if (ptr_P.get()) { P = *ptr_P.get(); }
    
        ERRWRAP2(cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_useOpenVX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::useOpenVX(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_useOptimized(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::useOptimized(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_validateDisparity(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat disparity;
    Mat cost;
    int minDisparity;
    int numberOfDisparities;
    int disp12MaxDisp=1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cost"), cost, ArgInfo("cost", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberOfDisparities"), numberOfDisparities, ArgInfo("numberOfDisparities", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDisp"), disp12MaxDisp, ArgInfo("disp12MaxDisp", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::validateDisparity(disparity, cost, minDisparity, numberOfDisparities, disp12MaxDisp), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_disparity;
    Ptr<UMat> ptr_cost;
    int minDisparity;
    int numberOfDisparities;
    int disp12MaxDisp=1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), ptr_disparity, ArgInfo("disparity", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cost"), ptr_cost, ArgInfo("cost", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDisparity"), minDisparity, ArgInfo("minDisparity", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numberOfDisparities"), numberOfDisparities, ArgInfo("numberOfDisparities", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disp12MaxDisp"), disp12MaxDisp, ArgInfo("disp12MaxDisp", 0, 1)) )
    {
        error_flag = false;
            UMat disparity; if (ptr_disparity.get()) { disparity = *ptr_disparity.get(); }
        UMat cost; if (ptr_cost.get()) { cost = *ptr_cost.get(); }
    
        ERRWRAP2(cv::validateDisparity(disparity, cost, minDisparity, numberOfDisparities, disp12MaxDisp), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, disparity);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_vconcat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat src;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::vconcat(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    vector_UMat src;
    Ptr<UMat> ptr_dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
            UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::vconcat(src, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_waitKeyEx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int delay=0;
    int retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "delay"), delay, ArgInfo("delay", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::waitKeyEx(delay), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_warpAffine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat M;
    Size dsize;
    int flags=INTER_LINEAR;
    int borderMode=BORDER_CONSTANT;
    Scalar borderValue;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_M;
    Size dsize;
    int flags=INTER_LINEAR;
    int borderMode=BORDER_CONSTANT;
    Scalar borderValue;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat M; if (ptr_M.get()) { M = *ptr_M.get(); }
    
        ERRWRAP2(cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_warpPerspective(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Mat M;
    Size dsize;
    int flags=INTER_LINEAR;
    int borderMode=BORDER_CONSTANT;
    Scalar borderValue;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Ptr<UMat> ptr_M;
    Size dsize;
    int flags=INTER_LINEAR;
    int borderMode=BORDER_CONSTANT;
    Scalar borderValue;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), ptr_M, ArgInfo("M", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderValue"), borderValue, ArgInfo("borderValue", 0, 1)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        UMat M; if (ptr_M.get()) { M = *ptr_M.get(); }
    
        ERRWRAP2(cv::warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_warpPolar(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Size dsize;
    Point2f center;
    double maxRadius;
    int flags;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxRadius"), maxRadius, ArgInfo("maxRadius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::warpPolar(src, dst, dsize, center, maxRadius, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_src;
    Ptr<UMat> ptr_dst;
    Size dsize;
    Point2f center;
    double maxRadius;
    int flags;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsize"), dsize, ArgInfo("dsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "center"), center, ArgInfo("center", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxRadius"), maxRadius, ArgInfo("maxRadius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
            UMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        UMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
    
        ERRWRAP2(cv::warpPolar(src, dst, dsize, center, maxRadius, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_watershed(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat markers;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markers"), markers, ArgInfo("markers", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::watershed(image, markers), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, markers);
        }
    }

    }
    

    {
    Ptr<UMat> ptr_image;
    Ptr<UMat> ptr_markers;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), ptr_image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markers"), ptr_markers, ArgInfo("markers", 1, 0)) )
    {
        error_flag = false;
            UMat image; if (ptr_image.get()) { image = *ptr_image.get(); }
        UMat markers; if (ptr_markers.get()) { markers = *ptr_markers.get(); }
    
        ERRWRAP2(cv::watershed(image, markers), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, markers);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_writeOpticalFlow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String path;
    Mat flow;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "path"), path, ArgInfo("path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), flow, ArgInfo("flow", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::writeOpticalFlow(path, flow), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String path;
    Ptr<UMat> ptr_flow;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "path"), path, ArgInfo("path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flow"), ptr_flow, ArgInfo("flow", 0, 0)) )
    {
        error_flag = false;
            UMat flow; if (ptr_flow.get()) { flow = *ptr_flow.get(); }
    
        ERRWRAP2(retval = cv::writeOpticalFlow(path, flow), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_Dictionary_getBitsFromByteList(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat byteList;
    int markerSize;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "byteList"), byteList, ArgInfo("byteList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerSize"), markerSize, ArgInfo("markerSize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::Dictionary::getBitsFromByteList(byteList, markerSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_Dictionary_getByteListFromBits(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat bits;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bits"), bits, ArgInfo("bits", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::Dictionary::getByteListFromBits(bits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_calibrateCameraAruco(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat corners;
    Mat ids;
    Mat counter;
    Ptr<Board> board;
    Size imageSize;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "counter"), counter, ArgInfo("counter", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraAruco(corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    vector_UMat corners;
    UMat ids;
    UMat counter;
    Ptr<Board> board;
    Size imageSize;
    UMat cameraMatrix;
    UMat distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "counter"), counter, ArgInfo("counter", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraAruco(corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_calibrateCameraArucoExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat corners;
    Mat ids;
    Mat counter;
    Ptr<Board> board;
    Size imageSize;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    Mat stdDeviationsIntrinsics;
    Mat stdDeviationsExtrinsics;
    Mat perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "counter"), counter, ArgInfo("counter", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraAruco(corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple8(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, stdDeviationsIntrinsics), evision_from(env, stdDeviationsExtrinsics), evision_from(env, perViewErrors));
        }
    }

    }
    

    {
    vector_UMat corners;
    UMat ids;
    UMat counter;
    Ptr<Board> board;
    Size imageSize;
    UMat cameraMatrix;
    UMat distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    UMat stdDeviationsIntrinsics;
    UMat stdDeviationsExtrinsics;
    UMat perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "counter"), counter, ArgInfo("counter", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraAruco(corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple8(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, stdDeviationsIntrinsics), evision_from(env, stdDeviationsExtrinsics), evision_from(env, perViewErrors));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_calibrateCameraCharuco(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat charucoCorners;
    vector_Mat charucoIds;
    Ptr<CharucoBoard> board;
    Size imageSize;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraCharuco(charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    vector_UMat charucoCorners;
    vector_UMat charucoIds;
    Ptr<CharucoBoard> board;
    Size imageSize;
    UMat cameraMatrix;
    UMat distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraCharuco(charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_calibrateCameraCharucoExtended(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat charucoCorners;
    vector_Mat charucoIds;
    Ptr<CharucoBoard> board;
    Size imageSize;
    Mat cameraMatrix;
    Mat distCoeffs;
    vector_Mat rvecs;
    vector_Mat tvecs;
    Mat stdDeviationsIntrinsics;
    Mat stdDeviationsExtrinsics;
    Mat perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraCharuco(charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple8(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, stdDeviationsIntrinsics), evision_from(env, stdDeviationsExtrinsics), evision_from(env, perViewErrors));
        }
    }

    }
    

    {
    vector_UMat charucoCorners;
    vector_UMat charucoIds;
    Ptr<CharucoBoard> board;
    Size imageSize;
    UMat cameraMatrix;
    UMat distCoeffs;
    vector_UMat rvecs;
    vector_UMat tvecs;
    UMat stdDeviationsIntrinsics;
    UMat stdDeviationsExtrinsics;
    UMat perViewErrors;
    int flags=0;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsIntrinsics"), stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stdDeviationsExtrinsics"), stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "perViewErrors"), perViewErrors, ArgInfo("perViewErrors", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::calibrateCameraCharuco(charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple8(env, evision_from(env, retval), evision_from(env, cameraMatrix), evision_from(env, distCoeffs), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, stdDeviationsIntrinsics), evision_from(env, stdDeviationsExtrinsics), evision_from(env, perViewErrors));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_detectCharucoDiamond(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    vector_Mat markerCorners;
    Mat markerIds;
    float squareMarkerLengthRate;
    vector_Mat diamondCorners;
    Mat diamondIds;
    Mat cameraMatrix;
    Mat distCoeffs;
    Ptr<Dictionary> dictionary=makePtr<Dictionary> (getPredefinedDictionary(PredefinedDictionaryType::DICT_4X4_50));

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerCorners"), markerCorners, ArgInfo("markerCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerIds"), markerIds, ArgInfo("markerIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "squareMarkerLengthRate"), squareMarkerLengthRate, ArgInfo("squareMarkerLengthRate", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondCorners"), diamondCorners, ArgInfo("diamondCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondIds"), diamondIds, ArgInfo("diamondIds", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::detectCharucoDiamond(image, markerCorners, markerIds, squareMarkerLengthRate, diamondCorners, diamondIds, cameraMatrix, distCoeffs, dictionary), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, diamondCorners), evision_from(env, diamondIds));
        }
    }

    }
    

    {
    UMat image;
    vector_UMat markerCorners;
    UMat markerIds;
    float squareMarkerLengthRate;
    vector_UMat diamondCorners;
    UMat diamondIds;
    UMat cameraMatrix;
    UMat distCoeffs;
    Ptr<Dictionary> dictionary=makePtr<Dictionary> (getPredefinedDictionary(PredefinedDictionaryType::DICT_4X4_50));

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerCorners"), markerCorners, ArgInfo("markerCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerIds"), markerIds, ArgInfo("markerIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "squareMarkerLengthRate"), squareMarkerLengthRate, ArgInfo("squareMarkerLengthRate", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondCorners"), diamondCorners, ArgInfo("diamondCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondIds"), diamondIds, ArgInfo("diamondIds", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::detectCharucoDiamond(image, markerCorners, markerIds, squareMarkerLengthRate, diamondCorners, diamondIds, cameraMatrix, distCoeffs, dictionary), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, diamondCorners), evision_from(env, diamondIds));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_detectMarkers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Ptr<Dictionary> dictionary;
    vector_Mat corners;
    Mat ids;
    Ptr<DetectorParameters> parameters=makePtr<DetectorParameters>();
    vector_Mat rejectedImgPoints;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rejectedImgPoints"), rejectedImgPoints, ArgInfo("rejectedImgPoints", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::detectMarkers(image, dictionary, corners, ids, parameters, rejectedImgPoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, corners), evision_from(env, ids), evision_from(env, rejectedImgPoints));
        }
    }

    }
    

    {
    UMat image;
    Ptr<Dictionary> dictionary;
    vector_UMat corners;
    UMat ids;
    Ptr<DetectorParameters> parameters=makePtr<DetectorParameters>();
    vector_UMat rejectedImgPoints;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rejectedImgPoints"), rejectedImgPoints, ArgInfo("rejectedImgPoints", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::detectMarkers(image, dictionary, corners, ids, parameters, rejectedImgPoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, corners), evision_from(env, ids), evision_from(env, rejectedImgPoints));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_drawCharucoDiamond(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<Dictionary> dictionary;
    Vec4i ids;
    int squareLength;
    int markerLength;
    Mat img;
    int marginSize=0;
    int borderBits=1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "squareLength"), squareLength, ArgInfo("squareLength", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerLength"), markerLength, ArgInfo("markerLength", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "marginSize"), marginSize, ArgInfo("marginSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderBits"), borderBits, ArgInfo("borderBits", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawCharucoDiamond(dictionary, ids, squareLength, markerLength, img, marginSize, borderBits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<Dictionary> dictionary;
    Vec4i ids;
    int squareLength;
    int markerLength;
    UMat img;
    int marginSize=0;
    int borderBits=1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "squareLength"), squareLength, ArgInfo("squareLength", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerLength"), markerLength, ArgInfo("markerLength", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "marginSize"), marginSize, ArgInfo("marginSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderBits"), borderBits, ArgInfo("borderBits", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawCharucoDiamond(dictionary, ids, squareLength, markerLength, img, marginSize, borderBits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_drawDetectedCornersCharuco(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat charucoCorners;
    Mat charucoIds;
    Scalar cornerColor=Scalar(255, 0, 0);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cornerColor"), cornerColor, ArgInfo("cornerColor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawDetectedCornersCharuco(image, charucoCorners, charucoIds, cornerColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    UMat image;
    UMat charucoCorners;
    UMat charucoIds;
    Scalar cornerColor=Scalar(255, 0, 0);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cornerColor"), cornerColor, ArgInfo("cornerColor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawDetectedCornersCharuco(image, charucoCorners, charucoIds, cornerColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_drawDetectedDiamonds(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    vector_Mat diamondCorners;
    Mat diamondIds;
    Scalar borderColor=Scalar(0, 0, 255);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondCorners"), diamondCorners, ArgInfo("diamondCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondIds"), diamondIds, ArgInfo("diamondIds", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderColor"), borderColor, ArgInfo("borderColor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawDetectedDiamonds(image, diamondCorners, diamondIds, borderColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    UMat image;
    vector_UMat diamondCorners;
    UMat diamondIds;
    Scalar borderColor=Scalar(0, 0, 255);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondCorners"), diamondCorners, ArgInfo("diamondCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "diamondIds"), diamondIds, ArgInfo("diamondIds", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderColor"), borderColor, ArgInfo("borderColor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawDetectedDiamonds(image, diamondCorners, diamondIds, borderColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_drawDetectedMarkers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    vector_Mat corners;
    Mat ids;
    Scalar borderColor=Scalar(0, 255, 0);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderColor"), borderColor, ArgInfo("borderColor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawDetectedMarkers(image, corners, ids, borderColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    UMat image;
    vector_UMat corners;
    UMat ids;
    Scalar borderColor=Scalar(0, 255, 0);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderColor"), borderColor, ArgInfo("borderColor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawDetectedMarkers(image, corners, ids, borderColor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_drawPlanarBoard(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<Board> board;
    Size outSize;
    Mat img;
    int marginSize;
    int borderBits;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outSize"), outSize, ArgInfo("outSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "marginSize"), marginSize, ArgInfo("marginSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderBits"), borderBits, ArgInfo("borderBits", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawPlanarBoard(board, outSize, img, marginSize, borderBits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Ptr<Board> board;
    Size outSize;
    UMat img;
    int marginSize;
    int borderBits;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outSize"), outSize, ArgInfo("outSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "marginSize"), marginSize, ArgInfo("marginSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderBits"), borderBits, ArgInfo("borderBits", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::drawPlanarBoard(board, outSize, img, marginSize, borderBits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_estimatePoseBoard(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat corners;
    Mat ids;
    Ptr<Board> board;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    bool useExtrinsicGuess=false;
    int retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::estimatePoseBoard(corners, ids, board, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, rvec), evision_from(env, tvec));
        }
    }

    }
    

    {
    vector_UMat corners;
    UMat ids;
    Ptr<Board> board;
    UMat cameraMatrix;
    UMat distCoeffs;
    UMat rvec;
    UMat tvec;
    bool useExtrinsicGuess=false;
    int retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ids"), ids, ArgInfo("ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::estimatePoseBoard(corners, ids, board, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, rvec), evision_from(env, tvec));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_estimatePoseCharucoBoard(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat charucoCorners;
    Mat charucoIds;
    Ptr<CharucoBoard> board;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvec;
    Mat tvec;
    bool useExtrinsicGuess=false;
    bool retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::estimatePoseCharucoBoard(charucoCorners, charucoIds, board, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat charucoCorners;
    UMat charucoIds;
    Ptr<CharucoBoard> board;
    UMat cameraMatrix;
    UMat distCoeffs;
    UMat rvec;
    UMat tvec;
    bool useExtrinsicGuess=false;
    bool retval;

    if( num_kw_args >= 7 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useExtrinsicGuess"), useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::estimatePoseCharucoBoard(charucoCorners, charucoIds, board, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_2_to_10_tuple_except_bool
                return enif_make_tuple2(env, evision_from(env, rvec), evision_from(env, tvec));
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_estimatePoseSingleMarkers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat corners;
    float markerLength;
    Mat cameraMatrix;
    Mat distCoeffs;
    Mat rvecs;
    Mat tvecs;
    Mat objPoints;
    Ptr<EstimateParameters> estimateParameters=makePtr<EstimateParameters>();

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerLength"), markerLength, ArgInfo("markerLength", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objPoints"), objPoints, ArgInfo("objPoints", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "estimateParameters"), estimateParameters, ArgInfo("estimateParameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::estimatePoseSingleMarkers(corners, markerLength, cameraMatrix, distCoeffs, rvecs, tvecs, objPoints, estimateParameters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, objPoints));
        }
    }

    }
    

    {
    vector_UMat corners;
    float markerLength;
    UMat cameraMatrix;
    UMat distCoeffs;
    UMat rvecs;
    UMat tvecs;
    UMat objPoints;
    Ptr<EstimateParameters> estimateParameters=makePtr<EstimateParameters>();

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerLength"), markerLength, ArgInfo("markerLength", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objPoints"), objPoints, ArgInfo("objPoints", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "estimateParameters"), estimateParameters, ArgInfo("estimateParameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::estimatePoseSingleMarkers(corners, markerLength, cameraMatrix, distCoeffs, rvecs, tvecs, objPoints, estimateParameters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, objPoints));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_extendDictionary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nMarkers;
    int markerSize;
    Dictionary baseDictionary;
    int randomSeed=0;
    Dictionary retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nMarkers"), nMarkers, ArgInfo("nMarkers", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerSize"), markerSize, ArgInfo("markerSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "baseDictionary"), baseDictionary, ArgInfo("baseDictionary", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "randomSeed"), randomSeed, ArgInfo("randomSeed", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::extendDictionary(nMarkers, markerSize, baseDictionary, randomSeed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_generateImageMarker(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Dictionary dictionary;
    int id;
    int sidePixels;
    Mat img;
    int borderBits=1;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "id"), id, ArgInfo("id", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sidePixels"), sidePixels, ArgInfo("sidePixels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderBits"), borderBits, ArgInfo("borderBits", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::generateImageMarker(dictionary, id, sidePixels, img, borderBits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    Dictionary dictionary;
    int id;
    int sidePixels;
    UMat img;
    int borderBits=1;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dictionary"), dictionary, ArgInfo("dictionary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "id"), id, ArgInfo("id", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sidePixels"), sidePixels, ArgInfo("sidePixels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderBits"), borderBits, ArgInfo("borderBits", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::generateImageMarker(dictionary, id, sidePixels, img, borderBits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_getBoardObjectAndImagePoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<Board> board;
    vector_Mat detectedCorners;
    Mat detectedIds;
    Mat objPoints;
    Mat imgPoints;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedCorners"), detectedCorners, ArgInfo("detectedCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedIds"), detectedIds, ArgInfo("detectedIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objPoints"), objPoints, ArgInfo("objPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgPoints"), imgPoints, ArgInfo("imgPoints", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::getBoardObjectAndImagePoints(board, detectedCorners, detectedIds, objPoints, imgPoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, objPoints), evision_from(env, imgPoints));
        }
    }

    }
    

    {
    Ptr<Board> board;
    vector_UMat detectedCorners;
    UMat detectedIds;
    UMat objPoints;
    UMat imgPoints;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedCorners"), detectedCorners, ArgInfo("detectedCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedIds"), detectedIds, ArgInfo("detectedIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objPoints"), objPoints, ArgInfo("objPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imgPoints"), imgPoints, ArgInfo("imgPoints", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::getBoardObjectAndImagePoints(board, detectedCorners, detectedIds, objPoints, imgPoints), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, objPoints), evision_from(env, imgPoints));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_getPredefinedDictionary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int dict;
    Dictionary retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dict"), dict, ArgInfo("dict", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::getPredefinedDictionary(dict), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_interpolateCornersCharuco(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat markerCorners;
    Mat markerIds;
    Mat image;
    Ptr<CharucoBoard> board;
    Mat charucoCorners;
    Mat charucoIds;
    Mat cameraMatrix;
    Mat distCoeffs;
    int minMarkers=2;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerCorners"), markerCorners, ArgInfo("markerCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerIds"), markerIds, ArgInfo("markerIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minMarkers"), minMarkers, ArgInfo("minMarkers", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs, minMarkers), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, charucoCorners), evision_from(env, charucoIds));
        }
    }

    }
    

    {
    vector_UMat markerCorners;
    UMat markerIds;
    UMat image;
    Ptr<CharucoBoard> board;
    UMat charucoCorners;
    UMat charucoIds;
    UMat cameraMatrix;
    UMat distCoeffs;
    int minMarkers=2;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerCorners"), markerCorners, ArgInfo("markerCorners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "markerIds"), markerIds, ArgInfo("markerIds", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoCorners"), charucoCorners, ArgInfo("charucoCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minMarkers"), minMarkers, ArgInfo("minMarkers", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs, minMarkers), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, charucoCorners), evision_from(env, charucoIds));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_refineDetectedMarkers(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Ptr<Board> board;
    vector_Mat detectedCorners;
    Mat detectedIds;
    vector_Mat rejectedCorners;
    Mat cameraMatrix;
    Mat distCoeffs;
    float minRepDistance=10.f;
    float errorCorrectionRate=3.f;
    bool checkAllOrders=true;
    Mat recoveredIdxs;
    Ptr<DetectorParameters> parameters=makePtr<DetectorParameters>();

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedCorners"), detectedCorners, ArgInfo("detectedCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedIds"), detectedIds, ArgInfo("detectedIds", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rejectedCorners"), rejectedCorners, ArgInfo("rejectedCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minRepDistance"), minRepDistance, ArgInfo("minRepDistance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "errorCorrectionRate"), errorCorrectionRate, ArgInfo("errorCorrectionRate", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "checkAllOrders"), checkAllOrders, ArgInfo("checkAllOrders", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "recoveredIdxs"), recoveredIdxs, ArgInfo("recoveredIdxs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::refineDetectedMarkers(image, board, detectedCorners, detectedIds, rejectedCorners, cameraMatrix, distCoeffs, minRepDistance, errorCorrectionRate, checkAllOrders, recoveredIdxs, parameters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, detectedCorners), evision_from(env, detectedIds), evision_from(env, rejectedCorners), evision_from(env, recoveredIdxs));
        }
    }

    }
    

    {
    UMat image;
    Ptr<Board> board;
    vector_UMat detectedCorners;
    UMat detectedIds;
    vector_UMat rejectedCorners;
    UMat cameraMatrix;
    UMat distCoeffs;
    float minRepDistance=10.f;
    float errorCorrectionRate=3.f;
    bool checkAllOrders=true;
    UMat recoveredIdxs;
    Ptr<DetectorParameters> parameters=makePtr<DetectorParameters>();

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedCorners"), detectedCorners, ArgInfo("detectedCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "detectedIds"), detectedIds, ArgInfo("detectedIds", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rejectedCorners"), rejectedCorners, ArgInfo("rejectedCorners", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeffs"), distCoeffs, ArgInfo("distCoeffs", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minRepDistance"), minRepDistance, ArgInfo("minRepDistance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "errorCorrectionRate"), errorCorrectionRate, ArgInfo("errorCorrectionRate", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "checkAllOrders"), checkAllOrders, ArgInfo("checkAllOrders", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "recoveredIdxs"), recoveredIdxs, ArgInfo("recoveredIdxs", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::aruco::refineDetectedMarkers(image, board, detectedCorners, detectedIds, rejectedCorners, cameraMatrix, distCoeffs, minRepDistance, errorCorrectionRate, checkAllOrders, recoveredIdxs, parameters), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, detectedCorners), evision_from(env, detectedIds), evision_from(env, rejectedCorners), evision_from(env, recoveredIdxs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_aruco_testCharucoCornersCollinear(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::aruco;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<CharucoBoard> board;
    Mat charucoIds;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::testCharucoCornersCollinear(board, charucoIds), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    Ptr<CharucoBoard> board;
    UMat charucoIds;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "board"), board, ArgInfo("board", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "charucoIds"), charucoIds, ArgInfo("charucoIds", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::aruco::testCharucoCornersCollinear(board, charucoIds), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bgsegm_createBackgroundSubtractorCNT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bgsegm;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int minPixelStability=15;
    bool useHistory=true;
    int maxPixelStability=15*60;
    bool isParallel=true;
    Ptr<BackgroundSubtractorCNT> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minPixelStability"), minPixelStability, ArgInfo("minPixelStability", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useHistory"), useHistory, ArgInfo("useHistory", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPixelStability"), maxPixelStability, ArgInfo("maxPixelStability", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isParallel"), isParallel, ArgInfo("isParallel", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createBackgroundSubtractorCNT(minPixelStability, useHistory, maxPixelStability, isParallel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bgsegm_createBackgroundSubtractorGMG(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bgsegm;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int initializationFrames=120;
    double decisionThreshold=0.8;
    Ptr<BackgroundSubtractorGMG> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "initializationFrames"), initializationFrames, ArgInfo("initializationFrames", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "decisionThreshold"), decisionThreshold, ArgInfo("decisionThreshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createBackgroundSubtractorGMG(initializationFrames, decisionThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bgsegm_createBackgroundSubtractorGSOC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bgsegm;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE;
    int nSamples=20;
    float replaceRate=0.003f;
    float propagationRate=0.01f;
    int hitsThreshold=32;
    float alpha=0.01f;
    float beta=0.0022f;
    float blinkingSupressionDecay=0.1f;
    float blinkingSupressionMultiplier=0.1f;
    float noiseRemovalThresholdFacBG=0.0004f;
    float noiseRemovalThresholdFacFG=0.0008f;
    Ptr<BackgroundSubtractorGSOC> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mc"), mc, ArgInfo("mc", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nSamples"), nSamples, ArgInfo("nSamples", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "replaceRate"), replaceRate, ArgInfo("replaceRate", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "propagationRate"), propagationRate, ArgInfo("propagationRate", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hitsThreshold"), hitsThreshold, ArgInfo("hitsThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blinkingSupressionDecay"), blinkingSupressionDecay, ArgInfo("blinkingSupressionDecay", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blinkingSupressionMultiplier"), blinkingSupressionMultiplier, ArgInfo("blinkingSupressionMultiplier", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "noiseRemovalThresholdFacBG"), noiseRemovalThresholdFacBG, ArgInfo("noiseRemovalThresholdFacBG", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "noiseRemovalThresholdFacFG"), noiseRemovalThresholdFacFG, ArgInfo("noiseRemovalThresholdFacFG", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createBackgroundSubtractorGSOC(mc, nSamples, replaceRate, propagationRate, hitsThreshold, alpha, beta, blinkingSupressionDecay, blinkingSupressionMultiplier, noiseRemovalThresholdFacBG, noiseRemovalThresholdFacFG), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bgsegm_createBackgroundSubtractorLSBP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bgsegm;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE;
    int nSamples=20;
    int LSBPRadius=16;
    float Tlower=2.0f;
    float Tupper=32.0f;
    float Tinc=1.0f;
    float Tdec=0.05f;
    float Rscale=10.0f;
    float Rincdec=0.005f;
    float noiseRemovalThresholdFacBG=0.0004f;
    float noiseRemovalThresholdFacFG=0.0008f;
    int LSBPthreshold=8;
    int minCount=2;
    Ptr<BackgroundSubtractorLSBP> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mc"), mc, ArgInfo("mc", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nSamples"), nSamples, ArgInfo("nSamples", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lSBPRadius"), LSBPRadius, ArgInfo("LSBPRadius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tlower"), Tlower, ArgInfo("Tlower", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tupper"), Tupper, ArgInfo("Tupper", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tinc"), Tinc, ArgInfo("Tinc", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tdec"), Tdec, ArgInfo("Tdec", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rscale"), Rscale, ArgInfo("Rscale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rincdec"), Rincdec, ArgInfo("Rincdec", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "noiseRemovalThresholdFacBG"), noiseRemovalThresholdFacBG, ArgInfo("noiseRemovalThresholdFacBG", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "noiseRemovalThresholdFacFG"), noiseRemovalThresholdFacFG, ArgInfo("noiseRemovalThresholdFacFG", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lSBPthreshold"), LSBPthreshold, ArgInfo("LSBPthreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minCount"), minCount, ArgInfo("minCount", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createBackgroundSubtractorLSBP(mc, nSamples, LSBPRadius, Tlower, Tupper, Tinc, Tdec, Rscale, Rincdec, noiseRemovalThresholdFacBG, noiseRemovalThresholdFacFG, LSBPthreshold, minCount), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bgsegm_createBackgroundSubtractorMOG(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bgsegm;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int history=200;
    int nmixtures=5;
    double backgroundRatio=0.7;
    double noiseSigma=0;
    Ptr<BackgroundSubtractorMOG> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "history"), history, ArgInfo("history", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nmixtures"), nmixtures, ArgInfo("nmixtures", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backgroundRatio"), backgroundRatio, ArgInfo("backgroundRatio", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "noiseSigma"), noiseSigma, ArgInfo("noiseSigma", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createBackgroundSubtractorMOG(history, nmixtures, backgroundRatio, noiseSigma), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bgsegm_createSyntheticSequenceGenerator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bgsegm;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat background;
    Mat object;
    double amplitude=2.0;
    double wavelength=20.0;
    double wavespeed=0.2;
    double objspeed=6.0;
    Ptr<SyntheticSequenceGenerator> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "background"), background, ArgInfo("background", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "object"), object, ArgInfo("object", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "amplitude"), amplitude, ArgInfo("amplitude", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "wavelength"), wavelength, ArgInfo("wavelength", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "wavespeed"), wavespeed, ArgInfo("wavespeed", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objspeed"), objspeed, ArgInfo("objspeed", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createSyntheticSequenceGenerator(background, object, amplitude, wavelength, wavespeed, objspeed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat background;
    UMat object;
    double amplitude=2.0;
    double wavelength=20.0;
    double wavespeed=0.2;
    double objspeed=6.0;
    Ptr<SyntheticSequenceGenerator> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "background"), background, ArgInfo("background", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "object"), object, ArgInfo("object", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "amplitude"), amplitude, ArgInfo("amplitude", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "wavelength"), wavelength, ArgInfo("wavelength", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "wavespeed"), wavespeed, ArgInfo("wavespeed", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objspeed"), objspeed, ArgInfo("objspeed", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bgsegm::createSyntheticSequenceGenerator(background, object, amplitude, wavelength, wavespeed, objspeed), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bioinspired_RetinaFastToneMapping_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bioinspired;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Size inputSize;
    Ptr<RetinaFastToneMapping> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputSize"), inputSize, ArgInfo("inputSize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bioinspired::RetinaFastToneMapping::create(inputSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bioinspired_Retina_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bioinspired;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Size inputSize;
    bool colorMode;
    int colorSamplingMethod=RETINA_COLOR_BAYER;
    bool useRetinaLogSampling=false;
    float reductionFactor=1.0f;
    float samplingStrength=10.0f;
    Ptr<Retina> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputSize"), inputSize, ArgInfo("inputSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colorMode"), colorMode, ArgInfo("colorMode", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colorSamplingMethod"), colorSamplingMethod, ArgInfo("colorSamplingMethod", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "useRetinaLogSampling"), useRetinaLogSampling, ArgInfo("useRetinaLogSampling", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reductionFactor"), reductionFactor, ArgInfo("reductionFactor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "samplingStrength"), samplingStrength, ArgInfo("samplingStrength", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bioinspired::Retina::create(inputSize, colorMode, colorSamplingMethod, useRetinaLogSampling, reductionFactor, samplingStrength), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Size inputSize;
    Ptr<Retina> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputSize"), inputSize, ArgInfo("inputSize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bioinspired::Retina::create(inputSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_bioinspired_TransientAreasSegmentationModule_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::bioinspired;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Size inputSize;
    Ptr<TransientAreasSegmentationModule> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputSize"), inputSize, ArgInfo("inputSize", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::bioinspired::TransientAreasSegmentationModule::create(inputSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_colored_kinfu_ColoredKinFu_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::colored_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> _params;
    Ptr<ColoredKinFu> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), _params, ArgInfo("_params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::colored_kinfu::ColoredKinFu::create(_params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_colored_kinfu_Params_coarseParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::colored_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::colored_kinfu::Params::coarseParams(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_colored_kinfu_Params_coloredTSDFParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::colored_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool isCoarse;
    Ptr<Params> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isCoarse"), isCoarse, ArgInfo("isCoarse", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::colored_kinfu::Params::coloredTSDFParams(isCoarse), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_colored_kinfu_Params_defaultParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::colored_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::colored_kinfu::Params::defaultParams(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_colored_kinfu_Params_hashTSDFParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::colored_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool isCoarse;
    Ptr<Params> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isCoarse"), isCoarse, ArgInfo("isCoarse", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::colored_kinfu::Params::hashTSDFParams(isCoarse), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_Event_elapsedTime(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Event> ptr_start;
    Ptr<Event> ptr_end_;
    float retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "start"), ptr_start, ArgInfo("start", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "end_"), ptr_end_, ArgInfo("end_", 0, 0)) )
    {
        error_flag = false;
            Event start; if (ptr_start.get()) { start = *ptr_start.get(); }
        Event end_; if (ptr_end_.get()) { end_ = *ptr_end_.get(); }
    
        ERRWRAP2(retval = cv::cuda::Event::elapsedTime(start, end_), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_GpuMat_defaultAllocator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    GpuMat::Allocator* retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::GpuMat::defaultAllocator(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_GpuMat_setDefaultAllocator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    GpuMat_Allocator* allocator;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "allocator"), allocator, ArgInfo("allocator", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::GpuMat::setDefaultAllocator(allocator), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_SURF_CUDA_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double _hessianThreshold;
    int _nOctaves=4;
    int _nOctaveLayers=2;
    bool _extended=false;
    float _keypointsRatio=0.01f;
    bool _upright=false;
    Ptr<SURF_CUDA> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hessianThreshold"), _hessianThreshold, ArgInfo("_hessianThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), _nOctaves, ArgInfo("_nOctaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), _nOctaveLayers, ArgInfo("_nOctaveLayers", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "extended"), _extended, ArgInfo("_extended", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypointsRatio"), _keypointsRatio, ArgInfo("_keypointsRatio", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upright"), _upright, ArgInfo("_upright", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::SURF_CUDA::create(_hessianThreshold, _nOctaves, _nOctaveLayers, _extended, _keypointsRatio, _upright), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_Stream_Null(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Stream retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::Stream::Null(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_has(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::has(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_hasBin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasBin(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_hasEqualOrGreater(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreater(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_hasEqualOrGreaterBin(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreaterBin(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_hasEqualOrGreaterPtx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrGreaterPtx(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_hasEqualOrLessPtx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasEqualOrLessPtx(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_TargetArchs_hasPtx(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int major;
    int minor;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "major"), major, ArgInfo("major", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minor"), minor, ArgInfo("minor", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::TargetArchs::hasPtx(major, minor), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_createContinuous(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int rows;
    int cols;
    int type;
    Ptr<cuda::GpuMat> ptr_arr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), ptr_arr, ArgInfo("arr", 1, 0)) )
    {
        error_flag = false;
            cuda::GpuMat arr; if (ptr_arr.get()) { arr = *ptr_arr.get(); }
    
        ERRWRAP2(cv::cuda::createContinuous(rows, cols, type, arr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arr);
        }
    }

    }
    

    {
    int rows;
    int cols;
    int type;
    Mat arr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::createContinuous(rows, cols, type, arr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arr);
        }
    }

    }
    

    {
    int rows;
    int cols;
    int type;
    UMat arr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::createContinuous(rows, cols, type, arr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_createGpuMatFromCudaMemory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int rows;
    int cols;
    int type;
    size_t cudaMemoryAddress;
    size_t step=Mat::AUTO_STEP;
    GpuMat retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cudaMemoryAddress"), cudaMemoryAddress, ArgInfo("cudaMemoryAddress", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "step"), step, ArgInfo("step", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::createGpuMatFromCudaMemory(rows, cols, type, cudaMemoryAddress, step), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Size size;
    int type;
    size_t cudaMemoryAddress;
    size_t step=Mat::AUTO_STEP;
    GpuMat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cudaMemoryAddress"), cudaMemoryAddress, ArgInfo("cudaMemoryAddress", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "step"), step, ArgInfo("step", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::createGpuMatFromCudaMemory(size, type, cudaMemoryAddress, step), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_ensureSizeIsEnough(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int rows;
    int cols;
    int type;
    Ptr<cuda::GpuMat> ptr_arr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), ptr_arr, ArgInfo("arr", 1, 0)) )
    {
        error_flag = false;
            cuda::GpuMat arr; if (ptr_arr.get()) { arr = *ptr_arr.get(); }
    
        ERRWRAP2(cv::cuda::ensureSizeIsEnough(rows, cols, type, arr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arr);
        }
    }

    }
    

    {
    int rows;
    int cols;
    int type;
    Mat arr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::ensureSizeIsEnough(rows, cols, type, arr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arr);
        }
    }

    }
    

    {
    int rows;
    int cols;
    int type;
    UMat arr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "arr"), arr, ArgInfo("arr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::ensureSizeIsEnough(rows, cols, type, arr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, arr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_fastNlMeansDenoising(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<GpuMat> ptr_src;
    Ptr<GpuMat> ptr_dst;
    float h;
    int search_window=21;
    int block_size=7;
    Ptr<Stream> ptr_stream;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "search_window"), search_window, ArgInfo("search_window", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "block_size"), block_size, ArgInfo("block_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), ptr_stream, ArgInfo("stream", 0, 1)) )
    {
        error_flag = false;
            GpuMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        GpuMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        Stream stream; if (ptr_stream.get()) { stream = *ptr_stream.get(); } else { stream = Stream::Null(); }
    
        ERRWRAP2(cv::cuda::fastNlMeansDenoising(src, dst, h, search_window, block_size, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_fastNlMeansDenoisingColored(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<GpuMat> ptr_src;
    Ptr<GpuMat> ptr_dst;
    float h_luminance;
    float photo_render;
    int search_window=21;
    int block_size=7;
    Ptr<Stream> ptr_stream;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h_luminance"), h_luminance, ArgInfo("h_luminance", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "photo_render"), photo_render, ArgInfo("photo_render", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "search_window"), search_window, ArgInfo("search_window", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "block_size"), block_size, ArgInfo("block_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), ptr_stream, ArgInfo("stream", 0, 1)) )
    {
        error_flag = false;
            GpuMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        GpuMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        Stream stream; if (ptr_stream.get()) { stream = *ptr_stream.get(); } else { stream = Stream::Null(); }
    
        ERRWRAP2(cv::cuda::fastNlMeansDenoisingColored(src, dst, h_luminance, photo_render, search_window, block_size, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_getCudaEnabledDeviceCount(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::getCudaEnabledDeviceCount(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_getDevice(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::getDevice(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_nonLocalMeans(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<GpuMat> ptr_src;
    Ptr<GpuMat> ptr_dst;
    float h;
    int search_window=21;
    int block_size=7;
    int borderMode=BORDER_DEFAULT;
    Ptr<Stream> ptr_stream;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), ptr_src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), ptr_dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "search_window"), search_window, ArgInfo("search_window", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "block_size"), block_size, ArgInfo("block_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderMode"), borderMode, ArgInfo("borderMode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stream"), ptr_stream, ArgInfo("stream", 0, 1)) )
    {
        error_flag = false;
            GpuMat src; if (ptr_src.get()) { src = *ptr_src.get(); }
        GpuMat dst; if (ptr_dst.get()) { dst = *ptr_dst.get(); }
        Stream stream; if (ptr_stream.get()) { stream = *ptr_stream.get(); } else { stream = Stream::Null(); }
    
        ERRWRAP2(cv::cuda::nonLocalMeans(src, dst, h, search_window, block_size, borderMode, stream), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_printCudaDeviceInfo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int device;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "device"), device, ArgInfo("device", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::printCudaDeviceInfo(device), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_printShortCudaDeviceInfo(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int device;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "device"), device, ArgInfo("device", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::printShortCudaDeviceInfo(device), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_registerPageLocked(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat m;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::registerPageLocked(m), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_resetDevice(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::resetDevice(), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_setBufferPoolConfig(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int deviceId;
    size_t stackSize;
    int stackCount;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "deviceId"), deviceId, ArgInfo("deviceId", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stackSize"), stackSize, ArgInfo("stackSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "stackCount"), stackCount, ArgInfo("stackCount", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::setBufferPoolConfig(deviceId, stackSize, stackCount), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_setBufferPoolUsage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool on;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "on"), on, ArgInfo("on", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::setBufferPoolUsage(on), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_setDevice(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int device;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "device"), device, ArgInfo("device", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::setDevice(device), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_unregisterPageLocked(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat m;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m"), m, ArgInfo("m", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::cuda::unregisterPageLocked(m), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_cuda_wrapStream(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::cuda;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    size_t cudaStreamMemoryAddress;
    Stream retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cudaStreamMemoryAddress"), cudaStreamMemoryAddress, ArgInfo("cudaStreamMemoryAddress", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::cuda::wrapStream(cudaStreamMemoryAddress), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_BestOf2NearestMatcher_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool try_use_gpu=false;
    float match_conf=0.3f;
    int num_matches_thresh1=6;
    int num_matches_thresh2=6;
    double matches_confindece_thresh=3.;
    Ptr<BestOf2NearestMatcher> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "try_use_gpu"), try_use_gpu, ArgInfo("try_use_gpu", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "match_conf"), match_conf, ArgInfo("match_conf", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh1"), num_matches_thresh1, ArgInfo("num_matches_thresh1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_matches_thresh2"), num_matches_thresh2, ArgInfo("num_matches_thresh2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches_confindece_thresh"), matches_confindece_thresh, ArgInfo("matches_confindece_thresh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::BestOf2NearestMatcher::create(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh2, matches_confindece_thresh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_Blender_createDefault(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int type;
    bool try_gpu=false;
    Ptr<Blender> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "try_gpu"), try_gpu, ArgInfo("try_gpu", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::Blender::createDefault(type, try_gpu), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_ExposureCompensator_createDefault(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int type;
    Ptr<ExposureCompensator> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::ExposureCompensator::createDefault(type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_SeamFinder_createDefault(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int type;
    Ptr<SeamFinder> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::SeamFinder::createDefault(type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_Timelapser_createDefault(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int type;
    Ptr<Timelapser> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::Timelapser::createDefault(type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_calibrateRotatingCamera(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Mat Hs;
    Mat K;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "hs"), Hs, ArgInfo("Hs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::calibrateRotatingCamera(Hs, K), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, K);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_computeImageFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<Feature2D> featuresFinder;
    vector_Mat images;
    vector_ImageFeatures features;
    vector_Mat masks;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "featuresFinder"), featuresFinder, ArgInfo("featuresFinder", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::computeImageFeatures(featuresFinder, images, features, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, features);
        }
    }

    }
    

    {
    Ptr<Feature2D> featuresFinder;
    vector_UMat images;
    vector_ImageFeatures features;
    vector_UMat masks;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "featuresFinder"), featuresFinder, ArgInfo("featuresFinder", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "masks"), masks, ArgInfo("masks", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::computeImageFeatures(featuresFinder, images, features, masks), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, features);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_computeImageFeatures2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<Feature2D> featuresFinder;
    Mat image;
    ImageFeatures features;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "featuresFinder"), featuresFinder, ArgInfo("featuresFinder", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::computeImageFeatures(featuresFinder, image, features, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, features);
        }
    }

    }
    

    {
    Ptr<Feature2D> featuresFinder;
    UMat image;
    ImageFeatures features;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "featuresFinder"), featuresFinder, ArgInfo("featuresFinder", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::computeImageFeatures(featuresFinder, image, features, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, features);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_createLaplacePyr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    UMat img;
    int num_levels;
    vector_UMat pyr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_levels"), num_levels, ArgInfo("num_levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr"), pyr, ArgInfo("pyr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::createLaplacePyr(img, num_levels, pyr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pyr);
        }
    }

    }
    

    {
    Mat img;
    int num_levels;
    vector_UMat pyr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_levels"), num_levels, ArgInfo("num_levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr"), pyr, ArgInfo("pyr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::createLaplacePyr(img, num_levels, pyr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pyr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_createLaplacePyrGpu(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    UMat img;
    int num_levels;
    vector_UMat pyr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_levels"), num_levels, ArgInfo("num_levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr"), pyr, ArgInfo("pyr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::createLaplacePyrGpu(img, num_levels, pyr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pyr);
        }
    }

    }
    

    {
    Mat img;
    int num_levels;
    vector_UMat pyr;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_levels"), num_levels, ArgInfo("num_levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr"), pyr, ArgInfo("pyr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::createLaplacePyrGpu(img, num_levels, pyr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pyr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_createWeightMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat mask;
    float sharpness;
    Mat weight;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sharpness"), sharpness, ArgInfo("sharpness", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight"), weight, ArgInfo("weight", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::createWeightMap(mask, sharpness, weight), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, weight);
        }
    }

    }
    

    {
    UMat mask;
    float sharpness;
    UMat weight;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sharpness"), sharpness, ArgInfo("sharpness", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight"), weight, ArgInfo("weight", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::createWeightMap(mask, sharpness, weight), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, weight);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_focalsFromHomography(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat H;
    double f0;
    double f1;
    bool f0_ok;
    bool f1_ok;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), H, ArgInfo("H", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f0"), f0, ArgInfo("f0", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f1"), f1, ArgInfo("f1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f0_ok"), f0_ok, ArgInfo("f0_ok", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "f1_ok"), f1_ok, ArgInfo("f1_ok", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::focalsFromHomography(H, f0, f1, f0_ok, f1_ok), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_leaveBiggestComponent(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_ImageFeatures features;
    vector_MatchesInfo pairwise_matches;
    float conf_threshold;
    std::vector<int> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pairwise_matches"), pairwise_matches, ArgInfo("pairwise_matches", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "conf_threshold"), conf_threshold, ArgInfo("conf_threshold", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::leaveBiggestComponent(features, pairwise_matches, conf_threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_matchesGraphAsString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_String paths;
    vector_MatchesInfo pairwise_matches;
    float conf_threshold;
    String retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "paths"), paths, ArgInfo("paths", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pairwise_matches"), pairwise_matches, ArgInfo("pairwise_matches", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "conf_threshold"), conf_threshold, ArgInfo("conf_threshold", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::matchesGraphAsString(paths, pairwise_matches, conf_threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_normalizeUsingWeightMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat weight;
    Mat src;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight"), weight, ArgInfo("weight", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::normalizeUsingWeightMap(weight, src), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, src);
        }
    }

    }
    

    {
    UMat weight;
    UMat src;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weight"), weight, ArgInfo("weight", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::normalizeUsingWeightMap(weight, src), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, src);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_overlapRoi(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Point tl1;
    Point tl2;
    Size sz1;
    Size sz2;
    Rect roi;
    bool retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl1"), tl1, ArgInfo("tl1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl2"), tl2, ArgInfo("tl2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sz1"), sz1, ArgInfo("sz1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sz2"), sz2, ArgInfo("sz2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "roi"), roi, ArgInfo("roi", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::overlapRoi(tl1, tl2, sz1, sz2, roi), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_restoreImageFromLaplacePyr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_UMat pyr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr"), pyr, ArgInfo("pyr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::restoreImageFromLaplacePyr(pyr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pyr);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_restoreImageFromLaplacePyrGpu(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_UMat pyr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pyr"), pyr, ArgInfo("pyr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::restoreImageFromLaplacePyrGpu(pyr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, pyr);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_resultRoi(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Point corners;
    vector_Size sizes;
    Rect retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sizes"), sizes, ArgInfo("sizes", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::resultRoi(corners, sizes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_Point corners;
    vector_UMat images;
    Rect retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::resultRoi(corners, images), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_resultRoiIntersection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Point corners;
    vector_Size sizes;
    Rect retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sizes"), sizes, ArgInfo("sizes", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::resultRoiIntersection(corners, sizes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_resultTl(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Point corners;
    Point retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corners"), corners, ArgInfo("corners", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::resultTl(corners), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_selectRandomSubset(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int count;
    int size;
    vector_int subset;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "count"), count, ArgInfo("count", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "subset"), subset, ArgInfo("subset", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::selectRandomSubset(count, size, subset), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_stitchingLogLevel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::detail::stitchingLogLevel(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_detail_waveCorrect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::detail;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Mat rmats;
    std::underlying_type_t<WaveCorrectKind> kind=static_cast<std::underlying_type_t<WaveCorrectKind>>(static_cast<WaveCorrectKind>(0));

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rmats"), rmats, ArgInfo("rmats", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kind"), kind, ArgInfo("kind", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::detail::waveCorrect(rmats, static_cast<WaveCorrectKind>(kind)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, rmats);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_NMSBoxes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Rect2d bboxes;
    vector_float scores;
    float score_threshold;
    float nms_threshold;
    vector_int indices;
    float eta=1.f;
    int top_k=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bboxes"), bboxes, ArgInfo("bboxes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scores"), scores, ArgInfo("scores", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eta"), eta, ArgInfo("eta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::NMSBoxes(bboxes, scores, score_threshold, nms_threshold, indices, eta, top_k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, indices);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_NMSBoxesBatched(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Rect2d bboxes;
    vector_float scores;
    vector_int class_ids;
    float score_threshold;
    float nms_threshold;
    vector_int indices;
    float eta=1.f;
    int top_k=0;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bboxes"), bboxes, ArgInfo("bboxes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scores"), scores, ArgInfo("scores", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "class_ids"), class_ids, ArgInfo("class_ids", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eta"), eta, ArgInfo("eta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::NMSBoxesBatched(bboxes, scores, class_ids, score_threshold, nms_threshold, indices, eta, top_k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, indices);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_NMSBoxesRotated(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_RotatedRect bboxes;
    vector_float scores;
    float score_threshold;
    float nms_threshold;
    vector_int indices;
    float eta=1.f;
    int top_k=0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bboxes"), bboxes, ArgInfo("bboxes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scores"), scores, ArgInfo("scores", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eta"), eta, ArgInfo("eta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::NMSBoxes(bboxes, scores, score_threshold, nms_threshold, indices, eta, top_k), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, indices);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_Net_readFromModelOptimizer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar bufferModelConfig;
    vector_uchar bufferWeights;
    Net retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModelConfig"), bufferModelConfig, ArgInfo("bufferModelConfig", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferWeights"), bufferWeights, ArgInfo("bufferWeights", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::Net::readFromModelOptimizer(bufferModelConfig, bufferWeights), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String xml;
    String bin;
    Net retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xml"), xml, ArgInfo("xml", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bin"), bin, ArgInfo("bin", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::Net::readFromModelOptimizer(xml, bin), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_blobFromImage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    double scalefactor=1.0;
    Size size;
    Scalar mean;
    bool swapRB=false;
    bool crop=false;
    int ddepth=CV_32F;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scalefactor"), scalefactor, ArgInfo("scalefactor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "swapRB"), swapRB, ArgInfo("swapRB", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImage(image, scalefactor, size, mean, swapRB, crop, ddepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat image;
    double scalefactor=1.0;
    Size size;
    Scalar mean;
    bool swapRB=false;
    bool crop=false;
    int ddepth=CV_32F;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scalefactor"), scalefactor, ArgInfo("scalefactor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "swapRB"), swapRB, ArgInfo("swapRB", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImage(image, scalefactor, size, mean, swapRB, crop, ddepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_blobFromImageWithParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat blob;
    Image2BlobParams param;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::blobFromImageWithParams(image, blob, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, blob);
        }
    }

    }
    

    {
    UMat image;
    UMat blob;
    Image2BlobParams param;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::blobFromImageWithParams(image, blob, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, blob);
        }
    }

    }
    

    {
    Mat image;
    Image2BlobParams param;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImageWithParams(image, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat image;
    Image2BlobParams param;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImageWithParams(image, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_blobFromImages(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat images;
    double scalefactor=1.0;
    Size size;
    Scalar mean;
    bool swapRB=false;
    bool crop=false;
    int ddepth=CV_32F;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scalefactor"), scalefactor, ArgInfo("scalefactor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "swapRB"), swapRB, ArgInfo("swapRB", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImages(images, scalefactor, size, mean, swapRB, crop, ddepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_UMat images;
    double scalefactor=1.0;
    Size size;
    Scalar mean;
    bool swapRB=false;
    bool crop=false;
    int ddepth=CV_32F;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scalefactor"), scalefactor, ArgInfo("scalefactor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mean"), mean, ArgInfo("mean", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "swapRB"), swapRB, ArgInfo("swapRB", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImages(images, scalefactor, size, mean, swapRB, crop, ddepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_blobFromImagesWithParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat images;
    Mat blob;
    Image2BlobParams param;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::blobFromImagesWithParams(images, blob, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, blob);
        }
    }

    }
    

    {
    vector_UMat images;
    UMat blob;
    Image2BlobParams param;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob"), blob, ArgInfo("blob", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::blobFromImagesWithParams(images, blob, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, blob);
        }
    }

    }
    

    {
    vector_Mat images;
    Image2BlobParams param;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImagesWithParams(images, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_UMat images;
    Image2BlobParams param;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param"), param, ArgInfo("param", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::blobFromImagesWithParams(images, param), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_getAvailableTargets(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<dnn_Backend> be=static_cast<std::underlying_type_t<dnn_Backend>>(static_cast<dnn_Backend>(0));
    std::vector<Target> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "be"), be, ArgInfo("be", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::getAvailableTargets(static_cast<dnn_Backend>(be)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_imagesFromBlob(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat blob_;
    vector_Mat images_;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob_"), blob_, ArgInfo("blob_", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images_"), images_, ArgInfo("images_", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::imagesFromBlob(blob_, images_), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, images_);
        }
    }

    }
    

    {
    Mat blob_;
    vector_UMat images_;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blob_"), blob_, ArgInfo("blob_", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images_"), images_, ArgInfo("images_", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::imagesFromBlob(blob_, images_), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, images_);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNet(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String framework;
    vector_uchar bufferModel;
    vector_uchar bufferConfig=std::vector<uchar>();
    Net retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "framework"), framework, ArgInfo("framework", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModel"), bufferModel, ArgInfo("bufferModel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferConfig"), bufferConfig, ArgInfo("bufferConfig", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNet(framework, bufferModel, bufferConfig), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String model;
    String config="";
    String framework="";
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "framework"), framework, ArgInfo("framework", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNet(model, config, framework), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromCaffe(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar bufferProto;
    vector_uchar bufferModel=std::vector<uchar>();
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferProto"), bufferProto, ArgInfo("bufferProto", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModel"), bufferModel, ArgInfo("bufferModel", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromCaffe(bufferProto, bufferModel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String prototxt;
    String caffeModel;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prototxt"), prototxt, ArgInfo("prototxt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "caffeModel"), caffeModel, ArgInfo("caffeModel", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromCaffe(prototxt, caffeModel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromDarknet(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar bufferCfg;
    vector_uchar bufferModel=std::vector<uchar>();
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferCfg"), bufferCfg, ArgInfo("bufferCfg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModel"), bufferModel, ArgInfo("bufferModel", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromDarknet(bufferCfg, bufferModel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String cfgFile;
    String darknetModel;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cfgFile"), cfgFile, ArgInfo("cfgFile", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "darknetModel"), darknetModel, ArgInfo("darknetModel", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromDarknet(cfgFile, darknetModel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromModelOptimizer(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar bufferModelConfig;
    vector_uchar bufferWeights;
    Net retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModelConfig"), bufferModelConfig, ArgInfo("bufferModelConfig", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferWeights"), bufferWeights, ArgInfo("bufferWeights", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromModelOptimizer(bufferModelConfig, bufferWeights), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String xml;
    String bin;
    Net retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xml"), xml, ArgInfo("xml", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bin"), bin, ArgInfo("bin", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromModelOptimizer(xml, bin), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromONNX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar buffer;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "buffer"), buffer, ArgInfo("buffer", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromONNX(buffer), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String onnxFile;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "onnxFile"), onnxFile, ArgInfo("onnxFile", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromONNX(onnxFile), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromTFLite(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar bufferModel;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModel"), bufferModel, ArgInfo("bufferModel", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromTFLite(bufferModel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String model;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromTFLite(model), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromTensorflow(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_uchar bufferModel;
    vector_uchar bufferConfig=std::vector<uchar>();
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferModel"), bufferModel, ArgInfo("bufferModel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bufferConfig"), bufferConfig, ArgInfo("bufferConfig", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromTensorflow(bufferModel, bufferConfig), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String model;
    String config;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "config"), config, ArgInfo("config", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromTensorflow(model, config), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readNetFromTorch(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String model;
    bool isBinary=true;
    bool evaluate=true;
    Net retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isBinary"), isBinary, ArgInfo("isBinary", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "evaluate"), evaluate, ArgInfo("evaluate", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readNetFromTorch(model, isBinary, evaluate), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readTensorFromONNX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String path;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "path"), path, ArgInfo("path", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readTensorFromONNX(path), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_readTorchBlob(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    bool isBinary=true;
    Mat retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isBinary"), isBinary, ArgInfo("isBinary", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn::readTorchBlob(filename, isBinary), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_shrinkCaffeModel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String src;
    String dst;
    vector_String layersTypes=std::vector<String>();

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layersTypes"), layersTypes, ArgInfo("layersTypes", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::shrinkCaffeModel(src, dst, layersTypes), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_softNMSBoxes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Rect bboxes;
    vector_float scores;
    vector_float updated_scores;
    float score_threshold;
    float nms_threshold;
    vector_int indices;
    size_t top_k=0;
    float sigma=0.5;
    std::underlying_type_t<SoftNMSMethod> method=static_cast<std::underlying_type_t<SoftNMSMethod>>(SoftNMSMethod::SOFTNMS_GAUSSIAN);

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bboxes"), bboxes, ArgInfo("bboxes", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scores"), scores, ArgInfo("scores", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "score_threshold"), score_threshold, ArgInfo("score_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nms_threshold"), nms_threshold, ArgInfo("nms_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "top_k"), top_k, ArgInfo("top_k", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::softNMSBoxes(bboxes, scores, updated_scores, score_threshold, nms_threshold, indices, top_k, sigma, static_cast<SoftNMSMethod>(method)), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, updated_scores), evision_from(env, indices));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_writeTextGraph(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String model;
    String output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::dnn::writeTextGraph(model, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dnn_superres_DnnSuperResImpl_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dnn_superres;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<DnnSuperResImpl> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dnn_superres::DnnSuperResImpl::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_dynafu_DynaFu_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::dynafu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<kinfu::Params> _params;
    Ptr<DynaFu> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), _params, ArgInfo("_params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::dynafu::DynaFu::create(_params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_BIF_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int num_bands=8;
    int num_rotations=12;
    Ptr<BIF> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "num_bands"), num_bands, ArgInfo("num_bands", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_rotations"), num_rotations, ArgInfo("num_rotations", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::BIF::create(num_bands, num_rotations), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_EigenFaceRecognizer_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int num_components=0;
    double threshold=DBL_MAX;
    Ptr<EigenFaceRecognizer> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "num_components"), num_components, ArgInfo("num_components", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::EigenFaceRecognizer::create(num_components, threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_FisherFaceRecognizer_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int num_components=0;
    double threshold=DBL_MAX;
    Ptr<FisherFaceRecognizer> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "num_components"), num_components, ArgInfo("num_components", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::FisherFaceRecognizer::create(num_components, threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_LBPHFaceRecognizer_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int radius=1;
    int neighbors=8;
    int grid_x=8;
    int grid_y=8;
    double threshold=DBL_MAX;
    Ptr<LBPHFaceRecognizer> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "neighbors"), neighbors, ArgInfo("neighbors", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "grid_x"), grid_x, ArgInfo("grid_x", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "grid_y"), grid_y, ArgInfo("grid_y", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::LBPHFaceRecognizer::create(radius, neighbors, grid_x, grid_y, threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_MACE_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int IMGSIZE=64;
    cv::Ptr<MACE> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "iMGSIZE"), IMGSIZE, ArgInfo("IMGSIZE", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::MACE::create(IMGSIZE), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_MACE_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    String objname;
    cv::Ptr<MACE> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objname"), objname, ArgInfo("objname", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::MACE::load(filename, objname), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_StandardCollector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double threshold=DBL_MAX;
    Ptr<StandardCollector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::StandardCollector::create(threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_createFacemarkAAM(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Facemark> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::createFacemarkAAM(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_createFacemarkKazemi(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Facemark> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::createFacemarkKazemi(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_createFacemarkLBF(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Facemark> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::createFacemarkLBF(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_drawFacemarks(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat points;
    Scalar color=Scalar(255,0,0);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::face::drawFacemarks(image, points, color), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }
    

    {
    UMat image;
    UMat points;
    Scalar color=Scalar(255,0,0);

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::face::drawFacemarks(image, points, color), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, image);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_getFacesHAAR(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat faces;
    String face_cascade_name;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "faces"), faces, ArgInfo("faces", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_cascade_name"), face_cascade_name, ArgInfo("face_cascade_name", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::getFacesHAAR(image, faces, face_cascade_name), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, faces);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    UMat image;
    UMat faces;
    String face_cascade_name;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "faces"), faces, ArgInfo("faces", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "face_cascade_name"), face_cascade_name, ArgInfo("face_cascade_name", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::getFacesHAAR(image, faces, face_cascade_name), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, faces);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_loadDatasetList(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String imageList;
    String annotationList;
    vector_String images;
    vector_String annotations;
    bool retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageList"), imageList, ArgInfo("imageList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "annotationList"), annotationList, ArgInfo("annotationList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "annotations"), annotations, ArgInfo("annotations", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadDatasetList(imageList, annotationList, images, annotations), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_loadFacePoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    Mat points;
    float offset=0.0f;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadFacePoints(filename, points, offset), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, points);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    UMat points;
    float offset=0.0f;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points"), points, ArgInfo("points", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadFacePoints(filename, points, offset), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, points);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_face_loadTrainingData(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::face;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String imageList;
    String groundTruth;
    vector_String images;
    Mat facePoints;
    float offset=0.0f;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageList"), imageList, ArgInfo("imageList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groundTruth"), groundTruth, ArgInfo("groundTruth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "facePoints"), facePoints, ArgInfo("facePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadTrainingData(imageList, groundTruth, images, facePoints, offset), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, facePoints);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String imageList;
    String groundTruth;
    vector_String images;
    UMat facePoints;
    float offset=0.0f;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageList"), imageList, ArgInfo("imageList", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groundTruth"), groundTruth, ArgInfo("groundTruth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "facePoints"), facePoints, ArgInfo("facePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadTrainingData(imageList, groundTruth, images, facePoints, offset), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, facePoints);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    vector_String images;
    Mat facePoints;
    char delim=' ';
    float offset=0.0f;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "facePoints"), facePoints, ArgInfo("facePoints", 1, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "delim"), &delim, ArgInfo("delim", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadTrainingData(filename, images, facePoints, delim, offset), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, facePoints);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    vector_String filename;
    vector_vector_Point2f trainlandmarks;
    vector_String trainimages;
    bool retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainlandmarks"), trainlandmarks, ArgInfo("trainlandmarks", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "trainimages"), trainimages, ArgInfo("trainimages", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadTrainingData(filename, trainlandmarks, trainimages), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }
    

    {
    String filename;
    vector_String images;
    UMat facePoints;
    char delim=' ';
    float offset=0.0f;
    bool retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "images"), images, ArgInfo("images", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "facePoints"), facePoints, ArgInfo("facePoints", 1, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "delim"), &delim, ArgInfo("delim", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "offset"), offset, ArgInfo("offset", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::face::loadTrainingData(filename, images, facePoints, delim, offset), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                // code_ret_1_tuple_except_bool
                return evision_from(env, facePoints);
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_calibrate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size image_size;
    Mat K;
    Mat D;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_size"), image_size, ArgInfo("image_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fisheye::calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, K), evision_from(env, D), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size image_size;
    UMat K;
    UMat D;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags=0;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_size"), image_size, ArgInfo("image_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fisheye::calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, retval), evision_from(env, K), evision_from(env, D), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_distortPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat undistorted;
    Mat distorted;
    Mat K;
    Mat D;
    double alpha=0;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::distortPoints(undistorted, distorted, K, D, alpha), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, distorted);
        }
    }

    }
    

    {
    UMat undistorted;
    UMat distorted;
    UMat K;
    UMat D;
    double alpha=0;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::distortPoints(undistorted, distorted, K, D, alpha), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, distorted);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_estimateNewCameraMatrixForUndistortRectify(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat K;
    Mat D;
    Size image_size;
    Mat R;
    Mat P;
    double balance=0.0;
    Size new_size;
    double fov_scale=1.0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_size"), image_size, ArgInfo("image_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "balance"), balance, ArgInfo("balance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "new_size"), new_size, ArgInfo("new_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fov_scale"), fov_scale, ArgInfo("fov_scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, P);
        }
    }

    }
    

    {
    UMat K;
    UMat D;
    Size image_size;
    UMat R;
    UMat P;
    double balance=0.0;
    Size new_size;
    double fov_scale=1.0;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_size"), image_size, ArgInfo("image_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "balance"), balance, ArgInfo("balance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "new_size"), new_size, ArgInfo("new_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fov_scale"), fov_scale, ArgInfo("fov_scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, P);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_initUndistortRectifyMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat K;
    Mat D;
    Mat R;
    Mat P;
    Size size;
    int m1type;
    Mat map1;
    Mat map2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }
    

    {
    UMat K;
    UMat D;
    UMat R;
    UMat P;
    Size size;
    int m1type;
    UMat map1;
    UMat map2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_projectPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat rvec;
    Mat tvec;
    Mat K;
    Mat D;
    double alpha=0;
    Mat jacobian;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), jacobian, ArgInfo("jacobian", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, imagePoints), evision_from(env, jacobian));
        }
    }

    }
    

    {
    UMat objectPoints;
    UMat imagePoints;
    UMat rvec;
    UMat tvec;
    UMat K;
    UMat D;
    double alpha=0;
    UMat jacobian;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), jacobian, ArgInfo("jacobian", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, imagePoints), evision_from(env, jacobian));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_stereoCalibrate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints1;
    vector_Mat imagePoints2;
    Mat K1;
    Mat D1;
    Mat K2;
    Mat D2;
    Size imageSize;
    Mat R;
    Mat T;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple9(env, evision_from(env, retval), evision_from(env, K1), evision_from(env, D1), evision_from(env, K2), evision_from(env, D2), evision_from(env, R), evision_from(env, T), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints1;
    vector_UMat imagePoints2;
    UMat K1;
    UMat D1;
    UMat K2;
    UMat D2;
    Size imageSize;
    UMat R;
    UMat T;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, rvecs, tvecs, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple9(env, evision_from(env, retval), evision_from(env, K1), evision_from(env, D1), evision_from(env, K2), evision_from(env, D2), evision_from(env, R), evision_from(env, T), evision_from(env, rvecs), evision_from(env, tvecs));
        }
    }

    }
    

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints1;
    vector_Mat imagePoints2;
    Mat K1;
    Mat D1;
    Mat K2;
    Mat D2;
    Size imageSize;
    Mat R;
    Mat T;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, retval), evision_from(env, K1), evision_from(env, D1), evision_from(env, K2), evision_from(env, D2), evision_from(env, R), evision_from(env, T));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints1;
    vector_UMat imagePoints2;
    UMat K1;
    UMat D1;
    UMat K2;
    UMat D2;
    Size imageSize;
    UMat R;
    UMat T;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, retval), evision_from(env, K1), evision_from(env, D1), evision_from(env, K2), evision_from(env, D2), evision_from(env, R), evision_from(env, T));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_stereoRectify(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat K1;
    Mat D1;
    Mat K2;
    Mat D2;
    Size imageSize;
    Mat R;
    Mat tvec;
    Mat R1;
    Mat R2;
    Mat P1;
    Mat P2;
    Mat Q;
    int flags;
    Size newImageSize;
    double balance=0.0;
    double fov_scale=1.0;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), Q, ArgInfo("Q", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImageSize"), newImageSize, ArgInfo("newImageSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "balance"), balance, ArgInfo("balance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fov_scale"), fov_scale, ArgInfo("fov_scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, R1), evision_from(env, R2), evision_from(env, P1), evision_from(env, P2), evision_from(env, Q));
        }
    }

    }
    

    {
    UMat K1;
    UMat D1;
    UMat K2;
    UMat D2;
    Size imageSize;
    UMat R;
    UMat tvec;
    UMat R1;
    UMat R2;
    UMat P1;
    UMat P2;
    UMat Q;
    int flags;
    Size newImageSize;
    double balance=0.0;
    double fov_scale=1.0;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize"), imageSize, ArgInfo("imageSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p1"), P1, ArgInfo("P1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p2"), P2, ArgInfo("P2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q"), Q, ArgInfo("Q", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newImageSize"), newImageSize, ArgInfo("newImageSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "balance"), balance, ArgInfo("balance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fov_scale"), fov_scale, ArgInfo("fov_scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple5(env, evision_from(env, R1), evision_from(env, R2), evision_from(env, P1), evision_from(env, P2), evision_from(env, Q));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_undistortImage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat distorted;
    Mat undistorted;
    Mat K;
    Mat D;
    Mat Knew=cv::Mat();
    Size new_size;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knew"), Knew, ArgInfo("Knew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "new_size"), new_size, ArgInfo("new_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::undistortImage(distorted, undistorted, K, D, Knew, new_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }
    

    {
    UMat distorted;
    UMat undistorted;
    UMat K;
    UMat D;
    UMat Knew=cv::UMat();
    Size new_size;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knew"), Knew, ArgInfo("Knew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "new_size"), new_size, ArgInfo("new_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::undistortImage(distorted, undistorted, K, D, Knew, new_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_fisheye_undistortPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::fisheye;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat distorted;
    Mat undistorted;
    Mat K;
    Mat D;
    Mat R;
    Mat P;
    TermCriteria criteria=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::undistortPoints(distorted, undistorted, K, D, R, P, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }
    

    {
    UMat distorted;
    UMat undistorted;
    UMat K;
    UMat D;
    UMat R;
    UMat P;
    TermCriteria criteria=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8);

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::fisheye::undistortPoints(distorted, undistorted, K, D, R, P, criteria), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT02D_FL_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    int radius;
    Mat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_FL_process(matrix, radius, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat matrix;
    int radius;
    UMat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_FL_process(matrix, radius, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT02D_FL_process_float(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    int radius;
    Mat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_FL_process_float(matrix, radius, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat matrix;
    int radius;
    UMat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_FL_process_float(matrix, radius, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT02D_components(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    Mat kernel;
    Mat components;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_components(matrix, kernel, components, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, components);
        }
    }

    }
    

    {
    UMat matrix;
    UMat kernel;
    UMat components;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_components(matrix, kernel, components, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, components);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT02D_inverseFT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat components;
    Mat kernel;
    Mat output;
    int width;
    int height;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_inverseFT(components, kernel, output, width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat components;
    UMat kernel;
    UMat output;
    int width;
    int height;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_inverseFT(components, kernel, output, width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT02D_iteration(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    Mat kernel;
    Mat output;
    Mat mask;
    Mat maskOutput;
    bool firstStop;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maskOutput"), maskOutput, ArgInfo("maskOutput", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "firstStop"), firstStop, ArgInfo("firstStop", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ft::FT02D_iteration(matrix, kernel, output, mask, maskOutput, firstStop), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, output), evision_from(env, maskOutput));
        }
    }

    }
    

    {
    UMat matrix;
    UMat kernel;
    UMat output;
    UMat mask;
    UMat maskOutput;
    bool firstStop;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maskOutput"), maskOutput, ArgInfo("maskOutput", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "firstStop"), firstStop, ArgInfo("firstStop", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ft::FT02D_iteration(matrix, kernel, output, mask, maskOutput, firstStop), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, output), evision_from(env, maskOutput));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT02D_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    Mat kernel;
    Mat output;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_process(matrix, kernel, output, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat matrix;
    UMat kernel;
    UMat output;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT02D_process(matrix, kernel, output, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT12D_components(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    Mat kernel;
    Mat components;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_components(matrix, kernel, components), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, components);
        }
    }

    }
    

    {
    UMat matrix;
    UMat kernel;
    UMat components;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_components(matrix, kernel, components), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, components);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT12D_createPolynomMatrixHorizontal(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int radius;
    Mat matrix;
    int chn;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_createPolynomMatrixHorizontal(radius, matrix, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matrix);
        }
    }

    }
    

    {
    int radius;
    UMat matrix;
    int chn;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_createPolynomMatrixHorizontal(radius, matrix, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matrix);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT12D_createPolynomMatrixVertical(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int radius;
    Mat matrix;
    int chn;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_createPolynomMatrixVertical(radius, matrix, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matrix);
        }
    }

    }
    

    {
    int radius;
    UMat matrix;
    int chn;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_createPolynomMatrixVertical(radius, matrix, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matrix);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT12D_inverseFT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat components;
    Mat kernel;
    Mat output;
    int width;
    int height;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_inverseFT(components, kernel, output, width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat components;
    UMat kernel;
    UMat output;
    int width;
    int height;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_inverseFT(components, kernel, output, width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT12D_polynomial(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    Mat kernel;
    Mat c00;
    Mat c10;
    Mat c01;
    Mat components;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c00"), c00, ArgInfo("c00", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c10"), c10, ArgInfo("c10", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c01"), c01, ArgInfo("c01", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_polynomial(matrix, kernel, c00, c10, c01, components, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, c00), evision_from(env, c10), evision_from(env, c01), evision_from(env, components));
        }
    }

    }
    

    {
    UMat matrix;
    UMat kernel;
    UMat c00;
    UMat c10;
    UMat c01;
    UMat components;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c00"), c00, ArgInfo("c00", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c10"), c10, ArgInfo("c10", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "c01"), c01, ArgInfo("c01", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "components"), components, ArgInfo("components", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_polynomial(matrix, kernel, c00, c10, c01, components, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, c00), evision_from(env, c10), evision_from(env, c01), evision_from(env, components));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_FT12D_process(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat matrix;
    Mat kernel;
    Mat output;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_process(matrix, kernel, output, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat matrix;
    UMat kernel;
    UMat output;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::FT12D_process(matrix, kernel, output, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_createKernel(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int function;
    int radius;
    Mat kernel;
    int chn;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "function"), function, ArgInfo("function", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::createKernel(function, radius, kernel, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, kernel);
        }
    }

    }
    

    {
    int function;
    int radius;
    UMat kernel;
    int chn;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "function"), function, ArgInfo("function", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::createKernel(function, radius, kernel, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, kernel);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_createKernel1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat A;
    Mat B;
    Mat kernel;
    int chn;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), A, ArgInfo("A", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), B, ArgInfo("B", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::createKernel(A, B, kernel, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, kernel);
        }
    }

    }
    

    {
    UMat A;
    UMat B;
    UMat kernel;
    int chn;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), A, ArgInfo("A", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), B, ArgInfo("B", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chn"), chn, ArgInfo("chn", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::createKernel(A, B, kernel, chn), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, kernel);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_filter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat kernel;
    Mat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::filter(image, kernel, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat image;
    UMat kernel;
    UMat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernel"), kernel, ArgInfo("kernel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::filter(image, kernel, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ft_inpaint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ft;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat mask;
    Mat output;
    int radius;
    int function;
    int algorithm;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "function"), function, ArgInfo("function", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "algorithm"), algorithm, ArgInfo("algorithm", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::inpaint(image, mask, output, radius, function, algorithm), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat image;
    UMat mask;
    UMat output;
    int radius;
    int function;
    int algorithm;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "function"), function, ArgInfo("function", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "algorithm"), algorithm, ArgInfo("algorithm", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ft::inpaint(image, mask, output, radius, function, algorithm), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_hfs_HfsSegment_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::hfs;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int height;
    int width;
    float segEgbThresholdI=0.08f;
    int minRegionSizeI=100;
    float segEgbThresholdII=0.28f;
    int minRegionSizeII=200;
    float spatialWeight=0.6f;
    int slicSpixelSize=8;
    int numSlicIter=5;
    Ptr<HfsSegment> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "segEgbThresholdI"), segEgbThresholdI, ArgInfo("segEgbThresholdI", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minRegionSizeI"), minRegionSizeI, ArgInfo("minRegionSizeI", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "segEgbThresholdII"), segEgbThresholdII, ArgInfo("segEgbThresholdII", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minRegionSizeII"), minRegionSizeII, ArgInfo("minRegionSizeII", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "spatialWeight"), spatialWeight, ArgInfo("spatialWeight", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "slicSpixelSize"), slicSpixelSize, ArgInfo("slicSpixelSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numSlicIter"), numSlicIter, ArgInfo("numSlicIter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::hfs::HfsSegment::create(height, width, segEgbThresholdI, minRegionSizeI, segEgbThresholdII, minRegionSizeII, spatialWeight, slicSpixelSize, numSlicIter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_AverageHash_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<AverageHash> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::img_hash::AverageHash::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_BlockMeanHash_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int mode=BLOCK_MEAN_HASH_MODE_0;
    Ptr<BlockMeanHash> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::img_hash::BlockMeanHash::create(mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_ColorMomentHash_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<ColorMomentHash> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::img_hash::ColorMomentHash::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_MarrHildrethHash_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float alpha=2.0f;
    float scale=1.0f;
    Ptr<MarrHildrethHash> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::img_hash::MarrHildrethHash::create(alpha, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_PHash_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<PHash> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::img_hash::PHash::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_RadialVarianceHash_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double sigma=1;
    int numOfAngleLine=180;
    Ptr<RadialVarianceHash> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numOfAngleLine"), numOfAngleLine, ArgInfo("numOfAngleLine", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::img_hash::RadialVarianceHash::create(sigma, numOfAngleLine), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_averageHash(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat inputArr;
    Mat outputArr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::averageHash(inputArr, outputArr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }
    

    {
    UMat inputArr;
    UMat outputArr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::averageHash(inputArr, outputArr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_blockMeanHash(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat inputArr;
    Mat outputArr;
    int mode=BLOCK_MEAN_HASH_MODE_0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::blockMeanHash(inputArr, outputArr, mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }
    

    {
    UMat inputArr;
    UMat outputArr;
    int mode=BLOCK_MEAN_HASH_MODE_0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::blockMeanHash(inputArr, outputArr, mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_colorMomentHash(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat inputArr;
    Mat outputArr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::colorMomentHash(inputArr, outputArr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }
    

    {
    UMat inputArr;
    UMat outputArr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::colorMomentHash(inputArr, outputArr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_marrHildrethHash(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat inputArr;
    Mat outputArr;
    float alpha=2.0f;
    float scale=1.0f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::marrHildrethHash(inputArr, outputArr, alpha, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }
    

    {
    UMat inputArr;
    UMat outputArr;
    float alpha=2.0f;
    float scale=1.0f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::marrHildrethHash(inputArr, outputArr, alpha, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_pHash(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat inputArr;
    Mat outputArr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::pHash(inputArr, outputArr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }
    

    {
    UMat inputArr;
    UMat outputArr;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::pHash(inputArr, outputArr), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_img_hash_radialVarianceHash(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::img_hash;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat inputArr;
    Mat outputArr;
    double sigma=1;
    int numOfAngleLine=180;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numOfAngleLine"), numOfAngleLine, ArgInfo("numOfAngleLine", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::radialVarianceHash(inputArr, outputArr, sigma, numOfAngleLine), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }
    

    {
    UMat inputArr;
    UMat outputArr;
    double sigma=1;
    int numOfAngleLine=180;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "inputArr"), inputArr, ArgInfo("inputArr", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputArr"), outputArr, ArgInfo("outputArr", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numOfAngleLine"), numOfAngleLine, ArgInfo("numOfAngleLine", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::img_hash::radialVarianceHash(inputArr, outputArr, sigma, numOfAngleLine), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outputArr);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intensity_transform_BIMEF(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::intensity_transform;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat input;
    Mat output;
    float mu=0.5f;
    float a=-0.3293f;
    float b=1.1258f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mu"), mu, ArgInfo("mu", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::BIMEF(input, output, mu, a, b), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat input;
    UMat output;
    float mu=0.5f;
    float a=-0.3293f;
    float b=1.1258f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mu"), mu, ArgInfo("mu", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::BIMEF(input, output, mu, a, b), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intensity_transform_BIMEF2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::intensity_transform;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat input;
    Mat output;
    float k;
    float mu;
    float a;
    float b;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mu"), mu, ArgInfo("mu", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::BIMEF(input, output, k, mu, a, b), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }
    

    {
    UMat input;
    UMat output;
    float k;
    float mu;
    float a;
    float b;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mu"), mu, ArgInfo("mu", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "a"), a, ArgInfo("a", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "b"), b, ArgInfo("b", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::BIMEF(input, output, k, mu, a, b), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, output);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intensity_transform_autoscaling(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::intensity_transform;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat input;
    Mat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::autoscaling(input, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intensity_transform_contrastStretching(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::intensity_transform;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat input;
    Mat output;
    int r1;
    int s1;
    int r2;
    int s2;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), r1, ArgInfo("r1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s1"), s1, ArgInfo("s1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), r2, ArgInfo("r2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s2"), s2, ArgInfo("s2", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::contrastStretching(input, output, r1, s1, r2, s2), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intensity_transform_gammaCorrection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::intensity_transform;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat input;
    Mat output;
    float gamma;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::gammaCorrection(input, output, gamma), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_intensity_transform_logTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::intensity_transform;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat input;
    Mat output;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "output"), output, ArgInfo("output", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::intensity_transform::logTransform(input, output), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ipp_getIppVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ipp;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ipp::getIppVersion(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ipp_setUseIPP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ipp;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool flag;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ipp::setUseIPP(flag), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ipp_setUseIPP_NotExact(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ipp;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool flag;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ipp::setUseIPP_NotExact(flag), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ipp_useIPP(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ipp;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ipp::useIPP(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ipp_useIPP_NotExact(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ipp;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ipp::useIPP_NotExact(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_KinFu_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> _params;
    Ptr<KinFu> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), _params, ArgInfo("_params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::KinFu::create(_params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_Params_coarseParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::Params::coarseParams(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_Params_coloredTSDFParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool isCoarse;
    Ptr<Params> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isCoarse"), isCoarse, ArgInfo("isCoarse", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::Params::coloredTSDFParams(isCoarse), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_Params_defaultParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::Params::defaultParams(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_Params_hashTSDFParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool isCoarse;
    Ptr<Params> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isCoarse"), isCoarse, ArgInfo("isCoarse", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::Params::hashTSDFParams(isCoarse), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_VolumeParams_coarseParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VolumeType> _volumeType=static_cast<std::underlying_type_t<VolumeType>>(static_cast<VolumeType>(0));
    Ptr<VolumeParams> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "volumeType"), _volumeType, ArgInfo("_volumeType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::VolumeParams::coarseParams(static_cast<VolumeType>(_volumeType)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_VolumeParams_defaultParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VolumeType> _volumeType=static_cast<std::underlying_type_t<VolumeType>>(static_cast<VolumeType>(0));
    Ptr<VolumeParams> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "volumeType"), _volumeType, ArgInfo("_volumeType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::VolumeParams::defaultParams(static_cast<VolumeType>(_volumeType)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_kinfu_makeVolume(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VolumeType> _volumeType=static_cast<std::underlying_type_t<VolumeType>>(static_cast<VolumeType>(0));
    float _voxelSize;
    Matx44f _pose;
    float _raycastStepFactor;
    float _truncDist;
    int _maxWeight;
    float _truncateThreshold;
    Vec3i _resolution;
    Ptr<Volume> retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "volumeType"), _volumeType, ArgInfo("_volumeType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "voxelSize"), _voxelSize, ArgInfo("_voxelSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pose"), _pose, ArgInfo("_pose", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "raycastStepFactor"), _raycastStepFactor, ArgInfo("_raycastStepFactor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "truncDist"), _truncDist, ArgInfo("_truncDist", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxWeight"), _maxWeight, ArgInfo("_maxWeight", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "truncateThreshold"), _truncateThreshold, ArgInfo("_truncateThreshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "resolution"), _resolution, ArgInfo("_resolution", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::kinfu::makeVolume(static_cast<VolumeType>(_volumeType), _voxelSize, _pose, _raycastStepFactor, _truncDist, _maxWeight, _truncateThreshold, _resolution), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_large_kinfu_LargeKinfu_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::large_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> _params;
    Ptr<LargeKinfu> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), _params, ArgInfo("_params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::large_kinfu::LargeKinfu::create(_params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_large_kinfu_Params_coarseParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::large_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::large_kinfu::Params::coarseParams(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_large_kinfu_Params_defaultParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::large_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Params> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::large_kinfu::Params::defaultParams(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_large_kinfu_Params_hashTSDFParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::large_kinfu;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool isCoarse;
    Ptr<Params> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isCoarse"), isCoarse, ArgInfo("isCoarse", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::large_kinfu::Params::hashTSDFParams(isCoarse), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_MultiTracker_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<MultiTracker> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::MultiTracker::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerBoosting_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerBoosting> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerBoosting::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerCSRT_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerCSRT> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerCSRT::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerKCF_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerKCF> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerKCF::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerMIL_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerMIL> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerMIL::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerMOSSE_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerMOSSE> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerMOSSE::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerMedianFlow_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerMedianFlow> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerMedianFlow::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_TrackerTLD_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::TrackerTLD> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::TrackerTLD::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_legacy_upgradeTrackingAPI(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::legacy;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<legacy::Tracker> legacy_tracker;
    Ptr<cv::Tracker> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "legacy_tracker"), legacy_tracker, ArgInfo("legacy_tracker", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::legacy::upgradeTrackingAPI(legacy_tracker), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::line_descriptor;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<BinaryDescriptor> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::line_descriptor::BinaryDescriptor::createBinaryDescriptor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_line_descriptor_LSDDetector_createLSDDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::line_descriptor;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<LSDDetector> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::line_descriptor::LSDDetector::createLSDDetector(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_line_descriptor_LSDDetector_createLSDDetectorWithParams(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::line_descriptor;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    LSDParam params;
    Ptr<LSDDetector> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::line_descriptor::LSDDetector::createLSDDetector(params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_line_descriptor_drawKeylines(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::line_descriptor;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat image;
    vector_KeyLine keylines;
    Mat outImage;
    Scalar color=Scalar::all( -1 );
    int flags=DrawLinesMatchesFlags::DEFAULT;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keylines"), keylines, ArgInfo("keylines", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImage"), outImage, ArgInfo("outImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::line_descriptor::drawKeylines(image, keylines, outImage, color, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImage);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_line_descriptor_drawLineMatches(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::line_descriptor;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat img1;
    vector_KeyLine keylines1;
    Mat img2;
    vector_KeyLine keylines2;
    vector_DMatch matches1to2;
    Mat outImg;
    Scalar matchColor=Scalar::all( -1 );
    Scalar singleLineColor=Scalar::all( -1 );
    vector_char matchesMask=std::vector<char>();
    int flags=DrawLinesMatchesFlags::DEFAULT;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img1"), img1, ArgInfo("img1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keylines1"), keylines1, ArgInfo("keylines1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img2"), img2, ArgInfo("img2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keylines2"), keylines2, ArgInfo("keylines2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outImg"), outImg, ArgInfo("outImg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchColor"), matchColor, ArgInfo("matchColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "singleLineColor"), singleLineColor, ArgInfo("singleLineColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matchesMask"), matchesMask, ArgInfo("matchesMask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::line_descriptor::drawLineMatches(img1, keylines1, img2, keylines2, matches1to2, outImg, matchColor, singleLineColor, matchesMask, flags), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, outImg);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_ColorGradient_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float weak_threshold;
    size_t num_features;
    float strong_threshold;
    Ptr<ColorGradient> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weak_threshold"), weak_threshold, ArgInfo("weak_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_features"), num_features, ArgInfo("num_features", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "strong_threshold"), strong_threshold, ArgInfo("strong_threshold", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::linemod::ColorGradient::create(weak_threshold, num_features, strong_threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_DepthNormal_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int distance_threshold;
    int difference_threshold;
    size_t num_features;
    int extract_threshold;
    Ptr<DepthNormal> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distance_threshold"), distance_threshold, ArgInfo("distance_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "difference_threshold"), difference_threshold, ArgInfo("difference_threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_features"), num_features, ArgInfo("num_features", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "extract_threshold"), extract_threshold, ArgInfo("extract_threshold", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::linemod::DepthNormal::create(distance_threshold, difference_threshold, num_features, extract_threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_Modality_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    FileNode fn_;
    Ptr<Modality> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fn_"), fn_, ArgInfo("fn_", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::linemod::Modality::create(fn_), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String modality_type;
    Ptr<Modality> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "modality_type"), modality_type, ArgInfo("modality_type", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::linemod::Modality::create(modality_type), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_colormap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat quantized;
    Mat dst;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "quantized"), quantized, ArgInfo("quantized", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::linemod::colormap(quantized, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_drawFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    vector_Template templates;
    Point2i tl;
    int size=10;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templates"), templates, ArgInfo("templates", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::linemod::drawFeatures(img, templates, tl, size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    UMat img;
    vector_Template templates;
    Point2i tl;
    int size=10;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templates"), templates, ArgInfo("templates", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tl"), tl, ArgInfo("tl", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::linemod::drawFeatures(img, templates, tl, size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_getDefaultLINE(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<linemod::Detector> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::linemod::getDefaultLINE(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_linemod_getDefaultLINEMOD(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::linemod;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<linemod::Detector> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::linemod::getDefaultLINEMOD(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mcc_CCheckerDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::mcc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<CCheckerDetector> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::mcc::CCheckerDetector::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mcc_CCheckerDraw_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::mcc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<CChecker> pChecker;
    Scalar color=CV_RGB(0, 250, 0);
    int thickness=2;
    Ptr<CCheckerDraw> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pChecker"), pChecker, ArgInfo("pChecker", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thickness"), thickness, ArgInfo("thickness", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::mcc::CCheckerDraw::create(pChecker, color, thickness), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mcc_CChecker_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::mcc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<CChecker> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::mcc::CChecker::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_mcc_DetectorParameters_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::mcc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<DetectorParameters> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::mcc::DetectorParameters::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<ANN_MLP> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::ANN_MLP::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ANN_MLP_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    Ptr<ANN_MLP> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::ANN_MLP::load(filepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Boost> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::Boost::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_Boost_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<Boost> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::Boost::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<DTrees> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::DTrees::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_DTrees_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<DTrees> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::DTrees::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<EM> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::EM::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_EM_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<EM> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::EM::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<KNearest> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::KNearest::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_KNearest_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    Ptr<KNearest> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::KNearest::load(filepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<LogisticRegression> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::LogisticRegression::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_LogisticRegression_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<LogisticRegression> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::LogisticRegression::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<NormalBayesClassifier> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::NormalBayesClassifier::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_NormalBayesClassifier_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<NormalBayesClassifier> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::NormalBayesClassifier::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_ParamGrid_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double minVal=0.;
    double maxVal=0.;
    double logstep=1.;
    Ptr<ParamGrid> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "minVal"), minVal, ArgInfo("minVal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxVal"), maxVal, ArgInfo("maxVal", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "logstep"), logstep, ArgInfo("logstep", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::ParamGrid::create(minVal, maxVal, logstep), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<RTrees> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::RTrees::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_RTrees_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<RTrees> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::RTrees::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SVMSGD> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::SVMSGD::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVMSGD_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    String nodeName = String();
    Ptr<SVMSGD> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nodeName"), nodeName, ArgInfo("nodeName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::SVMSGD::load(filepath, nodeName), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SVM> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::SVM::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_getDefaultGridPtr(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int param_id;
    Ptr<ParamGrid> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "param_id"), param_id, ArgInfo("param_id", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::SVM::getDefaultGridPtr(param_id), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_SVM_load(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filepath;
    Ptr<SVM> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filepath"), filepath, ArgInfo("filepath", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::SVM::load(filepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_TrainData_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat samples;
    int layout;
    Mat responses;
    Mat varIdx;
    Mat sampleIdx;
    Mat sampleWeights;
    Mat varType;
    Ptr<TrainData> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varIdx"), varIdx, ArgInfo("varIdx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleIdx"), sampleIdx, ArgInfo("sampleIdx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleWeights"), sampleWeights, ArgInfo("sampleWeights", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varType"), varType, ArgInfo("varType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat samples;
    int layout;
    UMat responses;
    UMat varIdx;
    UMat sampleIdx;
    UMat sampleWeights;
    UMat varType;
    Ptr<TrainData> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "samples"), samples, ArgInfo("samples", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responses"), responses, ArgInfo("responses", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varIdx"), varIdx, ArgInfo("varIdx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleIdx"), sampleIdx, ArgInfo("sampleIdx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sampleWeights"), sampleWeights, ArgInfo("sampleWeights", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "varType"), varType, ArgInfo("varType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_TrainData_getSubMatrix(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat matrix;
    Mat idx;
    int layout;
    Mat retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matrix"), matrix, ArgInfo("matrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "layout"), layout, ArgInfo("layout", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ml_TrainData_getSubVector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ml;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat vec;
    Mat idx;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vec"), vec, ArgInfo("vec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ml::TrainData::getSubVector(vec, idx), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_Device_getDefault(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Device retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ocl::Device::getDefault(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_finish(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(cv::ocl::finish(), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_haveAmdBlas(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ocl::haveAmdBlas(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_haveAmdFft(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ocl::haveAmdFft(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_haveOpenCL(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ocl::haveOpenCL(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_setUseOpenCL(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool flag;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ocl::setUseOpenCL(flag), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ocl_useOpenCL(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ocl;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ocl::useOpenCL(), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_calibrate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints;
    Size size;
    Mat K;
    Mat xi;
    Mat D;
    vector_Mat rvecs;
    vector_Mat tvecs;
    int flags;
    TermCriteria criteria;
    Mat idx;
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::omnidir::calibrate(objectPoints, imagePoints, size, K, xi, D, rvecs, tvecs, flags, criteria, idx), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, retval), evision_from(env, K), evision_from(env, xi), evision_from(env, D), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, idx));
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints;
    Size size;
    UMat K;
    UMat xi;
    UMat D;
    vector_UMat rvecs;
    vector_UMat tvecs;
    int flags;
    TermCriteria criteria;
    UMat idx;
    double retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecs"), rvecs, ArgInfo("rvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecs"), tvecs, ArgInfo("tvecs", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::omnidir::calibrate(objectPoints, imagePoints, size, K, xi, D, rvecs, tvecs, flags, criteria, idx), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple7(env, evision_from(env, retval), evision_from(env, K), evision_from(env, xi), evision_from(env, D), evision_from(env, rvecs), evision_from(env, tvecs), evision_from(env, idx));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_initUndistortRectifyMap(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat K;
    Mat D;
    Mat xi;
    Mat R;
    Mat P;
    Size size;
    int m1type;
    Mat map1;
    Mat map2;
    int flags;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::initUndistortRectifyMap(K, D, xi, R, P, size, m1type, map1, map2, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }
    

    {
    UMat K;
    UMat D;
    UMat xi;
    UMat R;
    UMat P;
    Size size;
    int m1type;
    UMat map1;
    UMat map2;
    int flags;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "p"), P, ArgInfo("P", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m1type"), m1type, ArgInfo("m1type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map1"), map1, ArgInfo("map1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "map2"), map2, ArgInfo("map2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::initUndistortRectifyMap(K, D, xi, R, P, size, m1type, map1, map2, flags), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, map1), evision_from(env, map2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_projectPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat objectPoints;
    Mat imagePoints;
    Mat rvec;
    Mat tvec;
    Mat K;
    double xi;
    Mat D;
    Mat jacobian;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), jacobian, ArgInfo("jacobian", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::projectPoints(objectPoints, imagePoints, rvec, tvec, K, xi, D, jacobian), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, imagePoints), evision_from(env, jacobian));
        }
    }

    }
    

    {
    UMat objectPoints;
    UMat imagePoints;
    UMat rvec;
    UMat tvec;
    UMat K;
    double xi;
    UMat D;
    UMat jacobian;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints"), imagePoints, ArgInfo("imagePoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "jacobian"), jacobian, ArgInfo("jacobian", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::projectPoints(objectPoints, imagePoints, rvec, tvec, K, xi, D, jacobian), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, imagePoints), evision_from(env, jacobian));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_stereoCalibrate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat objectPoints;
    vector_Mat imagePoints1;
    vector_Mat imagePoints2;
    Size imageSize1;
    Size imageSize2;
    Mat K1;
    Mat xi1;
    Mat D1;
    Mat K2;
    Mat xi2;
    Mat D2;
    Mat rvec;
    Mat tvec;
    vector_Mat rvecsL;
    vector_Mat tvecsL;
    int flags;
    TermCriteria criteria;
    Mat idx;
    double retval;

    if( num_kw_args >= 13 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize1"), imageSize1, ArgInfo("imageSize1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize2"), imageSize2, ArgInfo("imageSize2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi1"), xi1, ArgInfo("xi1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi2"), xi2, ArgInfo("xi2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecsL"), rvecsL, ArgInfo("rvecsL", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecsL"), tvecsL, ArgInfo("tvecsL", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::omnidir::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, imageSize1, imageSize2, K1, xi1, D1, K2, xi2, D2, rvec, tvec, rvecsL, tvecsL, flags, criteria, idx), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, objectPoints),
                evision_from(env, imagePoints1),
                evision_from(env, imagePoints2),
                evision_from(env, K1),
                evision_from(env, xi1),
                evision_from(env, D1),
                evision_from(env, K2),
                evision_from(env, xi2),
                evision_from(env, D2),
                evision_from(env, rvec),
                evision_from(env, tvec),
                evision_from(env, rvecsL),
                evision_from(env, tvecsL),
                evision_from(env, idx)};
            return enif_make_tuple_from_array(env, arr, 15);
        }
    }

    }
    

    {
    vector_UMat objectPoints;
    vector_UMat imagePoints1;
    vector_UMat imagePoints2;
    Size imageSize1;
    Size imageSize2;
    UMat K1;
    UMat xi1;
    UMat D1;
    UMat K2;
    UMat xi2;
    UMat D2;
    UMat rvec;
    UMat tvec;
    vector_UMat rvecsL;
    vector_UMat tvecsL;
    int flags;
    TermCriteria criteria;
    UMat idx;
    double retval;

    if( num_kw_args >= 13 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "objectPoints"), objectPoints, ArgInfo("objectPoints", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints1"), imagePoints1, ArgInfo("imagePoints1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imagePoints2"), imagePoints2, ArgInfo("imagePoints2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize1"), imageSize1, ArgInfo("imageSize1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imageSize2"), imageSize2, ArgInfo("imageSize2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi1"), xi1, ArgInfo("xi1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi2"), xi2, ArgInfo("xi2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvecsL"), rvecsL, ArgInfo("rvecsL", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvecsL"), tvecsL, ArgInfo("tvecsL", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "criteria"), criteria, ArgInfo("criteria", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "idx"), idx, ArgInfo("idx", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::omnidir::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, imageSize1, imageSize2, K1, xi1, D1, K2, xi2, D2, rvec, tvec, rvecsL, tvecsL, flags, criteria, idx), env, error_flag, error_term);
        if (!error_flag) {
            ERL_NIF_TERM arr[] = {evision_from(env, retval),
                evision_from(env, objectPoints),
                evision_from(env, imagePoints1),
                evision_from(env, imagePoints2),
                evision_from(env, K1),
                evision_from(env, xi1),
                evision_from(env, D1),
                evision_from(env, K2),
                evision_from(env, xi2),
                evision_from(env, D2),
                evision_from(env, rvec),
                evision_from(env, tvec),
                evision_from(env, rvecsL),
                evision_from(env, tvecsL),
                evision_from(env, idx)};
            return enif_make_tuple_from_array(env, arr, 15);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_stereoReconstruct(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image1;
    Mat image2;
    Mat K1;
    Mat D1;
    Mat xi1;
    Mat K2;
    Mat D2;
    Mat xi2;
    Mat R;
    Mat T;
    int flag;
    int numDisparities;
    int SADWindowSize;
    Mat disparity;
    Mat image1Rec;
    Mat image2Rec;
    Size newSize;
    Mat Knew=cv::Mat();
    Mat pointCloud;
    int pointType=XYZRGB;

    if( num_kw_args >= 13 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image1"), image1, ArgInfo("image1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image2"), image2, ArgInfo("image2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi1"), xi1, ArgInfo("xi1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi2"), xi2, ArgInfo("xi2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sADWindowSize"), SADWindowSize, ArgInfo("SADWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image1Rec"), image1Rec, ArgInfo("image1Rec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image2Rec"), image2Rec, ArgInfo("image2Rec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newSize"), newSize, ArgInfo("newSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knew"), Knew, ArgInfo("Knew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointCloud"), pointCloud, ArgInfo("pointCloud", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointType"), pointType, ArgInfo("pointType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::stereoReconstruct(image1, image2, K1, D1, xi1, K2, D2, xi2, R, T, flag, numDisparities, SADWindowSize, disparity, image1Rec, image2Rec, newSize, Knew, pointCloud, pointType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, disparity), evision_from(env, image1Rec), evision_from(env, image2Rec), evision_from(env, pointCloud));
        }
    }

    }
    

    {
    UMat image1;
    UMat image2;
    UMat K1;
    UMat D1;
    UMat xi1;
    UMat K2;
    UMat D2;
    UMat xi2;
    UMat R;
    UMat T;
    int flag;
    int numDisparities;
    int SADWindowSize;
    UMat disparity;
    UMat image1Rec;
    UMat image2Rec;
    Size newSize;
    UMat Knew=cv::UMat();
    UMat pointCloud;
    int pointType=XYZRGB;

    if( num_kw_args >= 13 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image1"), image1, ArgInfo("image1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image2"), image2, ArgInfo("image2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k1"), K1, ArgInfo("K1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d1"), D1, ArgInfo("D1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi1"), xi1, ArgInfo("xi1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k2"), K2, ArgInfo("K2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d2"), D2, ArgInfo("D2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi2"), xi2, ArgInfo("xi2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numDisparities"), numDisparities, ArgInfo("numDisparities", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sADWindowSize"), SADWindowSize, ArgInfo("SADWindowSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "disparity"), disparity, ArgInfo("disparity", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image1Rec"), image1Rec, ArgInfo("image1Rec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image2Rec"), image2Rec, ArgInfo("image2Rec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "newSize"), newSize, ArgInfo("newSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knew"), Knew, ArgInfo("Knew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointCloud"), pointCloud, ArgInfo("pointCloud", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointType"), pointType, ArgInfo("pointType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::stereoReconstruct(image1, image2, K1, D1, xi1, K2, D2, xi2, R, T, flag, numDisparities, SADWindowSize, disparity, image1Rec, image2Rec, newSize, Knew, pointCloud, pointType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, disparity), evision_from(env, image1Rec), evision_from(env, image2Rec), evision_from(env, pointCloud));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_stereoRectify(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat R;
    Mat T;
    Mat R1;
    Mat R2;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::stereoRectify(R, T, R1, R2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, R1), evision_from(env, R2));
        }
    }

    }
    

    {
    UMat R;
    UMat T;
    UMat R1;
    UMat R2;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r1"), R1, ArgInfo("R1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r2"), R2, ArgInfo("R2", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::stereoRectify(R, T, R1, R2), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, R1), evision_from(env, R2));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_undistortImage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat distorted;
    Mat undistorted;
    Mat K;
    Mat D;
    Mat xi;
    int flags;
    Mat Knew=cv::Mat();
    Size new_size;
    Mat R=Mat::eye(3, 3, CV_64F);

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knew"), Knew, ArgInfo("Knew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "new_size"), new_size, ArgInfo("new_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::undistortImage(distorted, undistorted, K, D, xi, flags, Knew, new_size, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }
    

    {
    UMat distorted;
    UMat undistorted;
    UMat K;
    UMat D;
    UMat xi;
    int flags;
    UMat Knew=cv::UMat();
    Size new_size;
    UMat R=UMat::eye(3, 3, CV_64F);

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "knew"), Knew, ArgInfo("Knew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "new_size"), new_size, ArgInfo("new_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::undistortImage(distorted, undistorted, K, D, xi, flags, Knew, new_size, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_omnidir_undistortPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::omnidir;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat distorted;
    Mat undistorted;
    Mat K;
    Mat D;
    Mat xi;
    Mat R;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::undistortPoints(distorted, undistorted, K, D, xi, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }
    

    {
    UMat distorted;
    UMat undistorted;
    UMat K;
    UMat D;
    UMat xi;
    UMat R;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distorted"), distorted, ArgInfo("distorted", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "undistorted"), undistorted, ArgInfo("undistorted", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), D, ArgInfo("D", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xi"), xi, ArgInfo("xi", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), R, ArgInfo("R", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::omnidir::undistortPoints(distorted, undistorted, K, D, xi, R), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, undistorted);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_parallel_setParallelForBackend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::parallel;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::string backendName;
    bool propagateNumThreads=true;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "backendName"), backendName, ArgInfo("backendName", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "propagateNumThreads"), propagateNumThreads, ArgInfo("propagateNumThreads", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::parallel::setParallelForBackend(backendName, propagateNumThreads), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_phase_unwrapping_HistogramPhaseUnwrapping_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::phase_unwrapping;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    HistogramPhaseUnwrapping_Params parameters=HistogramPhaseUnwrapping::Params();
    Ptr<HistogramPhaseUnwrapping> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::phase_unwrapping::HistogramPhaseUnwrapping::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_plot_Plot2d_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::plot;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat dataX;
    Mat dataY;
    Ptr<Plot2d> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dataX"), dataX, ArgInfo("dataX", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dataY"), dataY, ArgInfo("dataY", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::plot::Plot2d::create(dataX, dataY), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat dataX;
    UMat dataY;
    Ptr<Plot2d> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dataX"), dataX, ArgInfo("dataX", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dataY"), dataY, ArgInfo("dataY", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::plot::Plot2d::create(dataX, dataY), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Mat data;
    Ptr<Plot2d> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::plot::Plot2d::create(data), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat data;
    Ptr<Plot2d> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "data"), data, ArgInfo("data", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::plot::Plot2d::create(data), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_addNoisePC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat pc;
    double scale;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pc"), pc, ArgInfo("pc", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ppf_match_3d::addNoisePC(pc, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_computeNormalsPC3d(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat PC;
    Mat PCNormals;
    int NumNeighbors;
    bool FlipViewpoint;
    Vec3f viewpoint;
    int retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pC"), PC, ArgInfo("PC", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pCNormals"), PCNormals, ArgInfo("PCNormals", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numNeighbors"), NumNeighbors, ArgInfo("NumNeighbors", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flipViewpoint"), FlipViewpoint, ArgInfo("FlipViewpoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "viewpoint"), viewpoint, ArgInfo("viewpoint", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ppf_match_3d::computeNormalsPC3d(PC, PCNormals, NumNeighbors, FlipViewpoint, viewpoint), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, PCNormals));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_getRandomPose(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Matx44d Pose;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pose"), Pose, ArgInfo("Pose", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ppf_match_3d::getRandomPose(Pose), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_loadPLYSimple(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    char* fileName=(char*)"";
    int withNormals=0;
    Mat retval;

    if( num_kw_args >= 1 && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "fileName"), &fileName, ArgInfo("fileName", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "withNormals"), withNormals, ArgInfo("withNormals", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ppf_match_3d::loadPLYSimple(fileName, withNormals), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_samplePCByQuantization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat pc;
    Vec2f xrange;
    Vec2f yrange;
    Vec2f zrange;
    float sample_step_relative;
    int weightByCenter=0;
    Mat retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pc"), pc, ArgInfo("pc", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "xrange"), xrange, ArgInfo("xrange", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "yrange"), yrange, ArgInfo("yrange", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "zrange"), zrange, ArgInfo("zrange", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sample_step_relative"), sample_step_relative, ArgInfo("sample_step_relative", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weightByCenter"), weightByCenter, ArgInfo("weightByCenter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ppf_match_3d::samplePCByQuantization(pc, xrange, yrange, zrange, sample_step_relative, weightByCenter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_transformPCPose(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat pc;
    Matx44d Pose;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pc"), pc, ArgInfo("pc", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pose"), Pose, ArgInfo("Pose", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ppf_match_3d::transformPCPose(pc, Pose), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_writePLY(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat PC;
    char* fileName=(char*)"";

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pC"), PC, ArgInfo("PC", 0, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "fileName"), &fileName, ArgInfo("fileName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ppf_match_3d::writePLY(PC, fileName), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ppf_match_3d_writePLYVisibleNormals(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ppf_match_3d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat PC;
    char* fileName=(char*)"";

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pC"), PC, ArgInfo("PC", 0, 0)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "fileName"), &fileName, ArgInfo("fileName", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ppf_match_3d::writePLYVisibleNormals(PC, fileName), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityBRISQUE_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    String model_file_path;
    String range_file_path;
    cv::Scalar retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model_file_path"), model_file_path, ArgInfo("model_file_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "range_file_path"), range_file_path, ArgInfo("range_file_path", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::compute(img, model_file_path, range_file_path), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat img;
    String model_file_path;
    String range_file_path;
    cv::Scalar retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model_file_path"), model_file_path, ArgInfo("model_file_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "range_file_path"), range_file_path, ArgInfo("range_file_path", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::compute(img, model_file_path, range_file_path), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityBRISQUE_computeFeatures(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat features;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::quality::QualityBRISQUE::computeFeatures(img, features), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, features);
        }
    }

    }
    

    {
    UMat img;
    UMat features;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "features"), features, ArgInfo("features", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::quality::QualityBRISQUE::computeFeatures(img, features), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, features);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityBRISQUE_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<ml::SVM> model;
    Mat range;
    Ptr<QualityBRISQUE> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "range"), range, ArgInfo("range", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::create(model, range), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String model_file_path;
    String range_file_path;
    Ptr<QualityBRISQUE> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model_file_path"), model_file_path, ArgInfo("model_file_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "range_file_path"), range_file_path, ArgInfo("range_file_path", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityBRISQUE::create(model_file_path, range_file_path), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityGMSD_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Mat cmp;
    Mat qualityMap;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityGMSD::compute(ref, cmp, qualityMap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }
    

    {
    UMat ref;
    UMat cmp;
    UMat qualityMap;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityGMSD::compute(ref, cmp, qualityMap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityGMSD_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Ptr<QualityGMSD> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityGMSD::create(ref), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat ref;
    Ptr<QualityGMSD> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityGMSD::create(ref), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityMSE_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Mat cmp;
    Mat qualityMap;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityMSE::compute(ref, cmp, qualityMap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }
    

    {
    UMat ref;
    UMat cmp;
    UMat qualityMap;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityMSE::compute(ref, cmp, qualityMap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityMSE_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Ptr<QualityMSE> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityMSE::create(ref), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat ref;
    Ptr<QualityMSE> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityMSE::create(ref), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityPSNR_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Mat cmp;
    Mat qualityMap;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPixelValue"), maxPixelValue, ArgInfo("maxPixelValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityPSNR::compute(ref, cmp, qualityMap, maxPixelValue), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }
    

    {
    UMat ref;
    UMat cmp;
    UMat qualityMap;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPixelValue"), maxPixelValue, ArgInfo("maxPixelValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityPSNR::compute(ref, cmp, qualityMap, maxPixelValue), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualityPSNR_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    Ptr<QualityPSNR> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPixelValue"), maxPixelValue, ArgInfo("maxPixelValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityPSNR::create(ref, maxPixelValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat ref;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    Ptr<QualityPSNR> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPixelValue"), maxPixelValue, ArgInfo("maxPixelValue", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualityPSNR::create(ref, maxPixelValue), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualitySSIM_compute(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Mat cmp;
    Mat qualityMap;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualitySSIM::compute(ref, cmp, qualityMap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }
    

    {
    UMat ref;
    UMat cmp;
    UMat qualityMap;
    cv::Scalar retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cmp"), cmp, ArgInfo("cmp", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qualityMap"), qualityMap, ArgInfo("qualityMap", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualitySSIM::compute(ref, cmp, qualityMap), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, qualityMap));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_quality_QualitySSIM_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::quality;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat ref;
    Ptr<QualitySSIM> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualitySSIM::create(ref), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat ref;
    Ptr<QualitySSIM> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ref"), ref, ArgInfo("ref", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::quality::QualitySSIM::create(ref), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_GOSTracker_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat pts3d;
    Mat tris;
    int histBins=4;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histBins"), histBins, ArgInfo("histBins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sobelThesh"), sobelThesh, ArgInfo("sobelThesh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::GOSTracker::create(pts3d, tris, histBins, sobelThesh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat pts3d;
    UMat tris;
    int histBins=4;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histBins"), histBins, ArgInfo("histBins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sobelThesh"), sobelThesh, ArgInfo("sobelThesh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::GOSTracker::create(pts3d, tris, histBins, sobelThesh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_OLSTracker_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat pts3d;
    Mat tris;
    int histBins=8;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histBins"), histBins, ArgInfo("histBins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sobelThesh"), sobelThesh, ArgInfo("sobelThesh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::OLSTracker::create(pts3d, tris, histBins, sobelThesh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat pts3d;
    UMat tris;
    int histBins=8;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histBins"), histBins, ArgInfo("histBins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sobelThesh"), sobelThesh, ArgInfo("sobelThesh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::OLSTracker::create(pts3d, tris, histBins, sobelThesh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_Rapid_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat pts3d;
    Mat tris;
    Ptr<Rapid> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::Rapid::create(pts3d, tris), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat pts3d;
    UMat tris;
    Ptr<Rapid> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::Rapid::create(pts3d, tris), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_convertCorrespondencies(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat cols;
    Mat srcLocations;
    Mat pts2d;
    Mat pts3d;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcLocations"), srcLocations, ArgInfo("srcLocations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts2d"), pts2d, ArgInfo("pts2d", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::convertCorrespondencies(cols, srcLocations, pts2d, pts3d, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, pts2d), evision_from(env, pts3d));
        }
    }

    }
    

    {
    UMat cols;
    UMat srcLocations;
    UMat pts2d;
    UMat pts3d;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcLocations"), srcLocations, ArgInfo("srcLocations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts2d"), pts2d, ArgInfo("pts2d", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::convertCorrespondencies(cols, srcLocations, pts2d, pts3d, mask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, pts2d), evision_from(env, pts3d));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_drawCorrespondencies(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat bundle;
    Mat cols;
    Mat colors;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bundle"), bundle, ArgInfo("bundle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colors"), colors, ArgInfo("colors", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::drawCorrespondencies(bundle, cols, colors), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, bundle);
        }
    }

    }
    

    {
    UMat bundle;
    UMat cols;
    UMat colors;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bundle"), bundle, ArgInfo("bundle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "colors"), colors, ArgInfo("colors", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::drawCorrespondencies(bundle, cols, colors), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, bundle);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_drawSearchLines(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat locations;
    Scalar color;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "locations"), locations, ArgInfo("locations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::drawSearchLines(img, locations, color), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    UMat img;
    UMat locations;
    Scalar color;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "locations"), locations, ArgInfo("locations", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::drawSearchLines(img, locations, color), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_drawWireframe(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat pts2d;
    Mat tris;
    Scalar color;
    int type=LINE_8;
    bool cullBackface=false;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts2d"), pts2d, ArgInfo("pts2d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cullBackface"), cullBackface, ArgInfo("cullBackface", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::drawWireframe(img, pts2d, tris, color, type, cullBackface), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }
    

    {
    UMat img;
    UMat pts2d;
    UMat tris;
    Scalar color;
    int type=LINE_8;
    bool cullBackface=false;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts2d"), pts2d, ArgInfo("pts2d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "color"), color, ArgInfo("color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cullBackface"), cullBackface, ArgInfo("cullBackface", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::drawWireframe(img, pts2d, tris, color, type, cullBackface), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, img);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_extractControlPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int num;
    int len;
    Mat pts3d;
    Mat rvec;
    Mat tvec;
    Mat K;
    Size imsize;
    Mat tris;
    Mat ctl2d;
    Mat ctl3d;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num"), num, ArgInfo("num", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imsize"), imsize, ArgInfo("imsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctl2d"), ctl2d, ArgInfo("ctl2d", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctl3d"), ctl3d, ArgInfo("ctl3d", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::extractControlPoints(num, len, pts3d, rvec, tvec, K, imsize, tris, ctl2d, ctl3d), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, ctl2d), evision_from(env, ctl3d));
        }
    }

    }
    

    {
    int num;
    int len;
    UMat pts3d;
    UMat rvec;
    UMat tvec;
    UMat K;
    Size imsize;
    UMat tris;
    UMat ctl2d;
    UMat ctl3d;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num"), num, ArgInfo("num", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "imsize"), imsize, ArgInfo("imsize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctl2d"), ctl2d, ArgInfo("ctl2d", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctl3d"), ctl3d, ArgInfo("ctl3d", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::extractControlPoints(num, len, pts3d, rvec, tvec, K, imsize, tris, ctl2d, ctl3d), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, ctl2d), evision_from(env, ctl3d));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_extractLineBundle(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int len;
    Mat ctl2d;
    Mat img;
    Mat bundle;
    Mat srcLocations;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctl2d"), ctl2d, ArgInfo("ctl2d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bundle"), bundle, ArgInfo("bundle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcLocations"), srcLocations, ArgInfo("srcLocations", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::extractLineBundle(len, ctl2d, img, bundle, srcLocations), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, bundle), evision_from(env, srcLocations));
        }
    }

    }
    

    {
    int len;
    UMat ctl2d;
    UMat img;
    UMat bundle;
    UMat srcLocations;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ctl2d"), ctl2d, ArgInfo("ctl2d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bundle"), bundle, ArgInfo("bundle", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcLocations"), srcLocations, ArgInfo("srcLocations", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::extractLineBundle(len, ctl2d, img, bundle, srcLocations), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, bundle), evision_from(env, srcLocations));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_findCorrespondencies(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat bundle;
    Mat cols;
    Mat response;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bundle"), bundle, ArgInfo("bundle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::findCorrespondencies(bundle, cols, response), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, cols), evision_from(env, response));
        }
    }

    }
    

    {
    UMat bundle;
    UMat cols;
    UMat response;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "bundle"), bundle, ArgInfo("bundle", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "response"), response, ArgInfo("response", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rapid::findCorrespondencies(bundle, cols, response), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, cols), evision_from(env, response));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rapid_rapid(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rapid;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    int num;
    int len;
    Mat pts3d;
    Mat tris;
    Mat K;
    Mat rvec;
    Mat tvec;
    double rmsd;
    float retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num"), num, ArgInfo("num", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::rapid(img, num, len, pts3d, tris, K, rvec, tvec, &rmsd), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, rvec), evision_from(env, tvec), evision_from(env, rmsd));
        }
    }

    }
    

    {
    UMat img;
    int num;
    int len;
    UMat pts3d;
    UMat tris;
    UMat K;
    UMat rvec;
    UMat tvec;
    double rmsd;
    float retval;

    if( num_kw_args >= 8 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num"), num, ArgInfo("num", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pts3d"), pts3d, ArgInfo("pts3d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tris"), tris, ArgInfo("tris", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rvec"), rvec, ArgInfo("rvec", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "tvec"), tvec, ArgInfo("tvec", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rapid::rapid(img, num, len, pts3d, tris, K, rvec, tvec, &rmsd), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple4(env, evision_from(env, retval), evision_from(env, rvec), evision_from(env, tvec), evision_from(env, rmsd));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reg_MapTypeCaster_toAffine(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::reg;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Map> sourceMap;
    Ptr<MapAffine> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sourceMap"), sourceMap, ArgInfo("sourceMap", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::reg::MapTypeCaster::toAffine(sourceMap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reg_MapTypeCaster_toProjec(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::reg;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Map> sourceMap;
    Ptr<MapProjec> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sourceMap"), sourceMap, ArgInfo("sourceMap", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::reg::MapTypeCaster::toProjec(sourceMap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_reg_MapTypeCaster_toShift(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::reg;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<Map> sourceMap;
    Ptr<MapShift> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sourceMap"), sourceMap, ArgInfo("sourceMap", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::reg::MapTypeCaster::toShift(sourceMap), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_DepthCleaner_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int depth;
    int window_size=5;
    int method=DepthCleaner::DEPTH_CLEANER_NIL;
    Ptr<DepthCleaner> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window_size"), window_size, ArgInfo("window_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::DepthCleaner::create(depth, window_size, method), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_FastICPOdometry_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat cameraMatrix;
    float maxDistDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float angleThreshold=(float)(30. * CV_PI / 180.);
    float sigmaDepth=0.04f;
    float sigmaSpatial=4.5f;
    int kernelSize=7;
    vector_int iterCounts=std::vector<int>();
    Ptr<FastICPOdometry> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDistDiff"), maxDistDiff, ArgInfo("maxDistDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleThreshold"), angleThreshold, ArgInfo("angleThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaDepth"), sigmaDepth, ArgInfo("sigmaDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpatial"), sigmaSpatial, ArgInfo("sigmaSpatial", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kernelSize"), kernelSize, ArgInfo("kernelSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterCounts"), iterCounts, ArgInfo("iterCounts", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::FastICPOdometry::create(cameraMatrix, maxDistDiff, angleThreshold, sigmaDepth, sigmaSpatial, kernelSize, iterCounts), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_ICPOdometry_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    vector_int iterCounts=std::vector<int>();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<ICPOdometry> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDepth"), minDepth, ArgInfo("minDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDepth"), maxDepth, ArgInfo("maxDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDepthDiff"), maxDepthDiff, ArgInfo("maxDepthDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPointsPart"), maxPointsPart, ArgInfo("maxPointsPart", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterCounts"), iterCounts, ArgInfo("iterCounts", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::ICPOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, maxPointsPart, iterCounts, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_OdometryFrame_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat image;
    Mat depth;
    Mat mask;
    Mat normals;
    int ID=-1;
    Ptr<OdometryFrame> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normals"), normals, ArgInfo("normals", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iD"), ID, ArgInfo("ID", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::OdometryFrame::create(image, depth, mask, normals, ID), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_Odometry_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String odometryType;
    Ptr<Odometry> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "odometryType"), odometryType, ArgInfo("odometryType", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::Odometry::create(odometryType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_RgbdFrame_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat image;
    Mat depth;
    Mat mask;
    Mat normals;
    int ID=-1;
    Ptr<RgbdFrame> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normals"), normals, ArgInfo("normals", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iD"), ID, ArgInfo("ID", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::RgbdFrame::create(image, depth, mask, normals, ID), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_RgbdICPOdometry_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    vector_int iterCounts=std::vector<int>();
    vector_float minGradientMagnitudes=std::vector<float>();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<RgbdICPOdometry> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDepth"), minDepth, ArgInfo("minDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDepth"), maxDepth, ArgInfo("maxDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDepthDiff"), maxDepthDiff, ArgInfo("maxDepthDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPointsPart"), maxPointsPart, ArgInfo("maxPointsPart", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterCounts"), iterCounts, ArgInfo("iterCounts", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minGradientMagnitudes"), minGradientMagnitudes, ArgInfo("minGradientMagnitudes", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::RgbdICPOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, maxPointsPart, iterCounts, minGradientMagnitudes, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_RgbdNormals_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    int rows;
    int cols;
    int depth;
    Mat K;
    int window_size=5;
    int method=RgbdNormals::RGBD_NORMALS_METHOD_FALS;
    Ptr<RgbdNormals> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window_size"), window_size, ArgInfo("window_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::RgbdNormals::create(rows, cols, depth, K, window_size, method), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int rows;
    int cols;
    int depth;
    UMat K;
    int window_size=5;
    int method=RgbdNormals::RGBD_NORMALS_METHOD_FALS;
    Ptr<RgbdNormals> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "window_size"), window_size, ArgInfo("window_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::RgbdNormals::create(rows, cols, depth, K, window_size, method), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_RgbdOdometry_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat cameraMatrix;
    float minDepth=Odometry::DEFAULT_MIN_DEPTH();
    float maxDepth=Odometry::DEFAULT_MAX_DEPTH();
    float maxDepthDiff=Odometry::DEFAULT_MAX_DEPTH_DIFF();
    vector_int iterCounts=std::vector<int>();
    vector_float minGradientMagnitudes=std::vector<float>();
    float maxPointsPart=Odometry::DEFAULT_MAX_POINTS_PART();
    int transformType=Odometry::RIGID_BODY_MOTION;
    Ptr<RgbdOdometry> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minDepth"), minDepth, ArgInfo("minDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDepth"), maxDepth, ArgInfo("maxDepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxDepthDiff"), maxDepthDiff, ArgInfo("maxDepthDiff", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "iterCounts"), iterCounts, ArgInfo("iterCounts", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minGradientMagnitudes"), minGradientMagnitudes, ArgInfo("minGradientMagnitudes", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxPointsPart"), maxPointsPart, ArgInfo("maxPointsPart", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::RgbdOdometry::create(cameraMatrix, minDepth, maxDepth, maxDepthDiff, iterCounts, minGradientMagnitudes, maxPointsPart, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_RgbdPlane_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int method;
    int block_size;
    int min_size;
    double threshold;
    double sensor_error_a=0;
    double sensor_error_b=0;
    double sensor_error_c=0;
    Ptr<RgbdPlane> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "block_size"), block_size, ArgInfo("block_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_size"), min_size, ArgInfo("min_size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sensor_error_a"), sensor_error_a, ArgInfo("sensor_error_a", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sensor_error_b"), sensor_error_b, ArgInfo("sensor_error_b", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sensor_error_c"), sensor_error_c, ArgInfo("sensor_error_c", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::rgbd::RgbdPlane::create(method, block_size, min_size, threshold, sensor_error_a, sensor_error_b, sensor_error_c), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_depthTo3d(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat depth;
    Mat K;
    Mat points3d;
    Mat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points3d"), points3d, ArgInfo("points3d", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::depthTo3d(depth, K, points3d, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points3d);
        }
    }

    }
    

    {
    UMat depth;
    UMat K;
    UMat points3d;
    UMat mask;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points3d"), points3d, ArgInfo("points3d", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::depthTo3d(depth, K, points3d, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points3d);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_depthTo3dSparse(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat depth;
    Mat in_K;
    Mat in_points;
    Mat points3d;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "in_K"), in_K, ArgInfo("in_K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "in_points"), in_points, ArgInfo("in_points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points3d"), points3d, ArgInfo("points3d", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::depthTo3dSparse(depth, in_K, in_points, points3d), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points3d);
        }
    }

    }
    

    {
    UMat depth;
    UMat in_K;
    UMat in_points;
    UMat points3d;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "in_K"), in_K, ArgInfo("in_K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "in_points"), in_points, ArgInfo("in_points", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "points3d"), points3d, ArgInfo("points3d", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::depthTo3dSparse(depth, in_K, in_points, points3d), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, points3d);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_registerDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat unregisteredCameraMatrix;
    Mat registeredCameraMatrix;
    Mat registeredDistCoeffs;
    Mat Rt;
    Mat unregisteredDepth;
    Size outputImagePlaneSize;
    Mat registeredDepth;
    bool depthDilation=false;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "unregisteredCameraMatrix"), unregisteredCameraMatrix, ArgInfo("unregisteredCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "registeredCameraMatrix"), registeredCameraMatrix, ArgInfo("registeredCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "registeredDistCoeffs"), registeredDistCoeffs, ArgInfo("registeredDistCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rt"), Rt, ArgInfo("Rt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "unregisteredDepth"), unregisteredDepth, ArgInfo("unregisteredDepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputImagePlaneSize"), outputImagePlaneSize, ArgInfo("outputImagePlaneSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "registeredDepth"), registeredDepth, ArgInfo("registeredDepth", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depthDilation"), depthDilation, ArgInfo("depthDilation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::registerDepth(unregisteredCameraMatrix, registeredCameraMatrix, registeredDistCoeffs, Rt, unregisteredDepth, outputImagePlaneSize, registeredDepth, depthDilation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, registeredDepth);
        }
    }

    }
    

    {
    UMat unregisteredCameraMatrix;
    UMat registeredCameraMatrix;
    UMat registeredDistCoeffs;
    UMat Rt;
    UMat unregisteredDepth;
    Size outputImagePlaneSize;
    UMat registeredDepth;
    bool depthDilation=false;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "unregisteredCameraMatrix"), unregisteredCameraMatrix, ArgInfo("unregisteredCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "registeredCameraMatrix"), registeredCameraMatrix, ArgInfo("registeredCameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "registeredDistCoeffs"), registeredDistCoeffs, ArgInfo("registeredDistCoeffs", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rt"), Rt, ArgInfo("Rt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "unregisteredDepth"), unregisteredDepth, ArgInfo("unregisteredDepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "outputImagePlaneSize"), outputImagePlaneSize, ArgInfo("outputImagePlaneSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "registeredDepth"), registeredDepth, ArgInfo("registeredDepth", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depthDilation"), depthDilation, ArgInfo("depthDilation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::registerDepth(unregisteredCameraMatrix, registeredCameraMatrix, registeredDistCoeffs, Rt, unregisteredDepth, outputImagePlaneSize, registeredDepth, depthDilation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, registeredDepth);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_rescaleDepth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat in_;
    int depth;
    Mat out;
    double depth_factor=1000.0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "in_"), in_, ArgInfo("in_", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth_factor"), depth_factor, ArgInfo("depth_factor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::rescaleDepth(in_, depth, out, depth_factor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, out);
        }
    }

    }
    

    {
    UMat in_;
    int depth;
    UMat out;
    double depth_factor=1000.0;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "in_"), in_, ArgInfo("in_", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth_factor"), depth_factor, ArgInfo("depth_factor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::rescaleDepth(in_, depth, out, depth_factor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, out);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_rgbd_warpFrame(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::rgbd;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat depth;
    Mat mask;
    Mat Rt;
    Mat cameraMatrix;
    Mat distCoeff;
    Mat warpedImage;
    Mat warpedDepth;
    Mat warpedMask;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rt"), Rt, ArgInfo("Rt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeff"), distCoeff, ArgInfo("distCoeff", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpedImage"), warpedImage, ArgInfo("warpedImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpedDepth"), warpedDepth, ArgInfo("warpedDepth", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpedMask"), warpedMask, ArgInfo("warpedMask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::warpFrame(image, depth, mask, Rt, cameraMatrix, distCoeff, warpedImage, warpedDepth, warpedMask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, warpedImage), evision_from(env, warpedDepth), evision_from(env, warpedMask));
        }
    }

    }
    

    {
    Mat image;
    Mat depth;
    Mat mask;
    Mat Rt;
    Mat cameraMatrix;
    Mat distCoeff;
    UMat warpedImage;
    UMat warpedDepth;
    UMat warpedMask;

    if( num_kw_args >= 6 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "depth"), depth, ArgInfo("depth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rt"), Rt, ArgInfo("Rt", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cameraMatrix"), cameraMatrix, ArgInfo("cameraMatrix", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distCoeff"), distCoeff, ArgInfo("distCoeff", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpedImage"), warpedImage, ArgInfo("warpedImage", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpedDepth"), warpedDepth, ArgInfo("warpedDepth", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "warpedMask"), warpedMask, ArgInfo("warpedMask", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::rgbd::warpFrame(image, depth, mask, Rt, cameraMatrix, distCoeff, warpedImage, warpedDepth, warpedMask), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, warpedImage), evision_from(env, warpedDepth), evision_from(env, warpedMask));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_saliency_MotionSaliencyBinWangApr2014_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::saliency;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<MotionSaliencyBinWangApr2014> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::saliency::MotionSaliencyBinWangApr2014::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_saliency_ObjectnessBING_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::saliency;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<ObjectnessBING> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::saliency::ObjectnessBING::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_saliency_StaticSaliencyFineGrained_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::saliency;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<StaticSaliencyFineGrained> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::saliency::StaticSaliencyFineGrained::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_saliency_StaticSaliencySpectralResidual_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::saliency;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<StaticSaliencySpectralResidual> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::saliency::StaticSaliencySpectralResidual::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_samples_addSamplesDataSearchPath(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::samples;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String path;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "path"), path, ArgInfo("path", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::samples::addSamplesDataSearchPath(path), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_samples_addSamplesDataSearchSubDirectory(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::samples;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String subdir;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "subdir"), subdir, ArgInfo("subdir", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::samples::addSamplesDataSearchSubDirectory(subdir), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_samples_findFile(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::samples;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String relative_path;
    bool required=true;
    bool silentMode=false;
    cv::String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "relative_path"), relative_path, ArgInfo("relative_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "required"), required, ArgInfo("required", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "silentMode"), silentMode, ArgInfo("silentMode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::samples::findFile(relative_path, required, silentMode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_samples_findFileOrKeep(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::samples;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String relative_path;
    bool silentMode=false;
    cv::String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "relative_path"), relative_path, ArgInfo("relative_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "silentMode"), silentMode, ArgInfo("silentMode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::samples::findFileOrKeep(relative_path, silentMode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_stereo_QuasiDenseStereo_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::stereo;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Size monoImgSize;
    String paramFilepath=cv::String();
    cv::Ptr<QuasiDenseStereo> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "monoImgSize"), monoImgSize, ArgInfo("monoImgSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "paramFilepath"), paramFilepath, ArgInfo("paramFilepath", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::stereo::QuasiDenseStereo::create(monoImgSize, paramFilepath), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_structured_light_GrayCodePattern_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::structured_light;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int width;
    int height;
    Ptr<GrayCodePattern> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "width"), width, ArgInfo("width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "height"), height, ArgInfo("height", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::structured_light::GrayCodePattern::create(width, height), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_structured_light_SinusoidalPattern_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::structured_light;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SinusoidalPattern::Params> parameters=makePtr<SinusoidalPattern::Params>();
    Ptr<SinusoidalPattern> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "parameters"), parameters, ArgInfo("parameters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::structured_light::SinusoidalPattern::create(parameters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_OCRBeamSearchDecoder_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> classifier;
    std::string vocabulary;
    Mat transition_probabilities_table;
    Mat emission_probabilities_table;
    std::underlying_type_t<text_decoder_mode> mode=static_cast<std::underlying_type_t<text_decoder_mode>>(OCR_DECODER_VITERBI);
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transition_probabilities_table"), transition_probabilities_table, ArgInfo("transition_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "emission_probabilities_table"), emission_probabilities_table, ArgInfo("emission_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beam_size"), beam_size, ArgInfo("beam_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRBeamSearchDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, static_cast<text_decoder_mode>(mode), beam_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> classifier;
    std::string vocabulary;
    UMat transition_probabilities_table;
    UMat emission_probabilities_table;
    std::underlying_type_t<text_decoder_mode> mode=static_cast<std::underlying_type_t<text_decoder_mode>>(OCR_DECODER_VITERBI);
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transition_probabilities_table"), transition_probabilities_table, ArgInfo("transition_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "emission_probabilities_table"), emission_probabilities_table, ArgInfo("emission_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beam_size"), beam_size, ArgInfo("beam_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRBeamSearchDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, static_cast<text_decoder_mode>(mode), beam_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_OCRHMMDecoder_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    String vocabulary;
    Mat transition_probabilities_table;
    Mat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int classifier=OCR_KNN_CLASSIFIER;
    Ptr<OCRHMMDecoder> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transition_probabilities_table"), transition_probabilities_table, ArgInfo("transition_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "emission_probabilities_table"), emission_probabilities_table, ArgInfo("emission_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, classifier), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<OCRHMMDecoder::ClassifierCallback> classifier;
    String vocabulary;
    Mat transition_probabilities_table;
    Mat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    Ptr<OCRHMMDecoder> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transition_probabilities_table"), transition_probabilities_table, ArgInfo("transition_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "emission_probabilities_table"), emission_probabilities_table, ArgInfo("emission_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    String filename;
    String vocabulary;
    UMat transition_probabilities_table;
    UMat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    int classifier=OCR_KNN_CLASSIFIER;
    Ptr<OCRHMMDecoder> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transition_probabilities_table"), transition_probabilities_table, ArgInfo("transition_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "emission_probabilities_table"), emission_probabilities_table, ArgInfo("emission_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, classifier), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<OCRHMMDecoder::ClassifierCallback> classifier;
    String vocabulary;
    UMat transition_probabilities_table;
    UMat emission_probabilities_table;
    int mode=OCR_DECODER_VITERBI;
    Ptr<OCRHMMDecoder> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transition_probabilities_table"), transition_probabilities_table, ArgInfo("transition_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "emission_probabilities_table"), emission_probabilities_table, ArgInfo("emission_probabilities_table", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRHMMDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_OCRTesseract_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    char* datapath=0;
    char* language=0;
    char* char_whitelist=0;
    int oem=OEM_DEFAULT;
    int psmode=PSM_AUTO;
    Ptr<OCRTesseract> retval;

    if( convert_to_char(env, evision_get_kw(env, erl_terms, "datapath"), &datapath, ArgInfo("datapath", 0, 1)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "language"), &language, ArgInfo("language", 0, 1)) && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "char_whitelist"), &char_whitelist, ArgInfo("char_whitelist", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "oem"), oem, ArgInfo("oem", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "psmode"), psmode, ArgInfo("psmode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::OCRTesseract::create(datapath, language, char_whitelist, oem, psmode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_TextDetectorCNN_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String modelArchFilename;
    String modelWeightsFilename;
    Ptr<TextDetectorCNN> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "modelArchFilename"), modelArchFilename, ArgInfo("modelArchFilename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "modelWeightsFilename"), modelWeightsFilename, ArgInfo("modelWeightsFilename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::TextDetectorCNN::create(modelArchFilename, modelWeightsFilename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_computeNMChannels(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat _src;
    vector_Mat _channels;
    int _mode=ERFILTER_NM_RGBLGrad;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), _src, ArgInfo("_src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channels"), _channels, ArgInfo("_channels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), _mode, ArgInfo("_mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::computeNMChannels(_src, _channels, _mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, _channels);
        }
    }

    }
    

    {
    UMat _src;
    vector_UMat _channels;
    int _mode=ERFILTER_NM_RGBLGrad;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), _src, ArgInfo("_src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channels"), _channels, ArgInfo("_channels", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), _mode, ArgInfo("_mode", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::computeNMChannels(_src, _channels, _mode), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, _channels);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_createERFilterNM1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    int thresholdDelta=1;
    float minArea=(float)0.00025;
    float maxArea=(float)0.13;
    float minProbability=(float)0.4;
    bool nonMaxSuppression=true;
    float minProbabilityDiff=(float)0.1;
    Ptr<ERFilter> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresholdDelta"), thresholdDelta, ArgInfo("thresholdDelta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minArea"), minArea, ArgInfo("minArea", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxArea"), maxArea, ArgInfo("maxArea", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbability"), minProbability, ArgInfo("minProbability", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonMaxSuppression"), nonMaxSuppression, ArgInfo("nonMaxSuppression", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbabilityDiff"), minProbabilityDiff, ArgInfo("minProbabilityDiff", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::createERFilterNM1(filename, thresholdDelta, minArea, maxArea, minProbability, nonMaxSuppression, minProbabilityDiff), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<ERFilter::Callback> cb;
    int thresholdDelta=1;
    float minArea=(float)0.00025;
    float maxArea=(float)0.13;
    float minProbability=(float)0.4;
    bool nonMaxSuppression=true;
    float minProbabilityDiff=(float)0.1;
    Ptr<ERFilter> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cb"), cb, ArgInfo("cb", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresholdDelta"), thresholdDelta, ArgInfo("thresholdDelta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minArea"), minArea, ArgInfo("minArea", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxArea"), maxArea, ArgInfo("maxArea", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbability"), minProbability, ArgInfo("minProbability", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nonMaxSuppression"), nonMaxSuppression, ArgInfo("nonMaxSuppression", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbabilityDiff"), minProbabilityDiff, ArgInfo("minProbabilityDiff", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::createERFilterNM1(cb, thresholdDelta, minArea, maxArea, minProbability, nonMaxSuppression, minProbabilityDiff), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_createERFilterNM2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String filename;
    float minProbability=(float)0.3;
    Ptr<ERFilter> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbability"), minProbability, ArgInfo("minProbability", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::createERFilterNM2(filename, minProbability), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<ERFilter::Callback> cb;
    float minProbability=(float)0.3;
    Ptr<ERFilter> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cb"), cb, ArgInfo("cb", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbability"), minProbability, ArgInfo("minProbability", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::createERFilterNM2(cb, minProbability), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_createOCRHMMTransitionsTable(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String vocabulary;
    vector_String lexicon;
    Mat retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vocabulary"), vocabulary, ArgInfo("vocabulary", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lexicon"), lexicon, ArgInfo("lexicon", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::createOCRHMMTransitionsTable(vocabulary, lexicon), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_detectRegions(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Ptr<ERFilter> er_filter1;
    Ptr<ERFilter> er_filter2;
    vector_Rect groups_rects;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    String filename;
    float minProbability=(float)0.5;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter1"), er_filter1, ArgInfo("er_filter1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter2"), er_filter2, ArgInfo("er_filter2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbability"), minProbability, ArgInfo("minProbability", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::detectRegions(image, er_filter1, er_filter2, groups_rects, method, filename, minProbability), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, groups_rects);
        }
    }

    }
    

    {
    Mat image;
    Ptr<ERFilter> er_filter1;
    Ptr<ERFilter> er_filter2;
    vector_vector_Point regions;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter1"), er_filter1, ArgInfo("er_filter1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter2"), er_filter2, ArgInfo("er_filter2", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::detectRegions(image, er_filter1, er_filter2, regions), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, regions);
        }
    }

    }
    

    {
    UMat image;
    Ptr<ERFilter> er_filter1;
    Ptr<ERFilter> er_filter2;
    vector_Rect groups_rects;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    String filename;
    float minProbability=(float)0.5;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter1"), er_filter1, ArgInfo("er_filter1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter2"), er_filter2, ArgInfo("er_filter2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbability"), minProbability, ArgInfo("minProbability", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::detectRegions(image, er_filter1, er_filter2, groups_rects, method, filename, minProbability), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, groups_rects);
        }
    }

    }
    

    {
    UMat image;
    Ptr<ERFilter> er_filter1;
    Ptr<ERFilter> er_filter2;
    vector_vector_Point regions;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter1"), er_filter1, ArgInfo("er_filter1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "er_filter2"), er_filter2, ArgInfo("er_filter2", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::detectRegions(image, er_filter1, er_filter2, regions), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, regions);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_detectTextSWT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat input;
    vector_Rect result;
    bool dark_on_light;
    Mat draw;
    Mat chainBBs;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dark_on_light"), dark_on_light, ArgInfo("dark_on_light", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "draw"), draw, ArgInfo("draw", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chainBBs"), chainBBs, ArgInfo("chainBBs", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::detectTextSWT(input, result, dark_on_light, draw, chainBBs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, result), evision_from(env, draw), evision_from(env, chainBBs));
        }
    }

    }
    

    {
    UMat input;
    vector_Rect result;
    bool dark_on_light;
    UMat draw;
    UMat chainBBs;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "input"), input, ArgInfo("input", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dark_on_light"), dark_on_light, ArgInfo("dark_on_light", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "draw"), draw, ArgInfo("draw", 1, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "chainBBs"), chainBBs, ArgInfo("chainBBs", 1, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::detectTextSWT(input, result, dark_on_light, draw, chainBBs), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, result), evision_from(env, draw), evision_from(env, chainBBs));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_erGrouping(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat channel;
    vector_vector_Point regions;
    vector_Rect groups_rects;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    String filename;
    float minProbablity=(float)0.5;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channel"), channel, ArgInfo("channel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "regions"), regions, ArgInfo("regions", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbablity"), minProbablity, ArgInfo("minProbablity", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::erGrouping(image, channel, regions, groups_rects, method, filename, minProbablity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, groups_rects);
        }
    }

    }
    

    {
    UMat image;
    UMat channel;
    vector_vector_Point regions;
    vector_Rect groups_rects;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    String filename;
    float minProbablity=(float)0.5;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "channel"), channel, ArgInfo("channel", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "regions"), regions, ArgInfo("regions", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "method"), method, ArgInfo("method", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minProbablity"), minProbablity, ArgInfo("minProbablity", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::text::erGrouping(image, channel, regions, groups_rects, method, filename, minProbablity), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, groups_rects);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_loadClassifierNM1(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    Ptr<ERFilter::Callback> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::loadClassifierNM1(filename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_loadClassifierNM2(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    Ptr<ERFilter::Callback> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::loadClassifierNM2(filename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_loadOCRBeamSearchClassifierCNN(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::loadOCRBeamSearchClassifierCNN(filename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_loadOCRHMMClassifier(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    int classifier;
    Ptr<OCRHMMDecoder::ClassifierCallback> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "classifier"), classifier, ArgInfo("classifier", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::loadOCRHMMClassifier(filename, classifier), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_loadOCRHMMClassifierCNN(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    Ptr<OCRHMMDecoder::ClassifierCallback> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::loadOCRHMMClassifierCNN(filename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_text_loadOCRHMMClassifierNM(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::text;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String filename;
    Ptr<OCRHMMDecoder::ClassifierCallback> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "filename"), filename, ArgInfo("filename", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::text::loadOCRHMMClassifierNM(filename), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_copyMatAndDumpNamedArguments(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    Ptr<FunctionParams> ptr_params;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), ptr_params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
            FunctionParams params; if (ptr_params.get()) { params = *ptr_params.get(); }
    
        ERRWRAP2(retval = cv::utils::copyMatAndDumpNamedArguments(src, dst, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    Ptr<FunctionParams> ptr_params;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), ptr_params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
            FunctionParams params; if (ptr_params.get()) { params = *ptr_params.get(); }
    
        ERRWRAP2(retval = cv::utils::copyMatAndDumpNamedArguments(src, dst, params), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpBool(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpBool(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpCString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    char* argument=(char*)"";
    String retval;

    if( num_kw_args >= 1 && 
        convert_to_char(env, evision_get_kw(env, erl_terms, "argument"), &argument, ArgInfo("argument", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpCString(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpDouble(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpDouble(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpFloat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpFloat(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpInputArray(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputArray(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputArray(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpInputArrayOfArrays(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputArrayOfArrays(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_UMat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputArrayOfArrays(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpInputOutputArray(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputOutputArray(argument), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, argument));
        }
    }

    }
    

    {
    UMat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputOutputArray(argument), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, argument));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpInputOutputArrayOfArrays(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Mat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputOutputArrayOfArrays(argument), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, argument));
        }
    }

    }
    

    {
    vector_UMat argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInputOutputArrayOfArrays(argument), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, argument));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInt(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpInt64(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int64 argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpInt64(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpRange(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Range argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpRange(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Rect argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpRect(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpRotatedRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    RotatedRect argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpRotatedRect(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpSizeT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    size_t argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpSizeT(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpString(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpString(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpTermCriteria(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    TermCriteria argument;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpTermCriteria(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpVec2i(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Vec2i value=cv::Vec2i(42, 24);
    String retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpVec2i(value), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpVectorOfDouble(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_double vec;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vec"), vec, ArgInfo("vec", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpVectorOfDouble(vec), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpVectorOfInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_int vec;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vec"), vec, ArgInfo("vec", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpVectorOfInt(vec), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_dumpVectorOfRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Rect vec;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vec"), vec, ArgInfo("vec", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::dumpVectorOfRect(vec), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_generateVectorOfInt(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    size_t len;
    vector_int vec;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::utils::generateVectorOfInt(len, vec), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, vec);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_generateVectorOfMat(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    size_t len;
    int rows;
    int cols;
    int dtype;
    vector_Mat vec;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rows"), rows, ArgInfo("rows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "cols"), cols, ArgInfo("cols", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dtype"), dtype, ArgInfo("dtype", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "vec"), vec, ArgInfo("vec", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::utils::generateVectorOfMat(len, rows, cols, dtype, vec), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, vec);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_generateVectorOfRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    size_t len;
    vector_Rect vec;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "len"), len, ArgInfo("len", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::utils::generateVectorOfRect(len, vec), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, vec);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testAsyncArray(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat argument;
    AsyncArray retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testAsyncArray(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat argument;
    AsyncArray retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testAsyncArray(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testAsyncException(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    AsyncArray retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testAsyncException(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testOverloadResolution(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Rect rect;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rect"), rect, ArgInfo("rect", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testOverloadResolution(rect), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int value;
    Point point=Point(42, 24);
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "value"), value, ArgInfo("value", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "point"), point, ArgInfo("point", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testOverloadResolution(value, point), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testOverwriteNativeMethod(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int argument;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "argument"), argument, ArgInfo("argument", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testOverwriteNativeMethod(argument), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testRaiseGeneralException(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(cv::utils::testRaiseGeneralException(), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testReservedKeywordConversion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int positional_argument;
    int lambda=2;
    int from=3;
    String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "positional_argument"), positional_argument, ArgInfo("positional_argument", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "from"), from, ArgInfo("from", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testReservedKeywordConversion(positional_argument, lambda, from), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testRotatedRect(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float x;
    float y;
    float w;
    float h;
    float angle;
    RotatedRect retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "w"), w, ArgInfo("w", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testRotatedRect(x, y, w, h, angle), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_testRotatedRectVector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float x;
    float y;
    float w;
    float h;
    float angle;
    std::vector<RotatedRect> retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "x"), x, ArgInfo("x", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "y"), y, ArgInfo("y", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "w"), w, ArgInfo("w", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angle"), angle, ArgInfo("angle", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::testRotatedRectVector(x, y, w, h, angle), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_fs_getCacheDirectoryForDownloads(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::fs;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    cv::String retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::fs::getCacheDirectoryForDownloads(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_ExportClassName_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    OriginalClassName_Params params=OriginalClassName::Params();
    Ptr<OriginalClassName> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::nested::OriginalClassName::create(params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_ExportClassName_originalName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::nested::OriginalClassName::originalName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_OriginalClassName_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    OriginalClassName_Params params=OriginalClassName::Params();
    Ptr<OriginalClassName> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "params"), params, ArgInfo("params", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::nested::OriginalClassName::create(params), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_OriginalClassName_originalName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::string retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::nested::OriginalClassName::originalName(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_utils_nested_testEchoBooleanFunction(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::utils::nested;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool flag;
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flag"), flag, ArgInfo("flag", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::utils::nested::testEchoBooleanFunction(flag), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getBackendName(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VideoCaptureAPIs> api=static_cast<std::underlying_type_t<VideoCaptureAPIs>>(static_cast<VideoCaptureAPIs>(0));
    cv::String retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "api"), api, ArgInfo("api", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getBackendName(static_cast<VideoCaptureAPIs>(api)), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getBackends(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::vector<VideoCaptureAPIs> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getBackends(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getCameraBackendPluginVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VideoCaptureAPIs> api=static_cast<std::underlying_type_t<VideoCaptureAPIs>>(static_cast<VideoCaptureAPIs>(0));
    int version_ABI;
    int version_API;
    std::string retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "api"), api, ArgInfo("api", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getCameraBackendPluginVersion(static_cast<VideoCaptureAPIs>(api), version_ABI, version_API), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, version_ABI), evision_from(env, version_API));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getCameraBackends(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::vector<VideoCaptureAPIs> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getCameraBackends(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getStreamBackendPluginVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VideoCaptureAPIs> api=static_cast<std::underlying_type_t<VideoCaptureAPIs>>(static_cast<VideoCaptureAPIs>(0));
    int version_ABI;
    int version_API;
    std::string retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "api"), api, ArgInfo("api", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getStreamBackendPluginVersion(static_cast<VideoCaptureAPIs>(api), version_ABI, version_API), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, version_ABI), evision_from(env, version_API));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getStreamBackends(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::vector<VideoCaptureAPIs> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getStreamBackends(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getWriterBackendPluginVersion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VideoCaptureAPIs> api=static_cast<std::underlying_type_t<VideoCaptureAPIs>>(static_cast<VideoCaptureAPIs>(0));
    int version_ABI;
    int version_API;
    std::string retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "api"), api, ArgInfo("api", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getWriterBackendPluginVersion(static_cast<VideoCaptureAPIs>(api), version_ABI, version_API), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple3(env, evision_from(env, retval), evision_from(env, version_ABI), evision_from(env, version_API));
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_getWriterBackends(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::vector<VideoCaptureAPIs> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::getWriterBackends(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_hasBackend(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VideoCaptureAPIs> api=static_cast<std::underlying_type_t<VideoCaptureAPIs>>(static_cast<VideoCaptureAPIs>(0));
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "api"), api, ArgInfo("api", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::hasBackend(static_cast<VideoCaptureAPIs>(api)), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_videoio_registry_isBackendBuiltIn(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::videoio_registry;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    std::underlying_type_t<VideoCaptureAPIs> api=static_cast<std::underlying_type_t<VideoCaptureAPIs>>(static_cast<VideoCaptureAPIs>(0));
    bool retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "api"), api, ArgInfo("api", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::videoio_registry::isBackendBuiltIn(static_cast<VideoCaptureAPIs>(api)), env, error_flag, error_term);
        if (!error_flag) {
            if (retval) {
                return evision::nif::atom(env, "true");
            } else {
                return evision::nif::atom(env, "false");
            };
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_BEBLID_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float scale_factor;
    int n_bits=BEBLID::SIZE_512_BITS;
    Ptr<BEBLID> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale_factor"), scale_factor, ArgInfo("scale_factor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "n_bits"), n_bits, ArgInfo("n_bits", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::BEBLID::create(scale_factor, n_bits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_BoostDesc_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int desc=BoostDesc::BINBOOST_256;
    bool use_scale_orientation=true;
    float scale_factor=6.25f;
    Ptr<BoostDesc> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "desc"), desc, ArgInfo("desc", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "use_scale_orientation"), use_scale_orientation, ArgInfo("use_scale_orientation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale_factor"), scale_factor, ArgInfo("scale_factor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::BoostDesc::create(desc, use_scale_orientation, scale_factor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_BriefDescriptorExtractor_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int bytes=32;
    bool use_orientation=false;
    Ptr<BriefDescriptorExtractor> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bytes"), bytes, ArgInfo("bytes", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "use_orientation"), use_orientation, ArgInfo("use_orientation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::BriefDescriptorExtractor::create(bytes, use_orientation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_DAISY_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    float radius=15;
    int q_radius=3;
    int q_theta=8;
    int q_hist=8;
    std::underlying_type_t<DAISY_NormalizationType> norm=static_cast<std::underlying_type_t<DAISY_NormalizationType>>(DAISY::NRM_NONE);
    Mat H;
    bool interpolation=true;
    bool use_orientation=false;
    Ptr<DAISY> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q_radius"), q_radius, ArgInfo("q_radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q_theta"), q_theta, ArgInfo("q_theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q_hist"), q_hist, ArgInfo("q_hist", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "norm"), norm, ArgInfo("norm", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), H, ArgInfo("H", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interpolation"), interpolation, ArgInfo("interpolation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "use_orientation"), use_orientation, ArgInfo("use_orientation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::DAISY::create(radius, q_radius, q_theta, q_hist, static_cast<DAISY_NormalizationType>(norm), H, interpolation, use_orientation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    float radius=15;
    int q_radius=3;
    int q_theta=8;
    int q_hist=8;
    std::underlying_type_t<DAISY_NormalizationType> norm=static_cast<std::underlying_type_t<DAISY_NormalizationType>>(DAISY::NRM_NONE);
    UMat H;
    bool interpolation=true;
    bool use_orientation=false;
    Ptr<DAISY> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q_radius"), q_radius, ArgInfo("q_radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q_theta"), q_theta, ArgInfo("q_theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "q_hist"), q_hist, ArgInfo("q_hist", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "norm"), norm, ArgInfo("norm", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), H, ArgInfo("H", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "interpolation"), interpolation, ArgInfo("interpolation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "use_orientation"), use_orientation, ArgInfo("use_orientation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::DAISY::create(radius, q_radius, q_theta, q_hist, static_cast<DAISY_NormalizationType>(norm), H, interpolation, use_orientation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_FREAK_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool orientationNormalized=true;
    bool scaleNormalized=true;
    float patternScale=22.0f;
    int nOctaves=4;
    vector_int selectedPairs=std::vector<int>();
    Ptr<FREAK> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "orientationNormalized"), orientationNormalized, ArgInfo("orientationNormalized", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scaleNormalized"), scaleNormalized, ArgInfo("scaleNormalized", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "patternScale"), patternScale, ArgInfo("patternScale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), nOctaves, ArgInfo("nOctaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "selectedPairs"), selectedPairs, ArgInfo("selectedPairs", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::FREAK::create(orientationNormalized, scaleNormalized, patternScale, nOctaves, selectedPairs), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_HarrisLaplaceFeatureDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int numOctaves=6;
    float corn_thresh=0.01f;
    float DOG_thresh=0.01f;
    int maxCorners=5000;
    int num_layers=4;
    Ptr<HarrisLaplaceFeatureDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "numOctaves"), numOctaves, ArgInfo("numOctaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "corn_thresh"), corn_thresh, ArgInfo("corn_thresh", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dOG_thresh"), DOG_thresh, ArgInfo("DOG_thresh", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxCorners"), maxCorners, ArgInfo("maxCorners", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_layers"), num_layers, ArgInfo("num_layers", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::HarrisLaplaceFeatureDetector::create(numOctaves, corn_thresh, DOG_thresh, maxCorners, num_layers), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_LATCH_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int bytes=32;
    bool rotationInvariance=true;
    int half_ssd_size=3;
    double sigma=2.0;
    Ptr<LATCH> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "bytes"), bytes, ArgInfo("bytes", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rotationInvariance"), rotationInvariance, ArgInfo("rotationInvariance", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "half_ssd_size"), half_ssd_size, ArgInfo("half_ssd_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::LATCH::create(bytes, rotationInvariance, half_ssd_size, sigma), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_LUCID_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int lucid_kernel=1;
    int blur_kernel=2;
    Ptr<LUCID> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "lucid_kernel"), lucid_kernel, ArgInfo("lucid_kernel", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blur_kernel"), blur_kernel, ArgInfo("blur_kernel", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::LUCID::create(lucid_kernel, blur_kernel), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_MSDDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int m_patch_radius=3;
    int m_search_area_radius=5;
    int m_nms_radius=5;
    int m_nms_scale_radius=0;
    float m_th_saliency=250.0f;
    int m_kNN=4;
    float m_scale_factor=1.25f;
    int m_n_scales=-1;
    bool m_compute_orientation=false;
    Ptr<MSDDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "m_patch_radius"), m_patch_radius, ArgInfo("m_patch_radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_search_area_radius"), m_search_area_radius, ArgInfo("m_search_area_radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_nms_radius"), m_nms_radius, ArgInfo("m_nms_radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_nms_scale_radius"), m_nms_scale_radius, ArgInfo("m_nms_scale_radius", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_th_saliency"), m_th_saliency, ArgInfo("m_th_saliency", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_kNN"), m_kNN, ArgInfo("m_kNN", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_scale_factor"), m_scale_factor, ArgInfo("m_scale_factor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_n_scales"), m_n_scales, ArgInfo("m_n_scales", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "m_compute_orientation"), m_compute_orientation, ArgInfo("m_compute_orientation", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::MSDDetector::create(m_patch_radius, m_search_area_radius, m_nms_radius, m_nms_scale_radius, m_th_saliency, m_kNN, m_scale_factor, m_n_scales, m_compute_orientation), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_PCTSignaturesSQFD_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int distanceFunction=3;
    int similarityFunction=2;
    float similarityParameter=1.0f;
    Ptr<PCTSignaturesSQFD> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "distanceFunction"), distanceFunction, ArgInfo("distanceFunction", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "similarityFunction"), similarityFunction, ArgInfo("similarityFunction", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "similarityParameter"), similarityParameter, ArgInfo("similarityParameter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignaturesSQFD::create(distanceFunction, similarityFunction, similarityParameter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_PCTSignatures_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    vector_Point2f initSamplingPoints;
    vector_int initClusterSeedIndexes;
    Ptr<PCTSignatures> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "initSamplingPoints"), initSamplingPoints, ArgInfo("initSamplingPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "initClusterSeedIndexes"), initClusterSeedIndexes, ArgInfo("initClusterSeedIndexes", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignatures::create(initSamplingPoints, initClusterSeedIndexes), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    vector_Point2f initSamplingPoints;
    int initSeedCount;
    Ptr<PCTSignatures> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "initSamplingPoints"), initSamplingPoints, ArgInfo("initSamplingPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "initSeedCount"), initSeedCount, ArgInfo("initSeedCount", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignatures::create(initSamplingPoints, initSeedCount), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    int initSampleCount=2000;
    int initSeedCount=400;
    int pointDistribution=0;
    Ptr<PCTSignatures> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "initSampleCount"), initSampleCount, ArgInfo("initSampleCount", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "initSeedCount"), initSeedCount, ArgInfo("initSeedCount", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointDistribution"), pointDistribution, ArgInfo("pointDistribution", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::PCTSignatures::create(initSampleCount, initSeedCount, pointDistribution), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_PCTSignatures_drawSignature(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat source;
    Mat signature;
    Mat result;
    float radiusToShorterSideRatio=1.0 / 8;
    int borderThickness=1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "source"), source, ArgInfo("source", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signature"), signature, ArgInfo("signature", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radiusToShorterSideRatio"), radiusToShorterSideRatio, ArgInfo("radiusToShorterSideRatio", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderThickness"), borderThickness, ArgInfo("borderThickness", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xfeatures2d::PCTSignatures::drawSignature(source, signature, result, radiusToShorterSideRatio, borderThickness), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }
    

    {
    UMat source;
    UMat signature;
    UMat result;
    float radiusToShorterSideRatio=1.0 / 8;
    int borderThickness=1;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "source"), source, ArgInfo("source", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "signature"), signature, ArgInfo("signature", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radiusToShorterSideRatio"), radiusToShorterSideRatio, ArgInfo("radiusToShorterSideRatio", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderThickness"), borderThickness, ArgInfo("borderThickness", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xfeatures2d::PCTSignatures::drawSignature(source, signature, result, radiusToShorterSideRatio, borderThickness), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_PCTSignatures_generateInitPoints(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_Point2f initPoints;
    int count;
    int pointDistribution;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "initPoints"), initPoints, ArgInfo("initPoints", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "count"), count, ArgInfo("count", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "pointDistribution"), pointDistribution, ArgInfo("pointDistribution", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xfeatures2d::PCTSignatures::generateInitPoints(initPoints, count, pointDistribution), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_SIFT_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int nfeatures=0;
    int nOctaveLayers=3;
    double contrastThreshold=0.04;
    double edgeThreshold=10;
    double sigma=1.6;
    Ptr<cv::SIFT> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "nfeatures"), nfeatures, ArgInfo("nfeatures", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contrastThreshold"), contrastThreshold, ArgInfo("contrastThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeThreshold"), edgeThreshold, ArgInfo("edgeThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::SIFT_create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_SURF_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double hessianThreshold=100;
    int nOctaves=4;
    int nOctaveLayers=3;
    bool extended=false;
    bool upright=false;
    Ptr<SURF> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "hessianThreshold"), hessianThreshold, ArgInfo("hessianThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaves"), nOctaves, ArgInfo("nOctaves", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nOctaveLayers"), nOctaveLayers, ArgInfo("nOctaveLayers", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "extended"), extended, ArgInfo("extended", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "upright"), upright, ArgInfo("upright", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::SURF::create(hessianThreshold, nOctaves, nOctaveLayers, extended, upright), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_StarDetector_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int maxSize=45;
    int responseThreshold=30;
    int lineThresholdProjected=10;
    int lineThresholdBinarized=8;
    int suppressNonmaxSize=5;
    Ptr<StarDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "maxSize"), maxSize, ArgInfo("maxSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "responseThreshold"), responseThreshold, ArgInfo("responseThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineThresholdProjected"), lineThresholdProjected, ArgInfo("lineThresholdProjected", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lineThresholdBinarized"), lineThresholdBinarized, ArgInfo("lineThresholdBinarized", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "suppressNonmaxSize"), suppressNonmaxSize, ArgInfo("suppressNonmaxSize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::StarDetector::create(maxSize, responseThreshold, lineThresholdProjected, lineThresholdBinarized, suppressNonmaxSize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_TBMR_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int min_area=60;
    float max_area_relative=0.01f;
    float scale_factor=1.25f;
    int n_scales=-1;
    Ptr<TBMR> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "min_area"), min_area, ArgInfo("min_area", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_area_relative"), max_area_relative, ArgInfo("max_area_relative", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale_factor"), scale_factor, ArgInfo("scale_factor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "n_scales"), n_scales, ArgInfo("n_scales", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::TBMR::create(min_area, max_area_relative, scale_factor, n_scales), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_TEBLID_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float scale_factor;
    int n_bits=TEBLID::SIZE_256_BITS;
    Ptr<TEBLID> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale_factor"), scale_factor, ArgInfo("scale_factor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "n_bits"), n_bits, ArgInfo("n_bits", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::TEBLID::create(scale_factor, n_bits), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_VGG_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int desc=VGG::VGG_120;
    float isigma=1.4f;
    bool img_normalize=true;
    bool use_scale_orientation=true;
    float scale_factor=6.25f;
    bool dsc_normalize=false;
    Ptr<VGG> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "desc"), desc, ArgInfo("desc", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "isigma"), isigma, ArgInfo("isigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img_normalize"), img_normalize, ArgInfo("img_normalize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "use_scale_orientation"), use_scale_orientation, ArgInfo("use_scale_orientation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale_factor"), scale_factor, ArgInfo("scale_factor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dsc_normalize"), dsc_normalize, ArgInfo("dsc_normalize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xfeatures2d::VGG::create(desc, isigma, img_normalize, use_scale_orientation, scale_factor, dsc_normalize), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_matchGMS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Size size1;
    Size size2;
    vector_KeyPoint keypoints1;
    vector_KeyPoint keypoints2;
    vector_DMatch matches1to2;
    vector_DMatch matchesGMS;
    bool withRotation=false;
    bool withScale=false;
    double thresholdFactor=6.0;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size1"), size1, ArgInfo("size1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size2"), size2, ArgInfo("size2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "withRotation"), withRotation, ArgInfo("withRotation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "withScale"), withScale, ArgInfo("withScale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresholdFactor"), thresholdFactor, ArgInfo("thresholdFactor", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xfeatures2d::matchGMS(size1, size2, keypoints1, keypoints2, matches1to2, matchesGMS, withRotation, withScale, thresholdFactor), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, matchesGMS);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xfeatures2d_matchLOGOS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xfeatures2d;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    vector_KeyPoint keypoints1;
    vector_KeyPoint keypoints2;
    vector_int nn1;
    vector_int nn2;
    vector_DMatch matches1to2;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints1"), keypoints1, ArgInfo("keypoints1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "keypoints2"), keypoints2, ArgInfo("keypoints2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nn1"), nn1, ArgInfo("nn1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nn2"), nn2, ArgInfo("nn2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matches1to2"), matches1to2, ArgInfo("matches1to2", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xfeatures2d::matchLOGOS(keypoints1, keypoints2, nn1, nn2, matches1to2), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_AdaptiveManifoldFilter_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<AdaptiveManifoldFilter> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::AdaptiveManifoldFilter::create(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_FastHoughTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int dstMatDepth;
    int angleRange=ARO_315_135;
    int op=FHT_ADD;
    int makeSkew=HDO_DESKEW;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstMatDepth"), dstMatDepth, ArgInfo("dstMatDepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleRange"), angleRange, ArgInfo("angleRange", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "makeSkew"), makeSkew, ArgInfo("makeSkew", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::FastHoughTransform(src, dst, dstMatDepth, angleRange, op, makeSkew), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int dstMatDepth;
    int angleRange=ARO_315_135;
    int op=FHT_ADD;
    int makeSkew=HDO_DESKEW;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstMatDepth"), dstMatDepth, ArgInfo("dstMatDepth", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleRange"), angleRange, ArgInfo("angleRange", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "makeSkew"), makeSkew, ArgInfo("makeSkew", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::FastHoughTransform(src, dst, dstMatDepth, angleRange, op, makeSkew), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_GradientDericheX(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat op;
    Mat dst;
    double alpha;
    double omega;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "omega"), omega, ArgInfo("omega", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::GradientDericheX(op, dst, alpha, omega), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat op;
    UMat dst;
    double alpha;
    double omega;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "omega"), omega, ArgInfo("omega", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::GradientDericheX(op, dst, alpha, omega), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_GradientDericheY(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat op;
    Mat dst;
    double alpha;
    double omega;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "omega"), omega, ArgInfo("omega", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::GradientDericheY(op, dst, alpha, omega), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat op;
    UMat dst;
    double alpha;
    double omega;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "op"), op, ArgInfo("op", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "omega"), omega, ArgInfo("omega", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::GradientDericheY(op, dst, alpha, omega), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_HoughPoint2Line(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Point houghPoint;
    Mat srcImgInfo;
    int angleRange=ARO_315_135;
    int makeSkew=HDO_DESKEW;
    int rules=RO_IGNORE_BORDERS;
    Vec4i retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "houghPoint"), houghPoint, ArgInfo("houghPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgInfo"), srcImgInfo, ArgInfo("srcImgInfo", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleRange"), angleRange, ArgInfo("angleRange", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "makeSkew"), makeSkew, ArgInfo("makeSkew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rules"), rules, ArgInfo("rules", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::HoughPoint2Line(houghPoint, srcImgInfo, angleRange, makeSkew, rules), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Point houghPoint;
    UMat srcImgInfo;
    int angleRange=ARO_315_135;
    int makeSkew=HDO_DESKEW;
    int rules=RO_IGNORE_BORDERS;
    Vec4i retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "houghPoint"), houghPoint, ArgInfo("houghPoint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "srcImgInfo"), srcImgInfo, ArgInfo("srcImgInfo", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "angleRange"), angleRange, ArgInfo("angleRange", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "makeSkew"), makeSkew, ArgInfo("makeSkew", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rules"), rules, ArgInfo("rules", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::HoughPoint2Line(houghPoint, srcImgInfo, angleRange, makeSkew, rules), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_PeiLinNormalization(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat I;
    Mat T;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "i"), I, ArgInfo("I", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::PeiLinNormalization(I, T), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, T);
        }
    }

    }
    

    {
    UMat I;
    UMat T;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "i"), I, ArgInfo("I", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), T, ArgInfo("T", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::PeiLinNormalization(I, T), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, T);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_RadonTransform(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double theta=1;
    double start_angle=0;
    double end_angle=180;
    bool crop=false;
    bool norm=false;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "start_angle"), start_angle, ArgInfo("start_angle", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "end_angle"), end_angle, ArgInfo("end_angle", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "norm"), norm, ArgInfo("norm", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::RadonTransform(src, dst, theta, start_angle, end_angle, crop, norm), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    double theta=1;
    double start_angle=0;
    double end_angle=180;
    bool crop=false;
    bool norm=false;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "theta"), theta, ArgInfo("theta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "start_angle"), start_angle, ArgInfo("start_angle", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "end_angle"), end_angle, ArgInfo("end_angle", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "crop"), crop, ArgInfo("crop", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "norm"), norm, ArgInfo("norm", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::RadonTransform(src, dst, theta, start_angle, end_angle, crop, norm), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_RidgeDetectionFilter_create(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int ddepth=CV_32FC1;
    int dx=1;
    int dy=1;
    int ksize=3;
    int out_dtype=CV_8UC1;
    double scale=1;
    double delta=0;
    int borderType=BORDER_DEFAULT;
    Ptr<RidgeDetectionFilter> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "ddepth"), ddepth, ArgInfo("ddepth", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dx"), dx, ArgInfo("dx", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dy"), dy, ArgInfo("dy", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ksize"), ksize, ArgInfo("ksize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out_dtype"), out_dtype, ArgInfo("out_dtype", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "delta"), delta, ArgInfo("delta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::RidgeDetectionFilter::create(ddepth, dx, dy, ksize, out_dtype, scale, delta, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_amFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat joint;
    Mat src;
    Mat dst;
    double sigma_s;
    double sigma_r;
    bool adjust_outliers=false;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "joint"), joint, ArgInfo("joint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "adjust_outliers"), adjust_outliers, ArgInfo("adjust_outliers", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::amFilter(joint, src, dst, sigma_s, sigma_r, adjust_outliers), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat joint;
    UMat src;
    UMat dst;
    double sigma_s;
    double sigma_r;
    bool adjust_outliers=false;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "joint"), joint, ArgInfo("joint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "adjust_outliers"), adjust_outliers, ArgInfo("adjust_outliers", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::amFilter(joint, src, dst, sigma_s, sigma_r, adjust_outliers), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_anisotropicDiffusion(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    float alpha;
    float K;
    int niters;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "niters"), niters, ArgInfo("niters", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::anisotropicDiffusion(src, dst, alpha, K, niters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    float alpha;
    float K;
    int niters;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), K, ArgInfo("K", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "niters"), niters, ArgInfo("niters", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::anisotropicDiffusion(src, dst, alpha, K, niters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_bilateralTextureFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int fr=3;
    int numIter=1;
    double sigmaAlpha=-1.;
    double sigmaAvg=-1.;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fr"), fr, ArgInfo("fr", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIter"), numIter, ArgInfo("numIter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaAlpha"), sigmaAlpha, ArgInfo("sigmaAlpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaAvg"), sigmaAvg, ArgInfo("sigmaAvg", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::bilateralTextureFilter(src, dst, fr, numIter, sigmaAlpha, sigmaAvg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int fr=3;
    int numIter=1;
    double sigmaAlpha=-1.;
    double sigmaAvg=-1.;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fr"), fr, ArgInfo("fr", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIter"), numIter, ArgInfo("numIter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaAlpha"), sigmaAlpha, ArgInfo("sigmaAlpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaAvg"), sigmaAvg, ArgInfo("sigmaAvg", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::bilateralTextureFilter(src, dst, fr, numIter, sigmaAlpha, sigmaAvg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_colorMatchTemplate(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat templ;
    Mat result;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templ"), templ, ArgInfo("templ", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::colorMatchTemplate(img, templ, result), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }
    

    {
    UMat img;
    UMat templ;
    UMat result;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templ"), templ, ArgInfo("templ", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "result"), result, ArgInfo("result", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::colorMatchTemplate(img, templ, result), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, result);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_computeBadPixelPercent(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat GT;
    Mat src;
    Rect ROI;
    int thresh=24;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gT"), GT, ArgInfo("GT", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rOI"), ROI, ArgInfo("ROI", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::computeBadPixelPercent(GT, src, ROI, thresh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat GT;
    UMat src;
    Rect ROI;
    int thresh=24;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gT"), GT, ArgInfo("GT", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rOI"), ROI, ArgInfo("ROI", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thresh"), thresh, ArgInfo("thresh", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::computeBadPixelPercent(GT, src, ROI, thresh), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_computeMSE(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat GT;
    Mat src;
    Rect ROI;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gT"), GT, ArgInfo("GT", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rOI"), ROI, ArgInfo("ROI", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::computeMSE(GT, src, ROI), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat GT;
    UMat src;
    Rect ROI;
    double retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gT"), GT, ArgInfo("GT", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "rOI"), ROI, ArgInfo("ROI", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::computeMSE(GT, src, ROI), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_contourSampling(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat out;
    int nbElt;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbElt"), nbElt, ArgInfo("nbElt", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::contourSampling(src, out, nbElt), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, out);
        }
    }

    }
    

    {
    UMat src;
    UMat out;
    int nbElt;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "out"), out, ArgInfo("out", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbElt"), nbElt, ArgInfo("nbElt", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::contourSampling(src, out, nbElt), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, out);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_covarianceEstimation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int windowRows;
    int windowCols;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowRows"), windowRows, ArgInfo("windowRows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowCols"), windowCols, ArgInfo("windowCols", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::covarianceEstimation(src, dst, windowRows, windowCols), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int windowRows;
    int windowCols;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowRows"), windowRows, ArgInfo("windowRows", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "windowCols"), windowCols, ArgInfo("windowCols", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::covarianceEstimation(src, dst, windowRows, windowCols), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createAMFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double sigma_s;
    double sigma_r;
    bool adjust_outliers=false;
    Ptr<AdaptiveManifoldFilter> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_s"), sigma_s, ArgInfo("sigma_s", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_r"), sigma_r, ArgInfo("sigma_r", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "adjust_outliers"), adjust_outliers, ArgInfo("adjust_outliers", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createAMFilter(sigma_s, sigma_r, adjust_outliers), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createContourFitting(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int ctr=1024;
    int fd=16;
    Ptr<ContourFitting> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "ctr"), ctr, ArgInfo("ctr", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fd"), fd, ArgInfo("fd", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createContourFitting(ctr, fd), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createDTFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    double sigmaSpatial;
    double sigmaColor;
    int mode=DTF_NC;
    int numIters=3;
    Ptr<DTFilter> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpatial"), sigmaSpatial, ArgInfo("sigmaSpatial", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createDTFilter(guide, sigmaSpatial, sigmaColor, mode, numIters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat guide;
    double sigmaSpatial;
    double sigmaColor;
    int mode=DTF_NC;
    int numIters=3;
    Ptr<DTFilter> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpatial"), sigmaSpatial, ArgInfo("sigmaSpatial", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createDTFilter(guide, sigmaSpatial, sigmaColor, mode, numIters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createDisparityWLSFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<StereoMatcher> matcher_left;
    Ptr<DisparityWLSFilter> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matcher_left"), matcher_left, ArgInfo("matcher_left", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createDisparityWLSFilter(matcher_left), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createDisparityWLSFilterGeneric(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    bool use_confidence;
    Ptr<DisparityWLSFilter> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "use_confidence"), use_confidence, ArgInfo("use_confidence", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createDisparityWLSFilterGeneric(use_confidence), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createEdgeAwareInterpolator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<EdgeAwareInterpolator> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createEdgeAwareInterpolator(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createEdgeBoxes(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float alpha=0.65f;
    float beta=0.75f;
    float eta=1;
    float minScore=0.01f;
    int maxBoxes=10000;
    float edgeMinMag=0.1f;
    float edgeMergeThr=0.5f;
    float clusterMinMag=0.5f;
    float maxAspectRatio=3;
    float minBoxArea=1000;
    float gamma=2;
    float kappa=1.5f;
    Ptr<EdgeBoxes> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "alpha"), alpha, ArgInfo("alpha", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eta"), eta, ArgInfo("eta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minScore"), minScore, ArgInfo("minScore", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxBoxes"), maxBoxes, ArgInfo("maxBoxes", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeMinMag"), edgeMinMag, ArgInfo("edgeMinMag", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "edgeMergeThr"), edgeMergeThr, ArgInfo("edgeMergeThr", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "clusterMinMag"), clusterMinMag, ArgInfo("clusterMinMag", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxAspectRatio"), maxAspectRatio, ArgInfo("maxAspectRatio", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "minBoxArea"), minBoxArea, ArgInfo("minBoxArea", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kappa"), kappa, ArgInfo("kappa", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createEdgeBoxes(alpha, beta, eta, minScore, maxBoxes, edgeMinMag, edgeMergeThr, clusterMinMag, maxAspectRatio, minBoxArea, gamma, kappa), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createEdgeDrawing(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<EdgeDrawing> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createEdgeDrawing(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createFastBilateralSolverFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    double sigma_spatial;
    double sigma_luma;
    double sigma_chroma;
    double lambda=128.0;
    int num_iter=25;
    double max_tol=1e-5;
    Ptr<FastBilateralSolverFilter> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_spatial"), sigma_spatial, ArgInfo("sigma_spatial", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_luma"), sigma_luma, ArgInfo("sigma_luma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_chroma"), sigma_chroma, ArgInfo("sigma_chroma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_tol"), max_tol, ArgInfo("max_tol", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createFastBilateralSolverFilter(guide, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat guide;
    double sigma_spatial;
    double sigma_luma;
    double sigma_chroma;
    double lambda=128.0;
    int num_iter=25;
    double max_tol=1e-5;
    Ptr<FastBilateralSolverFilter> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_spatial"), sigma_spatial, ArgInfo("sigma_spatial", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_luma"), sigma_luma, ArgInfo("sigma_luma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_chroma"), sigma_chroma, ArgInfo("sigma_chroma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_tol"), max_tol, ArgInfo("max_tol", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createFastBilateralSolverFilter(guide, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createFastGlobalSmootherFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    double lambda;
    double sigma_color;
    double lambda_attenuation=0.25;
    int num_iter=3;
    Ptr<FastGlobalSmootherFilter> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_color"), sigma_color, ArgInfo("sigma_color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda_attenuation"), lambda_attenuation, ArgInfo("lambda_attenuation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createFastGlobalSmootherFilter(guide, lambda, sigma_color, lambda_attenuation, num_iter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat guide;
    double lambda;
    double sigma_color;
    double lambda_attenuation=0.25;
    int num_iter=3;
    Ptr<FastGlobalSmootherFilter> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_color"), sigma_color, ArgInfo("sigma_color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda_attenuation"), lambda_attenuation, ArgInfo("lambda_attenuation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createFastGlobalSmootherFilter(guide, lambda, sigma_color, lambda_attenuation, num_iter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createFastLineDetector(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int length_threshold=10;
    float distance_threshold=1.414213562f;
    double canny_th1=50.0;
    double canny_th2=50.0;
    int canny_aperture_size=3;
    bool do_merge=false;
    Ptr<FastLineDetector> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "length_threshold"), length_threshold, ArgInfo("length_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "distance_threshold"), distance_threshold, ArgInfo("distance_threshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "canny_th1"), canny_th1, ArgInfo("canny_th1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "canny_th2"), canny_th2, ArgInfo("canny_th2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "canny_aperture_size"), canny_aperture_size, ArgInfo("canny_aperture_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "do_merge"), do_merge, ArgInfo("do_merge", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createFastLineDetector(length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createGuidedFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    int radius;
    double eps;
    Ptr<GuidedFilter> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eps"), eps, ArgInfo("eps", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createGuidedFilter(guide, radius, eps), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat guide;
    int radius;
    double eps;
    Ptr<GuidedFilter> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eps"), eps, ArgInfo("eps", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createGuidedFilter(guide, radius, eps), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createQuaternionImage(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat qimg;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::createQuaternionImage(img, qimg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qimg);
        }
    }

    }
    

    {
    UMat img;
    UMat qimg;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::createQuaternionImage(img, qimg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qimg);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createRFFeatureGetter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<RFFeatureGetter> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createRFFeatureGetter(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createRICInterpolator(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<RICInterpolator> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createRICInterpolator(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createRightMatcher(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<StereoMatcher> matcher_left;
    Ptr<StereoMatcher> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "matcher_left"), matcher_left, ArgInfo("matcher_left", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createRightMatcher(matcher_left), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createScanSegment(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int image_width;
    int image_height;
    int num_superpixels;
    int slices=8;
    bool merge_small=true;
    cv::Ptr<ScanSegment> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_width"), image_width, ArgInfo("image_width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_height"), image_height, ArgInfo("image_height", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_superpixels"), num_superpixels, ArgInfo("num_superpixels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "slices"), slices, ArgInfo("slices", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "merge_small"), merge_small, ArgInfo("merge_small", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createScanSegment(image_width, image_height, num_superpixels, slices, merge_small), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createStructuredEdgeDetection(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String model;
    Ptr<RFFeatureGetter> howToGetFeatures;
    Ptr<StructuredEdgeDetection> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "model"), model, ArgInfo("model", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "howToGetFeatures"), howToGetFeatures, ArgInfo("howToGetFeatures", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createStructuredEdgeDetection(model, howToGetFeatures), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createSuperpixelLSC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    int region_size=10;
    float ratio=0.075f;
    Ptr<SuperpixelLSC> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "region_size"), region_size, ArgInfo("region_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ratio"), ratio, ArgInfo("ratio", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createSuperpixelLSC(image, region_size, ratio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat image;
    int region_size=10;
    float ratio=0.075f;
    Ptr<SuperpixelLSC> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "region_size"), region_size, ArgInfo("region_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ratio"), ratio, ArgInfo("ratio", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createSuperpixelLSC(image, region_size, ratio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createSuperpixelSEEDS(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    int image_width;
    int image_height;
    int image_channels;
    int num_superpixels;
    int num_levels;
    int prior=2;
    int histogram_bins=5;
    bool double_step=false;
    Ptr<SuperpixelSEEDS> retval;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_width"), image_width, ArgInfo("image_width", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_height"), image_height, ArgInfo("image_height", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image_channels"), image_channels, ArgInfo("image_channels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_superpixels"), num_superpixels, ArgInfo("num_superpixels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_levels"), num_levels, ArgInfo("num_levels", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "prior"), prior, ArgInfo("prior", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "histogram_bins"), histogram_bins, ArgInfo("histogram_bins", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "double_step"), double_step, ArgInfo("double_step", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createSuperpixelSEEDS(image_width, image_height, image_channels, num_superpixels, num_levels, prior, histogram_bins, double_step), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_createSuperpixelSLIC(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    int algorithm=SLICO;
    int region_size=10;
    float ruler=10.0f;
    Ptr<SuperpixelSLIC> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "algorithm"), algorithm, ArgInfo("algorithm", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "region_size"), region_size, ArgInfo("region_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ruler"), ruler, ArgInfo("ruler", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createSuperpixelSLIC(image, algorithm, region_size, ruler), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    UMat image;
    int algorithm=SLICO;
    int region_size=10;
    float ruler=10.0f;
    Ptr<SuperpixelSLIC> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "algorithm"), algorithm, ArgInfo("algorithm", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "region_size"), region_size, ArgInfo("region_size", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ruler"), ruler, ArgInfo("ruler", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::createSuperpixelSLIC(image, algorithm, region_size, ruler), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_dtFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    Mat src;
    Mat dst;
    double sigmaSpatial;
    double sigmaColor;
    int mode=DTF_NC;
    int numIters=3;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpatial"), sigmaSpatial, ArgInfo("sigmaSpatial", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::dtFilter(guide, src, dst, sigmaSpatial, sigmaColor, mode, numIters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat guide;
    UMat src;
    UMat dst;
    double sigmaSpatial;
    double sigmaColor;
    int mode=DTF_NC;
    int numIters=3;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpatial"), sigmaSpatial, ArgInfo("sigmaSpatial", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mode"), mode, ArgInfo("mode", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numIters"), numIters, ArgInfo("numIters", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::dtFilter(guide, src, dst, sigmaSpatial, sigmaColor, mode, numIters), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_edgePreservingFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int d;
    double threshold;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::edgePreservingFilter(src, dst, d, threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int d;
    double threshold;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "threshold"), threshold, ArgInfo("threshold", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::edgePreservingFilter(src, dst, d, threshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_fastBilateralSolverFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    Mat src;
    Mat confidence;
    Mat dst;
    double sigma_spatial=8;
    double sigma_luma=8;
    double sigma_chroma=8;
    double lambda=128.0;
    int num_iter=25;
    double max_tol=1e-5;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_spatial"), sigma_spatial, ArgInfo("sigma_spatial", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_luma"), sigma_luma, ArgInfo("sigma_luma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_chroma"), sigma_chroma, ArgInfo("sigma_chroma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_tol"), max_tol, ArgInfo("max_tol", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::fastBilateralSolverFilter(guide, src, confidence, dst, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat guide;
    UMat src;
    UMat confidence;
    UMat dst;
    double sigma_spatial=8;
    double sigma_luma=8;
    double sigma_chroma=8;
    double lambda=128.0;
    int num_iter=25;
    double max_tol=1e-5;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "confidence"), confidence, ArgInfo("confidence", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_spatial"), sigma_spatial, ArgInfo("sigma_spatial", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_luma"), sigma_luma, ArgInfo("sigma_luma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_chroma"), sigma_chroma, ArgInfo("sigma_chroma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "max_tol"), max_tol, ArgInfo("max_tol", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::fastBilateralSolverFilter(guide, src, confidence, dst, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_fastGlobalSmootherFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    Mat src;
    Mat dst;
    double lambda;
    double sigma_color;
    double lambda_attenuation=0.25;
    int num_iter=3;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_color"), sigma_color, ArgInfo("sigma_color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda_attenuation"), lambda_attenuation, ArgInfo("lambda_attenuation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::fastGlobalSmootherFilter(guide, src, dst, lambda, sigma_color, lambda_attenuation, num_iter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat guide;
    UMat src;
    UMat dst;
    double lambda;
    double sigma_color;
    double lambda_attenuation=0.25;
    int num_iter=3;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_color"), sigma_color, ArgInfo("sigma_color", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda_attenuation"), lambda_attenuation, ArgInfo("lambda_attenuation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "num_iter"), num_iter, ArgInfo("num_iter", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::fastGlobalSmootherFilter(guide, src, dst, lambda, sigma_color, lambda_attenuation, num_iter), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_findEllipses(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat image;
    Mat ellipses;
    float scoreThreshold=0.7f;
    float reliabilityThreshold=0.5f;
    float centerDistanceThreshold=0.05f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ellipses"), ellipses, ArgInfo("ellipses", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scoreThreshold"), scoreThreshold, ArgInfo("scoreThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reliabilityThreshold"), reliabilityThreshold, ArgInfo("reliabilityThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centerDistanceThreshold"), centerDistanceThreshold, ArgInfo("centerDistanceThreshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::findEllipses(image, ellipses, scoreThreshold, reliabilityThreshold, centerDistanceThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, ellipses);
        }
    }

    }
    

    {
    UMat image;
    UMat ellipses;
    float scoreThreshold=0.7f;
    float reliabilityThreshold=0.5f;
    float centerDistanceThreshold=0.05f;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "image"), image, ArgInfo("image", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "ellipses"), ellipses, ArgInfo("ellipses", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scoreThreshold"), scoreThreshold, ArgInfo("scoreThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "reliabilityThreshold"), reliabilityThreshold, ArgInfo("reliabilityThreshold", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "centerDistanceThreshold"), centerDistanceThreshold, ArgInfo("centerDistanceThreshold", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::findEllipses(image, ellipses, scoreThreshold, reliabilityThreshold, centerDistanceThreshold), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, ellipses);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_fourierDescriptor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int nbElt=-1;
    int nbFD=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbElt"), nbElt, ArgInfo("nbElt", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbFD"), nbFD, ArgInfo("nbFD", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::fourierDescriptor(src, dst, nbElt, nbFD), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int nbElt=-1;
    int nbFD=-1;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbElt"), nbElt, ArgInfo("nbElt", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "nbFD"), nbFD, ArgInfo("nbFD", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::fourierDescriptor(src, dst, nbElt, nbFD), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_getDisparityVis(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double scale=1.0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::getDisparityVis(src, dst, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    double scale=1.0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "scale"), scale, ArgInfo("scale", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::getDisparityVis(src, dst, scale), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_guidedFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat guide;
    Mat src;
    Mat dst;
    int radius;
    double eps;
    int dDepth=-1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eps"), eps, ArgInfo("eps", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dDepth"), dDepth, ArgInfo("dDepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::guidedFilter(guide, src, dst, radius, eps, dDepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat guide;
    UMat src;
    UMat dst;
    int radius;
    double eps;
    int dDepth=-1;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "guide"), guide, ArgInfo("guide", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "radius"), radius, ArgInfo("radius", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "eps"), eps, ArgInfo("eps", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dDepth"), dDepth, ArgInfo("dDepth", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::guidedFilter(guide, src, dst, radius, eps, dDepth), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_jointBilateralFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat joint;
    Mat src;
    Mat dst;
    int d;
    double sigmaColor;
    double sigmaSpace;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "joint"), joint, ArgInfo("joint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpace"), sigmaSpace, ArgInfo("sigmaSpace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::jointBilateralFilter(joint, src, dst, d, sigmaColor, sigmaSpace, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat joint;
    UMat src;
    UMat dst;
    int d;
    double sigmaColor;
    double sigmaSpace;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "joint"), joint, ArgInfo("joint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpace"), sigmaSpace, ArgInfo("sigmaSpace", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::jointBilateralFilter(joint, src, dst, d, sigmaColor, sigmaSpace, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_l0Smooth(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    double lambda=0.02;
    double kappa=2.0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kappa"), kappa, ArgInfo("kappa", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::l0Smooth(src, dst, lambda, kappa), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    double lambda=0.02;
    double kappa=2.0;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "lambda"), lambda, ArgInfo("lambda", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "kappa"), kappa, ArgInfo("kappa", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::l0Smooth(src, dst, lambda, kappa), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_niBlackThreshold(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat _src;
    Mat _dst;
    double maxValue;
    int type;
    int blockSize;
    double k;
    int binarizationMethod=BINARIZATION_NIBLACK;
    double r=128;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), _src, ArgInfo("_src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), _dst, ArgInfo("_dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxValue"), maxValue, ArgInfo("maxValue", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "binarizationMethod"), binarizationMethod, ArgInfo("binarizationMethod", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), r, ArgInfo("r", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::niBlackThreshold(_src, _dst, maxValue, type, blockSize, k, binarizationMethod, r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, _dst);
        }
    }

    }
    

    {
    UMat _src;
    UMat _dst;
    double maxValue;
    int type;
    int blockSize;
    double k;
    int binarizationMethod=BINARIZATION_NIBLACK;
    double r=128;

    if( num_kw_args >= 5 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), _src, ArgInfo("_src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), _dst, ArgInfo("_dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "maxValue"), maxValue, ArgInfo("maxValue", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "type"), type, ArgInfo("type", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockSize"), blockSize, ArgInfo("blockSize", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "binarizationMethod"), binarizationMethod, ArgInfo("binarizationMethod", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), r, ArgInfo("r", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::niBlackThreshold(_src, _dst, maxValue, type, blockSize, k, binarizationMethod, r), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, _dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_qconj(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat qimg;
    Mat qcimg;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qcimg"), qcimg, ArgInfo("qcimg", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qconj(qimg, qcimg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qcimg);
        }
    }

    }
    

    {
    UMat qimg;
    UMat qcimg;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qcimg"), qcimg, ArgInfo("qcimg", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qconj(qimg, qcimg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qcimg);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_qdft(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat img;
    Mat qimg;
    int flags;
    bool sideLeft;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sideLeft"), sideLeft, ArgInfo("sideLeft", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qdft(img, qimg, flags, sideLeft), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qimg);
        }
    }

    }
    

    {
    UMat img;
    UMat qimg;
    int flags;
    bool sideLeft;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "img"), img, ArgInfo("img", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "flags"), flags, ArgInfo("flags", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sideLeft"), sideLeft, ArgInfo("sideLeft", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qdft(img, qimg, flags, sideLeft), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qimg);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_qmultiply(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src1;
    Mat src2;
    Mat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qmultiply(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src1;
    UMat src2;
    UMat dst;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src1"), src1, ArgInfo("src1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src2"), src2, ArgInfo("src2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qmultiply(src1, src2, dst), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_qunitary(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat qimg;
    Mat qnimg;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qnimg"), qnimg, ArgInfo("qnimg", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qunitary(qimg, qnimg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qnimg);
        }
    }

    }
    

    {
    UMat qimg;
    UMat qnimg;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qimg"), qimg, ArgInfo("qimg", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "qnimg"), qnimg, ArgInfo("qnimg", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::qunitary(qimg, qnimg), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, qnimg);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_readGT(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    String src_path;
    Mat dst;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src_path"), src_path, ArgInfo("src_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::readGT(src_path, dst), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }
    

    {
    String src_path;
    UMat dst;
    int retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src_path"), src_path, ArgInfo("src_path", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::readGT(src_path, dst), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, retval), evision_from(env, dst));
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_rollingGuidanceFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int d=-1;
    double sigmaColor=25;
    double sigmaSpace=3;
    int numOfIter=4;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpace"), sigmaSpace, ArgInfo("sigmaSpace", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numOfIter"), numOfIter, ArgInfo("numOfIter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::rollingGuidanceFilter(src, dst, d, sigmaColor, sigmaSpace, numOfIter, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int d=-1;
    double sigmaColor=25;
    double sigmaSpace=3;
    int numOfIter=4;
    int borderType=BORDER_DEFAULT;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "d"), d, ArgInfo("d", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaColor"), sigmaColor, ArgInfo("sigmaColor", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigmaSpace"), sigmaSpace, ArgInfo("sigmaSpace", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "numOfIter"), numOfIter, ArgInfo("numOfIter", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "borderType"), borderType, ArgInfo("borderType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::rollingGuidanceFilter(src, dst, d, sigmaColor, sigmaSpace, numOfIter, borderType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_thinning(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int thinningType=THINNING_ZHANGSUEN;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thinningType"), thinningType, ArgInfo("thinningType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::thinning(src, dst, thinningType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int thinningType=THINNING_ZHANGSUEN;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "thinningType"), thinningType, ArgInfo("thinningType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::thinning(src, dst, thinningType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_transformFD(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat t;
    Mat dst;
    bool fdContour=true;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fdContour"), fdContour, ArgInfo("fdContour", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::transformFD(src, t, dst, fdContour), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat t;
    UMat dst;
    bool fdContour=true;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "t"), t, ArgInfo("t", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "fdContour"), fdContour, ArgInfo("fdContour", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::transformFD(src, t, dst, fdContour), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_weightedMedianFilter(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat joint;
    Mat src;
    Mat dst;
    int r;
    double sigma=25.5;
    int weightType=WMF_EXP;
    Mat mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "joint"), joint, ArgInfo("joint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), r, ArgInfo("r", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weightType"), weightType, ArgInfo("weightType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::weightedMedianFilter(joint, src, dst, r, sigma, weightType, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat joint;
    UMat src;
    UMat dst;
    int r;
    double sigma=25.5;
    int weightType=WMF_EXP;
    UMat mask;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "joint"), joint, ArgInfo("joint", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "r"), r, ArgInfo("r", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "weightType"), weightType, ArgInfo("weightType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::ximgproc::weightedMedianFilter(joint, src, dst, r, sigma, weightType, mask), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createGraphSegmentation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    double sigma=0.5;
    float k=300;
    int min_size=100;
    Ptr<GraphSegmentation> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "k"), k, ArgInfo("k", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "min_size"), min_size, ArgInfo("min_size", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createGraphSegmentation(sigma, k, min_size), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createSelectiveSearchSegmentation(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SelectiveSearchSegmentation> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SelectiveSearchSegmentationStrategyColor> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyFill(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SelectiveSearchSegmentationStrategyFill> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Ptr<SelectiveSearchSegmentationStrategy> s2;
    Ptr<SelectiveSearchSegmentationStrategy> s3;
    Ptr<SelectiveSearchSegmentationStrategy> s4;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s1"), s1, ArgInfo("s1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s2"), s2, ArgInfo("s2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s3"), s3, ArgInfo("s3", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s4"), s4, ArgInfo("s4", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1, s2, s3, s4), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Ptr<SelectiveSearchSegmentationStrategy> s2;
    Ptr<SelectiveSearchSegmentationStrategy> s3;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s1"), s1, ArgInfo("s1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s2"), s2, ArgInfo("s2", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s3"), s3, ArgInfo("s3", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1, s2, s3), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Ptr<SelectiveSearchSegmentationStrategy> s2;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s1"), s1, ArgInfo("s1", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s2"), s2, ArgInfo("s2", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1, s2), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "s1"), s1, ArgInfo("s1", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }
    

    {
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategySize(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SelectiveSearchSegmentationStrategySize> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyTexture(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::ximgproc::segmentation;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SelectiveSearchSegmentationStrategyTexture> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_applyChannelGains(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    float gainB;
    float gainG;
    float gainR;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gainB"), gainB, ArgInfo("gainB", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gainG"), gainG, ArgInfo("gainG", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gainR"), gainR, ArgInfo("gainR", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::applyChannelGains(src, dst, gainB, gainG, gainR), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    float gainB;
    float gainG;
    float gainR;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gainB"), gainB, ArgInfo("gainB", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gainG"), gainG, ArgInfo("gainG", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "gainR"), gainR, ArgInfo("gainR", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::applyChannelGains(src, dst, gainB, gainG, gainR), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_bm3dDenoising(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dstStep1;
    Mat dstStep2;
    float h=1;
    int templateWindowSize=4;
    int searchWindowSize=16;
    int blockMatchingStep1=2500;
    int blockMatchingStep2=400;
    int groupSize=8;
    int slidingStep=1;
    float beta=2.0f;
    int normType=cv::NORM_L2;
    int step=cv::xphoto::BM3D_STEPALL;
    int transformType=cv::xphoto::HAAR;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstStep1"), dstStep1, ArgInfo("dstStep1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstStep2"), dstStep2, ArgInfo("dstStep2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep1"), blockMatchingStep1, ArgInfo("blockMatchingStep1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep2"), blockMatchingStep2, ArgInfo("blockMatchingStep2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupSize"), groupSize, ArgInfo("groupSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "slidingStep"), slidingStep, ArgInfo("slidingStep", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "step"), step, ArgInfo("step", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::bm3dDenoising(src, dstStep1, dstStep2, h, templateWindowSize, searchWindowSize, blockMatchingStep1, blockMatchingStep2, groupSize, slidingStep, beta, normType, step, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dstStep1), evision_from(env, dstStep2));
        }
    }

    }
    

    {
    UMat src;
    UMat dstStep1;
    UMat dstStep2;
    float h=1;
    int templateWindowSize=4;
    int searchWindowSize=16;
    int blockMatchingStep1=2500;
    int blockMatchingStep2=400;
    int groupSize=8;
    int slidingStep=1;
    float beta=2.0f;
    int normType=cv::NORM_L2;
    int step=cv::xphoto::BM3D_STEPALL;
    int transformType=cv::xphoto::HAAR;

    if( num_kw_args >= 2 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstStep1"), dstStep1, ArgInfo("dstStep1", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dstStep2"), dstStep2, ArgInfo("dstStep2", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep1"), blockMatchingStep1, ArgInfo("blockMatchingStep1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep2"), blockMatchingStep2, ArgInfo("blockMatchingStep2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupSize"), groupSize, ArgInfo("groupSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "slidingStep"), slidingStep, ArgInfo("slidingStep", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "step"), step, ArgInfo("step", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::bm3dDenoising(src, dstStep1, dstStep2, h, templateWindowSize, searchWindowSize, blockMatchingStep1, blockMatchingStep2, groupSize, slidingStep, beta, normType, step, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return enif_make_tuple2(env, evision_from(env, dstStep1), evision_from(env, dstStep2));
        }
    }

    }
    

    {
    Mat src;
    Mat dst;
    float h=1;
    int templateWindowSize=4;
    int searchWindowSize=16;
    int blockMatchingStep1=2500;
    int blockMatchingStep2=400;
    int groupSize=8;
    int slidingStep=1;
    float beta=2.0f;
    int normType=cv::NORM_L2;
    int step=cv::xphoto::BM3D_STEPALL;
    int transformType=cv::xphoto::HAAR;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep1"), blockMatchingStep1, ArgInfo("blockMatchingStep1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep2"), blockMatchingStep2, ArgInfo("blockMatchingStep2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupSize"), groupSize, ArgInfo("groupSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "slidingStep"), slidingStep, ArgInfo("slidingStep", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "step"), step, ArgInfo("step", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::bm3dDenoising(src, dst, h, templateWindowSize, searchWindowSize, blockMatchingStep1, blockMatchingStep2, groupSize, slidingStep, beta, normType, step, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    float h=1;
    int templateWindowSize=4;
    int searchWindowSize=16;
    int blockMatchingStep1=2500;
    int blockMatchingStep2=400;
    int groupSize=8;
    int slidingStep=1;
    float beta=2.0f;
    int normType=cv::NORM_L2;
    int step=cv::xphoto::BM3D_STEPALL;
    int transformType=cv::xphoto::HAAR;

    if( num_kw_args >= 1 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "h"), h, ArgInfo("h", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "templateWindowSize"), templateWindowSize, ArgInfo("templateWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "searchWindowSize"), searchWindowSize, ArgInfo("searchWindowSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep1"), blockMatchingStep1, ArgInfo("blockMatchingStep1", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "blockMatchingStep2"), blockMatchingStep2, ArgInfo("blockMatchingStep2", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "groupSize"), groupSize, ArgInfo("groupSize", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "slidingStep"), slidingStep, ArgInfo("slidingStep", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "beta"), beta, ArgInfo("beta", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "normType"), normType, ArgInfo("normType", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "step"), step, ArgInfo("step", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "transformType"), transformType, ArgInfo("transformType", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::bm3dDenoising(src, dst, h, templateWindowSize, searchWindowSize, blockMatchingStep1, blockMatchingStep2, groupSize, slidingStep, beta, normType, step, transformType), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_createGrayworldWB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<GrayworldWB> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xphoto::createGrayworldWB(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_createLearningBasedWB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    String path_to_model;
    Ptr<LearningBasedWB> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "path_to_model"), path_to_model, ArgInfo("path_to_model", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xphoto::createLearningBasedWB(path_to_model), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_createSimpleWB(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Ptr<SimpleWB> retval;

    if((argc - nif_opts_index == 1) && erl_terms.size() == 0)
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xphoto::createSimpleWB(), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_createTonemapDurand(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    float gamma=1.0f;
    float contrast=4.0f;
    float saturation=1.0f;
    float sigma_color=2.0f;
    float sigma_space=2.0f;
    Ptr<TonemapDurand> retval;

    if( evision_to_safe(env, evision_get_kw(env, erl_terms, "gamma"), gamma, ArgInfo("gamma", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "contrast"), contrast, ArgInfo("contrast", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "saturation"), saturation, ArgInfo("saturation", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_color"), sigma_color, ArgInfo("sigma_color", 0, 1)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma_space"), sigma_space, ArgInfo("sigma_space", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(retval = cv::xphoto::createTonemapDurand(gamma, contrast, saturation, sigma_color, sigma_space), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, retval);
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_dctDenoising(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat src;
    Mat dst;
    double sigma;
    int psize=16;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "sigma"), sigma, ArgInfo("sigma", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "psize"), psize, ArgInfo("psize", 0, 1)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::dctDenoising(src, dst, sigma, psize), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_inpaint(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();
    Mat src;
    Mat mask;
    Mat dst;
    int algorithmType;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "mask"), mask, ArgInfo("mask", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "algorithmType"), algorithmType, ArgInfo("algorithmType", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::inpaint(src, mask, dst, algorithmType), env, error_flag, error_term);
        if (!error_flag) {
            return evision::nif::atom(env, "ok");
        }
    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

static ERL_NIF_TERM evision_cv_xphoto_oilPainting(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[])
{
    using namespace cv::xphoto;
    int error_flag = false;
    ERL_NIF_TERM error_term = 0;
    std::map<std::string, ERL_NIF_TERM> erl_terms;
    const int nif_opts_index = 0;
    if (nif_opts_index < argc) {
        evision::nif::parse_arg(env, nif_opts_index, argv, erl_terms);
    }
    const size_t num_kw_args = erl_terms.size();

    {
    Mat src;
    Mat dst;
    int size;
    int dynRatio;
    int code;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dynRatio"), dynRatio, ArgInfo("dynRatio", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::oilPainting(src, dst, size, dynRatio, code), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int size;
    int dynRatio;
    int code;

    if( num_kw_args >= 4 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dynRatio"), dynRatio, ArgInfo("dynRatio", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "code"), code, ArgInfo("code", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::oilPainting(src, dst, size, dynRatio, code), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    Mat src;
    Mat dst;
    int size;
    int dynRatio;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dynRatio"), dynRatio, ArgInfo("dynRatio", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::oilPainting(src, dst, size, dynRatio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }
    

    {
    UMat src;
    UMat dst;
    int size;
    int dynRatio;

    if( num_kw_args >= 3 && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "src"), src, ArgInfo("src", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dst"), dst, ArgInfo("dst", 1, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "size"), size, ArgInfo("size", 0, 0)) && 
        evision_to_safe(env, evision_get_kw(env, erl_terms, "dynRatio"), dynRatio, ArgInfo("dynRatio", 0, 0)) )
    {
        error_flag = false;
        
        ERRWRAP2(cv::xphoto::oilPainting(src, dst, size, dynRatio), env, error_flag, error_term);
        if (!error_flag) {
            return evision_from(env, dst);
        }
    }

    }

    if (error_flag != false) return error_term;
    else return enif_make_badarg(env);
}

