defmodule Evision do
  import Kernel, except: [apply: 2, apply: 3, min: 2, max: 2]

  @doc false
  def to_struct(any), do: Evision.Internal.Structurise.to_struct(any)


  @typedoc """
  Scalars are n-element tuples, where n can be 1, 2, 3, or 4.

  When passing a single number `X` as a scalar, it will be converted to `{X, 0, 0, 0}`.

  When passing a tuple with more than 4 elements, it will raise an error.
  """
  @type scalar :: number() | {number()} | {number(), number()} | {number(), number(), number()} | {number(), number(), number(), number()}

  @spec imdecode(binary(), integer()) :: Evision.Mat.maybe_mat_out()
  def imdecode(buf, flags) when is_integer(flags)
  do
      positional = [
          buf: buf,
          flags: flags
      ]
      :evision_nif.imdecode(positional)
      |> Evision.Internal.Structurise.to_struct()
  end

  import Bitwise

  @type enum :: integer()
  @doc enum: true
  def cv_INPAINT_NS, do: 0
  @doc enum: true
  def cv_INPAINT_TELEA, do: 1
  @doc enum: true
  def cv_LDR_SIZE, do: 256
  @doc enum: true
  def cv_NORMAL_CLONE, do: 1
  @doc enum: true
  def cv_MIXED_CLONE, do: 2
  @doc enum: true
  def cv_MONOCHROME_TRANSFER, do: 3
  @doc enum: true
  def cv_RECURS_FILTER, do: 1
  @doc enum: true
  def cv_NORMCONV_FILTER, do: 2
  @doc enum: true
  def cv_CAP_PROP_DC1394_OFF, do: -4
  @doc enum: true
  def cv_CAP_PROP_DC1394_MODE_MANUAL, do: -3
  @doc enum: true
  def cv_CAP_PROP_DC1394_MODE_AUTO, do: -2
  @doc enum: true
  def cv_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO, do: -1
  @doc enum: true
  def cv_CAP_PROP_DC1394_MAX, do: 31
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_GENERATOR, do: bsl(1, 31)
  @doc enum: true
  def cv_CAP_OPENNI_IMAGE_GENERATOR, do: bsl(1, 30)
  @doc enum: true
  def cv_CAP_OPENNI_IR_GENERATOR, do: bsl(1, 29)
  @doc enum: true
  def cv_CAP_OPENNI_GENERATORS_MASK, do: ((cv_CAP_OPENNI_DEPTH_GENERATOR() + cv_CAP_OPENNI_IMAGE_GENERATOR()) + cv_CAP_OPENNI_IR_GENERATOR())
  @doc enum: true
  def cv_CAP_PROP_OPENNI_OUTPUT_MODE, do: 100
  @doc enum: true
  def cv_CAP_PROP_OPENNI_FRAME_MAX_DEPTH, do: 101
  @doc enum: true
  def cv_CAP_PROP_OPENNI_BASELINE, do: 102
  @doc enum: true
  def cv_CAP_PROP_OPENNI_FOCAL_LENGTH, do: 103
  @doc enum: true
  def cv_CAP_PROP_OPENNI_REGISTRATION, do: 104
  @doc enum: true
  def cv_CAP_PROP_OPENNI_REGISTRATION_ON, do: cv_CAP_PROP_OPENNI_REGISTRATION()
  @doc enum: true
  def cv_CAP_PROP_OPENNI_APPROX_FRAME_SYNC, do: 105
  @doc enum: true
  def cv_CAP_PROP_OPENNI_MAX_BUFFER_SIZE, do: 106
  @doc enum: true
  def cv_CAP_PROP_OPENNI_CIRCLE_BUFFER, do: 107
  @doc enum: true
  def cv_CAP_PROP_OPENNI_MAX_TIME_DURATION, do: 108
  @doc enum: true
  def cv_CAP_PROP_OPENNI_GENERATOR_PRESENT, do: 109
  @doc enum: true
  def cv_CAP_PROP_OPENNI2_SYNC, do: 110
  @doc enum: true
  def cv_CAP_PROP_OPENNI2_MIRROR, do: 111
  @doc enum: true
  def cv_CAP_OPENNI_IMAGE_GENERATOR_PRESENT, do: (cv_CAP_OPENNI_IMAGE_GENERATOR() + cv_CAP_PROP_OPENNI_GENERATOR_PRESENT())
  @doc enum: true
  def cv_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE, do: (cv_CAP_OPENNI_IMAGE_GENERATOR() + cv_CAP_PROP_OPENNI_OUTPUT_MODE())
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_GENERATOR_PRESENT, do: (cv_CAP_OPENNI_DEPTH_GENERATOR() + cv_CAP_PROP_OPENNI_GENERATOR_PRESENT())
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_GENERATOR_BASELINE, do: (cv_CAP_OPENNI_DEPTH_GENERATOR() + cv_CAP_PROP_OPENNI_BASELINE())
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH, do: (cv_CAP_OPENNI_DEPTH_GENERATOR() + cv_CAP_PROP_OPENNI_FOCAL_LENGTH())
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, do: (cv_CAP_OPENNI_DEPTH_GENERATOR() + cv_CAP_PROP_OPENNI_REGISTRATION())
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON, do: cv_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION()
  @doc enum: true
  def cv_CAP_OPENNI_IR_GENERATOR_PRESENT, do: (cv_CAP_OPENNI_IR_GENERATOR() + cv_CAP_PROP_OPENNI_GENERATOR_PRESENT())
  @doc enum: true
  def cv_CAP_OPENNI_DEPTH_MAP, do: 0
  @doc enum: true
  def cv_CAP_OPENNI_POINT_CLOUD_MAP, do: 1
  @doc enum: true
  def cv_CAP_OPENNI_DISPARITY_MAP, do: 2
  @doc enum: true
  def cv_CAP_OPENNI_DISPARITY_MAP_32F, do: 3
  @doc enum: true
  def cv_CAP_OPENNI_VALID_DEPTH_MASK, do: 4
  @doc enum: true
  def cv_CAP_OPENNI_BGR_IMAGE, do: 5
  @doc enum: true
  def cv_CAP_OPENNI_GRAY_IMAGE, do: 6
  @doc enum: true
  def cv_CAP_OPENNI_IR_IMAGE, do: 7
  @doc enum: true
  def cv_CAP_OPENNI_VGA_30HZ, do: 0
  @doc enum: true
  def cv_CAP_OPENNI_SXGA_15HZ, do: 1
  @doc enum: true
  def cv_CAP_OPENNI_SXGA_30HZ, do: 2
  @doc enum: true
  def cv_CAP_OPENNI_QVGA_30HZ, do: 3
  @doc enum: true
  def cv_CAP_OPENNI_QVGA_60HZ, do: 4
  @doc enum: true
  def cv_CAP_PROP_GSTREAMER_QUEUE_LENGTH, do: 200
  @doc enum: true
  def cv_CAP_PROP_PVAPI_MULTICASTIP, do: 300
  @doc enum: true
  def cv_CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE, do: 301
  @doc enum: true
  def cv_CAP_PROP_PVAPI_DECIMATIONHORIZONTAL, do: 302
  @doc enum: true
  def cv_CAP_PROP_PVAPI_DECIMATIONVERTICAL, do: 303
  @doc enum: true
  def cv_CAP_PROP_PVAPI_BINNINGX, do: 304
  @doc enum: true
  def cv_CAP_PROP_PVAPI_BINNINGY, do: 305
  @doc enum: true
  def cv_CAP_PROP_PVAPI_PIXELFORMAT, do: 306
  @doc enum: true
  def cv_CAP_PVAPI_FSTRIGMODE_FREERUN, do: 0
  @doc enum: true
  def cv_CAP_PVAPI_FSTRIGMODE_SYNCIN1, do: 1
  @doc enum: true
  def cv_CAP_PVAPI_FSTRIGMODE_SYNCIN2, do: 2
  @doc enum: true
  def cv_CAP_PVAPI_FSTRIGMODE_FIXEDRATE, do: 3
  @doc enum: true
  def cv_CAP_PVAPI_FSTRIGMODE_SOFTWARE, do: 4
  @doc enum: true
  def cv_CAP_PVAPI_DECIMATION_OFF, do: 1
  @doc enum: true
  def cv_CAP_PVAPI_DECIMATION_2OUTOF4, do: 2
  @doc enum: true
  def cv_CAP_PVAPI_DECIMATION_2OUTOF8, do: 4
  @doc enum: true
  def cv_CAP_PVAPI_DECIMATION_2OUTOF16, do: 8
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_MONO8, do: 1
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_MONO16, do: 2
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_BAYER8, do: 3
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_BAYER16, do: 4
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_RGB24, do: 5
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_BGR24, do: 6
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_RGBA32, do: 7
  @doc enum: true
  def cv_CAP_PVAPI_PIXELFORMAT_BGRA32, do: 8
  @doc enum: true
  def cv_CAP_PROP_XI_DOWNSAMPLING, do: 400
  @doc enum: true
  def cv_CAP_PROP_XI_DATA_FORMAT, do: 401
  @doc enum: true
  def cv_CAP_PROP_XI_OFFSET_X, do: 402
  @doc enum: true
  def cv_CAP_PROP_XI_OFFSET_Y, do: 403
  @doc enum: true
  def cv_CAP_PROP_XI_TRG_SOURCE, do: 404
  @doc enum: true
  def cv_CAP_PROP_XI_TRG_SOFTWARE, do: 405
  @doc enum: true
  def cv_CAP_PROP_XI_GPI_SELECTOR, do: 406
  @doc enum: true
  def cv_CAP_PROP_XI_GPI_MODE, do: 407
  @doc enum: true
  def cv_CAP_PROP_XI_GPI_LEVEL, do: 408
  @doc enum: true
  def cv_CAP_PROP_XI_GPO_SELECTOR, do: 409
  @doc enum: true
  def cv_CAP_PROP_XI_GPO_MODE, do: 410
  @doc enum: true
  def cv_CAP_PROP_XI_LED_SELECTOR, do: 411
  @doc enum: true
  def cv_CAP_PROP_XI_LED_MODE, do: 412
  @doc enum: true
  def cv_CAP_PROP_XI_MANUAL_WB, do: 413
  @doc enum: true
  def cv_CAP_PROP_XI_AUTO_WB, do: 414
  @doc enum: true
  def cv_CAP_PROP_XI_AEAG, do: 415
  @doc enum: true
  def cv_CAP_PROP_XI_EXP_PRIORITY, do: 416
  @doc enum: true
  def cv_CAP_PROP_XI_AE_MAX_LIMIT, do: 417
  @doc enum: true
  def cv_CAP_PROP_XI_AG_MAX_LIMIT, do: 418
  @doc enum: true
  def cv_CAP_PROP_XI_AEAG_LEVEL, do: 419
  @doc enum: true
  def cv_CAP_PROP_XI_TIMEOUT, do: 420
  @doc enum: true
  def cv_CAP_PROP_XI_EXPOSURE, do: 421
  @doc enum: true
  def cv_CAP_PROP_XI_EXPOSURE_BURST_COUNT, do: 422
  @doc enum: true
  def cv_CAP_PROP_XI_GAIN_SELECTOR, do: 423
  @doc enum: true
  def cv_CAP_PROP_XI_GAIN, do: 424
  @doc enum: true
  def cv_CAP_PROP_XI_DOWNSAMPLING_TYPE, do: 426
  @doc enum: true
  def cv_CAP_PROP_XI_BINNING_SELECTOR, do: 427
  @doc enum: true
  def cv_CAP_PROP_XI_BINNING_VERTICAL, do: 428
  @doc enum: true
  def cv_CAP_PROP_XI_BINNING_HORIZONTAL, do: 429
  @doc enum: true
  def cv_CAP_PROP_XI_BINNING_PATTERN, do: 430
  @doc enum: true
  def cv_CAP_PROP_XI_DECIMATION_SELECTOR, do: 431
  @doc enum: true
  def cv_CAP_PROP_XI_DECIMATION_VERTICAL, do: 432
  @doc enum: true
  def cv_CAP_PROP_XI_DECIMATION_HORIZONTAL, do: 433
  @doc enum: true
  def cv_CAP_PROP_XI_DECIMATION_PATTERN, do: 434
  @doc enum: true
  def cv_CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR, do: 587
  @doc enum: true
  def cv_CAP_PROP_XI_TEST_PATTERN, do: 588
  @doc enum: true
  def cv_CAP_PROP_XI_IMAGE_DATA_FORMAT, do: 435
  @doc enum: true
  def cv_CAP_PROP_XI_SHUTTER_TYPE, do: 436
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_TAPS, do: 437
  @doc enum: true
  def cv_CAP_PROP_XI_AEAG_ROI_OFFSET_X, do: 439
  @doc enum: true
  def cv_CAP_PROP_XI_AEAG_ROI_OFFSET_Y, do: 440
  @doc enum: true
  def cv_CAP_PROP_XI_AEAG_ROI_WIDTH, do: 441
  @doc enum: true
  def cv_CAP_PROP_XI_AEAG_ROI_HEIGHT, do: 442
  @doc enum: true
  def cv_CAP_PROP_XI_BPC, do: 445
  @doc enum: true
  def cv_CAP_PROP_XI_WB_KR, do: 448
  @doc enum: true
  def cv_CAP_PROP_XI_WB_KG, do: 449
  @doc enum: true
  def cv_CAP_PROP_XI_WB_KB, do: 450
  @doc enum: true
  def cv_CAP_PROP_XI_WIDTH, do: 451
  @doc enum: true
  def cv_CAP_PROP_XI_HEIGHT, do: 452
  @doc enum: true
  def cv_CAP_PROP_XI_REGION_SELECTOR, do: 589
  @doc enum: true
  def cv_CAP_PROP_XI_REGION_MODE, do: 595
  @doc enum: true
  def cv_CAP_PROP_XI_LIMIT_BANDWIDTH, do: 459
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH, do: 460
  @doc enum: true
  def cv_CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH, do: 461
  @doc enum: true
  def cv_CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH, do: 462
  @doc enum: true
  def cv_CAP_PROP_XI_OUTPUT_DATA_PACKING, do: 463
  @doc enum: true
  def cv_CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE, do: 464
  @doc enum: true
  def cv_CAP_PROP_XI_IS_COOLED, do: 465
  @doc enum: true
  def cv_CAP_PROP_XI_COOLING, do: 466
  @doc enum: true
  def cv_CAP_PROP_XI_TARGET_TEMP, do: 467
  @doc enum: true
  def cv_CAP_PROP_XI_CHIP_TEMP, do: 468
  @doc enum: true
  def cv_CAP_PROP_XI_HOUS_TEMP, do: 469
  @doc enum: true
  def cv_CAP_PROP_XI_HOUS_BACK_SIDE_TEMP, do: 590
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_BOARD_TEMP, do: 596
  @doc enum: true
  def cv_CAP_PROP_XI_CMS, do: 470
  @doc enum: true
  def cv_CAP_PROP_XI_APPLY_CMS, do: 471
  @doc enum: true
  def cv_CAP_PROP_XI_IMAGE_IS_COLOR, do: 474
  @doc enum: true
  def cv_CAP_PROP_XI_COLOR_FILTER_ARRAY, do: 475
  @doc enum: true
  def cv_CAP_PROP_XI_GAMMAY, do: 476
  @doc enum: true
  def cv_CAP_PROP_XI_GAMMAC, do: 477
  @doc enum: true
  def cv_CAP_PROP_XI_SHARPNESS, do: 478
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_00, do: 479
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_01, do: 480
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_02, do: 481
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_03, do: 482
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_10, do: 483
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_11, do: 484
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_12, do: 485
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_13, do: 486
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_20, do: 487
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_21, do: 488
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_22, do: 489
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_23, do: 490
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_30, do: 491
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_31, do: 492
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_32, do: 493
  @doc enum: true
  def cv_CAP_PROP_XI_CC_MATRIX_33, do: 494
  @doc enum: true
  def cv_CAP_PROP_XI_DEFAULT_CC_MATRIX, do: 495
  @doc enum: true
  def cv_CAP_PROP_XI_TRG_SELECTOR, do: 498
  @doc enum: true
  def cv_CAP_PROP_XI_ACQ_FRAME_BURST_COUNT, do: 499
  @doc enum: true
  def cv_CAP_PROP_XI_DEBOUNCE_EN, do: 507
  @doc enum: true
  def cv_CAP_PROP_XI_DEBOUNCE_T0, do: 508
  @doc enum: true
  def cv_CAP_PROP_XI_DEBOUNCE_T1, do: 509
  @doc enum: true
  def cv_CAP_PROP_XI_DEBOUNCE_POL, do: 510
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_MODE, do: 511
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_APERTURE_VALUE, do: 512
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE, do: 513
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_FOCUS_MOVE, do: 514
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_FOCUS_DISTANCE, do: 515
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_FOCAL_LENGTH, do: 516
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_FEATURE_SELECTOR, do: 517
  @doc enum: true
  def cv_CAP_PROP_XI_LENS_FEATURE, do: 518
  @doc enum: true
  def cv_CAP_PROP_XI_DEVICE_MODEL_ID, do: 521
  @doc enum: true
  def cv_CAP_PROP_XI_DEVICE_SN, do: 522
  @doc enum: true
  def cv_CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA, do: 529
  @doc enum: true
  def cv_CAP_PROP_XI_IMAGE_PAYLOAD_SIZE, do: 530
  @doc enum: true
  def cv_CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT, do: 531
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ, do: 532
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX, do: 533
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT, do: 534
  @doc enum: true
  def cv_CAP_PROP_XI_FRAMERATE, do: 535
  @doc enum: true
  def cv_CAP_PROP_XI_COUNTER_SELECTOR, do: 536
  @doc enum: true
  def cv_CAP_PROP_XI_COUNTER_VALUE, do: 537
  @doc enum: true
  def cv_CAP_PROP_XI_ACQ_TIMING_MODE, do: 538
  @doc enum: true
  def cv_CAP_PROP_XI_AVAILABLE_BANDWIDTH, do: 539
  @doc enum: true
  def cv_CAP_PROP_XI_BUFFER_POLICY, do: 540
  @doc enum: true
  def cv_CAP_PROP_XI_LUT_EN, do: 541
  @doc enum: true
  def cv_CAP_PROP_XI_LUT_INDEX, do: 542
  @doc enum: true
  def cv_CAP_PROP_XI_LUT_VALUE, do: 543
  @doc enum: true
  def cv_CAP_PROP_XI_TRG_DELAY, do: 544
  @doc enum: true
  def cv_CAP_PROP_XI_TS_RST_MODE, do: 545
  @doc enum: true
  def cv_CAP_PROP_XI_TS_RST_SOURCE, do: 546
  @doc enum: true
  def cv_CAP_PROP_XI_IS_DEVICE_EXIST, do: 547
  @doc enum: true
  def cv_CAP_PROP_XI_ACQ_BUFFER_SIZE, do: 548
  @doc enum: true
  def cv_CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT, do: 549
  @doc enum: true
  def cv_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE, do: 550
  @doc enum: true
  def cv_CAP_PROP_XI_BUFFERS_QUEUE_SIZE, do: 551
  @doc enum: true
  def cv_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT, do: 552
  @doc enum: true
  def cv_CAP_PROP_XI_RECENT_FRAME, do: 553
  @doc enum: true
  def cv_CAP_PROP_XI_DEVICE_RESET, do: 554
  @doc enum: true
  def cv_CAP_PROP_XI_COLUMN_FPN_CORRECTION, do: 555
  @doc enum: true
  def cv_CAP_PROP_XI_ROW_FPN_CORRECTION, do: 591
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_MODE, do: 558
  @doc enum: true
  def cv_CAP_PROP_XI_HDR, do: 559
  @doc enum: true
  def cv_CAP_PROP_XI_HDR_KNEEPOINT_COUNT, do: 560
  @doc enum: true
  def cv_CAP_PROP_XI_HDR_T1, do: 561
  @doc enum: true
  def cv_CAP_PROP_XI_HDR_T2, do: 562
  @doc enum: true
  def cv_CAP_PROP_XI_KNEEPOINT1, do: 563
  @doc enum: true
  def cv_CAP_PROP_XI_KNEEPOINT2, do: 564
  @doc enum: true
  def cv_CAP_PROP_XI_IMAGE_BLACK_LEVEL, do: 565
  @doc enum: true
  def cv_CAP_PROP_XI_HW_REVISION, do: 571
  @doc enum: true
  def cv_CAP_PROP_XI_DEBUG_LEVEL, do: 572
  @doc enum: true
  def cv_CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION, do: 573
  @doc enum: true
  def cv_CAP_PROP_XI_FFS_FILE_ID, do: 594
  @doc enum: true
  def cv_CAP_PROP_XI_FFS_FILE_SIZE, do: 580
  @doc enum: true
  def cv_CAP_PROP_XI_FREE_FFS_SIZE, do: 581
  @doc enum: true
  def cv_CAP_PROP_XI_USED_FFS_SIZE, do: 582
  @doc enum: true
  def cv_CAP_PROP_XI_FFS_ACCESS_KEY, do: 583
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_FEATURE_SELECTOR, do: 585
  @doc enum: true
  def cv_CAP_PROP_XI_SENSOR_FEATURE_VALUE, do: 586
  @doc enum: true
  def cv_CAP_PROP_ARAVIS_AUTOTRIGGER, do: 600
  @doc enum: true
  def cv_CAP_PROP_IOS_DEVICE_FOCUS, do: 9001
  @doc enum: true
  def cv_CAP_PROP_IOS_DEVICE_EXPOSURE, do: 9002
  @doc enum: true
  def cv_CAP_PROP_IOS_DEVICE_FLASH, do: 9003
  @doc enum: true
  def cv_CAP_PROP_IOS_DEVICE_WHITEBALANCE, do: 9004
  @doc enum: true
  def cv_CAP_PROP_IOS_DEVICE_TORCH, do: 9005
  @doc enum: true
  def cv_CAP_PROP_GIGA_FRAME_OFFSET_X, do: 10001
  @doc enum: true
  def cv_CAP_PROP_GIGA_FRAME_OFFSET_Y, do: 10002
  @doc enum: true
  def cv_CAP_PROP_GIGA_FRAME_WIDTH_MAX, do: 10003
  @doc enum: true
  def cv_CAP_PROP_GIGA_FRAME_HEIGH_MAX, do: 10004
  @doc enum: true
  def cv_CAP_PROP_GIGA_FRAME_SENS_WIDTH, do: 10005
  @doc enum: true
  def cv_CAP_PROP_GIGA_FRAME_SENS_HEIGH, do: 10006
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_PROFILE_COUNT, do: 11001
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_PROFILE_IDX, do: 11002
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE, do: 11003
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE, do: 11004
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD, do: 11005
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ, do: 11006
  @doc enum: true
  def cv_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT, do: 11007
  @doc enum: true
  def cv_CAP_INTELPERC_DEPTH_GENERATOR, do: bsl(1, 29)
  @doc enum: true
  def cv_CAP_INTELPERC_IMAGE_GENERATOR, do: bsl(1, 28)
  @doc enum: true
  def cv_CAP_INTELPERC_IR_GENERATOR, do: bsl(1, 27)
  @doc enum: true
  def cv_CAP_INTELPERC_GENERATORS_MASK, do: ((cv_CAP_INTELPERC_DEPTH_GENERATOR() + cv_CAP_INTELPERC_IMAGE_GENERATOR()) + cv_CAP_INTELPERC_IR_GENERATOR())
  @doc enum: true
  def cv_CAP_INTELPERC_DEPTH_MAP, do: 0
  @doc enum: true
  def cv_CAP_INTELPERC_UVDEPTH_MAP, do: 1
  @doc enum: true
  def cv_CAP_INTELPERC_IR_MAP, do: 2
  @doc enum: true
  def cv_CAP_INTELPERC_IMAGE, do: 3
  @doc enum: true
  def cv_CAP_PROP_GPHOTO2_PREVIEW, do: 17001
  @doc enum: true
  def cv_CAP_PROP_GPHOTO2_WIDGET_ENUMERATE, do: 17002
  @doc enum: true
  def cv_CAP_PROP_GPHOTO2_RELOAD_CONFIG, do: 17003
  @doc enum: true
  def cv_CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE, do: 17004
  @doc enum: true
  def cv_CAP_PROP_GPHOTO2_COLLECT_MSGS, do: 17005
  @doc enum: true
  def cv_CAP_PROP_GPHOTO2_FLUSH_MSGS, do: 17006
  @doc enum: true
  def cv_CAP_PROP_SPEED, do: 17007
  @doc enum: true
  def cv_CAP_PROP_APERTURE, do: 17008
  @doc enum: true
  def cv_CAP_PROP_EXPOSUREPROGRAM, do: 17009
  @doc enum: true
  def cv_CAP_PROP_VIEWFINDER, do: 17010
  @doc enum: true
  def cv_CAP_PROP_IMAGES_BASE, do: 18000
  @doc enum: true
  def cv_CAP_PROP_IMAGES_LAST, do: 19000
  @doc enum: true
  def cv_LMEDS, do: 4
  @doc enum: true
  def cv_RANSAC, do: 8
  @doc enum: true
  def cv_RHO, do: 16
  @doc enum: true
  def cv_USAC_DEFAULT, do: 32
  @doc enum: true
  def cv_USAC_PARALLEL, do: 33
  @doc enum: true
  def cv_USAC_FM_8PTS, do: 34
  @doc enum: true
  def cv_USAC_FAST, do: 35
  @doc enum: true
  def cv_USAC_ACCURATE, do: 36
  @doc enum: true
  def cv_USAC_PROSAC, do: 37
  @doc enum: true
  def cv_USAC_MAGSAC, do: 38
  @doc enum: true
  def cv_CALIB_CB_ADAPTIVE_THRESH, do: 1
  @doc enum: true
  def cv_CALIB_CB_NORMALIZE_IMAGE, do: 2
  @doc enum: true
  def cv_CALIB_CB_FILTER_QUADS, do: 4
  @doc enum: true
  def cv_CALIB_CB_FAST_CHECK, do: 8
  @doc enum: true
  def cv_CALIB_CB_EXHAUSTIVE, do: 16
  @doc enum: true
  def cv_CALIB_CB_ACCURACY, do: 32
  @doc enum: true
  def cv_CALIB_CB_LARGER, do: 64
  @doc enum: true
  def cv_CALIB_CB_MARKER, do: 128
  @doc enum: true
  def cv_CALIB_CB_PLAIN, do: 256
  @doc enum: true
  def cv_CALIB_CB_SYMMETRIC_GRID, do: 1
  @doc enum: true
  def cv_CALIB_CB_ASYMMETRIC_GRID, do: 2
  @doc enum: true
  def cv_CALIB_CB_CLUSTERING, do: 4
  @doc enum: true
  def cv_CALIB_NINTRINSIC, do: 18
  @doc enum: true
  def cv_CALIB_USE_INTRINSIC_GUESS, do: 1
  @doc enum: true
  def cv_CALIB_FIX_ASPECT_RATIO, do: 2
  @doc enum: true
  def cv_CALIB_FIX_PRINCIPAL_POINT, do: 4
  @doc enum: true
  def cv_CALIB_ZERO_TANGENT_DIST, do: 8
  @doc enum: true
  def cv_CALIB_FIX_FOCAL_LENGTH, do: 16
  @doc enum: true
  def cv_CALIB_FIX_K1, do: 32
  @doc enum: true
  def cv_CALIB_FIX_K2, do: 64
  @doc enum: true
  def cv_CALIB_FIX_K3, do: 128
  @doc enum: true
  def cv_CALIB_FIX_K4, do: 2048
  @doc enum: true
  def cv_CALIB_FIX_K5, do: 4096
  @doc enum: true
  def cv_CALIB_FIX_K6, do: 8192
  @doc enum: true
  def cv_CALIB_RATIONAL_MODEL, do: 16384
  @doc enum: true
  def cv_CALIB_THIN_PRISM_MODEL, do: 32768
  @doc enum: true
  def cv_CALIB_FIX_S1_S2_S3_S4, do: 65536
  @doc enum: true
  def cv_CALIB_TILTED_MODEL, do: 262144
  @doc enum: true
  def cv_CALIB_FIX_TAUX_TAUY, do: 524288
  @doc enum: true
  def cv_CALIB_USE_QR, do: 1048576
  @doc enum: true
  def cv_CALIB_FIX_TANGENT_DIST, do: 2097152
  @doc enum: true
  def cv_CALIB_FIX_INTRINSIC, do: 256
  @doc enum: true
  def cv_CALIB_SAME_FOCAL_LENGTH, do: 512
  @doc enum: true
  def cv_CALIB_ZERO_DISPARITY, do: 1024
  @doc enum: true
  def cv_CALIB_USE_LU, do: bsl(1, 17)
  @doc enum: true
  def cv_CALIB_USE_EXTRINSIC_GUESS, do: bsl(1, 22)
  @doc enum: true
  def cv_FM_7POINT, do: 1
  @doc enum: true
  def cv_FM_8POINT, do: 2
  @doc enum: true
  def cv_FM_LMEDS, do: 4
  @doc enum: true
  def cv_FM_RANSAC, do: 8
  @doc enum: true
  def cv_CASCADE_DO_CANNY_PRUNING, do: 1
  @doc enum: true
  def cv_CASCADE_SCALE_IMAGE, do: 2
  @doc enum: true
  def cv_CASCADE_FIND_BIGGEST_OBJECT, do: 4
  @doc enum: true
  def cv_CASCADE_DO_ROUGH_SEARCH, do: 8
  @doc enum: true
  def cv_OPTFLOW_USE_INITIAL_FLOW, do: 4
  @doc enum: true
  def cv_OPTFLOW_LK_GET_MIN_EIGENVALS, do: 8
  @doc enum: true
  def cv_OPTFLOW_FARNEBACK_GAUSSIAN, do: 256
  @doc enum: true
  def cv_MOTION_TRANSLATION, do: 0
  @doc enum: true
  def cv_MOTION_EUCLIDEAN, do: 1
  @doc enum: true
  def cv_MOTION_AFFINE, do: 2
  @doc enum: true
  def cv_MOTION_HOMOGRAPHY, do: 3


  @doc """
  return a list of enabled modules in this build
  """
  def enabled_modules do
    :evision_nif.enabled_modules()
  end

  @doc """
  Finds an object center, size, and orientation.

  ##### Positional Arguments
  - **probImage**: `Evision.Mat`.

    Back projection of the object histogram. See calcBackProject.

  - **criteria**: `TermCriteria`.

    Stop criteria for the underlying meanShift.
    returns
    (in old interfaces) Number of iterations CAMSHIFT took to converge
    The function implements the CAMSHIFT object tracking algorithm @cite Bradski98 . First, it finds an
    object center using meanShift and then adjusts the window size and finds the optimal rotation. The
    function returns the rotated rectangle structure that includes the object position, size, and
    orientation. The next position of the search window can be obtained with RotatedRect::boundingRect()

  ##### Return
  - **retval**: `{centre={x, y}, size={s1, s2}, angle}`
  - **window**: `Rect`.

    Initial search window.

  See the OpenCV sample camshiftdemo.c that tracks colored objects.
  **Note**: 
  - (Python) A sample explaining the camshift tracking algorithm can be found at
    opencv_source_code/samples/python/camshift.py

  Python prototype (for reference only):
  ```python3
  CamShift(probImage, window, criteria) -> retval, window
  ```
  """
  @spec camShift(Evision.Mat.maybe_mat_in(), {number(), number(), number(), number()}, {integer(), integer(), number()}) :: {{{number(), number()}, {number(), number()}, number()}, {number(), number(), number(), number()}} | {:error, String.t()}
  def camShift(probImage, window, criteria) when (is_struct(probImage, Evision.Mat) or is_struct(probImage, Nx.Tensor) or is_number(probImage) or is_tuple(probImage)) and is_tuple(window) and is_tuple(criteria)
  do
    positional = [
      probImage: Evision.Internal.Structurise.from_struct(probImage),
      window: Evision.Internal.Structurise.from_struct(window),
      criteria: Evision.Internal.Structurise.from_struct(criteria)
    ]
    :evision_nif.camShift(positional)
    |> to_struct()
  end

  @doc """
  Canny

  ##### Positional Arguments
  - **dx**: `Evision.Mat`.

    16-bit x derivative of input image (CV_16SC1 or CV_16SC3).

  - **dy**: `Evision.Mat`.

    16-bit y derivative of input image (same type as dx).

  - **threshold1**: `double`.

    first threshold for the hysteresis procedure.

  - **threshold2**: `double`.

    second threshold for the hysteresis procedure.

  ##### Keyword Arguments
  - **l2gradient**: `bool`.

    a flag, indicating whether a more accurate \\f$L_2\\f$ norm
    \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (
    L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (
    L2gradient=false ).

  ##### Return
  - **edges**: `Evision.Mat.t()`.

    output edge map; single channels 8-bit image, which has the same size as image .

  Finds edges in an image using the Canny algorithm with custom image gradient.

  Python prototype (for reference only):
  ```python3
  Canny(dx, dy, threshold1, threshold2[, edges[, L2gradient]]) -> edges
  ```
  """
  @spec canny(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), number(), [{:l2gradient, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def canny(dx, dy, threshold1, threshold2, opts) when (is_struct(dx, Evision.Mat) or is_struct(dx, Nx.Tensor) or is_number(dx) or is_tuple(dx)) and (is_struct(dy, Evision.Mat) or is_struct(dy, Nx.Tensor) or is_number(dy) or is_tuple(dy)) and is_number(threshold1) and is_number(threshold2) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:l2gradient])
    positional = [
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy),
      threshold1: Evision.Internal.Structurise.from_struct(threshold1),
      threshold2: Evision.Internal.Structurise.from_struct(threshold2)
    ]
    :evision_nif.canny(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Canny

  ##### Positional Arguments
  - **dx**: `Evision.Mat`.

    16-bit x derivative of input image (CV_16SC1 or CV_16SC3).

  - **dy**: `Evision.Mat`.

    16-bit y derivative of input image (same type as dx).

  - **threshold1**: `double`.

    first threshold for the hysteresis procedure.

  - **threshold2**: `double`.

    second threshold for the hysteresis procedure.

  ##### Keyword Arguments
  - **l2gradient**: `bool`.

    a flag, indicating whether a more accurate \\f$L_2\\f$ norm
    \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (
    L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (
    L2gradient=false ).

  ##### Return
  - **edges**: `Evision.Mat.t()`.

    output edge map; single channels 8-bit image, which has the same size as image .

  Finds edges in an image using the Canny algorithm with custom image gradient.

  Python prototype (for reference only):
  ```python3
  Canny(dx, dy, threshold1, threshold2[, edges[, L2gradient]]) -> edges
  ```
  #### Variant 2:
  Finds edges in an image using the Canny algorithm @cite Canny86 .

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit input image.

  - **threshold1**: `double`.

    first threshold for the hysteresis procedure.

  - **threshold2**: `double`.

    second threshold for the hysteresis procedure.

  ##### Keyword Arguments
  - **apertureSize**: `integer()`.

    aperture size for the Sobel operator.

  - **l2gradient**: `bool`.

    a flag, indicating whether a more accurate \\f$L_2\\f$ norm
    \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (
    L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (
    L2gradient=false ).

  ##### Return
  - **edges**: `Evision.Mat.t()`.

    output edge map; single channels 8-bit image, which has the same size as image .

  The function finds edges in the input image and marks them in the output map edges using the
  Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
  largest value is used to find initial segments of strong edges. See
  <http://en.wikipedia.org/wiki/Canny_edge_detector>

  Python prototype (for reference only):
  ```python3
  Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) -> edges
  ```

  """
  @spec canny(Evision.Mat.maybe_mat_in(), number(), number(), [{:apertureSize, term()} | {:l2gradient, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def canny(image, threshold1, threshold2, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(threshold1) and is_number(threshold2) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:apertureSize, :l2gradient])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      threshold1: Evision.Internal.Structurise.from_struct(threshold1),
      threshold2: Evision.Internal.Structurise.from_struct(threshold2)
    ]
    :evision_nif.canny(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec canny(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def canny(dx, dy, threshold1, threshold2) when (is_struct(dx, Evision.Mat) or is_struct(dx, Nx.Tensor) or is_number(dx) or is_tuple(dx)) and (is_struct(dy, Evision.Mat) or is_struct(dy, Nx.Tensor) or is_number(dy) or is_tuple(dy)) and is_number(threshold1) and is_number(threshold2)
  do
    positional = [
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy),
      threshold1: Evision.Internal.Structurise.from_struct(threshold1),
      threshold2: Evision.Internal.Structurise.from_struct(threshold2)
    ]
    :evision_nif.canny(positional)
    |> to_struct()
  end

  @doc """
  Finds edges in an image using the Canny algorithm @cite Canny86 .

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit input image.

  - **threshold1**: `double`.

    first threshold for the hysteresis procedure.

  - **threshold2**: `double`.

    second threshold for the hysteresis procedure.

  ##### Keyword Arguments
  - **apertureSize**: `integer()`.

    aperture size for the Sobel operator.

  - **l2gradient**: `bool`.

    a flag, indicating whether a more accurate \\f$L_2\\f$ norm
    \\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (
    L2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (
    L2gradient=false ).

  ##### Return
  - **edges**: `Evision.Mat.t()`.

    output edge map; single channels 8-bit image, which has the same size as image .

  The function finds edges in the input image and marks them in the output map edges using the
  Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
  largest value is used to find initial segments of strong edges. See
  <http://en.wikipedia.org/wiki/Canny_edge_detector>

  Python prototype (for reference only):
  ```python3
  Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) -> edges
  ```
  """
  @spec canny(Evision.Mat.maybe_mat_in(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def canny(image, threshold1, threshold2) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(threshold1) and is_number(threshold2)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      threshold1: Evision.Internal.Structurise.from_struct(threshold1),
      threshold2: Evision.Internal.Structurise.from_struct(threshold2)
    ]
    :evision_nif.canny(positional)
    |> to_struct()
  end

  @doc """
  Computes the "minimal work" distance between two weighted point configurations.

  ##### Positional Arguments
  - **signature1**: `Evision.Mat`.

    First signature, a \\f$\\texttt{size1}\\times \\texttt{dims}+1\\f$ floating-point matrix.
    Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
    a single column (weights only) if the user-defined cost matrix is used. The weights must be
    non-negative and have at least one non-zero value.

  - **signature2**: `Evision.Mat`.

    Second signature of the same format as signature1 , though the number of rows
    may be different. The total weights may be different. In this case an extra "dummy" point is added
    to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
    value.

  - **distType**: `integer()`.

    Used metric. See #DistanceTypes.

  ##### Keyword Arguments
  - **cost**: `Evision.Mat`.

    User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ cost matrix. Also, if a cost matrix
    is used, lower boundary lowerBound cannot be calculated because it needs a metric function.

  ##### Return
  - **retval**: `float`
  - **lowerBound**: `float`.

    Optional input/output parameter: lower boundary of a distance between the two
    signatures that is a distance between mass centers. The lower boundary may not be calculated if
    the user-defined cost matrix is used, the total weights of point configurations are not equal, or
    if the signatures consist of weights only (the signature matrices have a single column). You
    * must** initialize \\*lowerBound . If the calculated distance between mass centers is greater or
      equal to \\*lowerBound (it means that the signatures are far enough), the function does not
      calculate EMD. In any case \\*lowerBound is set to the calculated distance between mass centers on
      return. Thus, if you want to calculate both distance between mass centers and EMD, \\*lowerBound
      should be set to 0.

  - **flow**: `Evision.Mat.t()`.

    Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is
    a flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of signature2 .

  The function computes the earth mover distance and/or a lower boundary of the distance between the
  two weighted point configurations. One of the applications described in @cite RubnerSept98,
  @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
  problem that is solved using some modification of a simplex algorithm, thus the complexity is
  exponential in the worst case, though, on average it is much faster. In the case of a real metric
  the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
  to determine roughly whether the two signatures are far enough so that they cannot relate to the
  same object.

  Python prototype (for reference only):
  ```python3
  EMD(signature1, signature2, distType[, cost[, lowerBound[, flow]]]) -> retval, lowerBound, flow
  ```
  """
  @spec emd(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:cost, term()}] | nil) :: {number(), number(), Evision.Mat.t()} | {:error, String.t()}
  def emd(signature1, signature2, distType, opts) when (is_struct(signature1, Evision.Mat) or is_struct(signature1, Nx.Tensor) or is_number(signature1) or is_tuple(signature1)) and (is_struct(signature2, Evision.Mat) or is_struct(signature2, Nx.Tensor) or is_number(signature2) or is_tuple(signature2)) and is_integer(distType) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:cost])
    positional = [
      signature1: Evision.Internal.Structurise.from_struct(signature1),
      signature2: Evision.Internal.Structurise.from_struct(signature2),
      distType: Evision.Internal.Structurise.from_struct(distType)
    ]
    :evision_nif.emd(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes the "minimal work" distance between two weighted point configurations.

  ##### Positional Arguments
  - **signature1**: `Evision.Mat`.

    First signature, a \\f$\\texttt{size1}\\times \\texttt{dims}+1\\f$ floating-point matrix.
    Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
    a single column (weights only) if the user-defined cost matrix is used. The weights must be
    non-negative and have at least one non-zero value.

  - **signature2**: `Evision.Mat`.

    Second signature of the same format as signature1 , though the number of rows
    may be different. The total weights may be different. In this case an extra "dummy" point is added
    to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
    value.

  - **distType**: `integer()`.

    Used metric. See #DistanceTypes.

  ##### Keyword Arguments
  - **cost**: `Evision.Mat`.

    User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ cost matrix. Also, if a cost matrix
    is used, lower boundary lowerBound cannot be calculated because it needs a metric function.

  ##### Return
  - **retval**: `float`
  - **lowerBound**: `float`.

    Optional input/output parameter: lower boundary of a distance between the two
    signatures that is a distance between mass centers. The lower boundary may not be calculated if
    the user-defined cost matrix is used, the total weights of point configurations are not equal, or
    if the signatures consist of weights only (the signature matrices have a single column). You
    * must** initialize \\*lowerBound . If the calculated distance between mass centers is greater or
      equal to \\*lowerBound (it means that the signatures are far enough), the function does not
      calculate EMD. In any case \\*lowerBound is set to the calculated distance between mass centers on
      return. Thus, if you want to calculate both distance between mass centers and EMD, \\*lowerBound
      should be set to 0.

  - **flow**: `Evision.Mat.t()`.

    Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is
    a flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of signature2 .

  The function computes the earth mover distance and/or a lower boundary of the distance between the
  two weighted point configurations. One of the applications described in @cite RubnerSept98,
  @cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
  problem that is solved using some modification of a simplex algorithm, thus the complexity is
  exponential in the worst case, though, on average it is much faster. In the case of a real metric
  the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
  to determine roughly whether the two signatures are far enough so that they cannot relate to the
  same object.

  Python prototype (for reference only):
  ```python3
  EMD(signature1, signature2, distType[, cost[, lowerBound[, flow]]]) -> retval, lowerBound, flow
  ```
  """
  @spec emd(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: {number(), number(), Evision.Mat.t()} | {:error, String.t()}
  def emd(signature1, signature2, distType) when (is_struct(signature1, Evision.Mat) or is_struct(signature1, Nx.Tensor) or is_number(signature1) or is_tuple(signature1)) and (is_struct(signature2, Evision.Mat) or is_struct(signature2, Nx.Tensor) or is_number(signature2) or is_tuple(signature2)) and is_integer(distType)
  do
    positional = [
      signature1: Evision.Internal.Structurise.from_struct(signature1),
      signature2: Evision.Internal.Structurise.from_struct(signature2),
      distType: Evision.Internal.Structurise.from_struct(distType)
    ]
    :evision_nif.emd(positional)
    |> to_struct()
  end

  @doc """
  Blurs an image using a Gaussian filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; the image can have any number of channels, which are processed
    independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **ksize**: `Size`.

    Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
    positive and odd. Or, they can be zero's and then they are computed from sigma.

  - **sigmaX**: `double`.

    Gaussian kernel standard deviation in X direction.

  ##### Keyword Arguments
  - **sigmaY**: `double`.

    Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
    equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
    respectively (see #getGaussianKernel for details); to fully control the result regardless of
    possible future modifications of all this semantics, it is recommended to specify all of ksize,
    sigmaX, and sigmaY.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function convolves the source image with the specified Gaussian kernel. In-place filtering is
  supported.

  @sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur

  Python prototype (for reference only):
  ```python3
  GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]]) -> dst
  ```
  """
  @spec gaussianBlur(Evision.Mat.maybe_mat_in(), {number(), number()}, number(), [{:borderType, term()} | {:sigmaY, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def gaussianBlur(src, ksize, sigmaX, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(ksize) and is_number(sigmaX) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :sigmaY])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      sigmaX: Evision.Internal.Structurise.from_struct(sigmaX)
    ]
    :evision_nif.gaussianBlur(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Blurs an image using a Gaussian filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; the image can have any number of channels, which are processed
    independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **ksize**: `Size`.

    Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
    positive and odd. Or, they can be zero's and then they are computed from sigma.

  - **sigmaX**: `double`.

    Gaussian kernel standard deviation in X direction.

  ##### Keyword Arguments
  - **sigmaY**: `double`.

    Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
    equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
    respectively (see #getGaussianKernel for details); to fully control the result regardless of
    possible future modifications of all this semantics, it is recommended to specify all of ksize,
    sigmaX, and sigmaY.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function convolves the source image with the specified Gaussian kernel. In-place filtering is
  supported.

  @sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur

  Python prototype (for reference only):
  ```python3
  GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]]) -> dst
  ```
  """
  @spec gaussianBlur(Evision.Mat.maybe_mat_in(), {number(), number()}, number()) :: Evision.Mat.t() | {:error, String.t()}
  def gaussianBlur(src, ksize, sigmaX) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(ksize) and is_number(sigmaX)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      sigmaX: Evision.Internal.Structurise.from_struct(sigmaX)
    ]
    :evision_nif.gaussianBlur(positional)
    |> to_struct()
  end

  @doc """
  Finds circles in a grayscale image using the Hough transform.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit, single-channel, grayscale input image.

  - **method**: `integer()`.

    Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.

  - **dp**: `double`.

    Inverse ratio of the accumulator resolution to the image resolution. For example, if
    dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
    half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
    unless some small very circles need to be detected.

  - **minDist**: `double`.

    Minimum distance between the centers of the detected circles. If the parameter is
    too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
    too large, some circles may be missed.

  ##### Keyword Arguments
  - **param1**: `double`.

    First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT,
    it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
    Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
    should normally be higher, such as 300 or normally exposed and contrasty images.

  - **param2**: `double`.

    Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the
    accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
    false circles may be detected. Circles, corresponding to the larger accumulator values, will be
    returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
    The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
    If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
    But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.

  - **minRadius**: `integer()`.

    Minimum circle radius.

  - **maxRadius**: `integer()`.

    Maximum circle radius. If <= 0, uses the maximum image dimension. If < 0, #HOUGH_GRADIENT returns
    centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

  ##### Return
  - **circles**: `Evision.Mat.t()`.

    Output vector of found circles. Each vector is encoded as  3 or 4 element
    floating-point vector \\f$(x, y, radius)\\f$ or \\f$(x, y, radius, votes)\\f$ .

  The function finds circles in a grayscale image using a modification of the Hough transform.
  Example: :
  @include snippets/imgproc_HoughLinesCircles.cpp
  **Note**: Usually the function detects the centers of circles well. However, it may fail to find correct
  radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
  you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
  to return centers only without radius search, and find the correct radius using an additional procedure.
  It also helps to smooth image a bit unless it's already soft. For example,
  GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.

  @sa fitEllipse, minEnclosingCircle

  Python prototype (for reference only):
  ```python3
  HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) -> circles
  ```
  """
  @spec houghCircles(Evision.Mat.maybe_mat_in(), integer(), number(), number(), [{:maxRadius, term()} | {:minRadius, term()} | {:param1, term()} | {:param2, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def houghCircles(image, method, dp, minDist, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(method) and is_number(dp) and is_number(minDist) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxRadius, :minRadius, :param1, :param2])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      method: Evision.Internal.Structurise.from_struct(method),
      dp: Evision.Internal.Structurise.from_struct(dp),
      minDist: Evision.Internal.Structurise.from_struct(minDist)
    ]
    :evision_nif.houghCircles(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds circles in a grayscale image using the Hough transform.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit, single-channel, grayscale input image.

  - **method**: `integer()`.

    Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.

  - **dp**: `double`.

    Inverse ratio of the accumulator resolution to the image resolution. For example, if
    dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
    half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
    unless some small very circles need to be detected.

  - **minDist**: `double`.

    Minimum distance between the centers of the detected circles. If the parameter is
    too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
    too large, some circles may be missed.

  ##### Keyword Arguments
  - **param1**: `double`.

    First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT,
    it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
    Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
    should normally be higher, such as 300 or normally exposed and contrasty images.

  - **param2**: `double`.

    Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the
    accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
    false circles may be detected. Circles, corresponding to the larger accumulator values, will be
    returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
    The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
    If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
    But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.

  - **minRadius**: `integer()`.

    Minimum circle radius.

  - **maxRadius**: `integer()`.

    Maximum circle radius. If <= 0, uses the maximum image dimension. If < 0, #HOUGH_GRADIENT returns
    centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

  ##### Return
  - **circles**: `Evision.Mat.t()`.

    Output vector of found circles. Each vector is encoded as  3 or 4 element
    floating-point vector \\f$(x, y, radius)\\f$ or \\f$(x, y, radius, votes)\\f$ .

  The function finds circles in a grayscale image using a modification of the Hough transform.
  Example: :
  @include snippets/imgproc_HoughLinesCircles.cpp
  **Note**: Usually the function detects the centers of circles well. However, it may fail to find correct
  radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
  you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
  to return centers only without radius search, and find the correct radius using an additional procedure.
  It also helps to smooth image a bit unless it's already soft. For example,
  GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.

  @sa fitEllipse, minEnclosingCircle

  Python prototype (for reference only):
  ```python3
  HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) -> circles
  ```
  """
  @spec houghCircles(Evision.Mat.maybe_mat_in(), integer(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def houghCircles(image, method, dp, minDist) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(method) and is_number(dp) and is_number(minDist)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      method: Evision.Internal.Structurise.from_struct(method),
      dp: Evision.Internal.Structurise.from_struct(dp),
      minDist: Evision.Internal.Structurise.from_struct(minDist)
    ]
    :evision_nif.houghCircles(positional)
    |> to_struct()
  end

  @doc """
  Finds lines in a binary image using the standard Hough transform.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit, single-channel binary source image. The image may be modified by the function.

  - **rho**: `double`.

    Distance resolution of the accumulator in pixels.

  - **theta**: `double`.

    Angle resolution of the accumulator in radians.

  - **threshold**: `integer()`.

    %Accumulator threshold parameter. Only those lines are returned that get enough
    votes ( \\f$>\\texttt{threshold}\\f$ ).

  ##### Keyword Arguments
  - **srn**: `double`.

    For the multi-scale Hough transform, it is a divisor for the distance resolution rho.
    The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
    rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
    parameters should be positive.

  - **stn**: `double`.

    For the multi-scale Hough transform, it is a divisor for the distance resolution theta.

  - **min_theta**: `double`.

    For standard and multi-scale Hough transform, minimum angle to check for lines.
    Must fall between 0 and max_theta.

  - **max_theta**: `double`.

    For standard and multi-scale Hough transform, an upper bound for the angle.
    Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
    less than max_theta, depending on the parameters min_theta and theta.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of lines. Each line is represented by a 2 or 3 element vector
    \\f$(\\rho, \\theta)\\f$ or \\f$(\\rho, \\theta, \\textrm{votes})\\f$, where \\f$\\rho\\f$ is the distance from
    the coordinate origin \\f$(0,0)\\f$ (top-left corner of the image), \\f$\\theta\\f$ is the line rotation
    angle in radians ( \\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\\f$ ), and
    \\f$\\textrm{votes}\\f$ is the value of accumulator.

  The function implements the standard or standard multi-scale Hough transform algorithm for line
  detection. See <http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm> for a good explanation of Hough
  transform.

  Python prototype (for reference only):
  ```python3
  HoughLines(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -> lines
  ```
  """
  @spec houghLines(Evision.Mat.maybe_mat_in(), number(), number(), integer(), [{:max_theta, term()} | {:min_theta, term()} | {:srn, term()} | {:stn, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def houghLines(image, rho, theta, threshold, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(rho) and is_number(theta) and is_integer(threshold) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:max_theta, :min_theta, :srn, :stn])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      rho: Evision.Internal.Structurise.from_struct(rho),
      theta: Evision.Internal.Structurise.from_struct(theta),
      threshold: Evision.Internal.Structurise.from_struct(threshold)
    ]
    :evision_nif.houghLines(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds lines in a binary image using the standard Hough transform.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit, single-channel binary source image. The image may be modified by the function.

  - **rho**: `double`.

    Distance resolution of the accumulator in pixels.

  - **theta**: `double`.

    Angle resolution of the accumulator in radians.

  - **threshold**: `integer()`.

    %Accumulator threshold parameter. Only those lines are returned that get enough
    votes ( \\f$>\\texttt{threshold}\\f$ ).

  ##### Keyword Arguments
  - **srn**: `double`.

    For the multi-scale Hough transform, it is a divisor for the distance resolution rho.
    The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
    rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
    parameters should be positive.

  - **stn**: `double`.

    For the multi-scale Hough transform, it is a divisor for the distance resolution theta.

  - **min_theta**: `double`.

    For standard and multi-scale Hough transform, minimum angle to check for lines.
    Must fall between 0 and max_theta.

  - **max_theta**: `double`.

    For standard and multi-scale Hough transform, an upper bound for the angle.
    Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
    less than max_theta, depending on the parameters min_theta and theta.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of lines. Each line is represented by a 2 or 3 element vector
    \\f$(\\rho, \\theta)\\f$ or \\f$(\\rho, \\theta, \\textrm{votes})\\f$, where \\f$\\rho\\f$ is the distance from
    the coordinate origin \\f$(0,0)\\f$ (top-left corner of the image), \\f$\\theta\\f$ is the line rotation
    angle in radians ( \\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\\f$ ), and
    \\f$\\textrm{votes}\\f$ is the value of accumulator.

  The function implements the standard or standard multi-scale Hough transform algorithm for line
  detection. See <http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm> for a good explanation of Hough
  transform.

  Python prototype (for reference only):
  ```python3
  HoughLines(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -> lines
  ```
  """
  @spec houghLines(Evision.Mat.maybe_mat_in(), number(), number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def houghLines(image, rho, theta, threshold) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(rho) and is_number(theta) and is_integer(threshold)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      rho: Evision.Internal.Structurise.from_struct(rho),
      theta: Evision.Internal.Structurise.from_struct(theta),
      threshold: Evision.Internal.Structurise.from_struct(threshold)
    ]
    :evision_nif.houghLines(positional)
    |> to_struct()
  end

  @doc """
  Finds line segments in a binary image using the probabilistic Hough transform.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit, single-channel binary source image. The image may be modified by the function.

  - **rho**: `double`.

    Distance resolution of the accumulator in pixels.

  - **theta**: `double`.

    Angle resolution of the accumulator in radians.

  - **threshold**: `integer()`.

    %Accumulator threshold parameter. Only those lines are returned that get enough
    votes ( \\f$>\\texttt{threshold}\\f$ ).

  ##### Keyword Arguments
  - **minLineLength**: `double`.

    Minimum line length. Line segments shorter than that are rejected.

  - **maxLineGap**: `double`.

    Maximum allowed gap between points on the same line to link them.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of lines. Each line is represented by a 4-element vector
    \\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, y_2)\\f$ are the ending points of each detected
    line segment.

  The function implements the probabilistic Hough transform algorithm for line detection, described
  in @cite Matas00
  See the line detection example below:
  @include snippets/imgproc_HoughLinesP.cpp
  This is a sample picture the function parameters have been tuned for:
  ![image](pics/building.jpg)
  And this is the output of the above program in case of the probabilistic Hough transform:
  ![image](pics/houghp.png)

  @sa LineSegmentDetector

  Python prototype (for reference only):
  ```python3
  HoughLinesP(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]]) -> lines
  ```
  """
  @spec houghLinesP(Evision.Mat.maybe_mat_in(), number(), number(), integer(), [{:maxLineGap, term()} | {:minLineLength, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def houghLinesP(image, rho, theta, threshold, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(rho) and is_number(theta) and is_integer(threshold) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxLineGap, :minLineLength])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      rho: Evision.Internal.Structurise.from_struct(rho),
      theta: Evision.Internal.Structurise.from_struct(theta),
      threshold: Evision.Internal.Structurise.from_struct(threshold)
    ]
    :evision_nif.houghLinesP(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds line segments in a binary image using the probabilistic Hough transform.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    8-bit, single-channel binary source image. The image may be modified by the function.

  - **rho**: `double`.

    Distance resolution of the accumulator in pixels.

  - **theta**: `double`.

    Angle resolution of the accumulator in radians.

  - **threshold**: `integer()`.

    %Accumulator threshold parameter. Only those lines are returned that get enough
    votes ( \\f$>\\texttt{threshold}\\f$ ).

  ##### Keyword Arguments
  - **minLineLength**: `double`.

    Minimum line length. Line segments shorter than that are rejected.

  - **maxLineGap**: `double`.

    Maximum allowed gap between points on the same line to link them.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of lines. Each line is represented by a 4-element vector
    \\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, y_2)\\f$ are the ending points of each detected
    line segment.

  The function implements the probabilistic Hough transform algorithm for line detection, described
  in @cite Matas00
  See the line detection example below:
  @include snippets/imgproc_HoughLinesP.cpp
  This is a sample picture the function parameters have been tuned for:
  ![image](pics/building.jpg)
  And this is the output of the above program in case of the probabilistic Hough transform:
  ![image](pics/houghp.png)

  @sa LineSegmentDetector

  Python prototype (for reference only):
  ```python3
  HoughLinesP(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]]) -> lines
  ```
  """
  @spec houghLinesP(Evision.Mat.maybe_mat_in(), number(), number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def houghLinesP(image, rho, theta, threshold) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(rho) and is_number(theta) and is_integer(threshold)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      rho: Evision.Internal.Structurise.from_struct(rho),
      theta: Evision.Internal.Structurise.from_struct(theta),
      threshold: Evision.Internal.Structurise.from_struct(threshold)
    ]
    :evision_nif.houghLinesP(positional)
    |> to_struct()
  end

  @doc """
  Finds lines in a set of points using the standard Hough transform.

  ##### Positional Arguments
  - **point**: `Evision.Mat`.

    Input vector of points. Each vector must be encoded as a Point vector \\f$(x,y)\\f$. Type must be CV_32FC2 or CV_32SC2.

  - **lines_max**: `integer()`.

    Max count of Hough lines.

  - **threshold**: `integer()`.

    %Accumulator threshold parameter. Only those lines are returned that get enough
    votes ( \\f$>\\texttt{threshold}\\f$ ).

  - **min_rho**: `double`.

    Minimum value for \\f$\\rho\\f$ for the accumulator (Note: \\f$\\rho\\f$ can be negative. The absolute value \\f$|\\rho|\\f$ is the distance of a line to the origin.).

  - **max_rho**: `double`.

    Maximum value for \\f$\\rho\\f$ for the accumulator.

  - **rho_step**: `double`.

    Distance resolution of the accumulator.

  - **min_theta**: `double`.

    Minimum angle value of the accumulator in radians.

  - **max_theta**: `double`.

    Upper bound for the angle value of the accumulator in radians. The actual maximum
    angle may be slightly less than max_theta, depending on the parameters min_theta and theta_step.

  - **theta_step**: `double`.

    Angle resolution of the accumulator in radians.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of found lines. Each vector is encoded as a vector<Vec3d> \\f$(votes, rho, theta)\\f$.
    The larger the value of 'votes', the higher the reliability of the Hough line.

  The function finds lines in a set of points using a modification of the Hough transform.
  @include snippets/imgproc_HoughLinesPointSet.cpp

  Python prototype (for reference only):
  ```python3
  HoughLinesPointSet(point, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step[, lines]) -> lines
  ```
  """
  @spec houghLinesPointSet(Evision.Mat.maybe_mat_in(), integer(), integer(), number(), number(), number(), number(), number(), number(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def houghLinesPointSet(point, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step, opts) when (is_struct(point, Evision.Mat) or is_struct(point, Nx.Tensor) or is_number(point) or is_tuple(point)) and is_integer(lines_max) and is_integer(threshold) and is_number(min_rho) and is_number(max_rho) and is_number(rho_step) and is_number(min_theta) and is_number(max_theta) and is_number(theta_step) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      point: Evision.Internal.Structurise.from_struct(point),
      lines_max: Evision.Internal.Structurise.from_struct(lines_max),
      threshold: Evision.Internal.Structurise.from_struct(threshold),
      min_rho: Evision.Internal.Structurise.from_struct(min_rho),
      max_rho: Evision.Internal.Structurise.from_struct(max_rho),
      rho_step: Evision.Internal.Structurise.from_struct(rho_step),
      min_theta: Evision.Internal.Structurise.from_struct(min_theta),
      max_theta: Evision.Internal.Structurise.from_struct(max_theta),
      theta_step: Evision.Internal.Structurise.from_struct(theta_step)
    ]
    :evision_nif.houghLinesPointSet(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds lines in a set of points using the standard Hough transform.

  ##### Positional Arguments
  - **point**: `Evision.Mat`.

    Input vector of points. Each vector must be encoded as a Point vector \\f$(x,y)\\f$. Type must be CV_32FC2 or CV_32SC2.

  - **lines_max**: `integer()`.

    Max count of Hough lines.

  - **threshold**: `integer()`.

    %Accumulator threshold parameter. Only those lines are returned that get enough
    votes ( \\f$>\\texttt{threshold}\\f$ ).

  - **min_rho**: `double`.

    Minimum value for \\f$\\rho\\f$ for the accumulator (Note: \\f$\\rho\\f$ can be negative. The absolute value \\f$|\\rho|\\f$ is the distance of a line to the origin.).

  - **max_rho**: `double`.

    Maximum value for \\f$\\rho\\f$ for the accumulator.

  - **rho_step**: `double`.

    Distance resolution of the accumulator.

  - **min_theta**: `double`.

    Minimum angle value of the accumulator in radians.

  - **max_theta**: `double`.

    Upper bound for the angle value of the accumulator in radians. The actual maximum
    angle may be slightly less than max_theta, depending on the parameters min_theta and theta_step.

  - **theta_step**: `double`.

    Angle resolution of the accumulator in radians.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of found lines. Each vector is encoded as a vector<Vec3d> \\f$(votes, rho, theta)\\f$.
    The larger the value of 'votes', the higher the reliability of the Hough line.

  The function finds lines in a set of points using a modification of the Hough transform.
  @include snippets/imgproc_HoughLinesPointSet.cpp

  Python prototype (for reference only):
  ```python3
  HoughLinesPointSet(point, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step[, lines]) -> lines
  ```
  """
  @spec houghLinesPointSet(Evision.Mat.maybe_mat_in(), integer(), integer(), number(), number(), number(), number(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def houghLinesPointSet(point, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step) when (is_struct(point, Evision.Mat) or is_struct(point, Nx.Tensor) or is_number(point) or is_tuple(point)) and is_integer(lines_max) and is_integer(threshold) and is_number(min_rho) and is_number(max_rho) and is_number(rho_step) and is_number(min_theta) and is_number(max_theta) and is_number(theta_step)
  do
    positional = [
      point: Evision.Internal.Structurise.from_struct(point),
      lines_max: Evision.Internal.Structurise.from_struct(lines_max),
      threshold: Evision.Internal.Structurise.from_struct(threshold),
      min_rho: Evision.Internal.Structurise.from_struct(min_rho),
      max_rho: Evision.Internal.Structurise.from_struct(max_rho),
      rho_step: Evision.Internal.Structurise.from_struct(rho_step),
      min_theta: Evision.Internal.Structurise.from_struct(min_theta),
      max_theta: Evision.Internal.Structurise.from_struct(max_theta),
      theta_step: Evision.Internal.Structurise.from_struct(theta_step)
    ]
    :evision_nif.houghLinesPointSet(positional)
    |> to_struct()
  end

  @doc """
  Finds lines in a binary image using the standard Hough transform and get accumulator.

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **rho**: `double`
  - **theta**: `double`
  - **threshold**: `integer()`

  ##### Keyword Arguments
  - **srn**: `double`.
  - **stn**: `double`.
  - **min_theta**: `double`.
  - **max_theta**: `double`.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

  **Note**: This function is for bindings use only. Use original function in C++ code
  @sa HoughLines

  Python prototype (for reference only):
  ```python3
  HoughLinesWithAccumulator(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -> lines
  ```
  """
  @spec houghLinesWithAccumulator(Evision.Mat.maybe_mat_in(), number(), number(), integer(), [{:max_theta, term()} | {:min_theta, term()} | {:srn, term()} | {:stn, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def houghLinesWithAccumulator(image, rho, theta, threshold, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(rho) and is_number(theta) and is_integer(threshold) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:max_theta, :min_theta, :srn, :stn])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      rho: Evision.Internal.Structurise.from_struct(rho),
      theta: Evision.Internal.Structurise.from_struct(theta),
      threshold: Evision.Internal.Structurise.from_struct(threshold)
    ]
    :evision_nif.houghLinesWithAccumulator(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds lines in a binary image using the standard Hough transform and get accumulator.

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **rho**: `double`
  - **theta**: `double`
  - **threshold**: `integer()`

  ##### Keyword Arguments
  - **srn**: `double`.
  - **stn**: `double`.
  - **min_theta**: `double`.
  - **max_theta**: `double`.

  ##### Return
  - **lines**: `Evision.Mat.t()`.

  **Note**: This function is for bindings use only. Use original function in C++ code
  @sa HoughLines

  Python prototype (for reference only):
  ```python3
  HoughLinesWithAccumulator(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -> lines
  ```
  """
  @spec houghLinesWithAccumulator(Evision.Mat.maybe_mat_in(), number(), number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def houghLinesWithAccumulator(image, rho, theta, threshold) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_number(rho) and is_number(theta) and is_integer(threshold)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      rho: Evision.Internal.Structurise.from_struct(rho),
      theta: Evision.Internal.Structurise.from_struct(theta),
      threshold: Evision.Internal.Structurise.from_struct(threshold)
    ]
    :evision_nif.houghLinesWithAccumulator(positional)
    |> to_struct()
  end

  @doc """
  HuMoments

  ##### Positional Arguments
  - **m**: `Moments`

  ##### Return
  - **hu**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  HuMoments(m[, hu]) -> hu
  ```
  """
  @spec huMoments(map(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def huMoments(m, opts) when is_map(m) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.huMoments(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  HuMoments

  ##### Positional Arguments
  - **m**: `Moments`

  ##### Return
  - **hu**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  HuMoments(m[, hu]) -> hu
  ```
  """
  @spec huMoments(map()) :: Evision.Mat.t() | {:error, String.t()}
  def huMoments(m) when is_map(m)
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.huMoments(positional)
    |> to_struct()
  end

  @doc """
  Performs a look-up table transform of an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array of 8-bit elements.

  - **lut**: `Evision.Mat`.

    look-up table of 256 elements; in case of multi-channel input array, the table should
    either have a single channel (in this case the same table is used for all channels) or the same
    number of channels as in the input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and number of channels as src, and the same depth as lut.

  The function LUT fills the output array with values from the look-up table. Indices of the entries
  are taken from the input array. That is, the function processes each element of src as follows:
  \\f[\\texttt{dst} (I)  \\leftarrow \\texttt{lut(src(I) + d)}\\f]
  where
  \\f[d =  \\fork{0}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV\\_8U}\\)}{128}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV\\_8S}\\)}\\f]
  @sa  convertScaleAbs, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  LUT(src, lut[, dst]) -> dst
  ```
  """
  @spec lut(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def lut(src, lut, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(lut, Evision.Mat) or is_struct(lut, Nx.Tensor) or is_number(lut) or is_tuple(lut)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      lut: Evision.Internal.Structurise.from_struct(lut)
    ]
    :evision_nif.lut(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs a look-up table transform of an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array of 8-bit elements.

  - **lut**: `Evision.Mat`.

    look-up table of 256 elements; in case of multi-channel input array, the table should
    either have a single channel (in this case the same table is used for all channels) or the same
    number of channels as in the input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and number of channels as src, and the same depth as lut.

  The function LUT fills the output array with values from the look-up table. Indices of the entries
  are taken from the input array. That is, the function processes each element of src as follows:
  \\f[\\texttt{dst} (I)  \\leftarrow \\texttt{lut(src(I) + d)}\\f]
  where
  \\f[d =  \\fork{0}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV\\_8U}\\)}{128}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV\\_8S}\\)}\\f]
  @sa  convertScaleAbs, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  LUT(src, lut[, dst]) -> dst
  ```
  """
  @spec lut(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def lut(src, lut) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(lut, Evision.Mat) or is_struct(lut, Nx.Tensor) or is_number(lut) or is_tuple(lut))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      lut: Evision.Internal.Structurise.from_struct(lut)
    ]
    :evision_nif.lut(positional)
    |> to_struct()
  end

  @doc """
  Calculates the Laplacian of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **ddepth**: `integer()`.

    Desired depth of the destination image, see @ref filter_depths "combinations".

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    Aperture size used to compute the second-derivative filters. See #getDerivKernels for
    details. The size must be positive and odd.

  - **scale**: `double`.

    Optional scale factor for the computed Laplacian values. By default, no scaling is
    applied. See #getDerivKernels for details.

  - **delta**: `double`.

    Optional delta value that is added to the results prior to storing them in dst .

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and the same number of channels as src .

  The function calculates the Laplacian of the source image by adding up the second x and y
  derivatives calculated using the Sobel operator:
  \\f[\\texttt{dst} =  \\Delta \\texttt{src} =  \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} +  \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\f]
  This is done when `ksize > 1`. When `ksize == 1`, the Laplacian is computed by filtering the image
  with the following \\f$3 \\times 3\\f$ aperture:
  \\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f]
  @sa  Sobel, Scharr

  Python prototype (for reference only):
  ```python3
  Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst
  ```
  """
  @spec laplacian(Evision.Mat.maybe_mat_in(), integer(), [{:borderType, term()} | {:delta, term()} | {:ksize, term()} | {:scale, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def laplacian(src, ddepth, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :delta, :ksize, :scale])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth)
    ]
    :evision_nif.laplacian(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the Laplacian of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **ddepth**: `integer()`.

    Desired depth of the destination image, see @ref filter_depths "combinations".

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    Aperture size used to compute the second-derivative filters. See #getDerivKernels for
    details. The size must be positive and odd.

  - **scale**: `double`.

    Optional scale factor for the computed Laplacian values. By default, no scaling is
    applied. See #getDerivKernels for details.

  - **delta**: `double`.

    Optional delta value that is added to the results prior to storing them in dst .

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and the same number of channels as src .

  The function calculates the Laplacian of the source image by adding up the second x and y
  derivatives calculated using the Sobel operator:
  \\f[\\texttt{dst} =  \\Delta \\texttt{src} =  \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} +  \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\f]
  This is done when `ksize > 1`. When `ksize == 1`, the Laplacian is computed by filtering the image
  with the following \\f$3 \\times 3\\f$ aperture:
  \\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f]
  @sa  Sobel, Scharr

  Python prototype (for reference only):
  ```python3
  Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst
  ```
  """
  @spec laplacian(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def laplacian(src, ddepth) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth)
    ]
    :evision_nif.laplacian(positional)
    |> to_struct()
  end

  @doc """
  Calculates the Mahalanobis distance between two vectors.

  ##### Positional Arguments
  - **v1**: `Evision.Mat`.

    first 1D input vector.

  - **v2**: `Evision.Mat`.

    second 1D input vector.

  - **icovar**: `Evision.Mat`.

    inverse covariance matrix.

  ##### Return
  - **retval**: `double`

  The function cv::Mahalanobis calculates and returns the weighted distance between two vectors:
  \\f[d( \\texttt{vec1} , \\texttt{vec2} )= \\sqrt{\\sum\\_{i,j}{\\texttt{icovar(i,j)}\\cdot(\\texttt{vec1}(I)-\\texttt{vec2}(I))\\cdot(\\texttt{vec1(j)}-\\texttt{vec2(j)})} }\\f]
  The covariance matrix may be calculated using the #calcCovarMatrix function and then inverted using
  the invert function (preferably using the #DECOMP_SVD method, as the most accurate).

  Python prototype (for reference only):
  ```python3
  Mahalanobis(v1, v2, icovar) -> retval
  ```
  """
  @spec mahalanobis(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def mahalanobis(v1, v2, icovar) when (is_struct(v1, Evision.Mat) or is_struct(v1, Nx.Tensor) or is_number(v1) or is_tuple(v1)) and (is_struct(v2, Evision.Mat) or is_struct(v2, Nx.Tensor) or is_number(v2) or is_tuple(v2)) and (is_struct(icovar, Evision.Mat) or is_struct(icovar, Nx.Tensor) or is_number(icovar) or is_tuple(icovar))
  do
    positional = [
      v1: Evision.Internal.Structurise.from_struct(v1),
      v2: Evision.Internal.Structurise.from_struct(v2),
      icovar: Evision.Internal.Structurise.from_struct(icovar)
    ]
    :evision_nif.mahalanobis(positional)
    |> to_struct()
  end

  @doc """
  PCABackProject

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **mean**: `Evision.Mat`
  - **eigenvectors**: `Evision.Mat`

  ##### Return
  - **result**: `Evision.Mat.t()`.

  wrap PCA::backProject

  Python prototype (for reference only):
  ```python3
  PCABackProject(data, mean, eigenvectors[, result]) -> result
  ```
  """
  @spec pcaBackProject(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def pcaBackProject(data, mean, eigenvectors, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (is_struct(eigenvectors, Evision.Mat) or is_struct(eigenvectors, Nx.Tensor) or is_number(eigenvectors) or is_tuple(eigenvectors)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      eigenvectors: Evision.Internal.Structurise.from_struct(eigenvectors)
    ]
    :evision_nif.pcaBackProject(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  PCABackProject

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **mean**: `Evision.Mat`
  - **eigenvectors**: `Evision.Mat`

  ##### Return
  - **result**: `Evision.Mat.t()`.

  wrap PCA::backProject

  Python prototype (for reference only):
  ```python3
  PCABackProject(data, mean, eigenvectors[, result]) -> result
  ```
  """
  @spec pcaBackProject(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def pcaBackProject(data, mean, eigenvectors) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (is_struct(eigenvectors, Evision.Mat) or is_struct(eigenvectors, Nx.Tensor) or is_number(eigenvectors) or is_tuple(eigenvectors))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      eigenvectors: Evision.Internal.Structurise.from_struct(eigenvectors)
    ]
    :evision_nif.pcaBackProject(positional)
    |> to_struct()
  end

  @doc """
  PCACompute

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **retainedVariance**: `double`

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.

  wrap PCA::operator()

  Python prototype (for reference only):
  ```python3
  PCACompute(data, mean, retainedVariance[, eigenvectors]) -> mean, eigenvectors
  ```
  """
  @spec pcaCompute(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute(data, mean, retainedVariance, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and is_number(retainedVariance) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      retainedVariance: Evision.Internal.Structurise.from_struct(retainedVariance)
    ]
    :evision_nif.pcaCompute(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  PCACompute

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **retainedVariance**: `double`

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.

  wrap PCA::operator()

  Python prototype (for reference only):
  ```python3
  PCACompute(data, mean, retainedVariance[, eigenvectors]) -> mean, eigenvectors
  ```
  #### Variant 2:
  PCACompute

  ##### Positional Arguments
  - **data**: `Evision.Mat`

  ##### Keyword Arguments
  - **maxComponents**: `integer()`.

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.

  wrap PCA::operator()

  Python prototype (for reference only):
  ```python3
  PCACompute(data, mean[, eigenvectors[, maxComponents]]) -> mean, eigenvectors
  ```

  """
  @spec pcaCompute(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:maxComponents, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute(data, mean, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxComponents])
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean)
    ]
    :evision_nif.pcaCompute(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec pcaCompute(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute(data, mean, retainedVariance) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and is_number(retainedVariance)
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      retainedVariance: Evision.Internal.Structurise.from_struct(retainedVariance)
    ]
    :evision_nif.pcaCompute(positional)
    |> to_struct()
  end

  @doc """
  PCACompute

  ##### Positional Arguments
  - **data**: `Evision.Mat`

  ##### Keyword Arguments
  - **maxComponents**: `integer()`.

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.

  wrap PCA::operator()

  Python prototype (for reference only):
  ```python3
  PCACompute(data, mean[, eigenvectors[, maxComponents]]) -> mean, eigenvectors
  ```
  """
  @spec pcaCompute(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute(data, mean) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean)
    ]
    :evision_nif.pcaCompute(positional)
    |> to_struct()
  end

  @doc """
  PCACompute2

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **retainedVariance**: `double`

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.
  - **eigenvalues**: `Evision.Mat.t()`.

  wrap PCA::operator() and add eigenvalues output parameter

  Python prototype (for reference only):
  ```python3
  PCACompute2(data, mean, retainedVariance[, eigenvectors[, eigenvalues]]) -> mean, eigenvectors, eigenvalues
  ```
  """
  @spec pcaCompute2(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute2(data, mean, retainedVariance, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and is_number(retainedVariance) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      retainedVariance: Evision.Internal.Structurise.from_struct(retainedVariance)
    ]
    :evision_nif.pcaCompute2(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  PCACompute2

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **retainedVariance**: `double`

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.
  - **eigenvalues**: `Evision.Mat.t()`.

  wrap PCA::operator() and add eigenvalues output parameter

  Python prototype (for reference only):
  ```python3
  PCACompute2(data, mean, retainedVariance[, eigenvectors[, eigenvalues]]) -> mean, eigenvectors, eigenvalues
  ```
  #### Variant 2:
  PCACompute2

  ##### Positional Arguments
  - **data**: `Evision.Mat`

  ##### Keyword Arguments
  - **maxComponents**: `integer()`.

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.
  - **eigenvalues**: `Evision.Mat.t()`.

  wrap PCA::operator() and add eigenvalues output parameter

  Python prototype (for reference only):
  ```python3
  PCACompute2(data, mean[, eigenvectors[, eigenvalues[, maxComponents]]]) -> mean, eigenvectors, eigenvalues
  ```

  """
  @spec pcaCompute2(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:maxComponents, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute2(data, mean, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxComponents])
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean)
    ]
    :evision_nif.pcaCompute2(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec pcaCompute2(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute2(data, mean, retainedVariance) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and is_number(retainedVariance)
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      retainedVariance: Evision.Internal.Structurise.from_struct(retainedVariance)
    ]
    :evision_nif.pcaCompute2(positional)
    |> to_struct()
  end

  @doc """
  PCACompute2

  ##### Positional Arguments
  - **data**: `Evision.Mat`

  ##### Keyword Arguments
  - **maxComponents**: `integer()`.

  ##### Return
  - **mean**: `Evision.Mat.t()`
  - **eigenvectors**: `Evision.Mat.t()`.
  - **eigenvalues**: `Evision.Mat.t()`.

  wrap PCA::operator() and add eigenvalues output parameter

  Python prototype (for reference only):
  ```python3
  PCACompute2(data, mean[, eigenvectors[, eigenvalues[, maxComponents]]]) -> mean, eigenvectors, eigenvalues
  ```
  """
  @spec pcaCompute2(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pcaCompute2(data, mean) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean)
    ]
    :evision_nif.pcaCompute2(positional)
    |> to_struct()
  end

  @doc """
  PCAProject

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **mean**: `Evision.Mat`
  - **eigenvectors**: `Evision.Mat`

  ##### Return
  - **result**: `Evision.Mat.t()`.

  wrap PCA::project

  Python prototype (for reference only):
  ```python3
  PCAProject(data, mean, eigenvectors[, result]) -> result
  ```
  """
  @spec pcaProject(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def pcaProject(data, mean, eigenvectors, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (is_struct(eigenvectors, Evision.Mat) or is_struct(eigenvectors, Nx.Tensor) or is_number(eigenvectors) or is_tuple(eigenvectors)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      eigenvectors: Evision.Internal.Structurise.from_struct(eigenvectors)
    ]
    :evision_nif.pcaProject(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  PCAProject

  ##### Positional Arguments
  - **data**: `Evision.Mat`
  - **mean**: `Evision.Mat`
  - **eigenvectors**: `Evision.Mat`

  ##### Return
  - **result**: `Evision.Mat.t()`.

  wrap PCA::project

  Python prototype (for reference only):
  ```python3
  PCAProject(data, mean, eigenvectors[, result]) -> result
  ```
  """
  @spec pcaProject(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def pcaProject(data, mean, eigenvectors) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (is_struct(eigenvectors, Evision.Mat) or is_struct(eigenvectors, Nx.Tensor) or is_number(eigenvectors) or is_tuple(eigenvectors))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      mean: Evision.Internal.Structurise.from_struct(mean),
      eigenvectors: Evision.Internal.Structurise.from_struct(eigenvectors)
    ]
    :evision_nif.pcaProject(positional)
    |> to_struct()
  end

  @doc """
  Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size as src1.

  ##### Keyword Arguments
  - **r**: `double`.

    the maximum pixel value (255 by default)

  ##### Return
  - **retval**: `double`

  This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB),
  between two input arrays src1 and src2. The arrays must have the same type.
  The PSNR is calculated as follows:
  \\f[
  \\texttt{PSNR} = 10 \\cdot \\log\\_{10}{\\left( \\frac{R^2}{MSE} \\right) }
  \\f]
  where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data)
  and MSE is the mean squared error between the two arrays.

  Python prototype (for reference only):
  ```python3
  PSNR(src1, src2[, R]) -> retval
  ```
  """
  @spec psnr(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:r, term()}] | nil) :: number() | {:error, String.t()}
  def psnr(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:r])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.psnr(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size as src1.

  ##### Keyword Arguments
  - **r**: `double`.

    the maximum pixel value (255 by default)

  ##### Return
  - **retval**: `double`

  This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB),
  between two input arrays src1 and src2. The arrays must have the same type.
  The PSNR is calculated as follows:
  \\f[
  \\texttt{PSNR} = 10 \\cdot \\log\\_{10}{\\left( \\frac{R^2}{MSE} \\right) }
  \\f]
  where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data)
  and MSE is the mean squared error between the two arrays.

  Python prototype (for reference only):
  ```python3
  PSNR(src1, src2[, R]) -> retval
  ```
  """
  @spec psnr(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def psnr(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.psnr(positional)
    |> to_struct()
  end

  @doc """
  Computes an RQ decomposition of 3x3 matrices.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    3x3 input matrix.

  ##### Return
  - **retval**: `Vec3d`
  - **mtxR**: `Evision.Mat.t()`.

    Output 3x3 upper-triangular matrix.

  - **mtxQ**: `Evision.Mat.t()`.

    Output 3x3 orthogonal matrix.

  - **qx**: `Evision.Mat.t()`.

    Optional output 3x3 rotation matrix around x-axis.

  - **qy**: `Evision.Mat.t()`.

    Optional output 3x3 rotation matrix around y-axis.

  - **qz**: `Evision.Mat.t()`.

    Optional output 3x3 rotation matrix around z-axis.

  The function computes a RQ decomposition using the given rotations. This function is used in
  #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
  and a rotation matrix.
  It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
  degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
  sequence of rotations about the three principal axes that results in the same orientation of an
  object, e.g. see @cite Slabaugh . Returned three rotation matrices and corresponding three Euler angles
  are only one of the possible solutions.

  Python prototype (for reference only):
  ```python3
  RQDecomp3x3(src[, mtxR[, mtxQ[, Qx[, Qy[, Qz]]]]]) -> retval, mtxR, mtxQ, Qx, Qy, Qz
  ```
  """
  @spec rqDecomp3x3(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {{number(), number(), number()}, Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def rqDecomp3x3(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.rqDecomp3x3(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes an RQ decomposition of 3x3 matrices.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    3x3 input matrix.

  ##### Return
  - **retval**: `Vec3d`
  - **mtxR**: `Evision.Mat.t()`.

    Output 3x3 upper-triangular matrix.

  - **mtxQ**: `Evision.Mat.t()`.

    Output 3x3 orthogonal matrix.

  - **qx**: `Evision.Mat.t()`.

    Optional output 3x3 rotation matrix around x-axis.

  - **qy**: `Evision.Mat.t()`.

    Optional output 3x3 rotation matrix around y-axis.

  - **qz**: `Evision.Mat.t()`.

    Optional output 3x3 rotation matrix around z-axis.

  The function computes a RQ decomposition using the given rotations. This function is used in
  #decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera
  and a rotation matrix.
  It optionally returns three rotation matrices, one for each axis, and the three Euler angles in
  degrees (as the return value) that could be used in OpenGL. Note, there is always more than one
  sequence of rotations about the three principal axes that results in the same orientation of an
  object, e.g. see @cite Slabaugh . Returned three rotation matrices and corresponding three Euler angles
  are only one of the possible solutions.

  Python prototype (for reference only):
  ```python3
  RQDecomp3x3(src[, mtxR[, mtxQ[, Qx[, Qy[, Qz]]]]]) -> retval, mtxR, mtxQ, Qx, Qy, Qz
  ```
  """
  @spec rqDecomp3x3(Evision.Mat.maybe_mat_in()) :: {{number(), number(), number()}, Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def rqDecomp3x3(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.rqDecomp3x3(positional)
    |> to_struct()
  end

  @doc """
  Converts a rotation matrix to a rotation vector or vice versa.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.

  - **jacobian**: `Evision.Mat.t()`.

    Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial
    derivatives of the output array components with respect to the input array components.

  \\f[\\begin{array}{l} \\theta \\leftarrow norm(r) \\\\\\\\ r  \\leftarrow r/ \\theta \\\\\\\\ R =  \\cos(\\theta) I + (1- \\cos{\\theta} ) r r^T +  \\sin(\\theta) \\vecthreethree{0}{-r\\_z}{r\\_y}{r\\_z}{0}{-r\\_x}{-r\\_y}{r\\_x}{0} \\end{array}\\f]
  Inverse transformation can be also done easily, since
  \\f[\\sin ( \\theta ) \\vecthreethree{0}{-r\\_z}{r\\_y}{r\\_z}{0}{-r\\_x}{-r\\_y}{r\\_x}{0} = \\frac{R - R^T}{2}\\f]
  A rotation vector is a convenient and most compact representation of a rotation matrix (since any
  rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry
  optimization procedures like @ref calibrateCamera, @ref stereoCalibrate, or @ref solvePnP .
  **Note**: More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate
  can be found in:
  - A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi @cite Gallego2014ACF

  **Note**: Useful information on SE(3) and Lie Groups can be found in:
  - A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco @cite blanco2010tutorial
  - Lie Groups for 2D and 3D Transformation, Ethan Eade @cite Eade17
  - A micro Lie theory for state estimation in robotics, Joan Solà, Jérémie Deray, Dinesh Atchuthan @cite Sol2018AML

  Python prototype (for reference only):
  ```python3
  Rodrigues(src[, dst[, jacobian]]) -> dst, jacobian
  ```
  """
  @spec rodrigues(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def rodrigues(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.rodrigues(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts a rotation matrix to a rotation vector or vice versa.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.

  - **jacobian**: `Evision.Mat.t()`.

    Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial
    derivatives of the output array components with respect to the input array components.

  \\f[\\begin{array}{l} \\theta \\leftarrow norm(r) \\\\\\\\ r  \\leftarrow r/ \\theta \\\\\\\\ R =  \\cos(\\theta) I + (1- \\cos{\\theta} ) r r^T +  \\sin(\\theta) \\vecthreethree{0}{-r\\_z}{r\\_y}{r\\_z}{0}{-r\\_x}{-r\\_y}{r\\_x}{0} \\end{array}\\f]
  Inverse transformation can be also done easily, since
  \\f[\\sin ( \\theta ) \\vecthreethree{0}{-r\\_z}{r\\_y}{r\\_z}{0}{-r\\_x}{-r\\_y}{r\\_x}{0} = \\frac{R - R^T}{2}\\f]
  A rotation vector is a convenient and most compact representation of a rotation matrix (since any
  rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry
  optimization procedures like @ref calibrateCamera, @ref stereoCalibrate, or @ref solvePnP .
  **Note**: More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate
  can be found in:
  - A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi @cite Gallego2014ACF

  **Note**: Useful information on SE(3) and Lie Groups can be found in:
  - A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco @cite blanco2010tutorial
  - Lie Groups for 2D and 3D Transformation, Ethan Eade @cite Eade17
  - A micro Lie theory for state estimation in robotics, Joan Solà, Jérémie Deray, Dinesh Atchuthan @cite Sol2018AML

  Python prototype (for reference only):
  ```python3
  Rodrigues(src[, dst[, jacobian]]) -> dst, jacobian
  ```
  """
  @spec rodrigues(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def rodrigues(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.rodrigues(positional)
    |> to_struct()
  end

  @doc """
  SVBackSubst

  ##### Positional Arguments
  - **w**: `Evision.Mat`
  - **u**: `Evision.Mat`
  - **vt**: `Evision.Mat`
  - **rhs**: `Evision.Mat`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  wrap SVD::backSubst

  Python prototype (for reference only):
  ```python3
  SVBackSubst(w, u, vt, rhs[, dst]) -> dst
  ```
  """
  @spec svBackSubst(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def svBackSubst(w, u, vt, rhs, opts) when (is_struct(w, Evision.Mat) or is_struct(w, Nx.Tensor) or is_number(w) or is_tuple(w)) and (is_struct(u, Evision.Mat) or is_struct(u, Nx.Tensor) or is_number(u) or is_tuple(u)) and (is_struct(vt, Evision.Mat) or is_struct(vt, Nx.Tensor) or is_number(vt) or is_tuple(vt)) and (is_struct(rhs, Evision.Mat) or is_struct(rhs, Nx.Tensor) or is_number(rhs) or is_tuple(rhs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      w: Evision.Internal.Structurise.from_struct(w),
      u: Evision.Internal.Structurise.from_struct(u),
      vt: Evision.Internal.Structurise.from_struct(vt),
      rhs: Evision.Internal.Structurise.from_struct(rhs)
    ]
    :evision_nif.svBackSubst(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  SVBackSubst

  ##### Positional Arguments
  - **w**: `Evision.Mat`
  - **u**: `Evision.Mat`
  - **vt**: `Evision.Mat`
  - **rhs**: `Evision.Mat`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  wrap SVD::backSubst

  Python prototype (for reference only):
  ```python3
  SVBackSubst(w, u, vt, rhs[, dst]) -> dst
  ```
  """
  @spec svBackSubst(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def svBackSubst(w, u, vt, rhs) when (is_struct(w, Evision.Mat) or is_struct(w, Nx.Tensor) or is_number(w) or is_tuple(w)) and (is_struct(u, Evision.Mat) or is_struct(u, Nx.Tensor) or is_number(u) or is_tuple(u)) and (is_struct(vt, Evision.Mat) or is_struct(vt, Nx.Tensor) or is_number(vt) or is_tuple(vt)) and (is_struct(rhs, Evision.Mat) or is_struct(rhs, Nx.Tensor) or is_number(rhs) or is_tuple(rhs))
  do
    positional = [
      w: Evision.Internal.Structurise.from_struct(w),
      u: Evision.Internal.Structurise.from_struct(u),
      vt: Evision.Internal.Structurise.from_struct(vt),
      rhs: Evision.Internal.Structurise.from_struct(rhs)
    ]
    :evision_nif.svBackSubst(positional)
    |> to_struct()
  end

  @doc """
  SVDecomp

  ##### Positional Arguments
  - **src**: `Evision.Mat`

  ##### Keyword Arguments
  - **flags**: `integer()`.

  ##### Return
  - **w**: `Evision.Mat.t()`.
  - **u**: `Evision.Mat.t()`.
  - **vt**: `Evision.Mat.t()`.

  wrap SVD::compute

  Python prototype (for reference only):
  ```python3
  SVDecomp(src[, w[, u[, vt[, flags]]]]) -> w, u, vt
  ```
  """
  @spec svdDecomp(Evision.Mat.maybe_mat_in(), [{:flags, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def svdDecomp(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.svdDecomp(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  SVDecomp

  ##### Positional Arguments
  - **src**: `Evision.Mat`

  ##### Keyword Arguments
  - **flags**: `integer()`.

  ##### Return
  - **w**: `Evision.Mat.t()`.
  - **u**: `Evision.Mat.t()`.
  - **vt**: `Evision.Mat.t()`.

  wrap SVD::compute

  Python prototype (for reference only):
  ```python3
  SVDecomp(src[, w[, u[, vt[, flags]]]]) -> w, u, vt
  ```
  """
  @spec svdDecomp(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def svdDecomp(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.svdDecomp(positional)
    |> to_struct()
  end

  @doc """
  Calculates the first x- or y- image derivative using Scharr operator.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    output image depth, see @ref filter_depths "combinations"

  - **dx**: `integer()`.

    order of the derivative x.

  - **dy**: `integer()`.

    order of the derivative y.

  ##### Keyword Arguments
  - **scale**: `double`.

    optional scale factor for the computed derivative values; by default, no scaling is
    applied (see #getDerivKernels for details).

  - **delta**: `double`.

    optional delta value that is added to the results prior to storing them in dst.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and the same number of channels as src.

  The function computes the first x- or y- spatial image derivative using the Scharr operator. The
  call
  \\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\\f]
  is equivalent to
  \\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER\\_SCHARR, scale, delta, borderType)} .\\f]
  @sa  cartToPolar

  Python prototype (for reference only):
  ```python3
  Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -> dst
  ```
  """
  @spec scharr(Evision.Mat.maybe_mat_in(), integer(), integer(), integer(), [{:borderType, term()} | {:delta, term()} | {:scale, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def scharr(src, ddepth, dx, dy, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_integer(dx) and is_integer(dy) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :delta, :scale])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy)
    ]
    :evision_nif.scharr(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the first x- or y- image derivative using Scharr operator.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    output image depth, see @ref filter_depths "combinations"

  - **dx**: `integer()`.

    order of the derivative x.

  - **dy**: `integer()`.

    order of the derivative y.

  ##### Keyword Arguments
  - **scale**: `double`.

    optional scale factor for the computed derivative values; by default, no scaling is
    applied (see #getDerivKernels for details).

  - **delta**: `double`.

    optional delta value that is added to the results prior to storing them in dst.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and the same number of channels as src.

  The function computes the first x- or y- spatial image derivative using the Scharr operator. The
  call
  \\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\\f]
  is equivalent to
  \\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER\\_SCHARR, scale, delta, borderType)} .\\f]
  @sa  cartToPolar

  Python prototype (for reference only):
  ```python3
  Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -> dst
  ```
  """
  @spec scharr(Evision.Mat.maybe_mat_in(), integer(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def scharr(src, ddepth, dx, dy) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_integer(dx) and is_integer(dy)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy)
    ]
    :evision_nif.scharr(positional)
    |> to_struct()
  end

  @doc """
  Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    output image depth, see @ref filter_depths "combinations"; in the case of
    8-bit input images it will result in truncated derivatives.

  - **dx**: `integer()`.

    order of the derivative x.

  - **dy**: `integer()`.

    order of the derivative y.

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    size of the extended Sobel kernel; it must be 1, 3, 5, or 7.

  - **scale**: `double`.

    optional scale factor for the computed derivative values; by default, no scaling is
    applied (see #getDerivKernels for details).

  - **delta**: `double`.

    optional delta value that is added to the results prior to storing them in dst.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and the same number of channels as src .

  In all cases except one, the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ separable kernel is used to
  calculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 \\times 1\\f$ or \\f$1 \\times 3\\f$
  kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first
  or the second x- or y- derivatives.
  There is also the special value `ksize = #FILTER_SCHARR (-1)` that corresponds to the \\f$3\\times3\\f$ Scharr
  filter that may give more accurate results than the \\f$3\\times3\\f$ Sobel. The Scharr aperture is
  \\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f]
  for the x-derivative, or transposed for the y-derivative.
  The function calculates an image derivative by convolving the image with the appropriate kernel:
  \\f[\\texttt{dst} =  \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f]
  The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
  resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
  or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
  case corresponds to a kernel of:
  \\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f]
  The second case corresponds to a kernel of:
  \\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f]
  @sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar

  Python prototype (for reference only):
  ```python3
  Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst
  ```
  """
  @spec sobel(Evision.Mat.maybe_mat_in(), integer(), integer(), integer(), [{:borderType, term()} | {:delta, term()} | {:ksize, term()} | {:scale, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def sobel(src, ddepth, dx, dy, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_integer(dx) and is_integer(dy) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :delta, :ksize, :scale])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy)
    ]
    :evision_nif.sobel(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    output image depth, see @ref filter_depths "combinations"; in the case of
    8-bit input images it will result in truncated derivatives.

  - **dx**: `integer()`.

    order of the derivative x.

  - **dy**: `integer()`.

    order of the derivative y.

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    size of the extended Sobel kernel; it must be 1, 3, 5, or 7.

  - **scale**: `double`.

    optional scale factor for the computed derivative values; by default, no scaling is
    applied (see #getDerivKernels for details).

  - **delta**: `double`.

    optional delta value that is added to the results prior to storing them in dst.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and the same number of channels as src .

  In all cases except one, the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ separable kernel is used to
  calculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 \\times 1\\f$ or \\f$1 \\times 3\\f$
  kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first
  or the second x- or y- derivatives.
  There is also the special value `ksize = #FILTER_SCHARR (-1)` that corresponds to the \\f$3\\times3\\f$ Scharr
  filter that may give more accurate results than the \\f$3\\times3\\f$ Sobel. The Scharr aperture is
  \\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f]
  for the x-derivative, or transposed for the y-derivative.
  The function calculates an image derivative by convolving the image with the appropriate kernel:
  \\f[\\texttt{dst} =  \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f]
  The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
  resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
  or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
  case corresponds to a kernel of:
  \\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f]
  The second case corresponds to a kernel of:
  \\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f]
  @sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar

  Python prototype (for reference only):
  ```python3
  Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst
  ```
  """
  @spec sobel(Evision.Mat.maybe_mat_in(), integer(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def sobel(src, ddepth, dx, dy) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_integer(dx) and is_integer(dy)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy)
    ]
    :evision_nif.sobel(positional)
    |> to_struct()
  end

  @doc """
  Calculates the per-element absolute difference between two arrays or between an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar.

  - **src2**: `Evision.Mat`.

    second input array or a scalar.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same size and type as input arrays.

  The function cv::absdiff calculates:
     Absolute difference between two arrays when they have the same
  size and type:
  \\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2}(I)|)\\f]
     Absolute difference between an array and a scalar when the second
  array is constructed from Scalar or has as many elements as the
  number of channels in `src1`:
  \\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2} |)\\f]
     Absolute difference between a scalar and an array when the first
  array is constructed from Scalar or has as many elements as the
  number of channels in `src2`:
  \\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1} -  \\texttt{src2}(I) |)\\f]
  where I is a multi-dimensional index of array elements. In case of
  multi-channel arrays, each channel is processed independently.
  **Note**: Saturation is not applied when the arrays have the depth CV_32S.
  You may even get a negative value in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `absdiff(src,X)` means `absdiff(src,(X,X,X,X))`.
  `absdiff(src,(X,))` means `absdiff(src,(X,0,0,0))`.
  @sa cv::abs(const Mat&)

  Python prototype (for reference only):
  ```python3
  absdiff(src1, src2[, dst]) -> dst
  ```
  """
  @spec absdiff(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def absdiff(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.absdiff(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the per-element absolute difference between two arrays or between an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar.

  - **src2**: `Evision.Mat`.

    second input array or a scalar.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same size and type as input arrays.

  The function cv::absdiff calculates:
     Absolute difference between two arrays when they have the same
  size and type:
  \\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2}(I)|)\\f]
     Absolute difference between an array and a scalar when the second
  array is constructed from Scalar or has as many elements as the
  number of channels in `src1`:
  \\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2} |)\\f]
     Absolute difference between a scalar and an array when the first
  array is constructed from Scalar or has as many elements as the
  number of channels in `src2`:
  \\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1} -  \\texttt{src2}(I) |)\\f]
  where I is a multi-dimensional index of array elements. In case of
  multi-channel arrays, each channel is processed independently.
  **Note**: Saturation is not applied when the arrays have the depth CV_32S.
  You may even get a negative value in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `absdiff(src,X)` means `absdiff(src,(X,X,X,X))`.
  `absdiff(src,(X,))` means `absdiff(src,(X,0,0,0))`.
  @sa cv::abs(const Mat&)

  Python prototype (for reference only):
  ```python3
  absdiff(src1, src2[, dst]) -> dst
  ```
  """
  @spec absdiff(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def absdiff(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.absdiff(positional)
    |> to_struct()
  end

  @doc """
  Adds an image to the accumulator image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.

  The function adds src or some of its elements to dst :
  \\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  The function supports multi-channel images. Each channel is processed independently.
  The function cv::accumulate can be used, for example, to collect statistics of a scene background
  viewed by a still camera and for the further foreground-background segmentation.

  @sa  accumulateSquare, accumulateProduct, accumulateWeighted

  Python prototype (for reference only):
  ```python3
  accumulate(src, dst[, mask]) -> dst
  ```
  """
  @spec accumulate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def accumulate(src, dst, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.accumulate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Adds an image to the accumulator image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.

  The function adds src or some of its elements to dst :
  \\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  The function supports multi-channel images. Each channel is processed independently.
  The function cv::accumulate can be used, for example, to collect statistics of a scene background
  viewed by a still camera and for the further foreground-background segmentation.

  @sa  accumulateSquare, accumulateProduct, accumulateWeighted

  Python prototype (for reference only):
  ```python3
  accumulate(src, dst[, mask]) -> dst
  ```
  """
  @spec accumulate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def accumulate(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.accumulate(positional)
    |> to_struct()
  end

  @doc """
  Adds the per-element product of two input images to the accumulator image.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    First input image, 1- or 3-channel, 8-bit or 32-bit floating point.

  - **src2**: `Evision.Mat`.

    Second input image of the same type and the same size as src1 .

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input images, 32-bit or 64-bit
    floating-point.

  The function adds the product of two images or their selected regions to the accumulator dst :
  \\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src1} (x,y)  \\cdot \\texttt{src2} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  The function supports multi-channel images. Each channel is processed independently.

  @sa  accumulate, accumulateSquare, accumulateWeighted

  Python prototype (for reference only):
  ```python3
  accumulateProduct(src1, src2, dst[, mask]) -> dst
  ```
  """
  @spec accumulateProduct(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def accumulateProduct(src1, src2, dst, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.accumulateProduct(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Adds the per-element product of two input images to the accumulator image.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    First input image, 1- or 3-channel, 8-bit or 32-bit floating point.

  - **src2**: `Evision.Mat`.

    Second input image of the same type and the same size as src1 .

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input images, 32-bit or 64-bit
    floating-point.

  The function adds the product of two images or their selected regions to the accumulator dst :
  \\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src1} (x,y)  \\cdot \\texttt{src2} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  The function supports multi-channel images. Each channel is processed independently.

  @sa  accumulate, accumulateSquare, accumulateWeighted

  Python prototype (for reference only):
  ```python3
  accumulateProduct(src1, src2, dst[, mask]) -> dst
  ```
  """
  @spec accumulateProduct(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def accumulateProduct(src1, src2, dst) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.accumulateProduct(positional)
    |> to_struct()
  end

  @doc """
  Adds the square of a source image to the accumulator image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input image as 1- or 3-channel, 8-bit or 32-bit floating point.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
    floating-point.

  The function adds the input image src or its selected region, raised to a power of 2, to the
  accumulator dst :
  \\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)^2  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  The function supports multi-channel images. Each channel is processed independently.

  @sa  accumulateSquare, accumulateProduct, accumulateWeighted

  Python prototype (for reference only):
  ```python3
  accumulateSquare(src, dst[, mask]) -> dst
  ```
  """
  @spec accumulateSquare(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def accumulateSquare(src, dst, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.accumulateSquare(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Adds the square of a source image to the accumulator image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input image as 1- or 3-channel, 8-bit or 32-bit floating point.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
    floating-point.

  The function adds the input image src or its selected region, raised to a power of 2, to the
  accumulator dst :
  \\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)^2  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  The function supports multi-channel images. Each channel is processed independently.

  @sa  accumulateSquare, accumulateProduct, accumulateWeighted

  Python prototype (for reference only):
  ```python3
  accumulateSquare(src, dst[, mask]) -> dst
  ```
  """
  @spec accumulateSquare(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def accumulateSquare(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.accumulateSquare(positional)
    |> to_struct()
  end

  @doc """
  Updates a running average.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input image as 1- or 3-channel, 8-bit or 32-bit floating point.

  - **alpha**: `double`.

    Weight of the input image.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
    floating-point.

  The function calculates the weighted sum of the input image src and the accumulator dst so that dst
  becomes a running average of a frame sequence:
  \\f[\\texttt{dst} (x,y)  \\leftarrow (1- \\texttt{alpha} )  \\cdot \\texttt{dst} (x,y) +  \\texttt{alpha} \\cdot \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).
  The function supports multi-channel images. Each channel is processed independently.

  @sa  accumulate, accumulateSquare, accumulateProduct

  Python prototype (for reference only):
  ```python3
  accumulateWeighted(src, dst, alpha[, mask]) -> dst
  ```
  """
  @spec accumulateWeighted(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), [{:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def accumulateWeighted(src, dst, alpha, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and is_number(alpha) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst),
      alpha: Evision.Internal.Structurise.from_struct(alpha)
    ]
    :evision_nif.accumulateWeighted(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Updates a running average.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input image as 1- or 3-channel, 8-bit or 32-bit floating point.

  - **alpha**: `double`.

    Weight of the input image.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
    floating-point.

  The function calculates the weighted sum of the input image src and the accumulator dst so that dst
  becomes a running average of a frame sequence:
  \\f[\\texttt{dst} (x,y)  \\leftarrow (1- \\texttt{alpha} )  \\cdot \\texttt{dst} (x,y) +  \\texttt{alpha} \\cdot \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]
  That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).
  The function supports multi-channel images. Each channel is processed independently.

  @sa  accumulate, accumulateSquare, accumulateProduct

  Python prototype (for reference only):
  ```python3
  accumulateWeighted(src, dst, alpha[, mask]) -> dst
  ```
  """
  @spec accumulateWeighted(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def accumulateWeighted(src, dst, alpha) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and is_number(alpha)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst),
      alpha: Evision.Internal.Structurise.from_struct(alpha)
    ]
    :evision_nif.accumulateWeighted(positional)
    |> to_struct()
  end

  @doc """
  Applies an adaptive threshold to an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source 8-bit single-channel image.

  - **maxValue**: `double`.

    Non-zero value assigned to the pixels for which the condition is satisfied

  - **adaptiveMethod**: `integer()`.

    Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.
    The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.

  - **thresholdType**: `integer()`.

    Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV,
    see #ThresholdTypes.

  - **blockSize**: `integer()`.

    Size of a pixel neighborhood that is used to calculate a threshold value for the
    pixel: 3, 5, 7, and so on.

  - **c**: `double`.

    Constant subtracted from the mean or weighted mean (see the details below). Normally, it
    is positive but may be zero or negative as well.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and the same type as src.

  The function transforms a grayscale image to a binary image according to the formulae:
  - **THRESH_BINARY**
    \\f[dst(x,y) =  \\fork{\\texttt{maxValue}}{if \\(src(x,y) > T(x,y)\\)}{0}{otherwise}\\f]

  - **THRESH_BINARY_INV**
    \\f[dst(x,y) =  \\fork{0}{if \\(src(x,y) > T(x,y)\\)}{\\texttt{maxValue}}{otherwise}\\f]
    where \\f$T(x,y)\\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).

  The function can process the image in-place.

  @sa  threshold, blur, GaussianBlur

  Python prototype (for reference only):
  ```python3
  adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -> dst
  ```
  """
  @spec adaptiveThreshold(Evision.Mat.maybe_mat_in(), number(), integer(), integer(), integer(), number(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, c, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(maxValue) and is_integer(adaptiveMethod) and is_integer(thresholdType) and is_integer(blockSize) and is_number(c) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      maxValue: Evision.Internal.Structurise.from_struct(maxValue),
      adaptiveMethod: Evision.Internal.Structurise.from_struct(adaptiveMethod),
      thresholdType: Evision.Internal.Structurise.from_struct(thresholdType),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      c: Evision.Internal.Structurise.from_struct(c)
    ]
    :evision_nif.adaptiveThreshold(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies an adaptive threshold to an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source 8-bit single-channel image.

  - **maxValue**: `double`.

    Non-zero value assigned to the pixels for which the condition is satisfied

  - **adaptiveMethod**: `integer()`.

    Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.
    The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.

  - **thresholdType**: `integer()`.

    Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV,
    see #ThresholdTypes.

  - **blockSize**: `integer()`.

    Size of a pixel neighborhood that is used to calculate a threshold value for the
    pixel: 3, 5, 7, and so on.

  - **c**: `double`.

    Constant subtracted from the mean or weighted mean (see the details below). Normally, it
    is positive but may be zero or negative as well.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and the same type as src.

  The function transforms a grayscale image to a binary image according to the formulae:
  - **THRESH_BINARY**
    \\f[dst(x,y) =  \\fork{\\texttt{maxValue}}{if \\(src(x,y) > T(x,y)\\)}{0}{otherwise}\\f]

  - **THRESH_BINARY_INV**
    \\f[dst(x,y) =  \\fork{0}{if \\(src(x,y) > T(x,y)\\)}{\\texttt{maxValue}}{otherwise}\\f]
    where \\f$T(x,y)\\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).

  The function can process the image in-place.

  @sa  threshold, blur, GaussianBlur

  Python prototype (for reference only):
  ```python3
  adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -> dst
  ```
  """
  @spec adaptiveThreshold(Evision.Mat.maybe_mat_in(), number(), integer(), integer(), integer(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, c) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(maxValue) and is_integer(adaptiveMethod) and is_integer(thresholdType) and is_integer(blockSize) and is_number(c)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      maxValue: Evision.Internal.Structurise.from_struct(maxValue),
      adaptiveMethod: Evision.Internal.Structurise.from_struct(adaptiveMethod),
      thresholdType: Evision.Internal.Structurise.from_struct(thresholdType),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      c: Evision.Internal.Structurise.from_struct(c)
    ]
    :evision_nif.adaptiveThreshold(positional)
    |> to_struct()
  end

  @doc """
  Calculates the per-element sum of two arrays or an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar.

  - **src2**: `Evision.Mat`.

    second input array or a scalar.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask - 8-bit single channel array, that specifies elements of the
    output array to be changed.

  - **dtype**: `integer()`.

    optional depth of the output array (see the discussion below).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same size and number of channels as the input array(s); the
    depth is defined by dtype or src1/src2.

  The function add calculates:
  - Sum of two arrays when both input arrays have the same size and the same number of channels:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
    elements as `src1.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
    elements as `src2.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} +  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]
    where `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.

  The first function in the list above can be replaced with matrix expressions:
  ```cpp
  dst = src1 + src2;
  dst += src1; // equivalent to add(dst, src1, dst);
  ```
  The input arrays and the output array can all have the same or different depths. For example, you
  can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
  floating-point array. Depth of the output array is determined by the dtype parameter. In the second
  and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
  be set to the default -1. In this case, the output array will have the same depth as the input
  array, be it src1, src2 or both.
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `add(src,X)` means `add(src,(X,X,X,X))`.
  `add(src,(X,))` means `add(src,(X,0,0,0))`.
  @sa subtract, addWeighted, scaleAdd, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  add(src1, src2[, dst[, mask[, dtype]]]) -> dst
  ```
  """
  @spec add(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:dtype, term()} | {:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def add(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype, :mask])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.add(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the per-element sum of two arrays or an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar.

  - **src2**: `Evision.Mat`.

    second input array or a scalar.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask - 8-bit single channel array, that specifies elements of the
    output array to be changed.

  - **dtype**: `integer()`.

    optional depth of the output array (see the discussion below).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same size and number of channels as the input array(s); the
    depth is defined by dtype or src1/src2.

  The function add calculates:
  - Sum of two arrays when both input arrays have the same size and the same number of channels:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
    elements as `src1.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
    elements as `src2.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} +  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]
    where `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.

  The first function in the list above can be replaced with matrix expressions:
  ```cpp
  dst = src1 + src2;
  dst += src1; // equivalent to add(dst, src1, dst);
  ```
  The input arrays and the output array can all have the same or different depths. For example, you
  can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
  floating-point array. Depth of the output array is determined by the dtype parameter. In the second
  and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
  be set to the default -1. In this case, the output array will have the same depth as the input
  array, be it src1, src2 or both.
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `add(src,X)` means `add(src,(X,X,X,X))`.
  `add(src,(X,))` means `add(src,(X,0,0,0))`.
  @sa subtract, addWeighted, scaleAdd, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  add(src1, src2[, dst[, mask[, dtype]]]) -> dst
  ```
  """
  @spec add(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def add(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.add(positional)
    |> to_struct()
  end

  @doc """
  Draws a text on the image.

  ##### Positional Arguments
  - **img**: `Evision.Mat`.

    8-bit 3-channel image where the text should be drawn.

  - **text**: `String`.

    Text to write on an image.

  - **org**: `Point`.

    Point(x,y) where the text should start on an image.

  - **nameFont**: `String`.

    Name of the font. The name should match the name of a system font (such as
    Times*). If the font is not found, a default one is used.

  ##### Keyword Arguments
  - **pointSize**: `integer()`.

    Size of the font. If not specified, equal zero or negative, the point size of the
    font is set to a system-dependent default value. Generally, this is 12 points.

  - **color**: `Evision.scalar()`.

    Color of the font in BGRA where A = 255 is fully transparent.

  - **weight**: `integer()`.

    Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control.

  - **style**: `integer()`.

    Font style. Available operation flags are : cv::QtFontStyles

  - **spacing**: `integer()`.

    Spacing between characters. It can be negative or positive.

  Python prototype (for reference only):
  ```python3
  addText(img, text, org, nameFont[, pointSize[, color[, weight[, style[, spacing]]]]]) -> None
  ```
  """
  @spec addText(Evision.Mat.maybe_mat_in(), binary(), {number(), number()}, binary(), [{:color, term()} | {:pointSize, term()} | {:spacing, term()} | {:style, term()} | {:weight, term()}] | nil) :: :ok | {:error, String.t()}
  def addText(img, text, org, nameFont, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_binary(text) and is_tuple(org) and is_binary(nameFont) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:color, :pointSize, :spacing, :style, :weight])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      text: Evision.Internal.Structurise.from_struct(text),
      org: Evision.Internal.Structurise.from_struct(org),
      nameFont: Evision.Internal.Structurise.from_struct(nameFont)
    ]
    :evision_nif.addText(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws a text on the image.

  ##### Positional Arguments
  - **img**: `Evision.Mat`.

    8-bit 3-channel image where the text should be drawn.

  - **text**: `String`.

    Text to write on an image.

  - **org**: `Point`.

    Point(x,y) where the text should start on an image.

  - **nameFont**: `String`.

    Name of the font. The name should match the name of a system font (such as
    Times*). If the font is not found, a default one is used.

  ##### Keyword Arguments
  - **pointSize**: `integer()`.

    Size of the font. If not specified, equal zero or negative, the point size of the
    font is set to a system-dependent default value. Generally, this is 12 points.

  - **color**: `Evision.scalar()`.

    Color of the font in BGRA where A = 255 is fully transparent.

  - **weight**: `integer()`.

    Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control.

  - **style**: `integer()`.

    Font style. Available operation flags are : cv::QtFontStyles

  - **spacing**: `integer()`.

    Spacing between characters. It can be negative or positive.

  Python prototype (for reference only):
  ```python3
  addText(img, text, org, nameFont[, pointSize[, color[, weight[, style[, spacing]]]]]) -> None
  ```
  """
  @spec addText(Evision.Mat.maybe_mat_in(), binary(), {number(), number()}, binary()) :: :ok | {:error, String.t()}
  def addText(img, text, org, nameFont) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_binary(text) and is_tuple(org) and is_binary(nameFont)
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      text: Evision.Internal.Structurise.from_struct(text),
      org: Evision.Internal.Structurise.from_struct(org),
      nameFont: Evision.Internal.Structurise.from_struct(nameFont)
    ]
    :evision_nif.addText(positional)
    |> to_struct()
  end

  @doc """
  Calculates the weighted sum of two arrays.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **alpha**: `double`.

    weight of the first array elements.

  - **src2**: `Evision.Mat`.

    second input array of the same size and channel number as src1.

  - **beta**: `double`.

    weight of the second array elements.

  - **gamma**: `double`.

    scalar added to each sum.

  ##### Keyword Arguments
  - **dtype**: `integer()`.

    optional depth of the output array; when both input arrays have the same depth, dtype
    can be set to -1, which will be equivalent to src1.depth().

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same size and number of channels as the input arrays.

  The function addWeighted calculates the weighted sum of two arrays as follows:
  \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{src1} (I)\\* \\texttt{alpha} +  \\texttt{src2} (I)\\* \\texttt{beta} +  \\texttt{gamma} )\\f]
  where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
  channel is processed independently.
  The function can be replaced with a matrix expression:
  ```cpp
  dst = src1*alpha + src2*beta + gamma;
  ```
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  @sa  add, subtract, scaleAdd, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -> dst
  ```
  """
  @spec addWeighted(Evision.Mat.maybe_mat_in(), number(), Evision.Mat.maybe_mat_in(), number(), number(), [{:dtype, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def addWeighted(src1, alpha, src2, beta, gamma, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and is_number(alpha) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_number(beta) and is_number(gamma) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      src2: Evision.Internal.Structurise.from_struct(src2),
      beta: Evision.Internal.Structurise.from_struct(beta),
      gamma: Evision.Internal.Structurise.from_struct(gamma)
    ]
    :evision_nif.addWeighted(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the weighted sum of two arrays.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **alpha**: `double`.

    weight of the first array elements.

  - **src2**: `Evision.Mat`.

    second input array of the same size and channel number as src1.

  - **beta**: `double`.

    weight of the second array elements.

  - **gamma**: `double`.

    scalar added to each sum.

  ##### Keyword Arguments
  - **dtype**: `integer()`.

    optional depth of the output array; when both input arrays have the same depth, dtype
    can be set to -1, which will be equivalent to src1.depth().

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same size and number of channels as the input arrays.

  The function addWeighted calculates the weighted sum of two arrays as follows:
  \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{src1} (I)\\* \\texttt{alpha} +  \\texttt{src2} (I)\\* \\texttt{beta} +  \\texttt{gamma} )\\f]
  where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
  channel is processed independently.
  The function can be replaced with a matrix expression:
  ```cpp
  dst = src1*alpha + src2*beta + gamma;
  ```
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  @sa  add, subtract, scaleAdd, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -> dst
  ```
  """
  @spec addWeighted(Evision.Mat.maybe_mat_in(), number(), Evision.Mat.maybe_mat_in(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def addWeighted(src1, alpha, src2, beta, gamma) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and is_number(alpha) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_number(beta) and is_number(gamma)
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      src2: Evision.Internal.Structurise.from_struct(src2),
      beta: Evision.Internal.Structurise.from_struct(beta),
      gamma: Evision.Internal.Structurise.from_struct(gamma)
    ]
    :evision_nif.addWeighted(positional)
    |> to_struct()
  end

  @doc """
  #### Variant 1:
  Applies a user colormap on a given image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. If CV_8UC3, then the CV_8UC1 image is generated internally using cv::COLOR_BGR2GRAY.

  - **userColor**: `Evision.Mat`.

    The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    The result is the colormapped source image of the same number of channels as userColor. Note: Mat::create is called on dst.

  Python prototype (for reference only):
  ```python3
  applyColorMap(src, userColor[, dst]) -> dst
  ```
  #### Variant 2:
  Applies a GNU Octave/MATLAB equivalent colormap on a given image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. If CV_8UC3, then the CV_8UC1 image is generated internally using cv::COLOR_BGR2GRAY.

  - **colormap**: `integer()`.

    The colormap to apply, see #ColormapTypes

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    The result is the colormapped source image. Note: Mat::create is called on dst.

  Python prototype (for reference only):
  ```python3
  applyColorMap(src, colormap[, dst]) -> dst
  ```

  """
  @spec applyColorMap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def applyColorMap(src, userColor, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(userColor, Evision.Mat) or is_struct(userColor, Nx.Tensor) or is_number(userColor) or is_tuple(userColor)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      userColor: Evision.Internal.Structurise.from_struct(userColor)
    ]
    :evision_nif.applyColorMap(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec applyColorMap(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def applyColorMap(src, colormap, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(colormap) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      colormap: Evision.Internal.Structurise.from_struct(colormap)
    ]
    :evision_nif.applyColorMap(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Applies a user colormap on a given image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. If CV_8UC3, then the CV_8UC1 image is generated internally using cv::COLOR_BGR2GRAY.

  - **userColor**: `Evision.Mat`.

    The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    The result is the colormapped source image of the same number of channels as userColor. Note: Mat::create is called on dst.

  Python prototype (for reference only):
  ```python3
  applyColorMap(src, userColor[, dst]) -> dst
  ```
  #### Variant 2:
  Applies a GNU Octave/MATLAB equivalent colormap on a given image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. If CV_8UC3, then the CV_8UC1 image is generated internally using cv::COLOR_BGR2GRAY.

  - **colormap**: `integer()`.

    The colormap to apply, see #ColormapTypes

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    The result is the colormapped source image. Note: Mat::create is called on dst.

  Python prototype (for reference only):
  ```python3
  applyColorMap(src, colormap[, dst]) -> dst
  ```

  """
  @spec applyColorMap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def applyColorMap(src, userColor) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(userColor, Evision.Mat) or is_struct(userColor, Nx.Tensor) or is_number(userColor) or is_tuple(userColor))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      userColor: Evision.Internal.Structurise.from_struct(userColor)
    ]
    :evision_nif.applyColorMap(positional)
    |> to_struct()
  end
  @spec applyColorMap(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def applyColorMap(src, colormap) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(colormap)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      colormap: Evision.Internal.Structurise.from_struct(colormap)
    ]
    :evision_nif.applyColorMap(positional)
    |> to_struct()
  end

  @doc """
  Approximates a polygonal curve(s) with the specified precision.

  ##### Positional Arguments
  - **curve**: `Evision.Mat`.

    Input vector of a 2D point stored in std::vector or Mat

  - **epsilon**: `double`.

    Parameter specifying the approximation accuracy. This is the maximum distance
    between the original curve and its approximation.

  - **closed**: `bool`.

    If true, the approximated curve is closed (its first and last vertices are
    connected). Otherwise, it is not closed.

  ##### Return
  - **approxCurve**: `Evision.Mat.t()`.

    Result of the approximation. The type should match the type of the input curve.

  The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less
  vertices so that the distance between them is less or equal to the specified precision. It uses the
  Douglas-Peucker algorithm <http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>

  Python prototype (for reference only):
  ```python3
  approxPolyDP(curve, epsilon, closed[, approxCurve]) -> approxCurve
  ```
  """
  @spec approxPolyDP(Evision.Mat.maybe_mat_in(), number(), boolean(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def approxPolyDP(curve, epsilon, closed, opts) when (is_struct(curve, Evision.Mat) or is_struct(curve, Nx.Tensor) or is_number(curve) or is_tuple(curve)) and is_number(epsilon) and is_boolean(closed) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      curve: Evision.Internal.Structurise.from_struct(curve),
      epsilon: Evision.Internal.Structurise.from_struct(epsilon),
      closed: Evision.Internal.Structurise.from_struct(closed)
    ]
    :evision_nif.approxPolyDP(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Approximates a polygonal curve(s) with the specified precision.

  ##### Positional Arguments
  - **curve**: `Evision.Mat`.

    Input vector of a 2D point stored in std::vector or Mat

  - **epsilon**: `double`.

    Parameter specifying the approximation accuracy. This is the maximum distance
    between the original curve and its approximation.

  - **closed**: `bool`.

    If true, the approximated curve is closed (its first and last vertices are
    connected). Otherwise, it is not closed.

  ##### Return
  - **approxCurve**: `Evision.Mat.t()`.

    Result of the approximation. The type should match the type of the input curve.

  The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less
  vertices so that the distance between them is less or equal to the specified precision. It uses the
  Douglas-Peucker algorithm <http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>

  Python prototype (for reference only):
  ```python3
  approxPolyDP(curve, epsilon, closed[, approxCurve]) -> approxCurve
  ```
  """
  @spec approxPolyDP(Evision.Mat.maybe_mat_in(), number(), boolean()) :: Evision.Mat.t() | {:error, String.t()}
  def approxPolyDP(curve, epsilon, closed) when (is_struct(curve, Evision.Mat) or is_struct(curve, Nx.Tensor) or is_number(curve) or is_tuple(curve)) and is_number(epsilon) and is_boolean(closed)
  do
    positional = [
      curve: Evision.Internal.Structurise.from_struct(curve),
      epsilon: Evision.Internal.Structurise.from_struct(epsilon),
      closed: Evision.Internal.Structurise.from_struct(closed)
    ]
    :evision_nif.approxPolyDP(positional)
    |> to_struct()
  end

  @doc """
  Calculates a contour perimeter or a curve length.

  ##### Positional Arguments
  - **curve**: `Evision.Mat`.

    Input vector of 2D points, stored in std::vector or Mat.

  - **closed**: `bool`.

    Flag indicating whether the curve is closed or not.

  ##### Return
  - **retval**: `double`

  The function computes a curve length or a closed contour perimeter.

  Python prototype (for reference only):
  ```python3
  arcLength(curve, closed) -> retval
  ```
  """
  @spec arcLength(Evision.Mat.maybe_mat_in(), boolean()) :: number() | {:error, String.t()}
  def arcLength(curve, closed) when (is_struct(curve, Evision.Mat) or is_struct(curve, Nx.Tensor) or is_number(curve) or is_tuple(curve)) and is_boolean(closed)
  do
    positional = [
      curve: Evision.Internal.Structurise.from_struct(curve),
      closed: Evision.Internal.Structurise.from_struct(closed)
    ]
    :evision_nif.arcLength(positional)
    |> to_struct()
  end

  @doc """
  Draws an arrow segment pointing from the first point to the second one.

  ##### Positional Arguments
  - **pt1**: `Point`.

    The point the arrow starts from.

  - **pt2**: `Point`.

    The point the arrow points to.

  - **color**: `Evision.scalar()`.

    Line color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Line thickness.

  - **line_type**: `integer()`.

    Type of the line. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the point coordinates.

  - **tipLength**: `double`.

    The length of the arrow tip in relation to the arrow length

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.

  Python prototype (for reference only):
  ```python3
  arrowedLine(img, pt1, pt2, color[, thickness[, line_type[, shift[, tipLength]]]]) -> img
  ```
  """
  @spec arrowedLine(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, Evision.scalar(), [{:line_type, term()} | {:shift, term()} | {:thickness, term()} | {:tipLength, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def arrowedLine(img, pt1, pt2, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(pt1) and is_tuple(pt2) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:line_type, :shift, :thickness, :tipLength])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.arrowedLine(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws an arrow segment pointing from the first point to the second one.

  ##### Positional Arguments
  - **pt1**: `Point`.

    The point the arrow starts from.

  - **pt2**: `Point`.

    The point the arrow points to.

  - **color**: `Evision.scalar()`.

    Line color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Line thickness.

  - **line_type**: `integer()`.

    Type of the line. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the point coordinates.

  - **tipLength**: `double`.

    The length of the arrow tip in relation to the arrow length

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.

  Python prototype (for reference only):
  ```python3
  arrowedLine(img, pt1, pt2, color[, thickness[, line_type[, shift[, tipLength]]]]) -> img
  ```
  """
  @spec arrowedLine(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def arrowedLine(img, pt1, pt2, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(pt1) and is_tuple(pt2) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.arrowedLine(positional)
    |> to_struct()
  end

  @doc """
  naive nearest neighbor finder

  ##### Positional Arguments
  - **src1**: `Evision.Mat`
  - **src2**: `Evision.Mat`
  - **dtype**: `integer()`

  ##### Keyword Arguments
  - **normType**: `integer()`.
  - **k**: `integer()`.
  - **mask**: `Evision.Mat`.
  - **update**: `integer()`.
  - **crosscheck**: `bool`.

  ##### Return
  - **dist**: `Evision.Mat.t()`.
  - **nidx**: `Evision.Mat.t()`.

  see http://en.wikipedia.org/wiki/Nearest_neighbor_search
  @todo document

  Python prototype (for reference only):
  ```python3
  batchDistance(src1, src2, dtype[, dist[, nidx[, normType[, K[, mask[, update[, crosscheck]]]]]]]) -> dist, nidx
  ```
  """
  @spec batchDistance(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:crosscheck, term()} | {:k, term()} | {:mask, term()} | {:normType, term()} | {:update, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def batchDistance(src1, src2, dtype, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_integer(dtype) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:crosscheck, :k, :mask, :normType, :update])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      dtype: Evision.Internal.Structurise.from_struct(dtype)
    ]
    :evision_nif.batchDistance(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  naive nearest neighbor finder

  ##### Positional Arguments
  - **src1**: `Evision.Mat`
  - **src2**: `Evision.Mat`
  - **dtype**: `integer()`

  ##### Keyword Arguments
  - **normType**: `integer()`.
  - **k**: `integer()`.
  - **mask**: `Evision.Mat`.
  - **update**: `integer()`.
  - **crosscheck**: `bool`.

  ##### Return
  - **dist**: `Evision.Mat.t()`.
  - **nidx**: `Evision.Mat.t()`.

  see http://en.wikipedia.org/wiki/Nearest_neighbor_search
  @todo document

  Python prototype (for reference only):
  ```python3
  batchDistance(src1, src2, dtype[, dist[, nidx[, normType[, K[, mask[, update[, crosscheck]]]]]]]) -> dist, nidx
  ```
  """
  @spec batchDistance(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def batchDistance(src1, src2, dtype) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_integer(dtype)
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      dtype: Evision.Internal.Structurise.from_struct(dtype)
    ]
    :evision_nif.batchDistance(positional)
    |> to_struct()
  end

  @doc """
  Applies the bilateral filter to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source 8-bit or floating-point, 1-channel or 3-channel image.

  - **d**: `integer()`.

    Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
    it is computed from sigmaSpace.

  - **sigmaColor**: `double`.

    Filter sigma in the color space. A larger value of the parameter means that
    farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
    in larger areas of semi-equal color.

  - **sigmaSpace**: `double`.

    Filter sigma in the coordinate space. A larger value of the parameter means that
    farther pixels will influence each other as long as their colors are close enough (see sigmaColor
    ). When d\\>0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
    proportional to sigmaSpace.

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and type as src .

  The function applies bilateral filtering to the input image, as described in
  http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
  bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
  very slow compared to most filters.
  _Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\\<
  10), the filter will not have much effect, whereas if they are large (\\> 150), they will have a very
  strong effect, making the image look "cartoonish".
  _Filter size_: Large filters (d \\> 5) are very slow, so it is recommended to use d=5 for real-time
  applications, and perhaps d=9 for offline applications that need heavy noise filtering.
  This filter does not work inplace.

  Python prototype (for reference only):
  ```python3
  bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -> dst
  ```
  """
  @spec bilateralFilter(Evision.Mat.maybe_mat_in(), integer(), number(), number(), [{:borderType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def bilateralFilter(src, d, sigmaColor, sigmaSpace, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(d) and is_number(sigmaColor) and is_number(sigmaSpace) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      d: Evision.Internal.Structurise.from_struct(d),
      sigmaColor: Evision.Internal.Structurise.from_struct(sigmaColor),
      sigmaSpace: Evision.Internal.Structurise.from_struct(sigmaSpace)
    ]
    :evision_nif.bilateralFilter(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies the bilateral filter to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source 8-bit or floating-point, 1-channel or 3-channel image.

  - **d**: `integer()`.

    Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
    it is computed from sigmaSpace.

  - **sigmaColor**: `double`.

    Filter sigma in the color space. A larger value of the parameter means that
    farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
    in larger areas of semi-equal color.

  - **sigmaSpace**: `double`.

    Filter sigma in the coordinate space. A larger value of the parameter means that
    farther pixels will influence each other as long as their colors are close enough (see sigmaColor
    ). When d\\>0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
    proportional to sigmaSpace.

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and type as src .

  The function applies bilateral filtering to the input image, as described in
  http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
  bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
  very slow compared to most filters.
  _Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\\<
  10), the filter will not have much effect, whereas if they are large (\\> 150), they will have a very
  strong effect, making the image look "cartoonish".
  _Filter size_: Large filters (d \\> 5) are very slow, so it is recommended to use d=5 for real-time
  applications, and perhaps d=9 for offline applications that need heavy noise filtering.
  This filter does not work inplace.

  Python prototype (for reference only):
  ```python3
  bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -> dst
  ```
  """
  @spec bilateralFilter(Evision.Mat.maybe_mat_in(), integer(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def bilateralFilter(src, d, sigmaColor, sigmaSpace) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(d) and is_number(sigmaColor) and is_number(sigmaSpace)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      d: Evision.Internal.Structurise.from_struct(d),
      sigmaColor: Evision.Internal.Structurise.from_struct(sigmaColor),
      sigmaSpace: Evision.Internal.Structurise.from_struct(sigmaSpace)
    ]
    :evision_nif.bilateralFilter(positional)
    |> to_struct()
  end

  @doc """
  blendLinear

  ##### Positional Arguments
  - **src1**: `Evision.Mat`
  - **src2**: `Evision.Mat`
  - **weights1**: `Evision.Mat`
  - **weights2**: `Evision.Mat`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  variant without `mask` parameter

  Python prototype (for reference only):
  ```python3
  blendLinear(src1, src2, weights1, weights2[, dst]) -> dst
  ```
  """
  @spec blendLinear(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def blendLinear(src1, src2, weights1, weights2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (is_struct(weights1, Evision.Mat) or is_struct(weights1, Nx.Tensor) or is_number(weights1) or is_tuple(weights1)) and (is_struct(weights2, Evision.Mat) or is_struct(weights2, Nx.Tensor) or is_number(weights2) or is_tuple(weights2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      weights1: Evision.Internal.Structurise.from_struct(weights1),
      weights2: Evision.Internal.Structurise.from_struct(weights2)
    ]
    :evision_nif.blendLinear(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  blendLinear

  ##### Positional Arguments
  - **src1**: `Evision.Mat`
  - **src2**: `Evision.Mat`
  - **weights1**: `Evision.Mat`
  - **weights2**: `Evision.Mat`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  variant without `mask` parameter

  Python prototype (for reference only):
  ```python3
  blendLinear(src1, src2, weights1, weights2[, dst]) -> dst
  ```
  """
  @spec blendLinear(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def blendLinear(src1, src2, weights1, weights2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (is_struct(weights1, Evision.Mat) or is_struct(weights1, Nx.Tensor) or is_number(weights1) or is_tuple(weights1)) and (is_struct(weights2, Evision.Mat) or is_struct(weights2, Nx.Tensor) or is_number(weights2) or is_tuple(weights2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      weights1: Evision.Internal.Structurise.from_struct(weights1),
      weights2: Evision.Internal.Structurise.from_struct(weights2)
    ]
    :evision_nif.blendLinear(positional)
    |> to_struct()
  end

  @doc """
  Blurs an image using the normalized box filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; it can have any number of channels, which are processed independently, but
    the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **ksize**: `Size`.

    blurring kernel size.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    anchor point; default value Point(-1,-1) means that the anchor is at the kernel
    center.

  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function smooths an image using the kernel:
  \\f[\\texttt{K} =  \\frac{1}{\\texttt{ksize.width\\*ksize.height}} \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ \\hdotsfor{6} \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ \\end{bmatrix}\\f]
  The call `blur(src, dst, ksize, anchor, borderType)` is equivalent to `boxFilter(src, dst, src.type(), ksize,
  anchor, true, borderType)`.
  @sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur

  Python prototype (for reference only):
  ```python3
  blur(src, ksize[, dst[, anchor[, borderType]]]) -> dst
  ```
  """
  @spec blur(Evision.Mat.maybe_mat_in(), {number(), number()}, [{:anchor, term()} | {:borderType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def blur(src, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.blur(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Blurs an image using the normalized box filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; it can have any number of channels, which are processed independently, but
    the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **ksize**: `Size`.

    blurring kernel size.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    anchor point; default value Point(-1,-1) means that the anchor is at the kernel
    center.

  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function smooths an image using the kernel:
  \\f[\\texttt{K} =  \\frac{1}{\\texttt{ksize.width\\*ksize.height}} \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ \\hdotsfor{6} \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ \\end{bmatrix}\\f]
  The call `blur(src, dst, ksize, anchor, borderType)` is equivalent to `boxFilter(src, dst, src.type(), ksize,
  anchor, true, borderType)`.
  @sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur

  Python prototype (for reference only):
  ```python3
  blur(src, ksize[, dst[, anchor[, borderType]]]) -> dst
  ```
  """
  @spec blur(Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def blur(src, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.blur(positional)
    |> to_struct()
  end

  @doc """
  Computes the source location of an extrapolated pixel.

  ##### Positional Arguments
  - **p**: `integer()`.

    0-based coordinate of the extrapolated pixel along one of the axes, likely \\<0 or \\>= len

  - **len**: `integer()`.

    Length of the array along the corresponding axis.

  - **borderType**: `integer()`.

    Border type, one of the #BorderTypes, except for #BORDER_TRANSPARENT and
    #BORDER_ISOLATED. When borderType==#BORDER_CONSTANT, the function always returns -1, regardless
    of p and len.

  ##### Return
  - **retval**: `integer()`

  The function computes and returns the coordinate of a donor pixel corresponding to the specified
  extrapolated pixel when using the specified extrapolation border mode. For example, if you use
  cv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and
  want to compute value of the "virtual" pixel Point(-5, 100) in a floating-point image img, it
  looks like:
  ```cpp
  float val = img.at<float>(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101),
  borderInterpolate(-5, img.cols, cv::BORDER_WRAP));
  ```
  Normally, the function is not called directly. It is used inside filtering functions and also in
  copyMakeBorder.

  @sa copyMakeBorder

  Python prototype (for reference only):
  ```python3
  borderInterpolate(p, len, borderType) -> retval
  ```
  """
  @spec borderInterpolate(integer(), integer(), integer()) :: integer() | {:error, String.t()}
  def borderInterpolate(p, len, borderType) when is_integer(p) and is_integer(len) and is_integer(borderType)
  do
    positional = [
      p: Evision.Internal.Structurise.from_struct(p),
      len: Evision.Internal.Structurise.from_struct(len),
      borderType: Evision.Internal.Structurise.from_struct(borderType)
    ]
    :evision_nif.borderInterpolate(positional)
    |> to_struct()
  end

  @doc """
  Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.

  ##### Positional Arguments
  - **array**: `Evision.Mat`.

    Input gray-scale image or 2D point set, stored in std::vector or Mat.

  ##### Return
  - **retval**: `Rect`

  The function calculates and returns the minimal up-right bounding rectangle for the specified point set or
  non-zero pixels of gray-scale image.

  Python prototype (for reference only):
  ```python3
  boundingRect(array) -> retval
  ```
  """
  @spec boundingRect(Evision.Mat.maybe_mat_in()) :: {number(), number(), number(), number()} | {:error, String.t()}
  def boundingRect(array) when (is_struct(array, Evision.Mat) or is_struct(array, Nx.Tensor) or is_number(array) or is_tuple(array))
  do
    positional = [
      array: Evision.Internal.Structurise.from_struct(array)
    ]
    :evision_nif.boundingRect(positional)
    |> to_struct()
  end

  @doc """
  Blurs an image using the box filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    the output image depth (-1 to use src.depth()).

  - **ksize**: `Size`.

    blurring kernel size.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    anchor point; default value Point(-1,-1) means that the anchor is at the kernel
    center.

  - **normalize**: `bool`.

    flag, specifying whether the kernel is normalized by its area or not.

  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function smooths an image using the kernel:
  \\f[\\texttt{K} =  \\alpha \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ \\hdotsfor{6} \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1 \\end{bmatrix}\\f]
  where
  \\f[\\alpha = \\begin{cases} \\frac{1}{\\texttt{ksize.width\\*ksize.height}} & \\texttt{when } \\texttt{normalize=true}  \\\\\\\\1 & \\texttt{otherwise}\\end{cases}\\f]
  Unnormalized box filter is useful for computing various integral characteristics over each pixel
  neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
  algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.
  @sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral

  Python prototype (for reference only):
  ```python3
  boxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -> dst
  ```
  """
  @spec boxFilter(Evision.Mat.maybe_mat_in(), integer(), {number(), number()}, [{:anchor, term()} | {:borderType, term()} | {:normalize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def boxFilter(src, ddepth, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_tuple(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :normalize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.boxFilter(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Blurs an image using the box filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    the output image depth (-1 to use src.depth()).

  - **ksize**: `Size`.

    blurring kernel size.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    anchor point; default value Point(-1,-1) means that the anchor is at the kernel
    center.

  - **normalize**: `bool`.

    flag, specifying whether the kernel is normalized by its area or not.

  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function smooths an image using the kernel:
  \\f[\\texttt{K} =  \\alpha \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\\\\\ \\hdotsfor{6} \\\\\\\\ 1 & 1 & 1 &  \\cdots & 1 & 1 \\end{bmatrix}\\f]
  where
  \\f[\\alpha = \\begin{cases} \\frac{1}{\\texttt{ksize.width\\*ksize.height}} & \\texttt{when } \\texttt{normalize=true}  \\\\\\\\1 & \\texttt{otherwise}\\end{cases}\\f]
  Unnormalized box filter is useful for computing various integral characteristics over each pixel
  neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
  algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.
  @sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral

  Python prototype (for reference only):
  ```python3
  boxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -> dst
  ```
  """
  @spec boxFilter(Evision.Mat.maybe_mat_in(), integer(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def boxFilter(src, ddepth, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_tuple(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.boxFilter(positional)
    |> to_struct()
  end

  @doc """
  Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.

  ##### Positional Arguments
  - **box**: `{centre={x, y}, size={s1, s2}, angle}`.

    The input rotated rectangle. It may be the output of @ref minAreaRect.

  ##### Return
  - **points**: `Evision.Mat.t()`.

    The output array of four vertices of rectangles.

  The function finds the four vertices of a rotated rectangle. This function is useful to draw the
  rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please
  visit the @ref tutorial_bounding_rotated_ellipses "tutorial on Creating Bounding rotated boxes and ellipses for contours" for more information.

  Python prototype (for reference only):
  ```python3
  boxPoints(box[, points]) -> points
  ```
  """
  @spec boxPoints({{number(), number()}, {number(), number()}, number()}, [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def boxPoints(box, opts) when is_tuple(box) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      box: Evision.Internal.Structurise.from_struct(box)
    ]
    :evision_nif.boxPoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.

  ##### Positional Arguments
  - **box**: `{centre={x, y}, size={s1, s2}, angle}`.

    The input rotated rectangle. It may be the output of @ref minAreaRect.

  ##### Return
  - **points**: `Evision.Mat.t()`.

    The output array of four vertices of rectangles.

  The function finds the four vertices of a rotated rectangle. This function is useful to draw the
  rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please
  visit the @ref tutorial_bounding_rotated_ellipses "tutorial on Creating Bounding rotated boxes and ellipses for contours" for more information.

  Python prototype (for reference only):
  ```python3
  boxPoints(box[, points]) -> points
  ```
  """
  @spec boxPoints({{number(), number()}, {number(), number()}, number()}) :: Evision.Mat.t() | {:error, String.t()}
  def boxPoints(box) when is_tuple(box)
  do
    positional = [
      box: Evision.Internal.Structurise.from_struct(box)
    ]
    :evision_nif.boxPoints(positional)
    |> to_struct()
  end

  @doc """
  Broadcast the given Mat to the given shape.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **shape**: `Evision.Mat`.

    target shape. Should be a list of CV_32S numbers. Note that negative values are not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the given shape

  Python prototype (for reference only):
  ```python3
  broadcast(src, shape[, dst]) -> dst
  ```
  """
  @spec broadcast(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def broadcast(src, shape, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(shape, Evision.Mat) or is_struct(shape, Nx.Tensor) or is_number(shape) or is_tuple(shape)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      shape: Evision.Internal.Structurise.from_struct(shape)
    ]
    :evision_nif.broadcast(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Broadcast the given Mat to the given shape.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **shape**: `Evision.Mat`.

    target shape. Should be a list of CV_32S numbers. Note that negative values are not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the given shape

  Python prototype (for reference only):
  ```python3
  broadcast(src, shape[, dst]) -> dst
  ```
  """
  @spec broadcast(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def broadcast(src, shape) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(shape, Evision.Mat) or is_struct(shape, Nx.Tensor) or is_number(shape) or is_tuple(shape))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      shape: Evision.Internal.Structurise.from_struct(shape)
    ]
    :evision_nif.broadcast(positional)
    |> to_struct()
  end

  @doc """
  Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.

  ##### Positional Arguments
  - **img**: `Evision.Mat`.

    8-bit input image.

  - **winSize**: `Size`.

    window size of optical flow algorithm. Must be not less than winSize argument of
    calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.

  - **maxLevel**: `integer()`.

    0-based maximal pyramid level number.

  ##### Keyword Arguments
  - **withDerivatives**: `bool`.

    set to precompute gradients for the every pyramid level. If pyramid is
    constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.

  - **pyrBorder**: `integer()`.

    the border mode for pyramid layers.

  - **derivBorder**: `integer()`.

    the border mode for gradients.

  - **tryReuseInputImage**: `bool`.

    put ROI of input image into the pyramid if possible. You can pass false
    to force data copying.

  ##### Return
  - **retval**: `integer()`
  - **pyramid**: `[Evision.Mat]`.

    output pyramid.

  @return number of levels in constructed pyramid. Can be less than maxLevel.

  Python prototype (for reference only):
  ```python3
  buildOpticalFlowPyramid(img, winSize, maxLevel[, pyramid[, withDerivatives[, pyrBorder[, derivBorder[, tryReuseInputImage]]]]]) -> retval, pyramid
  ```
  """
  @spec buildOpticalFlowPyramid(Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), [{:derivBorder, term()} | {:pyrBorder, term()} | {:tryReuseInputImage, term()} | {:withDerivatives, term()}] | nil) :: {integer(), list(Evision.Mat.t())} | {:error, String.t()}
  def buildOpticalFlowPyramid(img, winSize, maxLevel, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(winSize) and is_integer(maxLevel) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:derivBorder, :pyrBorder, :tryReuseInputImage, :withDerivatives])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      winSize: Evision.Internal.Structurise.from_struct(winSize),
      maxLevel: Evision.Internal.Structurise.from_struct(maxLevel)
    ]
    :evision_nif.buildOpticalFlowPyramid(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.

  ##### Positional Arguments
  - **img**: `Evision.Mat`.

    8-bit input image.

  - **winSize**: `Size`.

    window size of optical flow algorithm. Must be not less than winSize argument of
    calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.

  - **maxLevel**: `integer()`.

    0-based maximal pyramid level number.

  ##### Keyword Arguments
  - **withDerivatives**: `bool`.

    set to precompute gradients for the every pyramid level. If pyramid is
    constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.

  - **pyrBorder**: `integer()`.

    the border mode for pyramid layers.

  - **derivBorder**: `integer()`.

    the border mode for gradients.

  - **tryReuseInputImage**: `bool`.

    put ROI of input image into the pyramid if possible. You can pass false
    to force data copying.

  ##### Return
  - **retval**: `integer()`
  - **pyramid**: `[Evision.Mat]`.

    output pyramid.

  @return number of levels in constructed pyramid. Can be less than maxLevel.

  Python prototype (for reference only):
  ```python3
  buildOpticalFlowPyramid(img, winSize, maxLevel[, pyramid[, withDerivatives[, pyrBorder[, derivBorder[, tryReuseInputImage]]]]]) -> retval, pyramid
  ```
  """
  @spec buildOpticalFlowPyramid(Evision.Mat.maybe_mat_in(), {number(), number()}, integer()) :: {integer(), list(Evision.Mat.t())} | {:error, String.t()}
  def buildOpticalFlowPyramid(img, winSize, maxLevel) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(winSize) and is_integer(maxLevel)
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      winSize: Evision.Internal.Structurise.from_struct(winSize),
      maxLevel: Evision.Internal.Structurise.from_struct(maxLevel)
    ]
    :evision_nif.buildOpticalFlowPyramid(positional)
    |> to_struct()
  end

  @doc """
  calcBackProject

  ##### Positional Arguments
  - **images**: `[Evision.Mat]`
  - **channels**: `[integer()]`
  - **hist**: `Evision.Mat`
  - **ranges**: `[float]`
  - **scale**: `double`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  calcBackProject(images, channels, hist, ranges, scale[, dst]) -> dst
  ```
  """
  @spec calcBackProject(list(Evision.Mat.maybe_mat_in()), list(integer()), Evision.Mat.maybe_mat_in(), list(number()), number(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def calcBackProject(images, channels, hist, ranges, scale, opts) when is_list(images) and is_list(channels) and (is_struct(hist, Evision.Mat) or is_struct(hist, Nx.Tensor) or is_number(hist) or is_tuple(hist)) and is_list(ranges) and is_number(scale) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      images: Evision.Internal.Structurise.from_struct(images),
      channels: Evision.Internal.Structurise.from_struct(channels),
      hist: Evision.Internal.Structurise.from_struct(hist),
      ranges: Evision.Internal.Structurise.from_struct(ranges),
      scale: Evision.Internal.Structurise.from_struct(scale)
    ]
    :evision_nif.calcBackProject(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  calcBackProject

  ##### Positional Arguments
  - **images**: `[Evision.Mat]`
  - **channels**: `[integer()]`
  - **hist**: `Evision.Mat`
  - **ranges**: `[float]`
  - **scale**: `double`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  calcBackProject(images, channels, hist, ranges, scale[, dst]) -> dst
  ```
  """
  @spec calcBackProject(list(Evision.Mat.maybe_mat_in()), list(integer()), Evision.Mat.maybe_mat_in(), list(number()), number()) :: Evision.Mat.t() | {:error, String.t()}
  def calcBackProject(images, channels, hist, ranges, scale) when is_list(images) and is_list(channels) and (is_struct(hist, Evision.Mat) or is_struct(hist, Nx.Tensor) or is_number(hist) or is_tuple(hist)) and is_list(ranges) and is_number(scale)
  do
    positional = [
      images: Evision.Internal.Structurise.from_struct(images),
      channels: Evision.Internal.Structurise.from_struct(channels),
      hist: Evision.Internal.Structurise.from_struct(hist),
      ranges: Evision.Internal.Structurise.from_struct(ranges),
      scale: Evision.Internal.Structurise.from_struct(scale)
    ]
    :evision_nif.calcBackProject(positional)
    |> to_struct()
  end

  @doc """
  calcCovarMatrix

  ##### Positional Arguments
  - **samples**: `Evision.Mat`.

    samples stored as rows/columns of a single matrix.

  - **flags**: `integer()`.

    operation flags as a combination of #CovarFlags

  ##### Keyword Arguments
  - **ctype**: `integer()`.

    type of the matrixl; it equals 'CV_64F' by default.

  ##### Return
  - **covar**: `Evision.Mat.t()`.

    output covariance matrix of the type ctype and square size.

  - **mean**: `Evision.Mat.t()`.

    input or output (depending on the flags) array as the average value of the input vectors.

  Has overloading in C++

  **Note**: use #COVAR_ROWS or #COVAR_COLS flag

  Python prototype (for reference only):
  ```python3
  calcCovarMatrix(samples, mean, flags[, covar[, ctype]]) -> covar, mean
  ```
  """
  @spec calcCovarMatrix(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:ctype, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calcCovarMatrix(samples, mean, flags, opts) when (is_struct(samples, Evision.Mat) or is_struct(samples, Nx.Tensor) or is_number(samples) or is_tuple(samples)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:ctype])
    positional = [
      samples: Evision.Internal.Structurise.from_struct(samples),
      mean: Evision.Internal.Structurise.from_struct(mean),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.calcCovarMatrix(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  calcCovarMatrix

  ##### Positional Arguments
  - **samples**: `Evision.Mat`.

    samples stored as rows/columns of a single matrix.

  - **flags**: `integer()`.

    operation flags as a combination of #CovarFlags

  ##### Keyword Arguments
  - **ctype**: `integer()`.

    type of the matrixl; it equals 'CV_64F' by default.

  ##### Return
  - **covar**: `Evision.Mat.t()`.

    output covariance matrix of the type ctype and square size.

  - **mean**: `Evision.Mat.t()`.

    input or output (depending on the flags) array as the average value of the input vectors.

  Has overloading in C++

  **Note**: use #COVAR_ROWS or #COVAR_COLS flag

  Python prototype (for reference only):
  ```python3
  calcCovarMatrix(samples, mean, flags[, covar[, ctype]]) -> covar, mean
  ```
  """
  @spec calcCovarMatrix(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calcCovarMatrix(samples, mean, flags) when (is_struct(samples, Evision.Mat) or is_struct(samples, Nx.Tensor) or is_number(samples) or is_tuple(samples)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and is_integer(flags)
  do
    positional = [
      samples: Evision.Internal.Structurise.from_struct(samples),
      mean: Evision.Internal.Structurise.from_struct(mean),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.calcCovarMatrix(positional)
    |> to_struct()
  end

  @doc """
  calcHist

  ##### Positional Arguments
  - **images**: `[Evision.Mat]`
  - **channels**: `[integer()]`
  - **mask**: `Evision.Mat`
  - **histSize**: `[integer()]`
  - **ranges**: `[float]`

  ##### Keyword Arguments
  - **accumulate**: `bool`.

  ##### Return
  - **hist**: `Evision.Mat.t()`.

  Has overloading in C++

  this variant supports only uniform histograms.
  ranges argument is either empty vector or a flattened vector of histSize.size()*2 elements
  (histSize.size() element pairs). The first and second elements of each pair specify the lower and
  upper boundaries.

  Python prototype (for reference only):
  ```python3
  calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) -> hist
  ```
  """
  @spec calcHist(list(Evision.Mat.maybe_mat_in()), list(integer()), Evision.Mat.maybe_mat_in(), list(integer()), list(number()), [{:accumulate, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def calcHist(images, channels, mask, histSize, ranges, opts) when is_list(images) and is_list(channels) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_list(histSize) and is_list(ranges) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:accumulate])
    positional = [
      images: Evision.Internal.Structurise.from_struct(images),
      channels: Evision.Internal.Structurise.from_struct(channels),
      mask: Evision.Internal.Structurise.from_struct(mask),
      histSize: Evision.Internal.Structurise.from_struct(histSize),
      ranges: Evision.Internal.Structurise.from_struct(ranges)
    ]
    :evision_nif.calcHist(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  calcHist

  ##### Positional Arguments
  - **images**: `[Evision.Mat]`
  - **channels**: `[integer()]`
  - **mask**: `Evision.Mat`
  - **histSize**: `[integer()]`
  - **ranges**: `[float]`

  ##### Keyword Arguments
  - **accumulate**: `bool`.

  ##### Return
  - **hist**: `Evision.Mat.t()`.

  Has overloading in C++

  this variant supports only uniform histograms.
  ranges argument is either empty vector or a flattened vector of histSize.size()*2 elements
  (histSize.size() element pairs). The first and second elements of each pair specify the lower and
  upper boundaries.

  Python prototype (for reference only):
  ```python3
  calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) -> hist
  ```
  """
  @spec calcHist(list(Evision.Mat.maybe_mat_in()), list(integer()), Evision.Mat.maybe_mat_in(), list(integer()), list(number())) :: Evision.Mat.t() | {:error, String.t()}
  def calcHist(images, channels, mask, histSize, ranges) when is_list(images) and is_list(channels) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_list(histSize) and is_list(ranges)
  do
    positional = [
      images: Evision.Internal.Structurise.from_struct(images),
      channels: Evision.Internal.Structurise.from_struct(channels),
      mask: Evision.Internal.Structurise.from_struct(mask),
      histSize: Evision.Internal.Structurise.from_struct(histSize),
      ranges: Evision.Internal.Structurise.from_struct(ranges)
    ]
    :evision_nif.calcHist(positional)
    |> to_struct()
  end

  @doc """
  Computes a dense optical flow using the Gunnar Farneback's algorithm.

  ##### Positional Arguments
  - **prev**: `Evision.Mat`.

    first 8-bit single-channel input image.

  - **next**: `Evision.Mat`.

    second input image of the same size and the same type as prev.

  - **pyr_scale**: `double`.

    parameter, specifying the image scale (\\<1) to build pyramids for each image;
    pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous
    one.

  - **levels**: `integer()`.

    number of pyramid layers including the initial image; levels=1 means that no extra
    layers are created and only the original images are used.

  - **winsize**: `integer()`.

    averaging window size; larger values increase the algorithm robustness to image
    noise and give more chances for fast motion detection, but yield more blurred motion field.

  - **iterations**: `integer()`.

    number of iterations the algorithm does at each pyramid level.

  - **poly_n**: `integer()`.

    size of the pixel neighborhood used to find polynomial expansion in each pixel;
    larger values mean that the image will be approximated with smoother surfaces, yielding more
    robust algorithm and more blurred motion field, typically poly_n =5 or 7.

  - **poly_sigma**: `double`.

    standard deviation of the Gaussian that is used to smooth derivatives used as a
    basis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a
    good value would be poly_sigma=1.5.

  - **flags**: `integer()`.

    operation flags that can be a combination of the following:
    - **OPTFLOW_USE_INITIAL_FLOW** uses the input flow as an initial flow approximation.
    - **OPTFLOW_FARNEBACK_GAUSSIAN** uses the Gaussian \\f$\\texttt{winsize}\\times\\texttt{winsize}\\f$
      filter instead of a box filter of the same size for optical flow estimation; usually, this
      option gives z more accurate flow than with a box filter, at the cost of lower speed;
      normally, winsize for a Gaussian window should be set to a larger value to achieve the same
      level of robustness.

  ##### Return
  - **flow**: `Evision.Mat.t()`.

    computed flow image that has the same size as prev and type CV_32FC2.

  The function finds an optical flow for each prev pixel using the @cite Farneback2003 algorithm so that
  \\f[\\texttt{prev} (y,x)  \\sim \\texttt{next} ( y + \\texttt{flow} (y,x)\\[1],  x + \\texttt{flow} (y,x)\\[0])\\f]
  **Note**: Some examples:
  - An example using the optical flow algorithm described by Gunnar Farneback can be found at
    opencv_source_code/samples/cpp/fback.cpp

  - (Python) An example using the optical flow algorithm described by Gunnar Farneback can be
    found at opencv_source_code/samples/python/opt_flow.py

  Python prototype (for reference only):
  ```python3
  calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags) -> flow
  ```
  """
  @spec calcOpticalFlowFarneback(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), integer(), integer(), integer(), integer(), number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags) when (is_struct(prev, Evision.Mat) or is_struct(prev, Nx.Tensor) or is_number(prev) or is_tuple(prev)) and (is_struct(next, Evision.Mat) or is_struct(next, Nx.Tensor) or is_number(next) or is_tuple(next)) and (is_struct(flow, Evision.Mat) or is_struct(flow, Nx.Tensor) or is_number(flow) or is_tuple(flow)) and is_number(pyr_scale) and is_integer(levels) and is_integer(winsize) and is_integer(iterations) and is_integer(poly_n) and is_number(poly_sigma) and is_integer(flags)
  do
    positional = [
      prev: Evision.Internal.Structurise.from_struct(prev),
      next: Evision.Internal.Structurise.from_struct(next),
      flow: Evision.Internal.Structurise.from_struct(flow),
      pyr_scale: Evision.Internal.Structurise.from_struct(pyr_scale),
      levels: Evision.Internal.Structurise.from_struct(levels),
      winsize: Evision.Internal.Structurise.from_struct(winsize),
      iterations: Evision.Internal.Structurise.from_struct(iterations),
      poly_n: Evision.Internal.Structurise.from_struct(poly_n),
      poly_sigma: Evision.Internal.Structurise.from_struct(poly_sigma),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.calcOpticalFlowFarneback(positional)
    |> to_struct()
  end

  @doc """
  Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with
  pyramids.

  ##### Positional Arguments
  - **prevImg**: `Evision.Mat`.

    first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid.

  - **nextImg**: `Evision.Mat`.

    second input image or pyramid of the same size and the same type as prevImg.

  - **prevPts**: `Evision.Mat`.

    vector of 2D points for which the flow needs to be found; point coordinates must be
    single-precision floating-point numbers.

  ##### Keyword Arguments
  - **winSize**: `Size`.

    size of the search window at each pyramid level.

  - **maxLevel**: `integer()`.

    0-based maximal pyramid level number; if set to 0, pyramids are not used (single
    level), if set to 1, two levels are used, and so on; if pyramids are passed to input then
    algorithm will use as many levels as pyramids have but no more than maxLevel.

  - **criteria**: `TermCriteria`.

    parameter, specifying the termination criteria of the iterative search algorithm
    (after the specified maximum number of iterations criteria.maxCount or when the search window
    moves by less than criteria.epsilon.

  - **flags**: `integer()`.

    operation flags:
    - **OPTFLOW_USE_INITIAL_FLOW** uses initial estimations, stored in nextPts; if the flag is
      not set, then prevPts is copied to nextPts and is considered the initial estimate.
    - **OPTFLOW_LK_GET_MIN_EIGENVALS** use minimum eigen values as an error measure (see
      minEigThreshold description); if the flag is not set, then L1 distance between patches
      around the original and a moved point, divided by number of pixels in a window, is used as a
      error measure.

  - **minEigThreshold**: `double`.

    the algorithm calculates the minimum eigen value of a 2x2 normal matrix of
    optical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided
    by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding
    feature is filtered out and its flow is not processed, so it allows to remove bad points and get a
    performance boost.

  ##### Return
  - **nextPts**: `Evision.Mat.t()`.

    output vector of 2D points (with single-precision floating-point coordinates)
    containing the calculated new positions of input features in the second image; when
    OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input.

  - **status**: `Evision.Mat.t()`.

    output status vector (of unsigned chars); each element of the vector is set to 1 if
    the flow for the corresponding features has been found, otherwise, it is set to 0.

  - **err**: `Evision.Mat.t()`.

    output vector of errors; each element of the vector is set to an error for the
    corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't
    found then the error is not defined (use the status parameter to find such cases).

  The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See
  @cite Bouguet00 . The function is parallelized with the TBB library.
  **Note**: Some examples:
  - An example using the Lucas-Kanade optical flow algorithm can be found at
    opencv_source_code/samples/cpp/lkdemo.cpp

  - (Python) An example using the Lucas-Kanade optical flow algorithm can be found at
    opencv_source_code/samples/python/lk_track.py

  - (Python) An example using the Lucas-Kanade tracker for homography matching can be found at
    opencv_source_code/samples/python/lk_homography.py

  Python prototype (for reference only):
  ```python3
  calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts[, status[, err[, winSize[, maxLevel[, criteria[, flags[, minEigThreshold]]]]]]]) -> nextPts, status, err
  ```
  """
  @spec calcOpticalFlowPyrLK(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()} | {:maxLevel, term()} | {:minEigThreshold, term()} | {:winSize, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, opts) when (is_struct(prevImg, Evision.Mat) or is_struct(prevImg, Nx.Tensor) or is_number(prevImg) or is_tuple(prevImg)) and (is_struct(nextImg, Evision.Mat) or is_struct(nextImg, Nx.Tensor) or is_number(nextImg) or is_tuple(nextImg)) and (is_struct(prevPts, Evision.Mat) or is_struct(prevPts, Nx.Tensor) or is_number(prevPts) or is_tuple(prevPts)) and (is_struct(nextPts, Evision.Mat) or is_struct(nextPts, Nx.Tensor) or is_number(nextPts) or is_tuple(nextPts)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags, :maxLevel, :minEigThreshold, :winSize])
    positional = [
      prevImg: Evision.Internal.Structurise.from_struct(prevImg),
      nextImg: Evision.Internal.Structurise.from_struct(nextImg),
      prevPts: Evision.Internal.Structurise.from_struct(prevPts),
      nextPts: Evision.Internal.Structurise.from_struct(nextPts)
    ]
    :evision_nif.calcOpticalFlowPyrLK(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with
  pyramids.

  ##### Positional Arguments
  - **prevImg**: `Evision.Mat`.

    first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid.

  - **nextImg**: `Evision.Mat`.

    second input image or pyramid of the same size and the same type as prevImg.

  - **prevPts**: `Evision.Mat`.

    vector of 2D points for which the flow needs to be found; point coordinates must be
    single-precision floating-point numbers.

  ##### Keyword Arguments
  - **winSize**: `Size`.

    size of the search window at each pyramid level.

  - **maxLevel**: `integer()`.

    0-based maximal pyramid level number; if set to 0, pyramids are not used (single
    level), if set to 1, two levels are used, and so on; if pyramids are passed to input then
    algorithm will use as many levels as pyramids have but no more than maxLevel.

  - **criteria**: `TermCriteria`.

    parameter, specifying the termination criteria of the iterative search algorithm
    (after the specified maximum number of iterations criteria.maxCount or when the search window
    moves by less than criteria.epsilon.

  - **flags**: `integer()`.

    operation flags:
    - **OPTFLOW_USE_INITIAL_FLOW** uses initial estimations, stored in nextPts; if the flag is
      not set, then prevPts is copied to nextPts and is considered the initial estimate.
    - **OPTFLOW_LK_GET_MIN_EIGENVALS** use minimum eigen values as an error measure (see
      minEigThreshold description); if the flag is not set, then L1 distance between patches
      around the original and a moved point, divided by number of pixels in a window, is used as a
      error measure.

  - **minEigThreshold**: `double`.

    the algorithm calculates the minimum eigen value of a 2x2 normal matrix of
    optical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided
    by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding
    feature is filtered out and its flow is not processed, so it allows to remove bad points and get a
    performance boost.

  ##### Return
  - **nextPts**: `Evision.Mat.t()`.

    output vector of 2D points (with single-precision floating-point coordinates)
    containing the calculated new positions of input features in the second image; when
    OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input.

  - **status**: `Evision.Mat.t()`.

    output status vector (of unsigned chars); each element of the vector is set to 1 if
    the flow for the corresponding features has been found, otherwise, it is set to 0.

  - **err**: `Evision.Mat.t()`.

    output vector of errors; each element of the vector is set to an error for the
    corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't
    found then the error is not defined (use the status parameter to find such cases).

  The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See
  @cite Bouguet00 . The function is parallelized with the TBB library.
  **Note**: Some examples:
  - An example using the Lucas-Kanade optical flow algorithm can be found at
    opencv_source_code/samples/cpp/lkdemo.cpp

  - (Python) An example using the Lucas-Kanade optical flow algorithm can be found at
    opencv_source_code/samples/python/lk_track.py

  - (Python) An example using the Lucas-Kanade tracker for homography matching can be found at
    opencv_source_code/samples/python/lk_homography.py

  Python prototype (for reference only):
  ```python3
  calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts[, status[, err[, winSize[, maxLevel[, criteria[, flags[, minEigThreshold]]]]]]]) -> nextPts, status, err
  ```
  """
  @spec calcOpticalFlowPyrLK(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts) when (is_struct(prevImg, Evision.Mat) or is_struct(prevImg, Nx.Tensor) or is_number(prevImg) or is_tuple(prevImg)) and (is_struct(nextImg, Evision.Mat) or is_struct(nextImg, Nx.Tensor) or is_number(nextImg) or is_tuple(nextImg)) and (is_struct(prevPts, Evision.Mat) or is_struct(prevPts, Nx.Tensor) or is_number(prevPts) or is_tuple(prevPts)) and (is_struct(nextPts, Evision.Mat) or is_struct(nextPts, Nx.Tensor) or is_number(nextPts) or is_tuple(nextPts))
  do
    positional = [
      prevImg: Evision.Internal.Structurise.from_struct(prevImg),
      nextImg: Evision.Internal.Structurise.from_struct(nextImg),
      prevPts: Evision.Internal.Structurise.from_struct(prevPts),
      nextPts: Evision.Internal.Structurise.from_struct(nextPts)
    ]
    :evision_nif.calcOpticalFlowPyrLK(positional)
    |> to_struct()
  end

  @doc """
  calibrateCamera

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints**: `[Evision.Mat]`
  - **imageSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`
  - **distCoeffs**: `Evision.Mat.t()`
  - **rvecs**: `[Evision.Mat]`.
  - **tvecs**: `[Evision.Mat]`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs
  ```
  """
  @spec calibrateCamera(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t())} | {:error, String.t()}
  def calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, opts) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCamera(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  calibrateCamera

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints**: `[Evision.Mat]`
  - **imageSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`
  - **distCoeffs**: `Evision.Mat.t()`
  - **rvecs**: `[Evision.Mat]`.
  - **tvecs**: `[Evision.Mat]`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs
  ```
  """
  @spec calibrateCamera(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t())} | {:error, String.t()}
  def calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCamera(positional)
    |> to_struct()
  end

  @doc """
  Finds the camera intrinsic and extrinsic parameters from several views of a calibration
  pattern.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    In the new interface it is a vector of vectors of calibration pattern points in
    the calibration pattern coordinate space (e.g. std::vector<std::vector<cv::Vec3f>>). The outer
    vector contains as many elements as the number of pattern views. If the same calibration pattern
    is shown in each view and it is fully visible, all the vectors will be the same. Although, it is
    possible to use partially occluded patterns or even different patterns in different views. Then,
    the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's
    XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig.
    In the old interface all the vectors of object points from different views are concatenated
    together.

  - **imagePoints**: `[Evision.Mat]`.

    In the new interface it is a vector of vectors of the projections of calibration
    pattern points (e.g. std::vector<std::vector<cv::Vec2f>>). imagePoints.size() and
    objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal,
    respectively. In the old interface all the vectors of object points from different views are
    concatenated together.

  - **imageSize**: `Size`.

    Size of the image used only to initialize the camera intrinsic matrix.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Different flags that may be zero or a combination of the following values:
    - @ref CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of
      fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image
      center ( imageSize is used), and focal distances are computed in a least-squares fashion.
      Note, that if intrinsic parameters are known, there is no need to use this function just to
      estimate extrinsic parameters. Use @ref solvePnP instead.
    - @ref CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global
      optimization. It stays at the center or at a different location specified when

  - **criteria**: `TermCriteria`.

    Termination criteria for the iterative optimization algorithm.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`.

    Input/output 3x3 floating-point camera intrinsic matrix
    \\f$\\cameramatrix{A}\\f$ . If @ref CALIB_USE_INTRINSIC_GUESS
    and/or @ref CALIB_FIX_ASPECT_RATIO, @ref CALIB_FIX_PRINCIPAL_POINT or @ref CALIB_FIX_FOCAL_LENGTH
    are specified, some or all of fx, fy, cx, cy must be initialized before calling the function.

  - **distCoeffs**: `Evision.Mat.t()`.

    Input/output vector of distortion coefficients
    \\f$\\distcoeffs\\f$.

  - **rvecs**: `[Evision.Mat]`.

    Output vector of rotation vectors (@ref Rodrigues ) estimated for each pattern view
    (e.g. std::vector<cv::Mat>>). That is, each i-th rotation vector together with the corresponding
    i-th translation vector (see the next output parameter description) brings the calibration pattern
    from the object coordinate space (in which object points are specified) to the camera coordinate
    space. In more technical terms, the tuple of the i-th rotation and translation vector performs
    a change of basis from object coordinate space to camera coordinate space. Due to its duality, this
    tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate
    space.

  - **tvecs**: `[Evision.Mat]`.

    Output vector of translation vectors estimated for each pattern view, see parameter
    describtion above.

  - **stdDeviationsIntrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for intrinsic
    parameters. Order of deviations values:
    \\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,
    s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero.

  - **stdDeviationsExtrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for extrinsic
    parameters. Order of deviations values: \\f$(R_0, T_0, \\dotsc , R_{M - 1}, T_{M - 1})\\f$ where M is
    the number of pattern views. \\f$R_i, T_i\\f$ are concatenated 1x3 vectors.

  - **perViewErrors**: `Evision.Mat.t()`.

    Output vector of the RMS re-projection error estimated for each pattern view.

  @ref CALIB_USE_INTRINSIC_GUESS is set too.
  - @ref CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The
    ratio fx/fy stays the same as in the input cameraMatrix . When

  @ref CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are
  ignored, only their ratio is computed and used further.
  - @ref CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \\f$(p\\_1, p\\_2)\\f$ are set
    to zeros and stay zero.

  - @ref CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global optimization if
  @ref CALIB_USE_INTRINSIC_GUESS is set.
  - @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 The corresponding radial distortion
    coefficient is not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is
    set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  - @ref CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the
    backward compatibility, this extra flag should be explicitly specified to make the
    calibration function use the rational model and return 8 coefficients or more.

  - @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the
    backward compatibility, this extra flag should be explicitly specified to make the
    calibration function use the thin prism model and return 12 coefficients or more.

  - @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during
    the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
    supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  - @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the
    backward compatibility, this extra flag should be explicitly specified to make the
    calibration function use the tilted sensor model and return 14 coefficients.

  - @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during
    the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
    supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  @return the overall RMS re-projection error.
  The function estimates the intrinsic camera parameters and extrinsic parameters for each of the
  views. The algorithm is based on @cite Zhang2000 and @cite BouguetMCT . The coordinates of 3D object
  points and their corresponding 2D projections in each view must be specified. That may be achieved
  by using an object with known geometry and easily detectable feature points. Such an object is
  called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as
  a calibration rig (see @ref findChessboardCorners). Currently, initialization of intrinsic
  parameters (when @ref CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration
  patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also
  be used as long as initial cameraMatrix is provided.
  The algorithm performs the following steps:
  - Compute the initial intrinsic parameters (the option only available for planar calibration
    patterns) or read them from the input parameters. The distortion coefficients are all set to
    zeros initially unless some of CALIB_FIX_K? are specified.

  - Estimate the initial camera pose as if the intrinsic parameters have been already known. This is
    done using @ref solvePnP .

  - Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error,
    that is, the total sum of squared distances between the observed feature points imagePoints and
    the projected (using the current estimates for camera parameters and the poses) object points
    objectPoints. See @ref projectPoints for details.

  **Note**: 
  If you use a non-square (i.e. non-N-by-N) grid and @ref findChessboardCorners for calibration,
  and @ref calibrateCamera returns bad values (zero distortion coefficients, \\f$c\\_x\\f$ and
  \\f$c\\_y\\f$ very far from the image center, and/or large differences between \\f$f\\_x\\f$ and
  \\f$f\\_y\\f$ (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols)
  instead of using patternSize=cvSize(cols,rows) in @ref findChessboardCorners.
  **Note**: 
  The function may throw exceptions, if unsupported combination of parameters is provided or
  the system is underconstrained.
  @sa
  calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate,
  undistort

  Python prototype (for reference only):
  ```python3
  calibrateCameraExtended(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors
  ```
  """
  @spec calibrateCameraExtended(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateCameraExtended(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, opts) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCameraExtended(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the camera intrinsic and extrinsic parameters from several views of a calibration
  pattern.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    In the new interface it is a vector of vectors of calibration pattern points in
    the calibration pattern coordinate space (e.g. std::vector<std::vector<cv::Vec3f>>). The outer
    vector contains as many elements as the number of pattern views. If the same calibration pattern
    is shown in each view and it is fully visible, all the vectors will be the same. Although, it is
    possible to use partially occluded patterns or even different patterns in different views. Then,
    the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's
    XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig.
    In the old interface all the vectors of object points from different views are concatenated
    together.

  - **imagePoints**: `[Evision.Mat]`.

    In the new interface it is a vector of vectors of the projections of calibration
    pattern points (e.g. std::vector<std::vector<cv::Vec2f>>). imagePoints.size() and
    objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal,
    respectively. In the old interface all the vectors of object points from different views are
    concatenated together.

  - **imageSize**: `Size`.

    Size of the image used only to initialize the camera intrinsic matrix.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Different flags that may be zero or a combination of the following values:
    - @ref CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of
      fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image
      center ( imageSize is used), and focal distances are computed in a least-squares fashion.
      Note, that if intrinsic parameters are known, there is no need to use this function just to
      estimate extrinsic parameters. Use @ref solvePnP instead.
    - @ref CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global
      optimization. It stays at the center or at a different location specified when

  - **criteria**: `TermCriteria`.

    Termination criteria for the iterative optimization algorithm.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`.

    Input/output 3x3 floating-point camera intrinsic matrix
    \\f$\\cameramatrix{A}\\f$ . If @ref CALIB_USE_INTRINSIC_GUESS
    and/or @ref CALIB_FIX_ASPECT_RATIO, @ref CALIB_FIX_PRINCIPAL_POINT or @ref CALIB_FIX_FOCAL_LENGTH
    are specified, some or all of fx, fy, cx, cy must be initialized before calling the function.

  - **distCoeffs**: `Evision.Mat.t()`.

    Input/output vector of distortion coefficients
    \\f$\\distcoeffs\\f$.

  - **rvecs**: `[Evision.Mat]`.

    Output vector of rotation vectors (@ref Rodrigues ) estimated for each pattern view
    (e.g. std::vector<cv::Mat>>). That is, each i-th rotation vector together with the corresponding
    i-th translation vector (see the next output parameter description) brings the calibration pattern
    from the object coordinate space (in which object points are specified) to the camera coordinate
    space. In more technical terms, the tuple of the i-th rotation and translation vector performs
    a change of basis from object coordinate space to camera coordinate space. Due to its duality, this
    tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate
    space.

  - **tvecs**: `[Evision.Mat]`.

    Output vector of translation vectors estimated for each pattern view, see parameter
    describtion above.

  - **stdDeviationsIntrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for intrinsic
    parameters. Order of deviations values:
    \\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,
    s_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero.

  - **stdDeviationsExtrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for extrinsic
    parameters. Order of deviations values: \\f$(R_0, T_0, \\dotsc , R_{M - 1}, T_{M - 1})\\f$ where M is
    the number of pattern views. \\f$R_i, T_i\\f$ are concatenated 1x3 vectors.

  - **perViewErrors**: `Evision.Mat.t()`.

    Output vector of the RMS re-projection error estimated for each pattern view.

  @ref CALIB_USE_INTRINSIC_GUESS is set too.
  - @ref CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The
    ratio fx/fy stays the same as in the input cameraMatrix . When

  @ref CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are
  ignored, only their ratio is computed and used further.
  - @ref CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \\f$(p\\_1, p\\_2)\\f$ are set
    to zeros and stay zero.

  - @ref CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global optimization if
  @ref CALIB_USE_INTRINSIC_GUESS is set.
  - @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 The corresponding radial distortion
    coefficient is not changed during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is
    set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  - @ref CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the
    backward compatibility, this extra flag should be explicitly specified to make the
    calibration function use the rational model and return 8 coefficients or more.

  - @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the
    backward compatibility, this extra flag should be explicitly specified to make the
    calibration function use the thin prism model and return 12 coefficients or more.

  - @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during
    the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
    supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  - @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the
    backward compatibility, this extra flag should be explicitly specified to make the
    calibration function use the tilted sensor model and return 14 coefficients.

  - @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during
    the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
    supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  @return the overall RMS re-projection error.
  The function estimates the intrinsic camera parameters and extrinsic parameters for each of the
  views. The algorithm is based on @cite Zhang2000 and @cite BouguetMCT . The coordinates of 3D object
  points and their corresponding 2D projections in each view must be specified. That may be achieved
  by using an object with known geometry and easily detectable feature points. Such an object is
  called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as
  a calibration rig (see @ref findChessboardCorners). Currently, initialization of intrinsic
  parameters (when @ref CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration
  patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also
  be used as long as initial cameraMatrix is provided.
  The algorithm performs the following steps:
  - Compute the initial intrinsic parameters (the option only available for planar calibration
    patterns) or read them from the input parameters. The distortion coefficients are all set to
    zeros initially unless some of CALIB_FIX_K? are specified.

  - Estimate the initial camera pose as if the intrinsic parameters have been already known. This is
    done using @ref solvePnP .

  - Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error,
    that is, the total sum of squared distances between the observed feature points imagePoints and
    the projected (using the current estimates for camera parameters and the poses) object points
    objectPoints. See @ref projectPoints for details.

  **Note**: 
  If you use a non-square (i.e. non-N-by-N) grid and @ref findChessboardCorners for calibration,
  and @ref calibrateCamera returns bad values (zero distortion coefficients, \\f$c\\_x\\f$ and
  \\f$c\\_y\\f$ very far from the image center, and/or large differences between \\f$f\\_x\\f$ and
  \\f$f\\_y\\f$ (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols)
  instead of using patternSize=cvSize(cols,rows) in @ref findChessboardCorners.
  **Note**: 
  The function may throw exceptions, if unsupported combination of parameters is provided or
  the system is underconstrained.
  @sa
  calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate,
  undistort

  Python prototype (for reference only):
  ```python3
  calibrateCameraExtended(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors
  ```
  """
  @spec calibrateCameraExtended(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateCameraExtended(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCameraExtended(positional)
    |> to_struct()
  end

  @doc """
  calibrateCameraRO

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints**: `[Evision.Mat]`
  - **imageSize**: `Size`
  - **iFixedPoint**: `integer()`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`
  - **distCoeffs**: `Evision.Mat.t()`
  - **rvecs**: `[Evision.Mat]`.
  - **tvecs**: `[Evision.Mat]`.
  - **newObjPoints**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, flags[, criteria]]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints
  ```
  """
  @spec calibrateCameraRO(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, integer(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, opts) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and is_integer(iFixedPoint) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      iFixedPoint: Evision.Internal.Structurise.from_struct(iFixedPoint),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCameraRO(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  calibrateCameraRO

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints**: `[Evision.Mat]`
  - **imageSize**: `Size`
  - **iFixedPoint**: `integer()`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`
  - **distCoeffs**: `Evision.Mat.t()`
  - **rvecs**: `[Evision.Mat]`.
  - **tvecs**: `[Evision.Mat]`.
  - **newObjPoints**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, flags[, criteria]]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints
  ```
  """
  @spec calibrateCameraRO(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, integer(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and is_integer(iFixedPoint) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      iFixedPoint: Evision.Internal.Structurise.from_struct(iFixedPoint),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCameraRO(positional)
    |> to_struct()
  end

  @doc """
  Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    Vector of vectors of calibration pattern points in the calibration pattern
    coordinate space. See #calibrateCamera for details. If the method of releasing object to be used,
    the identical calibration board must be used in each view and it must be fully visible, and all
    objectPoints[i] must be the same and all points should be roughly close to a plane. **The calibration
    target has to be rigid, or at least static if the camera (rather than the calibration target) is
    shifted for grabbing images.**

  - **imagePoints**: `[Evision.Mat]`.

    Vector of vectors of the projections of calibration pattern points. See
    #calibrateCamera for details.

  - **imageSize**: `Size`.

    Size of the image used only to initialize the intrinsic camera matrix.

  - **iFixedPoint**: `integer()`.

    The index of the 3D object point in objectPoints[0] to be fixed. It also acts as
    a switch for calibration method selection. If object-releasing method to be used, pass in the
    parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will
    make standard calibration method selected. Usually the top-right corner point of the calibration
    board grid is recommended to be fixed when object-releasing method being utilized. According to
    \\cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front
    and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and
    newObjPoints are only possible if coordinates of these three fixed points are accurate enough.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Different flags that may be zero or a combination of some predefined values. See
    #calibrateCamera for details. If the method of releasing object is used, the calibration time may
    be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially
    less precise and less stable in some rare cases.

  - **criteria**: `TermCriteria`.

    Termination criteria for the iterative optimization algorithm.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`.

    Output 3x3 floating-point camera matrix. See #calibrateCamera for details.

  - **distCoeffs**: `Evision.Mat.t()`.

    Output vector of distortion coefficients. See #calibrateCamera for details.

  - **rvecs**: `[Evision.Mat]`.

    Output vector of rotation vectors estimated for each pattern view. See #calibrateCamera
    for details.

  - **tvecs**: `[Evision.Mat]`.

    Output vector of translation vectors estimated for each pattern view.

  - **newObjPoints**: `Evision.Mat.t()`.

    The updated output vector of calibration pattern points. The coordinates might
    be scaled based on three fixed points. The returned coordinates are accurate only if the above
    mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter
    is ignored with standard calibration method.

  - **stdDeviationsIntrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for intrinsic parameters.
    See #calibrateCamera for details.

  - **stdDeviationsExtrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for extrinsic parameters.
    See #calibrateCamera for details.

  - **stdDeviationsObjPoints**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for refined coordinates
    of calibration pattern points. It has the same size and order as objectPoints[0] vector. This
    parameter is ignored with standard calibration method.

  - **perViewErrors**: `Evision.Mat.t()`.

    Output vector of the RMS re-projection error estimated for each pattern view.

  This function is an extension of #calibrateCamera with the method of releasing object which was
  proposed in @cite strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar
  targets (calibration plates), this method can dramatically improve the precision of the estimated
  camera parameters. Both the object-releasing method and standard method are supported by this
  function. Use the parameter **iFixedPoint** for method selection. In the internal implementation,
  #calibrateCamera is a wrapper for this function.

  @return the overall RMS re-projection error.
  The function estimates the intrinsic camera parameters and extrinsic parameters for each of the
  views. The algorithm is based on @cite Zhang2000, @cite BouguetMCT and @cite strobl2011iccv. See
  #calibrateCamera for other detailed explanations.
  @sa
  calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort

  Python prototype (for reference only):
  ```python3
  calibrateCameraROExtended(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, stdDeviationsObjPoints[, perViewErrors[, flags[, criteria]]]]]]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors
  ```
  """
  @spec calibrateCameraROExtended(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, integer(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateCameraROExtended(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, opts) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and is_integer(iFixedPoint) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      iFixedPoint: Evision.Internal.Structurise.from_struct(iFixedPoint),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCameraROExtended(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    Vector of vectors of calibration pattern points in the calibration pattern
    coordinate space. See #calibrateCamera for details. If the method of releasing object to be used,
    the identical calibration board must be used in each view and it must be fully visible, and all
    objectPoints[i] must be the same and all points should be roughly close to a plane. **The calibration
    target has to be rigid, or at least static if the camera (rather than the calibration target) is
    shifted for grabbing images.**

  - **imagePoints**: `[Evision.Mat]`.

    Vector of vectors of the projections of calibration pattern points. See
    #calibrateCamera for details.

  - **imageSize**: `Size`.

    Size of the image used only to initialize the intrinsic camera matrix.

  - **iFixedPoint**: `integer()`.

    The index of the 3D object point in objectPoints[0] to be fixed. It also acts as
    a switch for calibration method selection. If object-releasing method to be used, pass in the
    parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will
    make standard calibration method selected. Usually the top-right corner point of the calibration
    board grid is recommended to be fixed when object-releasing method being utilized. According to
    \\cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front
    and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and
    newObjPoints are only possible if coordinates of these three fixed points are accurate enough.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Different flags that may be zero or a combination of some predefined values. See
    #calibrateCamera for details. If the method of releasing object is used, the calibration time may
    be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially
    less precise and less stable in some rare cases.

  - **criteria**: `TermCriteria`.

    Termination criteria for the iterative optimization algorithm.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix**: `Evision.Mat.t()`.

    Output 3x3 floating-point camera matrix. See #calibrateCamera for details.

  - **distCoeffs**: `Evision.Mat.t()`.

    Output vector of distortion coefficients. See #calibrateCamera for details.

  - **rvecs**: `[Evision.Mat]`.

    Output vector of rotation vectors estimated for each pattern view. See #calibrateCamera
    for details.

  - **tvecs**: `[Evision.Mat]`.

    Output vector of translation vectors estimated for each pattern view.

  - **newObjPoints**: `Evision.Mat.t()`.

    The updated output vector of calibration pattern points. The coordinates might
    be scaled based on three fixed points. The returned coordinates are accurate only if the above
    mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter
    is ignored with standard calibration method.

  - **stdDeviationsIntrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for intrinsic parameters.
    See #calibrateCamera for details.

  - **stdDeviationsExtrinsics**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for extrinsic parameters.
    See #calibrateCamera for details.

  - **stdDeviationsObjPoints**: `Evision.Mat.t()`.

    Output vector of standard deviations estimated for refined coordinates
    of calibration pattern points. It has the same size and order as objectPoints[0] vector. This
    parameter is ignored with standard calibration method.

  - **perViewErrors**: `Evision.Mat.t()`.

    Output vector of the RMS re-projection error estimated for each pattern view.

  This function is an extension of #calibrateCamera with the method of releasing object which was
  proposed in @cite strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar
  targets (calibration plates), this method can dramatically improve the precision of the estimated
  camera parameters. Both the object-releasing method and standard method are supported by this
  function. Use the parameter **iFixedPoint** for method selection. In the internal implementation,
  #calibrateCamera is a wrapper for this function.

  @return the overall RMS re-projection error.
  The function estimates the intrinsic camera parameters and extrinsic parameters for each of the
  views. The algorithm is based on @cite Zhang2000, @cite BouguetMCT and @cite strobl2011iccv. See
  #calibrateCamera for other detailed explanations.
  @sa
  calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort

  Python prototype (for reference only):
  ```python3
  calibrateCameraROExtended(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs[, rvecs[, tvecs[, newObjPoints[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, stdDeviationsObjPoints[, perViewErrors[, flags[, criteria]]]]]]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors
  ```
  """
  @spec calibrateCameraROExtended(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, integer(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateCameraROExtended(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and is_integer(iFixedPoint) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      iFixedPoint: Evision.Internal.Structurise.from_struct(iFixedPoint),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.calibrateCameraROExtended(positional)
    |> to_struct()
  end

  @doc """
  Computes Hand-Eye calibration: \\f$\\_{}^{g}\\textrm{T}\\_c\\f$

  ##### Positional Arguments
  - **r_gripper2base**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from gripper frame to robot base frame.

  - **t_gripper2base**: `[Evision.Mat]`.

    Translation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from gripper frame to robot base frame.

  - **r_target2cam**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from calibration target frame to camera frame.

  - **t_target2cam**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from calibration target frame to camera frame.

  ##### Keyword Arguments
  - **method**: `HandEyeCalibrationMethod`.

    One of the implemented Hand-Eye calibration method, see cv::HandEyeCalibrationMethod

  ##### Return
  - **r_cam2gripper**: `Evision.Mat.t()`.

    Estimated `(3x3)` rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$).

  - **t_cam2gripper**: `Evision.Mat.t()`.

    Estimated `(3x1)` translation part extracted from the homogeneous matrix that transforms a point
    expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$).

  The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the
  rotation then the translation (separable solutions) and the following methods are implemented:
  - R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \\cite Tsai89
  - F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \\cite Park94
  - R. Horaud, F. Dornaika Hand-Eye Calibration \\cite Horaud95

  Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),
  with the following implemented methods:
  - N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \\cite Andreff99
  - K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \\cite Daniilidis98

  The following picture describes the Hand-Eye calibration problem where the transformation between a camera ("eye")
  mounted on a robot gripper ("hand") has to be estimated. This configuration is called eye-in-hand.
  The eye-to-hand configuration consists in a static camera observing a calibration pattern mounted on the robot
  end-effector. The transformation from the camera to the robot base frame can then be estimated by inputting
  the suitable transformations to the function, see below.
  ![](pics/hand-eye_figure.png)
  The calibration procedure is the following:
  - a static calibration pattern is used to estimate the transformation between the target frame
    and the camera frame

  - the robot gripper is moved in order to acquire several poses
  - for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for
    instance the robot kinematics
    \\f[
    \\begin{bmatrix}
    X\\_b\\\\\\\\
    Y\\_b\\\\\\\\
    Z\\_b\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{b}\\textrm{R}\\_g & \\_{}^{b}\\textrm{t}\\_g \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_g\\\\\\\\
    Y\\_g\\\\\\\\
    Z\\_g\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  - for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using
    for instance a pose estimation method (PnP) from 2D-3D point correspondences
    \\f[
    \\begin{bmatrix}
    X\\_c\\\\\\\\
    Y\\_c\\\\\\\\
    Z\\_c\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{c}\\textrm{R}\\_t & \\_{}^{c}\\textrm{t}\\_t \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_t\\\\\\\\
    Y\\_t\\\\\\\\
    Z\\_t\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  The Hand-Eye calibration procedure returns the following homogeneous transformation
  \\f[
  \\begin{bmatrix}
  X\\_g\\\\\\\\
  Y\\_g\\\\\\\\
  Z\\_g\\\\\\\\
  1
  \\end{bmatrix}
  \\begin{bmatrix}
  \\_{}^{g}\\textrm{R}\\_c & \\_{}^{g}\\textrm{t}\\_c \\\\\\\\
  0\\_{1 \\times 3} & 1
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\_c\\\\\\\\
  Y\\_c\\\\\\\\
  Z\\_c\\\\\\\\
  1
  \\end{bmatrix}
  \\f]
  This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{X}\\mathbf{B}\\f$ equation:
  - for an eye-in-hand configuration
    \\f[
    \\begin{align\\*}
    ^{b}{\\textrm{T}\\_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(1)} &=
    \\hspace{0.1em} ^{b}{\\textrm{T}\\_g}^{(2)} \\hspace{0.2em} ^{g}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} \\\\\\\\
    (^{b}{\\textrm{T}\\_g}^{(2)})^{-1} \\hspace{0.2em} ^{b}{\\textrm{T}\\_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}\\_c &=
    \\hspace{0.1em} ^{g}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} (^{c}{\\textrm{T}\\_t}^{(1)})^{-1} \\\\\\\\
    \\textrm{A}\\_i \\textrm{X} &= \\textrm{X} \\textrm{B}\\_i \\\\\\\\
    \\end{align\\*}
    \\f]

  - for an eye-to-hand configuration
    \\f[
    \\begin{align\\*}
    ^{g}{\\textrm{T}\\_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(1)} &=
    \\hspace{0.1em} ^{g}{\\textrm{T}\\_b}^{(2)} \\hspace{0.2em} ^{b}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} \\\\\\\\
    (^{g}{\\textrm{T}\\_b}^{(2)})^{-1} \\hspace{0.2em} ^{g}{\\textrm{T}\\_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}\\_c &=
    \\hspace{0.1em} ^{b}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} (^{c}{\\textrm{T}\\_t}^{(1)})^{-1} \\\\\\\\
    \\textrm{A}\\_i \\textrm{X} &= \\textrm{X} \\textrm{B}\\_i \\\\\\\\
    \\end{align\\*}
    \\f]

  \\note
  Additional information can be found on this [website](http://campar.in.tum.de/Chair/HandEyeCalibration).
  \\note
  A minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation.
  So at least 3 different poses are required, but it is strongly recommended to use many more poses.

  Python prototype (for reference only):
  ```python3
  calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam[, R_cam2gripper[, t_cam2gripper[, method]]]) -> R_cam2gripper, t_cam2gripper
  ```
  """
  @spec calibrateHandEye(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), [{:method, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateHandEye(r_gripper2base, t_gripper2base, r_target2cam, t_target2cam, opts) when is_list(r_gripper2base) and is_list(t_gripper2base) and is_list(r_target2cam) and is_list(t_target2cam) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:method])
    positional = [
      r_gripper2base: Evision.Internal.Structurise.from_struct(r_gripper2base),
      t_gripper2base: Evision.Internal.Structurise.from_struct(t_gripper2base),
      r_target2cam: Evision.Internal.Structurise.from_struct(r_target2cam),
      t_target2cam: Evision.Internal.Structurise.from_struct(t_target2cam)
    ]
    :evision_nif.calibrateHandEye(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes Hand-Eye calibration: \\f$\\_{}^{g}\\textrm{T}\\_c\\f$

  ##### Positional Arguments
  - **r_gripper2base**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from gripper frame to robot base frame.

  - **t_gripper2base**: `[Evision.Mat]`.

    Translation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from gripper frame to robot base frame.

  - **r_target2cam**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from calibration target frame to camera frame.

  - **t_target2cam**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from calibration target frame to camera frame.

  ##### Keyword Arguments
  - **method**: `HandEyeCalibrationMethod`.

    One of the implemented Hand-Eye calibration method, see cv::HandEyeCalibrationMethod

  ##### Return
  - **r_cam2gripper**: `Evision.Mat.t()`.

    Estimated `(3x3)` rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$).

  - **t_cam2gripper**: `Evision.Mat.t()`.

    Estimated `(3x1)` translation part extracted from the homogeneous matrix that transforms a point
    expressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$).

  The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the
  rotation then the translation (separable solutions) and the following methods are implemented:
  - R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \\cite Tsai89
  - F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \\cite Park94
  - R. Horaud, F. Dornaika Hand-Eye Calibration \\cite Horaud95

  Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),
  with the following implemented methods:
  - N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \\cite Andreff99
  - K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \\cite Daniilidis98

  The following picture describes the Hand-Eye calibration problem where the transformation between a camera ("eye")
  mounted on a robot gripper ("hand") has to be estimated. This configuration is called eye-in-hand.
  The eye-to-hand configuration consists in a static camera observing a calibration pattern mounted on the robot
  end-effector. The transformation from the camera to the robot base frame can then be estimated by inputting
  the suitable transformations to the function, see below.
  ![](pics/hand-eye_figure.png)
  The calibration procedure is the following:
  - a static calibration pattern is used to estimate the transformation between the target frame
    and the camera frame

  - the robot gripper is moved in order to acquire several poses
  - for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for
    instance the robot kinematics
    \\f[
    \\begin{bmatrix}
    X\\_b\\\\\\\\
    Y\\_b\\\\\\\\
    Z\\_b\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{b}\\textrm{R}\\_g & \\_{}^{b}\\textrm{t}\\_g \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_g\\\\\\\\
    Y\\_g\\\\\\\\
    Z\\_g\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  - for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using
    for instance a pose estimation method (PnP) from 2D-3D point correspondences
    \\f[
    \\begin{bmatrix}
    X\\_c\\\\\\\\
    Y\\_c\\\\\\\\
    Z\\_c\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{c}\\textrm{R}\\_t & \\_{}^{c}\\textrm{t}\\_t \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_t\\\\\\\\
    Y\\_t\\\\\\\\
    Z\\_t\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  The Hand-Eye calibration procedure returns the following homogeneous transformation
  \\f[
  \\begin{bmatrix}
  X\\_g\\\\\\\\
  Y\\_g\\\\\\\\
  Z\\_g\\\\\\\\
  1
  \\end{bmatrix}
  \\begin{bmatrix}
  \\_{}^{g}\\textrm{R}\\_c & \\_{}^{g}\\textrm{t}\\_c \\\\\\\\
  0\\_{1 \\times 3} & 1
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\_c\\\\\\\\
  Y\\_c\\\\\\\\
  Z\\_c\\\\\\\\
  1
  \\end{bmatrix}
  \\f]
  This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{X}\\mathbf{B}\\f$ equation:
  - for an eye-in-hand configuration
    \\f[
    \\begin{align\\*}
    ^{b}{\\textrm{T}\\_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(1)} &=
    \\hspace{0.1em} ^{b}{\\textrm{T}\\_g}^{(2)} \\hspace{0.2em} ^{g}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} \\\\\\\\
    (^{b}{\\textrm{T}\\_g}^{(2)})^{-1} \\hspace{0.2em} ^{b}{\\textrm{T}\\_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}\\_c &=
    \\hspace{0.1em} ^{g}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} (^{c}{\\textrm{T}\\_t}^{(1)})^{-1} \\\\\\\\
    \\textrm{A}\\_i \\textrm{X} &= \\textrm{X} \\textrm{B}\\_i \\\\\\\\
    \\end{align\\*}
    \\f]

  - for an eye-to-hand configuration
    \\f[
    \\begin{align\\*}
    ^{g}{\\textrm{T}\\_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(1)} &=
    \\hspace{0.1em} ^{g}{\\textrm{T}\\_b}^{(2)} \\hspace{0.2em} ^{b}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} \\\\\\\\
    (^{g}{\\textrm{T}\\_b}^{(2)})^{-1} \\hspace{0.2em} ^{g}{\\textrm{T}\\_b}^{(1)} \\hspace{0.2em} ^{b}\\textrm{T}\\_c &=
    \\hspace{0.1em} ^{b}\\textrm{T}\\_c \\hspace{0.2em} ^{c}{\\textrm{T}\\_t}^{(2)} (^{c}{\\textrm{T}\\_t}^{(1)})^{-1} \\\\\\\\
    \\textrm{A}\\_i \\textrm{X} &= \\textrm{X} \\textrm{B}\\_i \\\\\\\\
    \\end{align\\*}
    \\f]

  \\note
  Additional information can be found on this [website](http://campar.in.tum.de/Chair/HandEyeCalibration).
  \\note
  A minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation.
  So at least 3 different poses are required, but it is strongly recommended to use many more poses.

  Python prototype (for reference only):
  ```python3
  calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam[, R_cam2gripper[, t_cam2gripper[, method]]]) -> R_cam2gripper, t_cam2gripper
  ```
  """
  @spec calibrateHandEye(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in())) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateHandEye(r_gripper2base, t_gripper2base, r_target2cam, t_target2cam) when is_list(r_gripper2base) and is_list(t_gripper2base) and is_list(r_target2cam) and is_list(t_target2cam)
  do
    positional = [
      r_gripper2base: Evision.Internal.Structurise.from_struct(r_gripper2base),
      t_gripper2base: Evision.Internal.Structurise.from_struct(t_gripper2base),
      r_target2cam: Evision.Internal.Structurise.from_struct(r_target2cam),
      t_target2cam: Evision.Internal.Structurise.from_struct(t_target2cam)
    ]
    :evision_nif.calibrateHandEye(positional)
    |> to_struct()
  end

  @doc """
  Computes Robot-World/Hand-Eye calibration: \\f$\\_{}^{w}\\textrm{T}\\_b\\f$ and \\f$\\_{}^{c}\\textrm{T}\\_g\\f$

  ##### Positional Arguments
  - **r_world2cam**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from world frame to the camera frame.

  - **t_world2cam**: `[Evision.Mat]`.

    Translation part extracted from the homogeneous matrix that transforms a point
    expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from world frame to the camera frame.

  - **r_base2gripper**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from robot base frame to the gripper frame.

  - **t_base2gripper**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from robot base frame to the gripper frame.

  ##### Keyword Arguments
  - **method**: `RobotWorldHandEyeCalibrationMethod`.

    One of the implemented Robot-World/Hand-Eye calibration method, see cv::RobotWorldHandEyeCalibrationMethod

  ##### Return
  - **r_base2world**: `Evision.Mat.t()`.

    Estimated `(3x3)` rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$).

  - **t_base2world**: `Evision.Mat.t()`.

    Estimated `(3x1)` translation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$).

  - **r_gripper2cam**: `Evision.Mat.t()`.

    Estimated `(3x3)` rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$).

  - **t_gripper2cam**: `Evision.Mat.t()`.

    Estimated `(3x1)` translation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$).

  The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the
  rotation then the translation (separable solutions):
  - M. Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \\cite Shah2013SolvingTR

  Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),
  with the following implemented method:
  - A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product \\cite Li2010SimultaneousRA

  The following picture describes the Robot-World/Hand-Eye calibration problem where the transformations between a robot and a world frame
  and between a robot gripper ("hand") and a camera ("eye") mounted at the robot end-effector have to be estimated.
  ![](pics/robot-world_hand-eye_figure.png)
  The calibration procedure is the following:
  - a static calibration pattern is used to estimate the transformation between the target frame
    and the camera frame

  - the robot gripper is moved in order to acquire several poses
  - for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for
    instance the robot kinematics
    \\f[
    \\begin{bmatrix}
    X\\_g\\\\\\\\
    Y\\_g\\\\\\\\
    Z\\_g\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{g}\\textrm{R}\\_b & \\_{}^{g}\\textrm{t}\\_b \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_b\\\\\\\\
    Y\\_b\\\\\\\\
    Z\\_b\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  - for each pose, the homogeneous transformation between the calibration target frame (the world frame) and the camera frame is recorded using
    for instance a pose estimation method (PnP) from 2D-3D point correspondences
    \\f[
    \\begin{bmatrix}
    X\\_c\\\\\\\\
    Y\\_c\\\\\\\\
    Z\\_c\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{c}\\textrm{R}\\_w & \\_{}^{c}\\textrm{t}\\_w \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_w\\\\\\\\
    Y\\_w\\\\\\\\
    Z\\_w\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  The Robot-World/Hand-Eye calibration procedure returns the following homogeneous transformations
  \\f[
  \\begin{bmatrix}
  X\\_w\\\\\\\\
  Y\\_w\\\\\\\\
  Z\\_w\\\\\\\\
  1
  \\end{bmatrix}
  \\begin{bmatrix}
  \\_{}^{w}\\textrm{R}\\_b & \\_{}^{w}\\textrm{t}\\_b \\\\\\\\
  0\\_{1 \\times 3} & 1
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\_b\\\\\\\\
  Y\\_b\\\\\\\\
  Z\\_b\\\\\\\\
  1
  \\end{bmatrix}
  \\f]
  \\f[
  \\begin{bmatrix}
  X\\_c\\\\\\\\
  Y\\_c\\\\\\\\
  Z\\_c\\\\\\\\
  1
  \\end{bmatrix}
  \\begin{bmatrix}
  \\_{}^{c}\\textrm{R}\\_g & \\_{}^{c}\\textrm{t}\\_g \\\\\\\\
  0\\_{1 \\times 3} & 1
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\_g\\\\\\\\
  Y\\_g\\\\\\\\
  Z\\_g\\\\\\\\
  1
  \\end{bmatrix}
  \\f]
  This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{Z}\\mathbf{B}\\f$ equation, with:
  - \\f$\\mathbf{A} \\Leftrightarrow \\hspace{0.1em} \\_{}^{c}\\textrm{T}\\_w\\f$
  - \\f$\\mathbf{X} \\Leftrightarrow \\hspace{0.1em} \\_{}^{w}\\textrm{T}\\_b\\f$
  - \\f$\\mathbf{Z} \\Leftrightarrow \\hspace{0.1em} \\_{}^{c}\\textrm{T}\\_g\\f$
  - \\f$\\mathbf{B} \\Leftrightarrow \\hspace{0.1em} \\_{}^{g}\\textrm{T}\\_b\\f$

  \\note
  At least 3 measurements are required (input vectors size must be greater or equal to 3).

  Python prototype (for reference only):
  ```python3
  calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper[, R_base2world[, t_base2world[, R_gripper2cam[, t_gripper2cam[, method]]]]]) -> R_base2world, t_base2world, R_gripper2cam, t_gripper2cam
  ```
  """
  @spec calibrateRobotWorldHandEye(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), [{:method, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateRobotWorldHandEye(r_world2cam, t_world2cam, r_base2gripper, t_base2gripper, opts) when is_list(r_world2cam) and is_list(t_world2cam) and is_list(r_base2gripper) and is_list(t_base2gripper) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:method])
    positional = [
      r_world2cam: Evision.Internal.Structurise.from_struct(r_world2cam),
      t_world2cam: Evision.Internal.Structurise.from_struct(t_world2cam),
      r_base2gripper: Evision.Internal.Structurise.from_struct(r_base2gripper),
      t_base2gripper: Evision.Internal.Structurise.from_struct(t_base2gripper)
    ]
    :evision_nif.calibrateRobotWorldHandEye(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes Robot-World/Hand-Eye calibration: \\f$\\_{}^{w}\\textrm{T}\\_b\\f$ and \\f$\\_{}^{c}\\textrm{T}\\_g\\f$

  ##### Positional Arguments
  - **r_world2cam**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from world frame to the camera frame.

  - **t_world2cam**: `[Evision.Mat]`.

    Translation part extracted from the homogeneous matrix that transforms a point
    expressed in the world frame to the camera frame (\\f$_{}^{c}\\textrm{T}_w\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from world frame to the camera frame.

  - **r_base2gripper**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$).
    This is a vector (`vector<Mat>`) that contains the rotation, `(3x3)` rotation matrices or `(3x1)` rotation vectors,
    for all the transformations from robot base frame to the gripper frame.

  - **t_base2gripper**: `[Evision.Mat]`.

    Rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_b\\f$).
    This is a vector (`vector<Mat>`) that contains the `(3x1)` translation vectors for all the transformations
    from robot base frame to the gripper frame.

  ##### Keyword Arguments
  - **method**: `RobotWorldHandEyeCalibrationMethod`.

    One of the implemented Robot-World/Hand-Eye calibration method, see cv::RobotWorldHandEyeCalibrationMethod

  ##### Return
  - **r_base2world**: `Evision.Mat.t()`.

    Estimated `(3x3)` rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$).

  - **t_base2world**: `Evision.Mat.t()`.

    Estimated `(3x1)` translation part extracted from the homogeneous matrix that transforms a point
    expressed in the robot base frame to the world frame (\\f$_{}^{w}\\textrm{T}_b\\f$).

  - **r_gripper2cam**: `Evision.Mat.t()`.

    Estimated `(3x3)` rotation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$).

  - **t_gripper2cam**: `Evision.Mat.t()`.

    Estimated `(3x1)` translation part extracted from the homogeneous matrix that transforms a point
    expressed in the gripper frame to the camera frame (\\f$_{}^{c}\\textrm{T}_g\\f$).

  The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the
  rotation then the translation (separable solutions):
  - M. Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \\cite Shah2013SolvingTR

  Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),
  with the following implemented method:
  - A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product \\cite Li2010SimultaneousRA

  The following picture describes the Robot-World/Hand-Eye calibration problem where the transformations between a robot and a world frame
  and between a robot gripper ("hand") and a camera ("eye") mounted at the robot end-effector have to be estimated.
  ![](pics/robot-world_hand-eye_figure.png)
  The calibration procedure is the following:
  - a static calibration pattern is used to estimate the transformation between the target frame
    and the camera frame

  - the robot gripper is moved in order to acquire several poses
  - for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for
    instance the robot kinematics
    \\f[
    \\begin{bmatrix}
    X\\_g\\\\\\\\
    Y\\_g\\\\\\\\
    Z\\_g\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{g}\\textrm{R}\\_b & \\_{}^{g}\\textrm{t}\\_b \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_b\\\\\\\\
    Y\\_b\\\\\\\\
    Z\\_b\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  - for each pose, the homogeneous transformation between the calibration target frame (the world frame) and the camera frame is recorded using
    for instance a pose estimation method (PnP) from 2D-3D point correspondences
    \\f[
    \\begin{bmatrix}
    X\\_c\\\\\\\\
    Y\\_c\\\\\\\\
    Z\\_c\\\\\\\\
    1
    \\end{bmatrix}=
    \\begin{bmatrix}
    \\_{}^{c}\\textrm{R}\\_w & \\_{}^{c}\\textrm{t}\\_w \\\\\\\\
    0\\_{1 \\times 3} & 1
    \\end{bmatrix}
    \\begin{bmatrix}
    X\\_w\\\\\\\\
    Y\\_w\\\\\\\\
    Z\\_w\\\\\\\\
    1
    \\end{bmatrix}
    \\f]

  The Robot-World/Hand-Eye calibration procedure returns the following homogeneous transformations
  \\f[
  \\begin{bmatrix}
  X\\_w\\\\\\\\
  Y\\_w\\\\\\\\
  Z\\_w\\\\\\\\
  1
  \\end{bmatrix}
  \\begin{bmatrix}
  \\_{}^{w}\\textrm{R}\\_b & \\_{}^{w}\\textrm{t}\\_b \\\\\\\\
  0\\_{1 \\times 3} & 1
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\_b\\\\\\\\
  Y\\_b\\\\\\\\
  Z\\_b\\\\\\\\
  1
  \\end{bmatrix}
  \\f]
  \\f[
  \\begin{bmatrix}
  X\\_c\\\\\\\\
  Y\\_c\\\\\\\\
  Z\\_c\\\\\\\\
  1
  \\end{bmatrix}
  \\begin{bmatrix}
  \\_{}^{c}\\textrm{R}\\_g & \\_{}^{c}\\textrm{t}\\_g \\\\\\\\
  0\\_{1 \\times 3} & 1
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\_g\\\\\\\\
  Y\\_g\\\\\\\\
  Z\\_g\\\\\\\\
  1
  \\end{bmatrix}
  \\f]
  This problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{Z}\\mathbf{B}\\f$ equation, with:
  - \\f$\\mathbf{A} \\Leftrightarrow \\hspace{0.1em} \\_{}^{c}\\textrm{T}\\_w\\f$
  - \\f$\\mathbf{X} \\Leftrightarrow \\hspace{0.1em} \\_{}^{w}\\textrm{T}\\_b\\f$
  - \\f$\\mathbf{Z} \\Leftrightarrow \\hspace{0.1em} \\_{}^{c}\\textrm{T}\\_g\\f$
  - \\f$\\mathbf{B} \\Leftrightarrow \\hspace{0.1em} \\_{}^{g}\\textrm{T}\\_b\\f$

  \\note
  At least 3 measurements are required (input vectors size must be greater or equal to 3).

  Python prototype (for reference only):
  ```python3
  calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper[, R_base2world[, t_base2world[, R_gripper2cam[, t_gripper2cam[, method]]]]]) -> R_base2world, t_base2world, R_gripper2cam, t_gripper2cam
  ```
  """
  @spec calibrateRobotWorldHandEye(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in())) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def calibrateRobotWorldHandEye(r_world2cam, t_world2cam, r_base2gripper, t_base2gripper) when is_list(r_world2cam) and is_list(t_world2cam) and is_list(r_base2gripper) and is_list(t_base2gripper)
  do
    positional = [
      r_world2cam: Evision.Internal.Structurise.from_struct(r_world2cam),
      t_world2cam: Evision.Internal.Structurise.from_struct(t_world2cam),
      r_base2gripper: Evision.Internal.Structurise.from_struct(r_base2gripper),
      t_base2gripper: Evision.Internal.Structurise.from_struct(t_base2gripper)
    ]
    :evision_nif.calibrateRobotWorldHandEye(positional)
    |> to_struct()
  end

  @doc """
  Computes useful camera characteristics from the camera intrinsic matrix.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix that can be estimated by #calibrateCamera or
    #stereoCalibrate .

  - **imageSize**: `Size`.

    Input image size in pixels.

  - **apertureWidth**: `double`.

    Physical width in mm of the sensor.

  - **apertureHeight**: `double`.

    Physical height in mm of the sensor.

  ##### Return
  - **fovx**: `double`.

    Output field of view in degrees along the horizontal sensor axis.

  - **fovy**: `double`.

    Output field of view in degrees along the vertical sensor axis.

  - **focalLength**: `double`.

    Focal length of the lens in mm.

  - **principalPoint**: `Point2d`.

    Principal point in mm.

  - **aspectRatio**: `double`.

    \\f$f_y/f_x\\f$

  The function computes various useful camera characteristics from the previously estimated camera
  matrix.
  **Note**: 
  Do keep in mind that the unity measure 'mm' stands for whatever unit of measure one chooses for
  the chessboard pitch (it can thus be any value).

  Python prototype (for reference only):
  ```python3
  calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight) -> fovx, fovy, focalLength, principalPoint, aspectRatio
  ```
  """
  @spec calibrationMatrixValues(Evision.Mat.maybe_mat_in(), {number(), number()}, number(), number()) :: {number(), number(), number(), {number(), number()}, number()} | {:error, String.t()}
  def calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and is_tuple(imageSize) and is_number(apertureWidth) and is_number(apertureHeight)
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      apertureWidth: Evision.Internal.Structurise.from_struct(apertureWidth),
      apertureHeight: Evision.Internal.Structurise.from_struct(apertureHeight)
    ]
    :evision_nif.calibrationMatrixValues(positional)
    |> to_struct()
  end

  @doc """
  Calculates the magnitude and angle of 2D vectors.

  ##### Positional Arguments
  - **x**: `Evision.Mat`.

    array of x-coordinates; this must be a single-precision or
    double-precision floating-point array.

  - **y**: `Evision.Mat`.

    array of y-coordinates, that must have the same size and same type as x.

  ##### Keyword Arguments
  - **angleInDegrees**: `bool`.

    a flag, indicating whether the angles are measured
    in radians (which is by default), or in degrees.

  ##### Return
  - **magnitude**: `Evision.Mat.t()`.

    output array of magnitudes of the same size and type as x.

  - **angle**: `Evision.Mat.t()`.

    output array of angles that has the same size and type as
    x; the angles are measured in radians (from 0 to 2\\*Pi) or in degrees (0 to 360 degrees).

  The function cv::cartToPolar calculates either the magnitude, angle, or both
  for every 2D vector (x(I),y(I)):
  \\f[\\begin{array}{l} \\texttt{magnitude} (I)= \\sqrt{\\texttt{x}(I)^2+\\texttt{y}(I)^2} , \\\\\\\\ \\texttt{angle} (I)= \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\[ \\cdot180 / \\pi ] \\end{array}\\f]
  The angles are calculated with accuracy about 0.3 degrees. For the point
  (0,0), the angle is set to 0.
  @sa Sobel, Scharr

  Python prototype (for reference only):
  ```python3
  cartToPolar(x, y[, magnitude[, angle[, angleInDegrees]]]) -> magnitude, angle
  ```
  """
  @spec cartToPolar(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:angleInDegrees, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def cartToPolar(x, y, opts) when (is_struct(x, Evision.Mat) or is_struct(x, Nx.Tensor) or is_number(x) or is_tuple(x)) and (is_struct(y, Evision.Mat) or is_struct(y, Nx.Tensor) or is_number(y) or is_tuple(y)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:angleInDegrees])
    positional = [
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.cartToPolar(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the magnitude and angle of 2D vectors.

  ##### Positional Arguments
  - **x**: `Evision.Mat`.

    array of x-coordinates; this must be a single-precision or
    double-precision floating-point array.

  - **y**: `Evision.Mat`.

    array of y-coordinates, that must have the same size and same type as x.

  ##### Keyword Arguments
  - **angleInDegrees**: `bool`.

    a flag, indicating whether the angles are measured
    in radians (which is by default), or in degrees.

  ##### Return
  - **magnitude**: `Evision.Mat.t()`.

    output array of magnitudes of the same size and type as x.

  - **angle**: `Evision.Mat.t()`.

    output array of angles that has the same size and type as
    x; the angles are measured in radians (from 0 to 2\\*Pi) or in degrees (0 to 360 degrees).

  The function cv::cartToPolar calculates either the magnitude, angle, or both
  for every 2D vector (x(I),y(I)):
  \\f[\\begin{array}{l} \\texttt{magnitude} (I)= \\sqrt{\\texttt{x}(I)^2+\\texttt{y}(I)^2} , \\\\\\\\ \\texttt{angle} (I)= \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\[ \\cdot180 / \\pi ] \\end{array}\\f]
  The angles are calculated with accuracy about 0.3 degrees. For the point
  (0,0), the angle is set to 0.
  @sa Sobel, Scharr

  Python prototype (for reference only):
  ```python3
  cartToPolar(x, y[, magnitude[, angle[, angleInDegrees]]]) -> magnitude, angle
  ```
  """
  @spec cartToPolar(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def cartToPolar(x, y) when (is_struct(x, Evision.Mat) or is_struct(x, Nx.Tensor) or is_number(x) or is_tuple(x)) and (is_struct(y, Evision.Mat) or is_struct(y, Nx.Tensor) or is_number(y) or is_tuple(y))
  do
    positional = [
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.cartToPolar(positional)
    |> to_struct()
  end

  @doc """
  checkChessboard

  ##### Positional Arguments
  - **img**: `Evision.Mat`
  - **size**: `Size`

  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  checkChessboard(img, size) -> retval
  ```
  """
  @spec checkChessboard(Evision.Mat.maybe_mat_in(), {number(), number()}) :: boolean() | {:error, String.t()}
  def checkChessboard(img, size) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(size)
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      size: Evision.Internal.Structurise.from_struct(size)
    ]
    :evision_nif.checkChessboard(positional)
    |> to_struct()
  end

  @doc """
  Returns true if the specified feature is supported by the host hardware.

  ##### Positional Arguments
  - **feature**: `integer()`.

    The feature of interest, one of cv::CpuFeatures

  ##### Return
  - **retval**: `bool`

  The function returns true if the host hardware supports the specified feature. When user calls
  setUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until
  setUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code
  in OpenCV.

  Python prototype (for reference only):
  ```python3
  checkHardwareSupport(feature) -> retval
  ```
  """
  @spec checkHardwareSupport(integer()) :: boolean() | {:error, String.t()}
  def checkHardwareSupport(feature) when is_integer(feature)
  do
    positional = [
      feature: Evision.Internal.Structurise.from_struct(feature)
    ]
    :evision_nif.checkHardwareSupport(positional)
    |> to_struct()
  end

  @doc """
  Checks every element of an input array for invalid values.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    input array.

  ##### Keyword Arguments
  - **quiet**: `bool`.

    a flag, indicating whether the functions quietly return false when the array elements
    are out of range or they throw an exception.

  - **minVal**: `double`.

    inclusive lower boundary of valid values range.

  - **maxVal**: `double`.

    exclusive upper boundary of valid values range.

  ##### Return
  - **retval**: `bool`
  - **pos**: `Point*`.

    optional output parameter, when not NULL, must be a pointer to array of src.dims
    elements.

  The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal \\>
  - DBL_MAX and maxVal \\< DBL_MAX, the function also checks that each value is between minVal and
    maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
    are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
    function either returns false (when quiet=true) or throws an exception.

  Python prototype (for reference only):
  ```python3
  checkRange(a[, quiet[, minVal[, maxVal]]]) -> retval, pos
  ```
  """
  @spec checkRange(Evision.Mat.maybe_mat_in(), [{:maxVal, term()} | {:minVal, term()} | {:quiet, term()}] | nil) :: {number(), number()} | false | {:error, String.t()}
  def checkRange(a, opts) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxVal, :minVal, :quiet])
    positional = [
      a: Evision.Internal.Structurise.from_struct(a)
    ]
    :evision_nif.checkRange(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Checks every element of an input array for invalid values.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    input array.

  ##### Keyword Arguments
  - **quiet**: `bool`.

    a flag, indicating whether the functions quietly return false when the array elements
    are out of range or they throw an exception.

  - **minVal**: `double`.

    inclusive lower boundary of valid values range.

  - **maxVal**: `double`.

    exclusive upper boundary of valid values range.

  ##### Return
  - **retval**: `bool`
  - **pos**: `Point*`.

    optional output parameter, when not NULL, must be a pointer to array of src.dims
    elements.

  The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal \\>
  - DBL_MAX and maxVal \\< DBL_MAX, the function also checks that each value is between minVal and
    maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
    are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
    function either returns false (when quiet=true) or throws an exception.

  Python prototype (for reference only):
  ```python3
  checkRange(a[, quiet[, minVal[, maxVal]]]) -> retval, pos
  ```
  """
  @spec checkRange(Evision.Mat.maybe_mat_in()) :: {number(), number()} | false | {:error, String.t()}
  def checkRange(a) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a))
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a)
    ]
    :evision_nif.checkRange(positional)
    |> to_struct()
  end

  @doc """
  Draws a circle.

  ##### Positional Arguments
  - **center**: `Point`.

    Center of the circle.

  - **radius**: `integer()`.

    Radius of the circle.

  - **color**: `Evision.scalar()`.

    Circle color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the circle outline, if positive. Negative values, like #FILLED,
    mean that a filled circle is to be drawn.

  - **lineType**: `integer()`.

    Type of the circle boundary. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the coordinates of the center and in the radius value.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image where the circle is drawn.

  The function cv::circle draws a simple or filled circle with a given center and radius.

  Python prototype (for reference only):
  ```python3
  circle(img, center, radius, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec circle(Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), Evision.scalar(), [{:lineType, term()} | {:shift, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def circle(img, center, radius, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(center) and is_integer(radius) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      center: Evision.Internal.Structurise.from_struct(center),
      radius: Evision.Internal.Structurise.from_struct(radius),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.circle(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws a circle.

  ##### Positional Arguments
  - **center**: `Point`.

    Center of the circle.

  - **radius**: `integer()`.

    Radius of the circle.

  - **color**: `Evision.scalar()`.

    Circle color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the circle outline, if positive. Negative values, like #FILLED,
    mean that a filled circle is to be drawn.

  - **lineType**: `integer()`.

    Type of the circle boundary. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the coordinates of the center and in the radius value.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image where the circle is drawn.

  The function cv::circle draws a simple or filled circle with a given center and radius.

  Python prototype (for reference only):
  ```python3
  circle(img, center, radius, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec circle(Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def circle(img, center, radius, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(center) and is_integer(radius) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      center: Evision.Internal.Structurise.from_struct(center),
      radius: Evision.Internal.Structurise.from_struct(radius),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.circle(positional)
    |> to_struct()
  end

  @doc """
  clipLine

  ##### Positional Arguments
  - **imgRect**: `Rect`.

    Image rectangle.

  ##### Return
  - **retval**: `bool`
  - **pt1**: `Point`.

    First line point.

  - **pt2**: `Point`.

    Second line point.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  clipLine(imgRect, pt1, pt2) -> retval, pt1, pt2
  ```
  """
  @spec clipLine({number(), number(), number(), number()}, {number(), number()}, {number(), number()}) :: {{number(), number()}, {number(), number()}} | false | {:error, String.t()}
  def clipLine(imgRect, pt1, pt2) when is_tuple(imgRect) and is_tuple(pt1) and is_tuple(pt2)
  do
    positional = [
      imgRect: Evision.Internal.Structurise.from_struct(imgRect),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2)
    ]
    :evision_nif.clipLine(positional)
    |> to_struct()
  end

  @doc """
  Given an original color image, two differently colored versions of this image can be mixed
  seamlessly.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  ##### Keyword Arguments
  - **red_mul**: `float`.

    R-channel multiply factor.

  - **green_mul**: `float`.

    G-channel multiply factor.

  - **blue_mul**: `float`.

    B-channel multiply factor.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  Multiplication factor is between .5 to 2.5.

  Python prototype (for reference only):
  ```python3
  colorChange(src, mask[, dst[, red_mul[, green_mul[, blue_mul]]]]) -> dst
  ```
  """
  @spec colorChange(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:blue_mul, term()} | {:green_mul, term()} | {:red_mul, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def colorChange(src, mask, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:blue_mul, :green_mul, :red_mul])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.colorChange(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Given an original color image, two differently colored versions of this image can be mixed
  seamlessly.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  ##### Keyword Arguments
  - **red_mul**: `float`.

    R-channel multiply factor.

  - **green_mul**: `float`.

    G-channel multiply factor.

  - **blue_mul**: `float`.

    B-channel multiply factor.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  Multiplication factor is between .5 to 2.5.

  Python prototype (for reference only):
  ```python3
  colorChange(src, mask[, dst[, red_mul[, green_mul[, blue_mul]]]]) -> dst
  ```
  """
  @spec colorChange(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def colorChange(src, mask) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.colorChange(positional)
    |> to_struct()
  end

  @doc """
  Performs the per-element comparison of two arrays or an array and scalar value.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar; when it is an array, it must have a single channel.

  - **src2**: `Evision.Mat`.

    second input array or a scalar; when it is an array, it must have a single channel.

  - **cmpop**: `integer()`.

    a flag, that specifies correspondence between the arrays (cv::CmpTypes)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of type ref CV_8U that has the same size and the same number of channels as
    the input arrays.

  The function compares:
     Elements of two arrays when src1 and src2 have the same size:
  \\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]
     Elements of src1 with a scalar src2 when src2 is constructed from
  Scalar or has a single element:
  \\f[\\texttt{dst} (I) =  \\texttt{src1}(I) \\,\\texttt{cmpop}\\,  \\texttt{src2}\\f]
     src1 with elements of src2 when src1 is constructed from Scalar or
  has a single element:
  \\f[\\texttt{dst} (I) =  \\texttt{src1}  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]
  When the comparison result is true, the corresponding element of output
  array is set to 255. The comparison operations can be replaced with the
  equivalent matrix expressions:
  ```cpp
  Mat dst1 = src1 >= src2;
  Mat dst2 = src1 < 8;
  ...
  ```
  @sa checkRange, min, max, threshold

  Python prototype (for reference only):
  ```python3
  compare(src1, src2, cmpop[, dst]) -> dst
  ```
  """
  @spec compare(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def compare(src1, src2, cmpop, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_integer(cmpop) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      cmpop: Evision.Internal.Structurise.from_struct(cmpop)
    ]
    :evision_nif.compare(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs the per-element comparison of two arrays or an array and scalar value.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar; when it is an array, it must have a single channel.

  - **src2**: `Evision.Mat`.

    second input array or a scalar; when it is an array, it must have a single channel.

  - **cmpop**: `integer()`.

    a flag, that specifies correspondence between the arrays (cv::CmpTypes)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of type ref CV_8U that has the same size and the same number of channels as
    the input arrays.

  The function compares:
     Elements of two arrays when src1 and src2 have the same size:
  \\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]
     Elements of src1 with a scalar src2 when src2 is constructed from
  Scalar or has a single element:
  \\f[\\texttt{dst} (I) =  \\texttt{src1}(I) \\,\\texttt{cmpop}\\,  \\texttt{src2}\\f]
     src1 with elements of src2 when src1 is constructed from Scalar or
  has a single element:
  \\f[\\texttt{dst} (I) =  \\texttt{src1}  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]
  When the comparison result is true, the corresponding element of output
  array is set to 255. The comparison operations can be replaced with the
  equivalent matrix expressions:
  ```cpp
  Mat dst1 = src1 >= src2;
  Mat dst2 = src1 < 8;
  ...
  ```
  @sa checkRange, min, max, threshold

  Python prototype (for reference only):
  ```python3
  compare(src1, src2, cmpop[, dst]) -> dst
  ```
  """
  @spec compare(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def compare(src1, src2, cmpop) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_integer(cmpop)
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      cmpop: Evision.Internal.Structurise.from_struct(cmpop)
    ]
    :evision_nif.compare(positional)
    |> to_struct()
  end

  @doc """
  Compares two histograms.

  ##### Positional Arguments
  - **h1**: `Evision.Mat`.

    First compared histogram.

  - **h2**: `Evision.Mat`.

    Second compared histogram of the same size as H1 .

  - **method**: `integer()`.

    Comparison method, see #HistCompMethods

  ##### Return
  - **retval**: `double`

  The function cv::compareHist compares two dense or two sparse histograms using the specified method.
  The function returns \\f$d(H\\_1, H\\_2)\\f$ .
  While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable
  for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling
  problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms
  or more general sparse configurations of weighted points, consider using the #EMD function.

  Python prototype (for reference only):
  ```python3
  compareHist(H1, H2, method) -> retval
  ```
  """
  @spec compareHist(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: number() | {:error, String.t()}
  def compareHist(h1, h2, method) when (is_struct(h1, Evision.Mat) or is_struct(h1, Nx.Tensor) or is_number(h1) or is_tuple(h1)) and (is_struct(h2, Evision.Mat) or is_struct(h2, Nx.Tensor) or is_number(h2) or is_tuple(h2)) and is_integer(method)
  do
    positional = [
      h1: Evision.Internal.Structurise.from_struct(h1),
      h2: Evision.Internal.Structurise.from_struct(h2),
      method: Evision.Internal.Structurise.from_struct(method)
    ]
    :evision_nif.compareHist(positional)
    |> to_struct()
  end

  @doc """
  Copies the lower or the upper half of a square matrix to its another half.
  ##### Keyword Arguments
  - **lowerToUpper**: `bool`.

    operation flag; if true, the lower half is copied to
    the upper half. Otherwise, the upper half is copied to the lower half.

  ##### Return
  - **m**: `Evision.Mat.t()`.

    input-output floating-point square matrix.

  The function cv::completeSymm copies the lower or the upper half of a square matrix to
  its another half. The matrix diagonal remains unchanged:
  - \\f$\\texttt{m}\\_{ij}=\\texttt{m}\\_{ji}\\f$ for \\f$i > j\\f$ if
    lowerToUpper=false

  - \\f$\\texttt{m}\\_{ij}=\\texttt{m}\\_{ji}\\f$ for \\f$i < j\\f$ if
    lowerToUpper=true

  @sa flip, transpose

  Python prototype (for reference only):
  ```python3
  completeSymm(m[, lowerToUpper]) -> m
  ```
  """
  @spec completeSymm(Evision.Mat.maybe_mat_in(), [{:lowerToUpper, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def completeSymm(m, opts) when (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lowerToUpper])
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.completeSymm(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Copies the lower or the upper half of a square matrix to its another half.
  ##### Keyword Arguments
  - **lowerToUpper**: `bool`.

    operation flag; if true, the lower half is copied to
    the upper half. Otherwise, the upper half is copied to the lower half.

  ##### Return
  - **m**: `Evision.Mat.t()`.

    input-output floating-point square matrix.

  The function cv::completeSymm copies the lower or the upper half of a square matrix to
  its another half. The matrix diagonal remains unchanged:
  - \\f$\\texttt{m}\\_{ij}=\\texttt{m}\\_{ji}\\f$ for \\f$i > j\\f$ if
    lowerToUpper=false

  - \\f$\\texttt{m}\\_{ij}=\\texttt{m}\\_{ji}\\f$ for \\f$i < j\\f$ if
    lowerToUpper=true

  @sa flip, transpose

  Python prototype (for reference only):
  ```python3
  completeSymm(m[, lowerToUpper]) -> m
  ```
  """
  @spec completeSymm(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def completeSymm(m) when (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m))
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.completeSymm(positional)
    |> to_struct()
  end

  @doc """
  Combines two rotation-and-shift transformations.

  ##### Positional Arguments
  - **rvec1**: `Evision.Mat`.

    First rotation vector.

  - **tvec1**: `Evision.Mat`.

    First translation vector.

  - **rvec2**: `Evision.Mat`.

    Second rotation vector.

  - **tvec2**: `Evision.Mat`.

    Second translation vector.

  ##### Return
  - **rvec3**: `Evision.Mat.t()`.

    Output rotation vector of the superposition.

  - **tvec3**: `Evision.Mat.t()`.

    Output translation vector of the superposition.

  - **dr3dr1**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to rvec1

  - **dr3dt1**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to tvec1

  - **dr3dr2**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to rvec2

  - **dr3dt2**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to tvec2

  - **dt3dr1**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to rvec1

  - **dt3dt1**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to tvec1

  - **dt3dr2**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to rvec2

  - **dt3dt2**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to tvec2

  The functions compute:
  \\f[\\begin{array}{l} \\texttt{rvec3} =  \\mathrm{rodrigues} ^{-1} \\left ( \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\mathrm{rodrigues} ( \\texttt{rvec1} ) \\right )  \\\\\\\\ \\texttt{tvec3} =  \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\texttt{tvec1} +  \\texttt{tvec2} \\end{array} ,\\f]
  where \\f$\\mathrm{rodrigues}\\f$ denotes a rotation vector to a rotation matrix transformation, and
  \\f$\\mathrm{rodrigues}^{-1}\\f$ denotes the inverse transformation. See #Rodrigues for details.
  Also, the functions can compute the derivatives of the output vectors with regards to the input
  vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
  your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
  function that contains a matrix multiplication.

  Python prototype (for reference only):
  ```python3
  composeRT(rvec1, tvec1, rvec2, tvec2[, rvec3[, tvec3[, dr3dr1[, dr3dt1[, dr3dr2[, dr3dt2[, dt3dr1[, dt3dt1[, dt3dr2[, dt3dt2]]]]]]]]]]) -> rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2
  ```
  """
  @spec composeRT(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def composeRT(rvec1, tvec1, rvec2, tvec2, opts) when (is_struct(rvec1, Evision.Mat) or is_struct(rvec1, Nx.Tensor) or is_number(rvec1) or is_tuple(rvec1)) and (is_struct(tvec1, Evision.Mat) or is_struct(tvec1, Nx.Tensor) or is_number(tvec1) or is_tuple(tvec1)) and (is_struct(rvec2, Evision.Mat) or is_struct(rvec2, Nx.Tensor) or is_number(rvec2) or is_tuple(rvec2)) and (is_struct(tvec2, Evision.Mat) or is_struct(tvec2, Nx.Tensor) or is_number(tvec2) or is_tuple(tvec2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      rvec1: Evision.Internal.Structurise.from_struct(rvec1),
      tvec1: Evision.Internal.Structurise.from_struct(tvec1),
      rvec2: Evision.Internal.Structurise.from_struct(rvec2),
      tvec2: Evision.Internal.Structurise.from_struct(tvec2)
    ]
    :evision_nif.composeRT(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Combines two rotation-and-shift transformations.

  ##### Positional Arguments
  - **rvec1**: `Evision.Mat`.

    First rotation vector.

  - **tvec1**: `Evision.Mat`.

    First translation vector.

  - **rvec2**: `Evision.Mat`.

    Second rotation vector.

  - **tvec2**: `Evision.Mat`.

    Second translation vector.

  ##### Return
  - **rvec3**: `Evision.Mat.t()`.

    Output rotation vector of the superposition.

  - **tvec3**: `Evision.Mat.t()`.

    Output translation vector of the superposition.

  - **dr3dr1**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to rvec1

  - **dr3dt1**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to tvec1

  - **dr3dr2**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to rvec2

  - **dr3dt2**: `Evision.Mat.t()`.

    Optional output derivative of rvec3 with regard to tvec2

  - **dt3dr1**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to rvec1

  - **dt3dt1**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to tvec1

  - **dt3dr2**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to rvec2

  - **dt3dt2**: `Evision.Mat.t()`.

    Optional output derivative of tvec3 with regard to tvec2

  The functions compute:
  \\f[\\begin{array}{l} \\texttt{rvec3} =  \\mathrm{rodrigues} ^{-1} \\left ( \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\mathrm{rodrigues} ( \\texttt{rvec1} ) \\right )  \\\\\\\\ \\texttt{tvec3} =  \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\texttt{tvec1} +  \\texttt{tvec2} \\end{array} ,\\f]
  where \\f$\\mathrm{rodrigues}\\f$ denotes a rotation vector to a rotation matrix transformation, and
  \\f$\\mathrm{rodrigues}^{-1}\\f$ denotes the inverse transformation. See #Rodrigues for details.
  Also, the functions can compute the derivatives of the output vectors with regards to the input
  vectors (see #matMulDeriv ). The functions are used inside #stereoCalibrate but can also be used in
  your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a
  function that contains a matrix multiplication.

  Python prototype (for reference only):
  ```python3
  composeRT(rvec1, tvec1, rvec2, tvec2[, rvec3[, tvec3[, dr3dr1[, dr3dt1[, dr3dr2[, dr3dt2[, dt3dr1[, dt3dt1[, dt3dr2[, dt3dt2]]]]]]]]]]) -> rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2
  ```
  """
  @spec composeRT(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def composeRT(rvec1, tvec1, rvec2, tvec2) when (is_struct(rvec1, Evision.Mat) or is_struct(rvec1, Nx.Tensor) or is_number(rvec1) or is_tuple(rvec1)) and (is_struct(tvec1, Evision.Mat) or is_struct(tvec1, Nx.Tensor) or is_number(tvec1) or is_tuple(tvec1)) and (is_struct(rvec2, Evision.Mat) or is_struct(rvec2, Nx.Tensor) or is_number(rvec2) or is_tuple(rvec2)) and (is_struct(tvec2, Evision.Mat) or is_struct(tvec2, Nx.Tensor) or is_number(tvec2) or is_tuple(tvec2))
  do
    positional = [
      rvec1: Evision.Internal.Structurise.from_struct(rvec1),
      tvec1: Evision.Internal.Structurise.from_struct(tvec1),
      rvec2: Evision.Internal.Structurise.from_struct(rvec2),
      tvec2: Evision.Internal.Structurise.from_struct(tvec2)
    ]
    :evision_nif.composeRT(positional)
    |> to_struct()
  end

  @doc """
  For points in an image of a stereo pair, computes the corresponding epilines in the other image.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input points. \\f$N \\times 1\\f$ or \\f$1 \\times N\\f$ matrix of type CV_32FC2 or
    vector\\<Point2f\\> .

  - **whichImage**: `integer()`.

    Index of the image (1 or 2) that contains the points .

  - **f**: `Evision.Mat`.

    Fundamental matrix that can be estimated using #findFundamentalMat or #stereoRectify .

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of the epipolar lines corresponding to the points in the other image.
    Each line \\f$ax + by + c=0\\f$ is encoded by 3 numbers \\f$(a, b, c)\\f$ .

  For every point in one of the two images of a stereo pair, the function finds the equation of the
  corresponding epipolar line in the other image.
  From the fundamental matrix definition (see #findFundamentalMat ), line \\f$l^{(2)}\\_i\\f$ in the second
  image for the point \\f$p^{(1)}\\_i\\f$ in the first image (when whichImage=1 ) is computed as:
  \\f[l^{(2)}\\_i = F p^{(1)}\\_i\\f]
  And vice versa, when whichImage=2, \\f$l^{(1)}\\_i\\f$ is computed from \\f$p^{(2)}\\_i\\f$ as:
  \\f[l^{(1)}\\_i = F^T p^{(2)}\\_i\\f]
  Line coefficients are defined up to a scale. They are normalized so that \\f$a\\_i^2+b\\_i^2=1\\f$ .

  Python prototype (for reference only):
  ```python3
  computeCorrespondEpilines(points, whichImage, F[, lines]) -> lines
  ```
  """
  @spec computeCorrespondEpilines(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def computeCorrespondEpilines(points, whichImage, f, opts) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and is_integer(whichImage) and (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points),
      whichImage: Evision.Internal.Structurise.from_struct(whichImage),
      f: Evision.Internal.Structurise.from_struct(f)
    ]
    :evision_nif.computeCorrespondEpilines(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  For points in an image of a stereo pair, computes the corresponding epilines in the other image.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input points. \\f$N \\times 1\\f$ or \\f$1 \\times N\\f$ matrix of type CV_32FC2 or
    vector\\<Point2f\\> .

  - **whichImage**: `integer()`.

    Index of the image (1 or 2) that contains the points .

  - **f**: `Evision.Mat`.

    Fundamental matrix that can be estimated using #findFundamentalMat or #stereoRectify .

  ##### Return
  - **lines**: `Evision.Mat.t()`.

    Output vector of the epipolar lines corresponding to the points in the other image.
    Each line \\f$ax + by + c=0\\f$ is encoded by 3 numbers \\f$(a, b, c)\\f$ .

  For every point in one of the two images of a stereo pair, the function finds the equation of the
  corresponding epipolar line in the other image.
  From the fundamental matrix definition (see #findFundamentalMat ), line \\f$l^{(2)}\\_i\\f$ in the second
  image for the point \\f$p^{(1)}\\_i\\f$ in the first image (when whichImage=1 ) is computed as:
  \\f[l^{(2)}\\_i = F p^{(1)}\\_i\\f]
  And vice versa, when whichImage=2, \\f$l^{(1)}\\_i\\f$ is computed from \\f$p^{(2)}\\_i\\f$ as:
  \\f[l^{(1)}\\_i = F^T p^{(2)}\\_i\\f]
  Line coefficients are defined up to a scale. They are normalized so that \\f$a\\_i^2+b\\_i^2=1\\f$ .

  Python prototype (for reference only):
  ```python3
  computeCorrespondEpilines(points, whichImage, F[, lines]) -> lines
  ```
  """
  @spec computeCorrespondEpilines(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def computeCorrespondEpilines(points, whichImage, f) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and is_integer(whichImage) and (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points),
      whichImage: Evision.Internal.Structurise.from_struct(whichImage),
      f: Evision.Internal.Structurise.from_struct(f)
    ]
    :evision_nif.computeCorrespondEpilines(positional)
    |> to_struct()
  end

  @doc """
  Computes the Enhanced Correlation Coefficient value between two images @cite EP08 .

  ##### Positional Arguments
  - **templateImage**: `Evision.Mat`.

    single-channel template image; CV_8U or CV_32F array.

  - **inputImage**: `Evision.Mat`.

    single-channel input image to be warped to provide an image similar to
    templateImage, same type as templateImage.

  ##### Keyword Arguments
  - **inputMask**: `Evision.Mat`.

    An optional mask to indicate valid values of inputImage.

  ##### Return
  - **retval**: `double`

  @sa
  findTransformECC

  Python prototype (for reference only):
  ```python3
  computeECC(templateImage, inputImage[, inputMask]) -> retval
  ```
  """
  @spec computeECC(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:inputMask, term()}] | nil) :: number() | {:error, String.t()}
  def computeECC(templateImage, inputImage, opts) when (is_struct(templateImage, Evision.Mat) or is_struct(templateImage, Nx.Tensor) or is_number(templateImage) or is_tuple(templateImage)) and (is_struct(inputImage, Evision.Mat) or is_struct(inputImage, Nx.Tensor) or is_number(inputImage) or is_tuple(inputImage)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:inputMask])
    positional = [
      templateImage: Evision.Internal.Structurise.from_struct(templateImage),
      inputImage: Evision.Internal.Structurise.from_struct(inputImage)
    ]
    :evision_nif.computeECC(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes the Enhanced Correlation Coefficient value between two images @cite EP08 .

  ##### Positional Arguments
  - **templateImage**: `Evision.Mat`.

    single-channel template image; CV_8U or CV_32F array.

  - **inputImage**: `Evision.Mat`.

    single-channel input image to be warped to provide an image similar to
    templateImage, same type as templateImage.

  ##### Keyword Arguments
  - **inputMask**: `Evision.Mat`.

    An optional mask to indicate valid values of inputImage.

  ##### Return
  - **retval**: `double`

  @sa
  findTransformECC

  Python prototype (for reference only):
  ```python3
  computeECC(templateImage, inputImage[, inputMask]) -> retval
  ```
  """
  @spec computeECC(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def computeECC(templateImage, inputImage) when (is_struct(templateImage, Evision.Mat) or is_struct(templateImage, Nx.Tensor) or is_number(templateImage) or is_tuple(templateImage)) and (is_struct(inputImage, Evision.Mat) or is_struct(inputImage, Nx.Tensor) or is_number(inputImage) or is_tuple(inputImage))
  do
    positional = [
      templateImage: Evision.Internal.Structurise.from_struct(templateImage),
      inputImage: Evision.Internal.Structurise.from_struct(inputImage)
    ]
    :evision_nif.computeECC(positional)
    |> to_struct()
  end

  @doc """
  connectedComponents

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  ##### Keyword Arguments
  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  connectedComponents(image[, labels[, connectivity[, ltype]]]) -> retval, labels
  ```
  """
  @spec connectedComponents(Evision.Mat.maybe_mat_in(), [{:connectivity, term()} | {:ltype, term()}] | nil) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponents(image, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:connectivity, :ltype])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image)
    ]
    :evision_nif.connectedComponents(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  connectedComponents

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  ##### Keyword Arguments
  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  connectedComponents(image[, labels[, connectivity[, ltype]]]) -> retval, labels
  ```
  """
  @spec connectedComponents(Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponents(image) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image)
    ]
    :evision_nif.connectedComponents(positional)
    |> to_struct()
  end

  @doc """
  computes the connected components labeled image of boolean image

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  - **ccltype**: `integer()`.

    connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes).

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
  represents the background label. ltype specifies the output label image type, an important
  consideration based on the total number of labels or alternatively the total number of pixels in
  the source image. ccltype specifies the connected components labeling algorithm to use, currently
  Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms
  are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces
  a row major ordering of labels while Spaghetti and BBDT do not.
  This function uses parallel version of the algorithms if at least one allowed
  parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.

  Python prototype (for reference only):
  ```python3
  connectedComponentsWithAlgorithm(image, connectivity, ltype, ccltype[, labels]) -> retval, labels
  ```
  """
  @spec connectedComponentsWithAlgorithm(Evision.Mat.maybe_mat_in(), integer(), integer(), integer(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponentsWithAlgorithm(image, connectivity, ltype, ccltype, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(connectivity) and is_integer(ltype) and is_integer(ccltype) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      connectivity: Evision.Internal.Structurise.from_struct(connectivity),
      ltype: Evision.Internal.Structurise.from_struct(ltype),
      ccltype: Evision.Internal.Structurise.from_struct(ccltype)
    ]
    :evision_nif.connectedComponentsWithAlgorithm(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  computes the connected components labeled image of boolean image

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  - **ccltype**: `integer()`.

    connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes).

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
  represents the background label. ltype specifies the output label image type, an important
  consideration based on the total number of labels or alternatively the total number of pixels in
  the source image. ccltype specifies the connected components labeling algorithm to use, currently
  Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms
  are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces
  a row major ordering of labels while Spaghetti and BBDT do not.
  This function uses parallel version of the algorithms if at least one allowed
  parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.

  Python prototype (for reference only):
  ```python3
  connectedComponentsWithAlgorithm(image, connectivity, ltype, ccltype[, labels]) -> retval, labels
  ```
  """
  @spec connectedComponentsWithAlgorithm(Evision.Mat.maybe_mat_in(), integer(), integer(), integer()) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponentsWithAlgorithm(image, connectivity, ltype, ccltype) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(connectivity) and is_integer(ltype) and is_integer(ccltype)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      connectivity: Evision.Internal.Structurise.from_struct(connectivity),
      ltype: Evision.Internal.Structurise.from_struct(ltype),
      ccltype: Evision.Internal.Structurise.from_struct(ccltype)
    ]
    :evision_nif.connectedComponentsWithAlgorithm(positional)
    |> to_struct()
  end

  @doc """
  connectedComponentsWithStats

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  ##### Keyword Arguments
  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  - **stats**: `Evision.Mat.t()`.

    statistics output for each label, including the background label.
    Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
    #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.

  - **centroids**: `Evision.Mat.t()`.

    centroid output for each label, including the background label. Centroids are
    accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  connectedComponentsWithStats(image[, labels[, stats[, centroids[, connectivity[, ltype]]]]]) -> retval, labels, stats, centroids
  ```
  """
  @spec connectedComponentsWithStats(Evision.Mat.maybe_mat_in(), [{:connectivity, term()} | {:ltype, term()}] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponentsWithStats(image, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:connectivity, :ltype])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image)
    ]
    :evision_nif.connectedComponentsWithStats(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  connectedComponentsWithStats

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  ##### Keyword Arguments
  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  - **stats**: `Evision.Mat.t()`.

    statistics output for each label, including the background label.
    Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
    #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.

  - **centroids**: `Evision.Mat.t()`.

    centroid output for each label, including the background label. Centroids are
    accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  connectedComponentsWithStats(image[, labels[, stats[, centroids[, connectivity[, ltype]]]]]) -> retval, labels, stats, centroids
  ```
  """
  @spec connectedComponentsWithStats(Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponentsWithStats(image) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image)
    ]
    :evision_nif.connectedComponentsWithStats(positional)
    |> to_struct()
  end

  @doc """
  computes the connected components labeled image of boolean image and also produces a statistics output for each label

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  - **ccltype**: `integer()`.

    connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes).

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  - **stats**: `Evision.Mat.t()`.

    statistics output for each label, including the background label.
    Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
    #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.

  - **centroids**: `Evision.Mat.t()`.

    centroid output for each label, including the background label. Centroids are
    accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.

  image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
  represents the background label. ltype specifies the output label image type, an important
  consideration based on the total number of labels or alternatively the total number of pixels in
  the source image. ccltype specifies the connected components labeling algorithm to use, currently
  Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms
  are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces
  a row major ordering of labels while Spaghetti and BBDT do not.
  This function uses parallel version of the algorithms (statistics included) if at least one allowed
  parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.

  Python prototype (for reference only):
  ```python3
  connectedComponentsWithStatsWithAlgorithm(image, connectivity, ltype, ccltype[, labels[, stats[, centroids]]]) -> retval, labels, stats, centroids
  ```
  """
  @spec connectedComponentsWithStatsWithAlgorithm(Evision.Mat.maybe_mat_in(), integer(), integer(), integer(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponentsWithStatsWithAlgorithm(image, connectivity, ltype, ccltype, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(connectivity) and is_integer(ltype) and is_integer(ccltype) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      connectivity: Evision.Internal.Structurise.from_struct(connectivity),
      ltype: Evision.Internal.Structurise.from_struct(ltype),
      ccltype: Evision.Internal.Structurise.from_struct(ccltype)
    ]
    :evision_nif.connectedComponentsWithStatsWithAlgorithm(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  computes the connected components labeled image of boolean image and also produces a statistics output for each label

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    the 8-bit single-channel image to be labeled

  - **connectivity**: `integer()`.

    8 or 4 for 8-way or 4-way connectivity respectively

  - **ltype**: `integer()`.

    output image label type. Currently CV_32S and CV_16U are supported.

  - **ccltype**: `integer()`.

    connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes).

  ##### Return
  - **retval**: `integer()`
  - **labels**: `Evision.Mat.t()`.

    destination labeled image

  - **stats**: `Evision.Mat.t()`.

    statistics output for each label, including the background label.
    Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
    #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.

  - **centroids**: `Evision.Mat.t()`.

    centroid output for each label, including the background label. Centroids are
    accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.

  image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
  represents the background label. ltype specifies the output label image type, an important
  consideration based on the total number of labels or alternatively the total number of pixels in
  the source image. ccltype specifies the connected components labeling algorithm to use, currently
  Bolelli (Spaghetti) @cite Bolelli2019, Grana (BBDT) @cite Grana2010 and Wu's (SAUF) @cite Wu2009 algorithms
  are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces
  a row major ordering of labels while Spaghetti and BBDT do not.
  This function uses parallel version of the algorithms (statistics included) if at least one allowed
  parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.

  Python prototype (for reference only):
  ```python3
  connectedComponentsWithStatsWithAlgorithm(image, connectivity, ltype, ccltype[, labels[, stats[, centroids]]]) -> retval, labels, stats, centroids
  ```
  """
  @spec connectedComponentsWithStatsWithAlgorithm(Evision.Mat.maybe_mat_in(), integer(), integer(), integer()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def connectedComponentsWithStatsWithAlgorithm(image, connectivity, ltype, ccltype) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(connectivity) and is_integer(ltype) and is_integer(ccltype)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      connectivity: Evision.Internal.Structurise.from_struct(connectivity),
      ltype: Evision.Internal.Structurise.from_struct(ltype),
      ccltype: Evision.Internal.Structurise.from_struct(ccltype)
    ]
    :evision_nif.connectedComponentsWithStatsWithAlgorithm(positional)
    |> to_struct()
  end

  @doc """
  Calculates a contour area.

  ##### Positional Arguments
  - **contour**: `Evision.Mat`.

    Input vector of 2D points (contour vertices), stored in std::vector or Mat.

  ##### Keyword Arguments
  - **oriented**: `bool`.

    Oriented area flag. If it is true, the function returns a signed area value,
    depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
    determine orientation of a contour by taking the sign of an area. By default, the parameter is
    false, which means that the absolute value is returned.

  ##### Return
  - **retval**: `double`

  The function computes a contour area. Similarly to moments , the area is computed using the Green
  formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using
  #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong
  results for contours with self-intersections.
  Example:
  ```
  vector<Point> contour;
  contour.push_back(Point2f(0, 0));
  contour.push_back(Point2f(10, 0));
  contour.push_back(Point2f(10, 10));
  contour.push_back(Point2f(5, 4));
  double area0 = contourArea(contour);
  vector<Point> approx;
  approxPolyDP(contour, approx, 5, true);
  double area1 = contourArea(approx);
  cout << "area0 =" << area0 << endl <<
  "area1 =" << area1 << endl <<
  "approx poly vertices" << approx.size() << endl;
  ```

  Python prototype (for reference only):
  ```python3
  contourArea(contour[, oriented]) -> retval
  ```
  """
  @spec contourArea(Evision.Mat.maybe_mat_in(), [{:oriented, term()}] | nil) :: number() | {:error, String.t()}
  def contourArea(contour, opts) when (is_struct(contour, Evision.Mat) or is_struct(contour, Nx.Tensor) or is_number(contour) or is_tuple(contour)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:oriented])
    positional = [
      contour: Evision.Internal.Structurise.from_struct(contour)
    ]
    :evision_nif.contourArea(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates a contour area.

  ##### Positional Arguments
  - **contour**: `Evision.Mat`.

    Input vector of 2D points (contour vertices), stored in std::vector or Mat.

  ##### Keyword Arguments
  - **oriented**: `bool`.

    Oriented area flag. If it is true, the function returns a signed area value,
    depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
    determine orientation of a contour by taking the sign of an area. By default, the parameter is
    false, which means that the absolute value is returned.

  ##### Return
  - **retval**: `double`

  The function computes a contour area. Similarly to moments , the area is computed using the Green
  formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using
  #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong
  results for contours with self-intersections.
  Example:
  ```
  vector<Point> contour;
  contour.push_back(Point2f(0, 0));
  contour.push_back(Point2f(10, 0));
  contour.push_back(Point2f(10, 10));
  contour.push_back(Point2f(5, 4));
  double area0 = contourArea(contour);
  vector<Point> approx;
  approxPolyDP(contour, approx, 5, true);
  double area1 = contourArea(approx);
  cout << "area0 =" << area0 << endl <<
  "area1 =" << area1 << endl <<
  "approx poly vertices" << approx.size() << endl;
  ```

  Python prototype (for reference only):
  ```python3
  contourArea(contour[, oriented]) -> retval
  ```
  """
  @spec contourArea(Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def contourArea(contour) when (is_struct(contour, Evision.Mat) or is_struct(contour, Nx.Tensor) or is_number(contour) or is_tuple(contour))
  do
    positional = [
      contour: Evision.Internal.Structurise.from_struct(contour)
    ]
    :evision_nif.contourArea(positional)
    |> to_struct()
  end

  @doc """
  Converts an array to half precision floating number.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array.

  This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data.
  There are two use modes (src -> dst): CV_32F -> CV_16S and CV_16S -> CV_32F. The input array has to have type of CV_32F or
  CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error.
  The format of half precision floating point is defined in IEEE 754-2008.

  @deprecated Use Mat::convertTo with CV_16F instead.

  Python prototype (for reference only):
  ```python3
  convertFp16(src[, dst]) -> dst
  ```
  """
  @spec convertFp16(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def convertFp16(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertFp16(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts an array to half precision floating number.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array.

  This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data.
  There are two use modes (src -> dst): CV_32F -> CV_16S and CV_16S -> CV_32F. The input array has to have type of CV_32F or
  CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error.
  The format of half precision floating point is defined in IEEE 754-2008.

  @deprecated Use Mat::convertTo with CV_16F instead.

  Python prototype (for reference only):
  ```python3
  convertFp16(src[, dst]) -> dst
  ```
  """
  @spec convertFp16(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def convertFp16(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertFp16(positional)
    |> to_struct()
  end

  @doc """
  Converts image transformation maps from one representation to another.

  ##### Positional Arguments
  - **map1**: `Evision.Mat`.

    The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .

  - **map2**: `Evision.Mat`.

    The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
    respectively.

  - **dstmap1type**: `integer()`.

    Type of the first output map that should be CV_16SC2, CV_32FC1, or
    CV_32FC2 .

  ##### Keyword Arguments
  - **nninterpolation**: `bool`.

    Flag indicating whether the fixed-point maps are used for the
    nearest-neighbor or for a more complex interpolation.

  ##### Return
  - **dstmap1**: `Evision.Mat.t()`.

    The first output map that has the type dstmap1type and the same size as src .

  - **dstmap2**: `Evision.Mat.t()`.

    The second output map.

  The function converts a pair of maps for remap from one representation to another. The following
  options ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ (dstmap1.type(), dstmap2.type()) ) are
  supported:
  - \\f$\\texttt{(CV\\_32FC1, CV\\_32FC1)} \\rightarrow \\texttt{(CV\\_16SC2, CV\\_16UC1)}\\f$. This is the
    most frequently used conversion operation, in which the original floating-point maps (see #remap)
    are converted to a more compact and much faster fixed-point representation. The first output array
    contains the rounded coordinates and the second array (created only when nninterpolation=false )
    contains indices in the interpolation tables.

  - \\f$\\texttt{(CV\\_32FC2)} \\rightarrow \\texttt{(CV\\_16SC2, CV\\_16UC1)}\\f$. The same as above but
    the original maps are stored in one 2-channel matrix.

  - Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
    as the originals.

  @sa  remap, undistort, initUndistortRectifyMap

  Python prototype (for reference only):
  ```python3
  convertMaps(map1, map2, dstmap1type[, dstmap1[, dstmap2[, nninterpolation]]]) -> dstmap1, dstmap2
  ```
  """
  @spec convertMaps(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:nninterpolation, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def convertMaps(map1, map2, dstmap1type, opts) when (is_struct(map1, Evision.Mat) or is_struct(map1, Nx.Tensor) or is_number(map1) or is_tuple(map1)) and (is_struct(map2, Evision.Mat) or is_struct(map2, Nx.Tensor) or is_number(map2) or is_tuple(map2)) and is_integer(dstmap1type) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:nninterpolation])
    positional = [
      map1: Evision.Internal.Structurise.from_struct(map1),
      map2: Evision.Internal.Structurise.from_struct(map2),
      dstmap1type: Evision.Internal.Structurise.from_struct(dstmap1type)
    ]
    :evision_nif.convertMaps(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts image transformation maps from one representation to another.

  ##### Positional Arguments
  - **map1**: `Evision.Mat`.

    The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .

  - **map2**: `Evision.Mat`.

    The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
    respectively.

  - **dstmap1type**: `integer()`.

    Type of the first output map that should be CV_16SC2, CV_32FC1, or
    CV_32FC2 .

  ##### Keyword Arguments
  - **nninterpolation**: `bool`.

    Flag indicating whether the fixed-point maps are used for the
    nearest-neighbor or for a more complex interpolation.

  ##### Return
  - **dstmap1**: `Evision.Mat.t()`.

    The first output map that has the type dstmap1type and the same size as src .

  - **dstmap2**: `Evision.Mat.t()`.

    The second output map.

  The function converts a pair of maps for remap from one representation to another. The following
  options ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ (dstmap1.type(), dstmap2.type()) ) are
  supported:
  - \\f$\\texttt{(CV\\_32FC1, CV\\_32FC1)} \\rightarrow \\texttt{(CV\\_16SC2, CV\\_16UC1)}\\f$. This is the
    most frequently used conversion operation, in which the original floating-point maps (see #remap)
    are converted to a more compact and much faster fixed-point representation. The first output array
    contains the rounded coordinates and the second array (created only when nninterpolation=false )
    contains indices in the interpolation tables.

  - \\f$\\texttt{(CV\\_32FC2)} \\rightarrow \\texttt{(CV\\_16SC2, CV\\_16UC1)}\\f$. The same as above but
    the original maps are stored in one 2-channel matrix.

  - Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
    as the originals.

  @sa  remap, undistort, initUndistortRectifyMap

  Python prototype (for reference only):
  ```python3
  convertMaps(map1, map2, dstmap1type[, dstmap1[, dstmap2[, nninterpolation]]]) -> dstmap1, dstmap2
  ```
  """
  @spec convertMaps(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def convertMaps(map1, map2, dstmap1type) when (is_struct(map1, Evision.Mat) or is_struct(map1, Nx.Tensor) or is_number(map1) or is_tuple(map1)) and (is_struct(map2, Evision.Mat) or is_struct(map2, Nx.Tensor) or is_number(map2) or is_tuple(map2)) and is_integer(dstmap1type)
  do
    positional = [
      map1: Evision.Internal.Structurise.from_struct(map1),
      map2: Evision.Internal.Structurise.from_struct(map2),
      dstmap1type: Evision.Internal.Structurise.from_struct(dstmap1type)
    ]
    :evision_nif.convertMaps(positional)
    |> to_struct()
  end

  @doc """
  Converts points from homogeneous to Euclidean space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input vector of N-dimensional points.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output vector of N-1-dimensional points.

  The function converts points homogeneous to Euclidean space using perspective projection. That is,
  each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the
  output point coordinates will be (0,0,0,...).

  Python prototype (for reference only):
  ```python3
  convertPointsFromHomogeneous(src[, dst]) -> dst
  ```
  """
  @spec convertPointsFromHomogeneous(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def convertPointsFromHomogeneous(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertPointsFromHomogeneous(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts points from homogeneous to Euclidean space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input vector of N-dimensional points.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output vector of N-1-dimensional points.

  The function converts points homogeneous to Euclidean space using perspective projection. That is,
  each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the
  output point coordinates will be (0,0,0,...).

  Python prototype (for reference only):
  ```python3
  convertPointsFromHomogeneous(src[, dst]) -> dst
  ```
  """
  @spec convertPointsFromHomogeneous(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def convertPointsFromHomogeneous(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertPointsFromHomogeneous(positional)
    |> to_struct()
  end

  @doc """
  Converts points from Euclidean to homogeneous space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input vector of N-dimensional points.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output vector of N+1-dimensional points.

  The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of
  point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1).

  Python prototype (for reference only):
  ```python3
  convertPointsToHomogeneous(src[, dst]) -> dst
  ```
  """
  @spec convertPointsToHomogeneous(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def convertPointsToHomogeneous(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertPointsToHomogeneous(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts points from Euclidean to homogeneous space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input vector of N-dimensional points.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output vector of N+1-dimensional points.

  The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of
  point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1).

  Python prototype (for reference only):
  ```python3
  convertPointsToHomogeneous(src[, dst]) -> dst
  ```
  """
  @spec convertPointsToHomogeneous(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def convertPointsToHomogeneous(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertPointsToHomogeneous(positional)
    |> to_struct()
  end

  @doc """
  Scales, calculates absolute values, and converts the result to 8-bit.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Keyword Arguments
  - **alpha**: `double`.

    optional scale factor.

  - **beta**: `double`.

    optional delta added to the scaled values.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array.

  On each element of the input array, the function convertScaleAbs
  performs three operations sequentially: scaling, taking an absolute
  value, conversion to an unsigned 8-bit type:
  \\f[\\texttt{dst} (I)= \\texttt{saturate\\\\_cast<uchar>} (| \\texttt{src} (I)\\* \\texttt{alpha} +  \\texttt{beta} |)\\f]
  In case of multi-channel arrays, the function processes each channel
  independently. When the output is not 8-bit, the operation can be
  emulated by calling the Mat::convertTo method (or by using matrix
  expressions) and then by calculating an absolute value of the result.
  For example:
  ```cpp
  Mat_<float> A(30,30);
  randu(A, Scalar(-100), Scalar(100));
  Mat_<float> B = A*5 + 3;
  B = abs(B);
  // Mat_<float> B = abs(A*5+3) will also do the job,
  // but it will allocate a temporary matrix
  ```
  @sa  Mat::convertTo, cv::abs(const Mat&)

  Python prototype (for reference only):
  ```python3
  convertScaleAbs(src[, dst[, alpha[, beta]]]) -> dst
  ```
  """
  @spec convertScaleAbs(Evision.Mat.maybe_mat_in(), [{:alpha, term()} | {:beta, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def convertScaleAbs(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:alpha, :beta])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertScaleAbs(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Scales, calculates absolute values, and converts the result to 8-bit.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Keyword Arguments
  - **alpha**: `double`.

    optional scale factor.

  - **beta**: `double`.

    optional delta added to the scaled values.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array.

  On each element of the input array, the function convertScaleAbs
  performs three operations sequentially: scaling, taking an absolute
  value, conversion to an unsigned 8-bit type:
  \\f[\\texttt{dst} (I)= \\texttt{saturate\\\\_cast<uchar>} (| \\texttt{src} (I)\\* \\texttt{alpha} +  \\texttt{beta} |)\\f]
  In case of multi-channel arrays, the function processes each channel
  independently. When the output is not 8-bit, the operation can be
  emulated by calling the Mat::convertTo method (or by using matrix
  expressions) and then by calculating an absolute value of the result.
  For example:
  ```cpp
  Mat_<float> A(30,30);
  randu(A, Scalar(-100), Scalar(100));
  Mat_<float> B = A*5 + 3;
  B = abs(B);
  // Mat_<float> B = abs(A*5+3) will also do the job,
  // but it will allocate a temporary matrix
  ```
  @sa  Mat::convertTo, cv::abs(const Mat&)

  Python prototype (for reference only):
  ```python3
  convertScaleAbs(src[, dst[, alpha[, beta]]]) -> dst
  ```
  """
  @spec convertScaleAbs(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def convertScaleAbs(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.convertScaleAbs(positional)
    |> to_struct()
  end

  @doc """
  Finds the convex hull of a point set.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input 2D point set, stored in std::vector or Mat.

  ##### Keyword Arguments
  - **clockwise**: `bool`.

    Orientation flag. If it is true, the output convex hull is oriented clockwise.
    Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
    to the right, and its Y axis pointing upwards.

  - **returnPoints**: `bool`.

    Operation flag. In case of a matrix, when the flag is true, the function
    returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
    output array is std::vector, the flag is ignored, and the output depends on the type of the
    vector: std::vector\\<int\\> implies returnPoints=false, std::vector\\<Point\\> implies
    returnPoints=true.

  ##### Return
  - **hull**: `Evision.Mat.t()`.

    Output convex hull. It is either an integer vector of indices or vector of points. In
    the first case, the hull elements are 0-based indices of the convex hull points in the original
    array (since the set of convex hull points is a subset of the original point set). In the second
    case, hull elements are the convex hull points themselves.

  The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82
  that has *O(N logN)* complexity in the current implementation.

  **Note**: `points` and `hull` should be different arrays, inplace processing isn't supported.
  Check @ref tutorial_hull "the corresponding tutorial" for more details.
  useful links:
  https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/

  Python prototype (for reference only):
  ```python3
  convexHull(points[, hull[, clockwise[, returnPoints]]]) -> hull
  ```
  """
  @spec convexHull(Evision.Mat.maybe_mat_in(), [{:clockwise, term()} | {:returnPoints, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def convexHull(points, opts) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:clockwise, :returnPoints])
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.convexHull(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the convex hull of a point set.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input 2D point set, stored in std::vector or Mat.

  ##### Keyword Arguments
  - **clockwise**: `bool`.

    Orientation flag. If it is true, the output convex hull is oriented clockwise.
    Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
    to the right, and its Y axis pointing upwards.

  - **returnPoints**: `bool`.

    Operation flag. In case of a matrix, when the flag is true, the function
    returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
    output array is std::vector, the flag is ignored, and the output depends on the type of the
    vector: std::vector\\<int\\> implies returnPoints=false, std::vector\\<Point\\> implies
    returnPoints=true.

  ##### Return
  - **hull**: `Evision.Mat.t()`.

    Output convex hull. It is either an integer vector of indices or vector of points. In
    the first case, the hull elements are 0-based indices of the convex hull points in the original
    array (since the set of convex hull points is a subset of the original point set). In the second
    case, hull elements are the convex hull points themselves.

  The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82
  that has *O(N logN)* complexity in the current implementation.

  **Note**: `points` and `hull` should be different arrays, inplace processing isn't supported.
  Check @ref tutorial_hull "the corresponding tutorial" for more details.
  useful links:
  https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/

  Python prototype (for reference only):
  ```python3
  convexHull(points[, hull[, clockwise[, returnPoints]]]) -> hull
  ```
  """
  @spec convexHull(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def convexHull(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.convexHull(positional)
    |> to_struct()
  end

  @doc """
  Finds the convexity defects of a contour.

  ##### Positional Arguments
  - **contour**: `Evision.Mat`.

    Input contour.

  - **convexhull**: `Evision.Mat`.

    Convex hull obtained using convexHull that should contain indices of the contour
    points that make the hull.

  ##### Return
  - **convexityDefects**: `Evision.Mat.t()`.

    The output vector of convexity defects. In C++ and the new Python/Java
    interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i):
    (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices
    in the original contour of the convexity defect beginning, end and the farthest point, and
    fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the
    farthest contour point and the hull. That is, to get the floating-point value of the depth will be
    fixpt_depth/256.0.

  The figure below displays convexity defects of a hand contour:
  ![image](pics/defects.png)

  Python prototype (for reference only):
  ```python3
  convexityDefects(contour, convexhull[, convexityDefects]) -> convexityDefects
  ```
  """
  @spec convexityDefects(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def convexityDefects(contour, convexhull, opts) when (is_struct(contour, Evision.Mat) or is_struct(contour, Nx.Tensor) or is_number(contour) or is_tuple(contour)) and (is_struct(convexhull, Evision.Mat) or is_struct(convexhull, Nx.Tensor) or is_number(convexhull) or is_tuple(convexhull)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      contour: Evision.Internal.Structurise.from_struct(contour),
      convexhull: Evision.Internal.Structurise.from_struct(convexhull)
    ]
    :evision_nif.convexityDefects(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the convexity defects of a contour.

  ##### Positional Arguments
  - **contour**: `Evision.Mat`.

    Input contour.

  - **convexhull**: `Evision.Mat`.

    Convex hull obtained using convexHull that should contain indices of the contour
    points that make the hull.

  ##### Return
  - **convexityDefects**: `Evision.Mat.t()`.

    The output vector of convexity defects. In C++ and the new Python/Java
    interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i):
    (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices
    in the original contour of the convexity defect beginning, end and the farthest point, and
    fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the
    farthest contour point and the hull. That is, to get the floating-point value of the depth will be
    fixpt_depth/256.0.

  The figure below displays convexity defects of a hand contour:
  ![image](pics/defects.png)

  Python prototype (for reference only):
  ```python3
  convexityDefects(contour, convexhull[, convexityDefects]) -> convexityDefects
  ```
  """
  @spec convexityDefects(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def convexityDefects(contour, convexhull) when (is_struct(contour, Evision.Mat) or is_struct(contour, Nx.Tensor) or is_number(contour) or is_tuple(contour)) and (is_struct(convexhull, Evision.Mat) or is_struct(convexhull, Nx.Tensor) or is_number(convexhull) or is_tuple(convexhull))
  do
    positional = [
      contour: Evision.Internal.Structurise.from_struct(contour),
      convexhull: Evision.Internal.Structurise.from_struct(convexhull)
    ]
    :evision_nif.convexityDefects(positional)
    |> to_struct()
  end

  @doc """
  Forms a border around an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **top**: `integer()`.

    the top pixels

  - **bottom**: `integer()`.

    the bottom pixels

  - **left**: `integer()`.

    the left pixels

  - **right**: `integer()`.

    Parameter specifying how many pixels in each direction from the source image rectangle
    to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
    to be built.

  - **borderType**: `integer()`.

    Border type. See borderInterpolate for details.

  ##### Keyword Arguments
  - **value**: `Evision.scalar()`.

    Border value if borderType==BORDER_CONSTANT .

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same type as src and the size Size(src.cols+left+right,
    src.rows+top+bottom) .

  The function copies the source image into the middle of the destination image. The areas to the
  left, to the right, above and below the copied source image will be filled with extrapolated
  pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
  what other more complex functions, including your own, may do to simplify image boundary handling.
  The function supports the mode when src is already in the middle of dst . In this case, the
  function does not copy src itself but simply constructs the border, for example:
  ```cpp
  // let border be the same in all directions
  int border=2;
  // constructs a larger image to fit both the image and the border
  Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
  // select the middle part of it w/o copying data
  Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
  // convert image from RGB to grayscale
  cvtColor(rgb, gray, COLOR_RGB2GRAY);
  // form a border in-place
  copyMakeBorder(gray, gray_buf, border, border,
  border, border, BORDER_REPLICATE);
  // now do some custom filtering ...
  ...
  ```
  **Note**: When the source image is a part (ROI) of a bigger image, the function will try to use the
  pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
  if src was not a ROI, use borderType | #BORDER_ISOLATED.

  @sa  borderInterpolate

  Python prototype (for reference only):
  ```python3
  copyMakeBorder(src, top, bottom, left, right, borderType[, dst[, value]]) -> dst
  ```
  """
  @spec copyMakeBorder(Evision.Mat.maybe_mat_in(), integer(), integer(), integer(), integer(), integer(), [{:value, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def copyMakeBorder(src, top, bottom, left, right, borderType, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(top) and is_integer(bottom) and is_integer(left) and is_integer(right) and is_integer(borderType) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:value])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      top: Evision.Internal.Structurise.from_struct(top),
      bottom: Evision.Internal.Structurise.from_struct(bottom),
      left: Evision.Internal.Structurise.from_struct(left),
      right: Evision.Internal.Structurise.from_struct(right),
      borderType: Evision.Internal.Structurise.from_struct(borderType)
    ]
    :evision_nif.copyMakeBorder(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Forms a border around an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **top**: `integer()`.

    the top pixels

  - **bottom**: `integer()`.

    the bottom pixels

  - **left**: `integer()`.

    the left pixels

  - **right**: `integer()`.

    Parameter specifying how many pixels in each direction from the source image rectangle
    to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
    to be built.

  - **borderType**: `integer()`.

    Border type. See borderInterpolate for details.

  ##### Keyword Arguments
  - **value**: `Evision.scalar()`.

    Border value if borderType==BORDER_CONSTANT .

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same type as src and the size Size(src.cols+left+right,
    src.rows+top+bottom) .

  The function copies the source image into the middle of the destination image. The areas to the
  left, to the right, above and below the copied source image will be filled with extrapolated
  pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
  what other more complex functions, including your own, may do to simplify image boundary handling.
  The function supports the mode when src is already in the middle of dst . In this case, the
  function does not copy src itself but simply constructs the border, for example:
  ```cpp
  // let border be the same in all directions
  int border=2;
  // constructs a larger image to fit both the image and the border
  Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
  // select the middle part of it w/o copying data
  Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
  // convert image from RGB to grayscale
  cvtColor(rgb, gray, COLOR_RGB2GRAY);
  // form a border in-place
  copyMakeBorder(gray, gray_buf, border, border,
  border, border, BORDER_REPLICATE);
  // now do some custom filtering ...
  ...
  ```
  **Note**: When the source image is a part (ROI) of a bigger image, the function will try to use the
  pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
  if src was not a ROI, use borderType | #BORDER_ISOLATED.

  @sa  borderInterpolate

  Python prototype (for reference only):
  ```python3
  copyMakeBorder(src, top, bottom, left, right, borderType[, dst[, value]]) -> dst
  ```
  """
  @spec copyMakeBorder(Evision.Mat.maybe_mat_in(), integer(), integer(), integer(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def copyMakeBorder(src, top, bottom, left, right, borderType) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(top) and is_integer(bottom) and is_integer(left) and is_integer(right) and is_integer(borderType)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      top: Evision.Internal.Structurise.from_struct(top),
      bottom: Evision.Internal.Structurise.from_struct(bottom),
      left: Evision.Internal.Structurise.from_struct(left),
      right: Evision.Internal.Structurise.from_struct(right),
      borderType: Evision.Internal.Structurise.from_struct(borderType)
    ]
    :evision_nif.copyMakeBorder(positional)
    |> to_struct()
  end

  @doc """
  This is an overloaded member function, provided for convenience (python)
  Copies the matrix to another one.
  When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    source matrix.

  - **mask**: `Evision.Mat`.

    Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix
    elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination matrix. If it does not have a proper size or type before the operation, it is
    reallocated.

  Python prototype (for reference only):
  ```python3
  copyTo(src, mask[, dst]) -> dst
  ```
  """
  @spec copyTo(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def copyTo(src, mask, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.copyTo(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  This is an overloaded member function, provided for convenience (python)
  Copies the matrix to another one.
  When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    source matrix.

  - **mask**: `Evision.Mat`.

    Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix
    elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination matrix. If it does not have a proper size or type before the operation, it is
    reallocated.

  Python prototype (for reference only):
  ```python3
  copyTo(src, mask[, dst]) -> dst
  ```
  """
  @spec copyTo(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def copyTo(src, mask) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.copyTo(positional)
    |> to_struct()
  end

  @doc """
  Calculates eigenvalues and eigenvectors of image blocks for corner detection.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input single-channel 8-bit or floating-point image.

  - **blockSize**: `integer()`.

    Neighborhood size (see details below).

  - **ksize**: `integer()`.

    Aperture parameter for the Sobel operator.

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Image to store the results. It has the same size as src and the type CV_32FC(6) .

  For every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers a blockSize \\f$\\times\\f$ blockSize
  neighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of derivatives over the neighborhood as:
  \\f[M =  \\begin{bmatrix} \\sum \\_{S(p)}(dI/dx)^2 &  \\sum \\_{S(p)}dI/dx dI/dy  \\\\\\\\ \\sum \\_{S(p)}dI/dx dI/dy &  \\sum \\_{S(p)}(dI/dy)^2 \\end{bmatrix}\\f]
  where the derivatives are computed using the Sobel operator.
  After that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores them in the destination image as
  \\f$(\\lambda\\_1, \\lambda\\_2, x\\_1, y\\_1, x\\_2, y\\_2)\\f$ where
  - \\f$\\lambda\\_1, \\lambda\\_2\\f$ are the non-sorted eigenvalues of \\f$M\\f$
  - \\f$x\\_1, y\\_1\\f$ are the eigenvectors corresponding to \\f$\\lambda\\_1\\f$
  - \\f$x\\_2, y\\_2\\f$ are the eigenvectors corresponding to \\f$\\lambda\\_2\\f$

  The output of the function can be used for robust edge or corner detection.

  @sa  cornerMinEigenVal, cornerHarris, preCornerDetect

  Python prototype (for reference only):
  ```python3
  cornerEigenValsAndVecs(src, blockSize, ksize[, dst[, borderType]]) -> dst
  ```
  """
  @spec cornerEigenValsAndVecs(Evision.Mat.maybe_mat_in(), integer(), integer(), [{:borderType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def cornerEigenValsAndVecs(src, blockSize, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(blockSize) and is_integer(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.cornerEigenValsAndVecs(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates eigenvalues and eigenvectors of image blocks for corner detection.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input single-channel 8-bit or floating-point image.

  - **blockSize**: `integer()`.

    Neighborhood size (see details below).

  - **ksize**: `integer()`.

    Aperture parameter for the Sobel operator.

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Image to store the results. It has the same size as src and the type CV_32FC(6) .

  For every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers a blockSize \\f$\\times\\f$ blockSize
  neighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of derivatives over the neighborhood as:
  \\f[M =  \\begin{bmatrix} \\sum \\_{S(p)}(dI/dx)^2 &  \\sum \\_{S(p)}dI/dx dI/dy  \\\\\\\\ \\sum \\_{S(p)}dI/dx dI/dy &  \\sum \\_{S(p)}(dI/dy)^2 \\end{bmatrix}\\f]
  where the derivatives are computed using the Sobel operator.
  After that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores them in the destination image as
  \\f$(\\lambda\\_1, \\lambda\\_2, x\\_1, y\\_1, x\\_2, y\\_2)\\f$ where
  - \\f$\\lambda\\_1, \\lambda\\_2\\f$ are the non-sorted eigenvalues of \\f$M\\f$
  - \\f$x\\_1, y\\_1\\f$ are the eigenvectors corresponding to \\f$\\lambda\\_1\\f$
  - \\f$x\\_2, y\\_2\\f$ are the eigenvectors corresponding to \\f$\\lambda\\_2\\f$

  The output of the function can be used for robust edge or corner detection.

  @sa  cornerMinEigenVal, cornerHarris, preCornerDetect

  Python prototype (for reference only):
  ```python3
  cornerEigenValsAndVecs(src, blockSize, ksize[, dst[, borderType]]) -> dst
  ```
  """
  @spec cornerEigenValsAndVecs(Evision.Mat.maybe_mat_in(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def cornerEigenValsAndVecs(src, blockSize, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(blockSize) and is_integer(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.cornerEigenValsAndVecs(positional)
    |> to_struct()
  end

  @doc """
  Harris corner detector.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input single-channel 8-bit or floating-point image.

  - **blockSize**: `integer()`.

    Neighborhood size (see the details on #cornerEigenValsAndVecs ).

  - **ksize**: `integer()`.

    Aperture parameter for the Sobel operator.

  - **k**: `double`.

    Harris detector free parameter. See the formula above.

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Image to store the Harris detector responses. It has the type CV_32FC1 and the same
    size as src .

  The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
  cornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a \\f$2\\times2\\f$ gradient covariance
  matrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood. Then, it
  computes the following characteristic:
  \\f[\\texttt{dst} (x,y) =  \\mathrm{det} M^{(x,y)} - k  \\cdot \\left ( \\mathrm{tr} M^{(x,y)} \\right )^2\\f]
  Corners in the image can be found as the local maxima of this response map.

  Python prototype (for reference only):
  ```python3
  cornerHarris(src, blockSize, ksize, k[, dst[, borderType]]) -> dst
  ```
  """
  @spec cornerHarris(Evision.Mat.maybe_mat_in(), integer(), integer(), number(), [{:borderType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def cornerHarris(src, blockSize, ksize, k, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(blockSize) and is_integer(ksize) and is_number(k) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      k: Evision.Internal.Structurise.from_struct(k)
    ]
    :evision_nif.cornerHarris(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Harris corner detector.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input single-channel 8-bit or floating-point image.

  - **blockSize**: `integer()`.

    Neighborhood size (see the details on #cornerEigenValsAndVecs ).

  - **ksize**: `integer()`.

    Aperture parameter for the Sobel operator.

  - **k**: `double`.

    Harris detector free parameter. See the formula above.

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Image to store the Harris detector responses. It has the type CV_32FC1 and the same
    size as src .

  The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
  cornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a \\f$2\\times2\\f$ gradient covariance
  matrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood. Then, it
  computes the following characteristic:
  \\f[\\texttt{dst} (x,y) =  \\mathrm{det} M^{(x,y)} - k  \\cdot \\left ( \\mathrm{tr} M^{(x,y)} \\right )^2\\f]
  Corners in the image can be found as the local maxima of this response map.

  Python prototype (for reference only):
  ```python3
  cornerHarris(src, blockSize, ksize, k[, dst[, borderType]]) -> dst
  ```
  """
  @spec cornerHarris(Evision.Mat.maybe_mat_in(), integer(), integer(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def cornerHarris(src, blockSize, ksize, k) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(blockSize) and is_integer(ksize) and is_number(k)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      k: Evision.Internal.Structurise.from_struct(k)
    ]
    :evision_nif.cornerHarris(positional)
    |> to_struct()
  end

  @doc """
  Calculates the minimal eigenvalue of gradient matrices for corner detection.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input single-channel 8-bit or floating-point image.

  - **blockSize**: `integer()`.

    Neighborhood size (see the details on #cornerEigenValsAndVecs ).

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    Aperture parameter for the Sobel operator.

  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
    src .

  The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
  eigenvalue of the covariance matrix of derivatives, that is, \\f$\\min(\\lambda\\_1, \\lambda\\_2)\\f$ in terms
  of the formulae in the cornerEigenValsAndVecs description.

  Python prototype (for reference only):
  ```python3
  cornerMinEigenVal(src, blockSize[, dst[, ksize[, borderType]]]) -> dst
  ```
  """
  @spec cornerMinEigenVal(Evision.Mat.maybe_mat_in(), integer(), [{:borderType, term()} | {:ksize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def cornerMinEigenVal(src, blockSize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(blockSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :ksize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize)
    ]
    :evision_nif.cornerMinEigenVal(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the minimal eigenvalue of gradient matrices for corner detection.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input single-channel 8-bit or floating-point image.

  - **blockSize**: `integer()`.

    Neighborhood size (see the details on #cornerEigenValsAndVecs ).

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    Aperture parameter for the Sobel operator.

  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
    src .

  The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
  eigenvalue of the covariance matrix of derivatives, that is, \\f$\\min(\\lambda\\_1, \\lambda\\_2)\\f$ in terms
  of the formulae in the cornerEigenValsAndVecs description.

  Python prototype (for reference only):
  ```python3
  cornerMinEigenVal(src, blockSize[, dst[, ksize[, borderType]]]) -> dst
  ```
  """
  @spec cornerMinEigenVal(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def cornerMinEigenVal(src, blockSize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(blockSize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize)
    ]
    :evision_nif.cornerMinEigenVal(positional)
    |> to_struct()
  end

  @doc """
  Refines the corner locations.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Input single-channel, 8-bit or float image.

  - **winSize**: `Size`.

    Half of the side length of the search window. For example, if winSize=Size(5,5) ,
    then a \\f$(5*2+1) \\times (5*2+1) = 11 \\times 11\\f$ search window is used.

  - **zeroZone**: `Size`.

    Half of the size of the dead region in the middle of the search zone over which
    the summation in the formula below is not done. It is used sometimes to avoid possible
    singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such
    a size.

  - **criteria**: `TermCriteria`.

    Criteria for termination of the iterative process of corner refinement. That is,
    the process of corner position refinement stops either after criteria.maxCount iterations or when
    the corner position moves by less than criteria.epsilon on some iteration.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

    Initial coordinates of the input corners and refined coordinates provided for
    output.

  The function iterates to find the sub-pixel accurate location of corners or radial saddle
  points as described in @cite forstner1987fast, and as shown on the figure below.
  ![image](pics/cornersubpix.png)
  Sub-pixel accurate corner locator is based on the observation that every vector from the center \\f$q\\f$
  to a point \\f$p\\f$ located within a neighborhood of \\f$q\\f$ is orthogonal to the image gradient at \\f$p\\f$
  subject to image and measurement noise. Consider the expression:
  \\f[\\epsilon \\_i = {DI\\_{p\\_i}}^T  \\cdot (q - p\\_i)\\f]
  where \\f${DI\\_{p\\_i}}\\f$ is an image gradient at one of the points \\f$p\\_i\\f$ in a neighborhood of \\f$q\\f$ . The
  value of \\f$q\\f$ is to be found so that \\f$\\epsilon\\_i\\f$ is minimized. A system of equations may be set up
  with \\f$\\epsilon\\_i\\f$ set to zero:
  \\f[\\sum \\_i(DI\\_{p\\_i}  \\cdot {DI\\_{p\\_i}}^T) \\cdot q -  \\sum \\_i(DI\\_{p\\_i}  \\cdot {DI\\_{p\\_i}}^T  \\cdot p\\_i)\\f]
  where the gradients are summed within a neighborhood ("search window") of \\f$q\\f$ . Calling the first
  gradient term \\f$G\\f$ and the second gradient term \\f$b\\f$ gives:
  \\f[q = G^{-1}  \\cdot b\\f]
  The algorithm sets the center of the neighborhood window at this new center \\f$q\\f$ and then iterates
  until the center stays within a set threshold.

  Python prototype (for reference only):
  ```python3
  cornerSubPix(image, corners, winSize, zeroZone, criteria) -> corners
  ```
  """
  @spec cornerSubPix(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, {integer(), integer(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def cornerSubPix(image, corners, winSize, zeroZone, criteria) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(corners, Evision.Mat) or is_struct(corners, Nx.Tensor) or is_number(corners) or is_tuple(corners)) and is_tuple(winSize) and is_tuple(zeroZone) and is_tuple(criteria)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      corners: Evision.Internal.Structurise.from_struct(corners),
      winSize: Evision.Internal.Structurise.from_struct(winSize),
      zeroZone: Evision.Internal.Structurise.from_struct(zeroZone),
      criteria: Evision.Internal.Structurise.from_struct(criteria)
    ]
    :evision_nif.cornerSubPix(positional)
    |> to_struct()
  end

  @doc """
  Refines coordinates of corresponding points.

  ##### Positional Arguments
  - **f**: `Evision.Mat`.

    3x3 fundamental matrix.

  - **points1**: `Evision.Mat`.

    1xN array containing the first set of points.

  - **points2**: `Evision.Mat`.

    1xN array containing the second set of points.

  ##### Return
  - **newPoints1**: `Evision.Mat.t()`.

    The optimized points1.

  - **newPoints2**: `Evision.Mat.t()`.

    The optimized points2.

  The function implements the Optimal Triangulation Method (see Multiple View Geometry @cite HartleyZ00 for details).
  For each given point correspondence points1[i] \\<-\\> points2[i], and a fundamental matrix F, it
  computes the corrected correspondences newPoints1[i] \\<-\\> newPoints2[i] that minimize the geometric
  error \\f$d(points1\\[i], newPoints1\\[i])^2 + d(points2\\[i],newPoints2\\[i])^2\\f$ (where \\f$d(a,b)\\f$ is the
  geometric distance between points \\f$a\\f$ and \\f$b\\f$ ) subject to the epipolar constraint
  \\f$newPoints2^T \\cdot F \\cdot newPoints1 = 0\\f$ .

  Python prototype (for reference only):
  ```python3
  correctMatches(F, points1, points2[, newPoints1[, newPoints2]]) -> newPoints1, newPoints2
  ```
  """
  @spec correctMatches(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def correctMatches(f, points1, points2, opts) when (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      f: Evision.Internal.Structurise.from_struct(f),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.correctMatches(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Refines coordinates of corresponding points.

  ##### Positional Arguments
  - **f**: `Evision.Mat`.

    3x3 fundamental matrix.

  - **points1**: `Evision.Mat`.

    1xN array containing the first set of points.

  - **points2**: `Evision.Mat`.

    1xN array containing the second set of points.

  ##### Return
  - **newPoints1**: `Evision.Mat.t()`.

    The optimized points1.

  - **newPoints2**: `Evision.Mat.t()`.

    The optimized points2.

  The function implements the Optimal Triangulation Method (see Multiple View Geometry @cite HartleyZ00 for details).
  For each given point correspondence points1[i] \\<-\\> points2[i], and a fundamental matrix F, it
  computes the corrected correspondences newPoints1[i] \\<-\\> newPoints2[i] that minimize the geometric
  error \\f$d(points1\\[i], newPoints1\\[i])^2 + d(points2\\[i],newPoints2\\[i])^2\\f$ (where \\f$d(a,b)\\f$ is the
  geometric distance between points \\f$a\\f$ and \\f$b\\f$ ) subject to the epipolar constraint
  \\f$newPoints2^T \\cdot F \\cdot newPoints1 = 0\\f$ .

  Python prototype (for reference only):
  ```python3
  correctMatches(F, points1, points2[, newPoints1[, newPoints2]]) -> newPoints1, newPoints2
  ```
  """
  @spec correctMatches(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def correctMatches(f, points1, points2) when (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2))
  do
    positional = [
      f: Evision.Internal.Structurise.from_struct(f),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.correctMatches(positional)
    |> to_struct()
  end

  @doc """
  Counts non-zero array elements.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    single-channel array.

  ##### Return
  - **retval**: `integer()`

  The function returns the number of non-zero elements in src :
  \\f[\\sum \\_{I: \\; \\texttt{src} (I) \\ne0 } 1\\f]
  The function do not work with multi-channel arrays. If you need to count non-zero array
  elements across all the channels, use Mat::reshape first to reinterpret the array as
  single-channel. Or you may extract the particular channel using either extractImageCOI, or
  mixChannels, or split.
  **Note**: 
  - If only whether there are non-zero elements is important, @ref hasNonZero is helpful.
  - If the location of non-zero array elements is important, @ref findNonZero is helpful.
  @sa  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix
  @sa  findNonZero, hasNonZero

  Python prototype (for reference only):
  ```python3
  countNonZero(src) -> retval
  ```
  """
  @spec countNonZero(Evision.Mat.maybe_mat_in()) :: integer() | {:error, String.t()}
  def countNonZero(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.countNonZero(positional)
    |> to_struct()
  end

  @doc """
  createAffineTransformer

  ##### Positional Arguments
  - **fullAffine**: `bool`

  ##### Return
  - **retval**: `Evision.AffineTransformer.t()`

  Complete constructor

  Python prototype (for reference only):
  ```python3
  createAffineTransformer(fullAffine) -> retval
  ```
  """
  @spec createAffineTransformer(boolean()) :: Evision.AffineTransformer.t() | {:error, String.t()}
  def createAffineTransformer(fullAffine) when is_boolean(fullAffine)
  do
    positional = [
      fullAffine: Evision.Internal.Structurise.from_struct(fullAffine)
    ]
    :evision_nif.createAffineTransformer(positional)
    |> to_struct()
  end

  @doc """
  Creates AlignMTB object
  ##### Keyword Arguments
  - **max_bits**: `integer()`.

    logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are
    usually good enough (31 and 63 pixels shift respectively).

  - **exclude_range**: `integer()`.

    range for exclusion bitmap that is constructed to suppress noise around the
    median value.

  - **cut**: `bool`.

    if true cuts images, otherwise fills the new regions with zeros.

  ##### Return
  - **retval**: `Evision.AlignMTB.t()`

  Python prototype (for reference only):
  ```python3
  createAlignMTB([, max_bits[, exclude_range[, cut]]]) -> retval
  ```
  """
  @spec createAlignMTB([{:cut, term()} | {:exclude_range, term()} | {:max_bits, term()}] | nil) :: Evision.AlignMTB.t() | {:error, String.t()}
  def createAlignMTB(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:cut, :exclude_range, :max_bits])
    positional = [
    ]
    :evision_nif.createAlignMTB(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates AlignMTB object
  ##### Keyword Arguments
  - **max_bits**: `integer()`.

    logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are
    usually good enough (31 and 63 pixels shift respectively).

  - **exclude_range**: `integer()`.

    range for exclusion bitmap that is constructed to suppress noise around the
    median value.

  - **cut**: `bool`.

    if true cuts images, otherwise fills the new regions with zeros.

  ##### Return
  - **retval**: `Evision.AlignMTB.t()`

  Python prototype (for reference only):
  ```python3
  createAlignMTB([, max_bits[, exclude_range[, cut]]]) -> retval
  ```
  """
  @spec createAlignMTB() :: Evision.AlignMTB.t() | {:error, String.t()}
  def createAlignMTB() do
    positional = [
    ]
    :evision_nif.createAlignMTB(positional)
    |> to_struct()
  end

  @doc """
  Creates KNN Background Subtractor
  ##### Keyword Arguments
  - **history**: `integer()`.

    Length of the history.

  - **dist2Threshold**: `double`.

    Threshold on the squared distance between the pixel and the sample to decide
    whether a pixel is close to that sample. This parameter does not affect the background update.

  - **detectShadows**: `bool`.

    If true, the algorithm will detect shadows and mark them. It decreases the
    speed a bit, so if you do not need this feature, set the parameter to false.

  ##### Return
  - **retval**: `Evision.BackgroundSubtractorKNN.t()`

  Python prototype (for reference only):
  ```python3
  createBackgroundSubtractorKNN([, history[, dist2Threshold[, detectShadows]]]) -> retval
  ```
  """
  @spec createBackgroundSubtractorKNN([{:detectShadows, term()} | {:dist2Threshold, term()} | {:history, term()}] | nil) :: Evision.BackgroundSubtractorKNN.t() | {:error, String.t()}
  def createBackgroundSubtractorKNN(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:detectShadows, :dist2Threshold, :history])
    positional = [
    ]
    :evision_nif.createBackgroundSubtractorKNN(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates KNN Background Subtractor
  ##### Keyword Arguments
  - **history**: `integer()`.

    Length of the history.

  - **dist2Threshold**: `double`.

    Threshold on the squared distance between the pixel and the sample to decide
    whether a pixel is close to that sample. This parameter does not affect the background update.

  - **detectShadows**: `bool`.

    If true, the algorithm will detect shadows and mark them. It decreases the
    speed a bit, so if you do not need this feature, set the parameter to false.

  ##### Return
  - **retval**: `Evision.BackgroundSubtractorKNN.t()`

  Python prototype (for reference only):
  ```python3
  createBackgroundSubtractorKNN([, history[, dist2Threshold[, detectShadows]]]) -> retval
  ```
  """
  @spec createBackgroundSubtractorKNN() :: Evision.BackgroundSubtractorKNN.t() | {:error, String.t()}
  def createBackgroundSubtractorKNN() do
    positional = [
    ]
    :evision_nif.createBackgroundSubtractorKNN(positional)
    |> to_struct()
  end

  @doc """
  Creates MOG2 Background Subtractor
  ##### Keyword Arguments
  - **history**: `integer()`.

    Length of the history.

  - **varThreshold**: `double`.

    Threshold on the squared Mahalanobis distance between the pixel and the model
    to decide whether a pixel is well described by the background model. This parameter does not
    affect the background update.

  - **detectShadows**: `bool`.

    If true, the algorithm will detect shadows and mark them. It decreases the
    speed a bit, so if you do not need this feature, set the parameter to false.

  ##### Return
  - **retval**: `Evision.BackgroundSubtractorMOG2.t()`

  Python prototype (for reference only):
  ```python3
  createBackgroundSubtractorMOG2([, history[, varThreshold[, detectShadows]]]) -> retval
  ```
  """
  @spec createBackgroundSubtractorMOG2([{:detectShadows, term()} | {:history, term()} | {:varThreshold, term()}] | nil) :: Evision.BackgroundSubtractorMOG2.t() | {:error, String.t()}
  def createBackgroundSubtractorMOG2(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:detectShadows, :history, :varThreshold])
    positional = [
    ]
    :evision_nif.createBackgroundSubtractorMOG2(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates MOG2 Background Subtractor
  ##### Keyword Arguments
  - **history**: `integer()`.

    Length of the history.

  - **varThreshold**: `double`.

    Threshold on the squared Mahalanobis distance between the pixel and the model
    to decide whether a pixel is well described by the background model. This parameter does not
    affect the background update.

  - **detectShadows**: `bool`.

    If true, the algorithm will detect shadows and mark them. It decreases the
    speed a bit, so if you do not need this feature, set the parameter to false.

  ##### Return
  - **retval**: `Evision.BackgroundSubtractorMOG2.t()`

  Python prototype (for reference only):
  ```python3
  createBackgroundSubtractorMOG2([, history[, varThreshold[, detectShadows]]]) -> retval
  ```
  """
  @spec createBackgroundSubtractorMOG2() :: Evision.BackgroundSubtractorMOG2.t() | {:error, String.t()}
  def createBackgroundSubtractorMOG2() do
    positional = [
    ]
    :evision_nif.createBackgroundSubtractorMOG2(positional)
    |> to_struct()
  end

  @doc """
  Creates a smart pointer to a cv::CLAHE class and initializes it.
  ##### Keyword Arguments
  - **clipLimit**: `double`.

    Threshold for contrast limiting.

  - **tileGridSize**: `Size`.

    Size of grid for histogram equalization. Input image will be divided into
    equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.

  ##### Return
  - **retval**: `Evision.CLAHE.t()`

  Python prototype (for reference only):
  ```python3
  createCLAHE([, clipLimit[, tileGridSize]]) -> retval
  ```
  """
  @spec createCLAHE([{:clipLimit, term()} | {:tileGridSize, term()}] | nil) :: Evision.CLAHE.t() | {:error, String.t()}
  def createCLAHE(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:clipLimit, :tileGridSize])
    positional = [
    ]
    :evision_nif.createCLAHE(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates a smart pointer to a cv::CLAHE class and initializes it.
  ##### Keyword Arguments
  - **clipLimit**: `double`.

    Threshold for contrast limiting.

  - **tileGridSize**: `Size`.

    Size of grid for histogram equalization. Input image will be divided into
    equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.

  ##### Return
  - **retval**: `Evision.CLAHE.t()`

  Python prototype (for reference only):
  ```python3
  createCLAHE([, clipLimit[, tileGridSize]]) -> retval
  ```
  """
  @spec createCLAHE() :: Evision.CLAHE.t() | {:error, String.t()}
  def createCLAHE() do
    positional = [
    ]
    :evision_nif.createCLAHE(positional)
    |> to_struct()
  end

  @doc """
  Creates CalibrateDebevec object
  ##### Keyword Arguments
  - **samples**: `integer()`.

    number of pixel locations to use

  - **lambda**: `float`.

    smoothness term weight. Greater values produce smoother results, but can alter the
    response.

  - **random**: `bool`.

    if true sample pixel locations are chosen at random, otherwise they form a
    rectangular grid.

  ##### Return
  - **retval**: `Evision.CalibrateDebevec.t()`

  Python prototype (for reference only):
  ```python3
  createCalibrateDebevec([, samples[, lambda[, random]]]) -> retval
  ```
  """
  @spec createCalibrateDebevec([{:lambda, term()} | {:random, term()} | {:samples, term()}] | nil) :: Evision.CalibrateDebevec.t() | {:error, String.t()}
  def createCalibrateDebevec(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:lambda, :random, :samples])
    positional = [
    ]
    :evision_nif.createCalibrateDebevec(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates CalibrateDebevec object
  ##### Keyword Arguments
  - **samples**: `integer()`.

    number of pixel locations to use

  - **lambda**: `float`.

    smoothness term weight. Greater values produce smoother results, but can alter the
    response.

  - **random**: `bool`.

    if true sample pixel locations are chosen at random, otherwise they form a
    rectangular grid.

  ##### Return
  - **retval**: `Evision.CalibrateDebevec.t()`

  Python prototype (for reference only):
  ```python3
  createCalibrateDebevec([, samples[, lambda[, random]]]) -> retval
  ```
  """
  @spec createCalibrateDebevec() :: Evision.CalibrateDebevec.t() | {:error, String.t()}
  def createCalibrateDebevec() do
    positional = [
    ]
    :evision_nif.createCalibrateDebevec(positional)
    |> to_struct()
  end

  @doc """
  Creates CalibrateRobertson object
  ##### Keyword Arguments
  - **max_iter**: `integer()`.

    maximal number of Gauss-Seidel solver iterations.

  - **threshold**: `float`.

    target difference between results of two successive steps of the minimization.

  ##### Return
  - **retval**: `Evision.CalibrateRobertson.t()`

  Python prototype (for reference only):
  ```python3
  createCalibrateRobertson([, max_iter[, threshold]]) -> retval
  ```
  """
  @spec createCalibrateRobertson([{:max_iter, term()} | {:threshold, term()}] | nil) :: Evision.CalibrateRobertson.t() | {:error, String.t()}
  def createCalibrateRobertson(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:max_iter, :threshold])
    positional = [
    ]
    :evision_nif.createCalibrateRobertson(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates CalibrateRobertson object
  ##### Keyword Arguments
  - **max_iter**: `integer()`.

    maximal number of Gauss-Seidel solver iterations.

  - **threshold**: `float`.

    target difference between results of two successive steps of the minimization.

  ##### Return
  - **retval**: `Evision.CalibrateRobertson.t()`

  Python prototype (for reference only):
  ```python3
  createCalibrateRobertson([, max_iter[, threshold]]) -> retval
  ```
  """
  @spec createCalibrateRobertson() :: Evision.CalibrateRobertson.t() | {:error, String.t()}
  def createCalibrateRobertson() do
    positional = [
    ]
    :evision_nif.createCalibrateRobertson(positional)
    |> to_struct()
  end

  @doc """
  createChiHistogramCostExtractor
  ##### Keyword Arguments
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createChiHistogramCostExtractor([, nDummies[, defaultCost]]) -> retval
  ```
  """
  @spec createChiHistogramCostExtractor([{:defaultCost, term()} | {:nDummies, term()}] | nil) :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createChiHistogramCostExtractor(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:defaultCost, :nDummies])
    positional = [
    ]
    :evision_nif.createChiHistogramCostExtractor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createChiHistogramCostExtractor
  ##### Keyword Arguments
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createChiHistogramCostExtractor([, nDummies[, defaultCost]]) -> retval
  ```
  """
  @spec createChiHistogramCostExtractor() :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createChiHistogramCostExtractor() do
    positional = [
    ]
    :evision_nif.createChiHistogramCostExtractor(positional)
    |> to_struct()
  end

  @doc """
  createEMDHistogramCostExtractor
  ##### Keyword Arguments
  - **flag**: `integer()`.
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createEMDHistogramCostExtractor([, flag[, nDummies[, defaultCost]]]) -> retval
  ```
  """
  @spec createEMDHistogramCostExtractor([{:defaultCost, term()} | {:flag, term()} | {:nDummies, term()}] | nil) :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createEMDHistogramCostExtractor(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:defaultCost, :flag, :nDummies])
    positional = [
    ]
    :evision_nif.createEMDHistogramCostExtractor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createEMDHistogramCostExtractor
  ##### Keyword Arguments
  - **flag**: `integer()`.
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createEMDHistogramCostExtractor([, flag[, nDummies[, defaultCost]]]) -> retval
  ```
  """
  @spec createEMDHistogramCostExtractor() :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createEMDHistogramCostExtractor() do
    positional = [
    ]
    :evision_nif.createEMDHistogramCostExtractor(positional)
    |> to_struct()
  end

  @doc """
  createEMDL1HistogramCostExtractor
  ##### Keyword Arguments
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createEMDL1HistogramCostExtractor([, nDummies[, defaultCost]]) -> retval
  ```
  """
  @spec createEMDL1HistogramCostExtractor([{:defaultCost, term()} | {:nDummies, term()}] | nil) :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createEMDL1HistogramCostExtractor(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:defaultCost, :nDummies])
    positional = [
    ]
    :evision_nif.createEMDL1HistogramCostExtractor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createEMDL1HistogramCostExtractor
  ##### Keyword Arguments
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createEMDL1HistogramCostExtractor([, nDummies[, defaultCost]]) -> retval
  ```
  """
  @spec createEMDL1HistogramCostExtractor() :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createEMDL1HistogramCostExtractor() do
    positional = [
    ]
    :evision_nif.createEMDL1HistogramCostExtractor(positional)
    |> to_struct()
  end

  @doc """
  Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it.
  ##### Return
  - **retval**: `Evision.GeneralizedHoughBallard.t()`

  Python prototype (for reference only):
  ```python3
  createGeneralizedHoughBallard() -> retval
  ```
  """
  @spec createGeneralizedHoughBallard() :: Evision.GeneralizedHoughBallard.t() | {:error, String.t()}
  def createGeneralizedHoughBallard() do
    positional = [
    ]
    :evision_nif.createGeneralizedHoughBallard(positional)
    |> to_struct()
  end

  @doc """
  Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it.
  ##### Return
  - **retval**: `Evision.GeneralizedHoughGuil.t()`

  Python prototype (for reference only):
  ```python3
  createGeneralizedHoughGuil() -> retval
  ```
  """
  @spec createGeneralizedHoughGuil() :: Evision.GeneralizedHoughGuil.t() | {:error, String.t()}
  def createGeneralizedHoughGuil() do
    positional = [
    ]
    :evision_nif.createGeneralizedHoughGuil(positional)
    |> to_struct()
  end

  @doc """
  This function computes a Hanning window coefficients in two dimensions.

  ##### Positional Arguments
  - **winSize**: `Size`.

    The window size specifications (both width and height must be > 1)

  - **type**: `integer()`.

    Created array type

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination array to place Hann coefficients in

  See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)
  for more information.
  An example is shown below:
  ```
  // create hanning window of size 100x100 and type CV_32F
  Mat hann;
  createHanningWindow(hann, Size(100, 100), CV_32F);
  ```

  Python prototype (for reference only):
  ```python3
  createHanningWindow(winSize, type[, dst]) -> dst
  ```
  """
  @spec createHanningWindow({number(), number()}, integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def createHanningWindow(winSize, type, opts) when is_tuple(winSize) and is_integer(type) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      winSize: Evision.Internal.Structurise.from_struct(winSize),
      type: Evision.Internal.Structurise.from_struct(type)
    ]
    :evision_nif.createHanningWindow(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  This function computes a Hanning window coefficients in two dimensions.

  ##### Positional Arguments
  - **winSize**: `Size`.

    The window size specifications (both width and height must be > 1)

  - **type**: `integer()`.

    Created array type

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination array to place Hann coefficients in

  See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)
  for more information.
  An example is shown below:
  ```
  // create hanning window of size 100x100 and type CV_32F
  Mat hann;
  createHanningWindow(hann, Size(100, 100), CV_32F);
  ```

  Python prototype (for reference only):
  ```python3
  createHanningWindow(winSize, type[, dst]) -> dst
  ```
  """
  @spec createHanningWindow({number(), number()}, integer()) :: Evision.Mat.t() | {:error, String.t()}
  def createHanningWindow(winSize, type) when is_tuple(winSize) and is_integer(type)
  do
    positional = [
      winSize: Evision.Internal.Structurise.from_struct(winSize),
      type: Evision.Internal.Structurise.from_struct(type)
    ]
    :evision_nif.createHanningWindow(positional)
    |> to_struct()
  end

  @doc """
  createHausdorffDistanceExtractor
  ##### Keyword Arguments
  - **distanceFlag**: `integer()`.
  - **rankProp**: `float`.

  ##### Return
  - **retval**: `Evision.HausdorffDistanceExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createHausdorffDistanceExtractor([, distanceFlag[, rankProp]]) -> retval
  ```
  """
  @spec createHausdorffDistanceExtractor([{:distanceFlag, term()} | {:rankProp, term()}] | nil) :: Evision.HausdorffDistanceExtractor.t() | {:error, String.t()}
  def createHausdorffDistanceExtractor(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:distanceFlag, :rankProp])
    positional = [
    ]
    :evision_nif.createHausdorffDistanceExtractor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createHausdorffDistanceExtractor
  ##### Keyword Arguments
  - **distanceFlag**: `integer()`.
  - **rankProp**: `float`.

  ##### Return
  - **retval**: `Evision.HausdorffDistanceExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createHausdorffDistanceExtractor([, distanceFlag[, rankProp]]) -> retval
  ```
  """
  @spec createHausdorffDistanceExtractor() :: Evision.HausdorffDistanceExtractor.t() | {:error, String.t()}
  def createHausdorffDistanceExtractor() do
    positional = [
    ]
    :evision_nif.createHausdorffDistanceExtractor(positional)
    |> to_struct()
  end

  @doc """
  Creates a smart pointer to a LineSegmentDetector object and initializes it.
  ##### Keyword Arguments
  - **refine**: `integer()`.

    The way found lines will be refined, see #LineSegmentDetectorModes

  - **scale**: `double`.

    The scale of the image that will be used to find the lines. Range (0..1].

  - **sigma_scale**: `double`.

    Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.

  - **quant**: `double`.

    Bound to the quantization error on the gradient norm.

  - **ang_th**: `double`.

    Gradient angle tolerance in degrees.

  - **log_eps**: `double`.

    Detection threshold: -log10(NFA) \\> log_eps. Used only when advance refinement is chosen.

  - **density_th**: `double`.

    Minimal density of aligned region points in the enclosing rectangle.

  - **n_bins**: `integer()`.

    Number of bins in pseudo-ordering of gradient modulus.

  ##### Return
  - **retval**: `Evision.LineSegmentDetector.t()`

  The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
  to edit those, as to tailor it for their own application.

  Python prototype (for reference only):
  ```python3
  createLineSegmentDetector([, refine[, scale[, sigma_scale[, quant[, ang_th[, log_eps[, density_th[, n_bins]]]]]]]]) -> retval
  ```
  """
  @spec createLineSegmentDetector([{:ang_th, term()} | {:density_th, term()} | {:log_eps, term()} | {:n_bins, term()} | {:quant, term()} | {:refine, term()} | {:scale, term()} | {:sigma_scale, term()}] | nil) :: Evision.LineSegmentDetector.t() | {:error, String.t()}
  def createLineSegmentDetector(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:ang_th, :density_th, :log_eps, :n_bins, :quant, :refine, :scale, :sigma_scale])
    positional = [
    ]
    :evision_nif.createLineSegmentDetector(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates a smart pointer to a LineSegmentDetector object and initializes it.
  ##### Keyword Arguments
  - **refine**: `integer()`.

    The way found lines will be refined, see #LineSegmentDetectorModes

  - **scale**: `double`.

    The scale of the image that will be used to find the lines. Range (0..1].

  - **sigma_scale**: `double`.

    Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.

  - **quant**: `double`.

    Bound to the quantization error on the gradient norm.

  - **ang_th**: `double`.

    Gradient angle tolerance in degrees.

  - **log_eps**: `double`.

    Detection threshold: -log10(NFA) \\> log_eps. Used only when advance refinement is chosen.

  - **density_th**: `double`.

    Minimal density of aligned region points in the enclosing rectangle.

  - **n_bins**: `integer()`.

    Number of bins in pseudo-ordering of gradient modulus.

  ##### Return
  - **retval**: `Evision.LineSegmentDetector.t()`

  The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
  to edit those, as to tailor it for their own application.

  Python prototype (for reference only):
  ```python3
  createLineSegmentDetector([, refine[, scale[, sigma_scale[, quant[, ang_th[, log_eps[, density_th[, n_bins]]]]]]]]) -> retval
  ```
  """
  @spec createLineSegmentDetector() :: Evision.LineSegmentDetector.t() | {:error, String.t()}
  def createLineSegmentDetector() do
    positional = [
    ]
    :evision_nif.createLineSegmentDetector(positional)
    |> to_struct()
  end

  @doc """
  Creates MergeDebevec object
  ##### Return
  - **retval**: `Evision.MergeDebevec.t()`

  Python prototype (for reference only):
  ```python3
  createMergeDebevec() -> retval
  ```
  """
  @spec createMergeDebevec() :: Evision.MergeDebevec.t() | {:error, String.t()}
  def createMergeDebevec() do
    positional = [
    ]
    :evision_nif.createMergeDebevec(positional)
    |> to_struct()
  end

  @doc """
  Creates MergeMertens object
  ##### Keyword Arguments
  - **contrast_weight**: `float`.

    contrast measure weight. See MergeMertens.

  - **saturation_weight**: `float`.

    saturation measure weight

  - **exposure_weight**: `float`.

    well-exposedness measure weight

  ##### Return
  - **retval**: `Evision.MergeMertens.t()`

  Python prototype (for reference only):
  ```python3
  createMergeMertens([, contrast_weight[, saturation_weight[, exposure_weight]]]) -> retval
  ```
  """
  @spec createMergeMertens([{:contrast_weight, term()} | {:exposure_weight, term()} | {:saturation_weight, term()}] | nil) :: Evision.MergeMertens.t() | {:error, String.t()}
  def createMergeMertens(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:contrast_weight, :exposure_weight, :saturation_weight])
    positional = [
    ]
    :evision_nif.createMergeMertens(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates MergeMertens object
  ##### Keyword Arguments
  - **contrast_weight**: `float`.

    contrast measure weight. See MergeMertens.

  - **saturation_weight**: `float`.

    saturation measure weight

  - **exposure_weight**: `float`.

    well-exposedness measure weight

  ##### Return
  - **retval**: `Evision.MergeMertens.t()`

  Python prototype (for reference only):
  ```python3
  createMergeMertens([, contrast_weight[, saturation_weight[, exposure_weight]]]) -> retval
  ```
  """
  @spec createMergeMertens() :: Evision.MergeMertens.t() | {:error, String.t()}
  def createMergeMertens() do
    positional = [
    ]
    :evision_nif.createMergeMertens(positional)
    |> to_struct()
  end

  @doc """
  Creates MergeRobertson object
  ##### Return
  - **retval**: `Evision.MergeRobertson.t()`

  Python prototype (for reference only):
  ```python3
  createMergeRobertson() -> retval
  ```
  """
  @spec createMergeRobertson() :: Evision.MergeRobertson.t() | {:error, String.t()}
  def createMergeRobertson() do
    positional = [
    ]
    :evision_nif.createMergeRobertson(positional)
    |> to_struct()
  end

  @doc """
  createNormHistogramCostExtractor
  ##### Keyword Arguments
  - **flag**: `integer()`.
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createNormHistogramCostExtractor([, flag[, nDummies[, defaultCost]]]) -> retval
  ```
  """
  @spec createNormHistogramCostExtractor([{:defaultCost, term()} | {:flag, term()} | {:nDummies, term()}] | nil) :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createNormHistogramCostExtractor(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:defaultCost, :flag, :nDummies])
    positional = [
    ]
    :evision_nif.createNormHistogramCostExtractor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createNormHistogramCostExtractor
  ##### Keyword Arguments
  - **flag**: `integer()`.
  - **nDummies**: `integer()`.
  - **defaultCost**: `float`.

  ##### Return
  - **retval**: `Evision.HistogramCostExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createNormHistogramCostExtractor([, flag[, nDummies[, defaultCost]]]) -> retval
  ```
  """
  @spec createNormHistogramCostExtractor() :: Evision.HistogramCostExtractor.t() | {:error, String.t()}
  def createNormHistogramCostExtractor() do
    positional = [
    ]
    :evision_nif.createNormHistogramCostExtractor(positional)
    |> to_struct()
  end

  @doc """
  createShapeContextDistanceExtractor
  ##### Keyword Arguments
  - **nAngularBins**: `integer()`.
  - **nRadialBins**: `integer()`.
  - **innerRadius**: `float`.
  - **outerRadius**: `float`.
  - **iterations**: `integer()`.
  - **comparer**: `Evision.HistogramCostExtractor`.
  - **transformer**: `Evision.ShapeTransformer`.

  ##### Return
  - **retval**: `Evision.ShapeContextDistanceExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createShapeContextDistanceExtractor([, nAngularBins[, nRadialBins[, innerRadius[, outerRadius[, iterations[, comparer[, transformer]]]]]]]) -> retval
  ```
  """
  @spec createShapeContextDistanceExtractor([{:comparer, term()} | {:innerRadius, term()} | {:iterations, term()} | {:nAngularBins, term()} | {:nRadialBins, term()} | {:outerRadius, term()} | {:transformer, term()}] | nil) :: Evision.ShapeContextDistanceExtractor.t() | {:error, String.t()}
  def createShapeContextDistanceExtractor(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:comparer, :innerRadius, :iterations, :nAngularBins, :nRadialBins, :outerRadius, :transformer])
    positional = [
    ]
    :evision_nif.createShapeContextDistanceExtractor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createShapeContextDistanceExtractor
  ##### Keyword Arguments
  - **nAngularBins**: `integer()`.
  - **nRadialBins**: `integer()`.
  - **innerRadius**: `float`.
  - **outerRadius**: `float`.
  - **iterations**: `integer()`.
  - **comparer**: `Evision.HistogramCostExtractor`.
  - **transformer**: `Evision.ShapeTransformer`.

  ##### Return
  - **retval**: `Evision.ShapeContextDistanceExtractor.t()`

  Python prototype (for reference only):
  ```python3
  createShapeContextDistanceExtractor([, nAngularBins[, nRadialBins[, innerRadius[, outerRadius[, iterations[, comparer[, transformer]]]]]]]) -> retval
  ```
  """
  @spec createShapeContextDistanceExtractor() :: Evision.ShapeContextDistanceExtractor.t() | {:error, String.t()}
  def createShapeContextDistanceExtractor() do
    positional = [
    ]
    :evision_nif.createShapeContextDistanceExtractor(positional)
    |> to_struct()
  end

  @doc """
  createThinPlateSplineShapeTransformer
  ##### Keyword Arguments
  - **regularizationParameter**: `double`.

  ##### Return
  - **retval**: `Evision.ThinPlateSplineShapeTransformer.t()`

  Complete constructor

  Python prototype (for reference only):
  ```python3
  createThinPlateSplineShapeTransformer([, regularizationParameter]) -> retval
  ```
  """
  @spec createThinPlateSplineShapeTransformer([{:regularizationParameter, term()}] | nil) :: Evision.ThinPlateSplineShapeTransformer.t() | {:error, String.t()}
  def createThinPlateSplineShapeTransformer(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:regularizationParameter])
    positional = [
    ]
    :evision_nif.createThinPlateSplineShapeTransformer(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  createThinPlateSplineShapeTransformer
  ##### Keyword Arguments
  - **regularizationParameter**: `double`.

  ##### Return
  - **retval**: `Evision.ThinPlateSplineShapeTransformer.t()`

  Complete constructor

  Python prototype (for reference only):
  ```python3
  createThinPlateSplineShapeTransformer([, regularizationParameter]) -> retval
  ```
  """
  @spec createThinPlateSplineShapeTransformer() :: Evision.ThinPlateSplineShapeTransformer.t() | {:error, String.t()}
  def createThinPlateSplineShapeTransformer() do
    positional = [
    ]
    :evision_nif.createThinPlateSplineShapeTransformer(positional)
    |> to_struct()
  end

  @doc """
  Creates simple linear mapper with gamma correction
  ##### Keyword Arguments
  - **gamma**: `float`.

    positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
    equal to 2.2f is suitable for most displays.
    Generally gamma \\> 1 brightens the image and gamma \\< 1 darkens it.

  ##### Return
  - **retval**: `Evision.Tonemap.t()`

  Python prototype (for reference only):
  ```python3
  createTonemap([, gamma]) -> retval
  ```
  """
  @spec createTonemap([{:gamma, term()}] | nil) :: Evision.Tonemap.t() | {:error, String.t()}
  def createTonemap(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:gamma])
    positional = [
    ]
    :evision_nif.createTonemap(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates simple linear mapper with gamma correction
  ##### Keyword Arguments
  - **gamma**: `float`.

    positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
    equal to 2.2f is suitable for most displays.
    Generally gamma \\> 1 brightens the image and gamma \\< 1 darkens it.

  ##### Return
  - **retval**: `Evision.Tonemap.t()`

  Python prototype (for reference only):
  ```python3
  createTonemap([, gamma]) -> retval
  ```
  """
  @spec createTonemap() :: Evision.Tonemap.t() | {:error, String.t()}
  def createTonemap() do
    positional = [
    ]
    :evision_nif.createTonemap(positional)
    |> to_struct()
  end

  @doc """
  Creates TonemapDrago object
  ##### Keyword Arguments
  - **gamma**: `float`.

    gamma value for gamma correction. See createTonemap

  - **saturation**: `float`.

    positive saturation enhancement value. 1.0 preserves saturation, values greater
    than 1 increase saturation and values less than 1 decrease it.

  - **bias**: `float`.

    value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best
    results, default value is 0.85.

  ##### Return
  - **retval**: `Evision.TonemapDrago.t()`

  Python prototype (for reference only):
  ```python3
  createTonemapDrago([, gamma[, saturation[, bias]]]) -> retval
  ```
  """
  @spec createTonemapDrago([{:bias, term()} | {:gamma, term()} | {:saturation, term()}] | nil) :: Evision.TonemapDrago.t() | {:error, String.t()}
  def createTonemapDrago(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:bias, :gamma, :saturation])
    positional = [
    ]
    :evision_nif.createTonemapDrago(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates TonemapDrago object
  ##### Keyword Arguments
  - **gamma**: `float`.

    gamma value for gamma correction. See createTonemap

  - **saturation**: `float`.

    positive saturation enhancement value. 1.0 preserves saturation, values greater
    than 1 increase saturation and values less than 1 decrease it.

  - **bias**: `float`.

    value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best
    results, default value is 0.85.

  ##### Return
  - **retval**: `Evision.TonemapDrago.t()`

  Python prototype (for reference only):
  ```python3
  createTonemapDrago([, gamma[, saturation[, bias]]]) -> retval
  ```
  """
  @spec createTonemapDrago() :: Evision.TonemapDrago.t() | {:error, String.t()}
  def createTonemapDrago() do
    positional = [
    ]
    :evision_nif.createTonemapDrago(positional)
    |> to_struct()
  end

  @doc """
  Creates TonemapMantiuk object
  ##### Keyword Arguments
  - **gamma**: `float`.

    gamma value for gamma correction. See createTonemap

  - **scale**: `float`.

    contrast scale factor. HVS response is multiplied by this parameter, thus compressing
    dynamic range. Values from 0.6 to 0.9 produce best results.

  - **saturation**: `float`.

    saturation enhancement value. See createTonemapDrago

  ##### Return
  - **retval**: `Evision.TonemapMantiuk.t()`

  Python prototype (for reference only):
  ```python3
  createTonemapMantiuk([, gamma[, scale[, saturation]]]) -> retval
  ```
  """
  @spec createTonemapMantiuk([{:gamma, term()} | {:saturation, term()} | {:scale, term()}] | nil) :: Evision.TonemapMantiuk.t() | {:error, String.t()}
  def createTonemapMantiuk(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:gamma, :saturation, :scale])
    positional = [
    ]
    :evision_nif.createTonemapMantiuk(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates TonemapMantiuk object
  ##### Keyword Arguments
  - **gamma**: `float`.

    gamma value for gamma correction. See createTonemap

  - **scale**: `float`.

    contrast scale factor. HVS response is multiplied by this parameter, thus compressing
    dynamic range. Values from 0.6 to 0.9 produce best results.

  - **saturation**: `float`.

    saturation enhancement value. See createTonemapDrago

  ##### Return
  - **retval**: `Evision.TonemapMantiuk.t()`

  Python prototype (for reference only):
  ```python3
  createTonemapMantiuk([, gamma[, scale[, saturation]]]) -> retval
  ```
  """
  @spec createTonemapMantiuk() :: Evision.TonemapMantiuk.t() | {:error, String.t()}
  def createTonemapMantiuk() do
    positional = [
    ]
    :evision_nif.createTonemapMantiuk(positional)
    |> to_struct()
  end

  @doc """
  Creates TonemapReinhard object
  ##### Keyword Arguments
  - **gamma**: `float`.

    gamma value for gamma correction. See createTonemap

  - **intensity**: `float`.

    result intensity in [-8, 8] range. Greater intensity produces brighter results.

  - **light_adapt**: `float`.

    light adaptation in [0, 1] range. If 1 adaptation is based only on pixel
    value, if 0 it's global, otherwise it's a weighted mean of this two cases.

  - **color_adapt**: `float`.

    chromatic adaptation in [0, 1] range. If 1 channels are treated independently,
    if 0 adaptation level is the same for each channel.

  ##### Return
  - **retval**: `Evision.TonemapReinhard.t()`

  Python prototype (for reference only):
  ```python3
  createTonemapReinhard([, gamma[, intensity[, light_adapt[, color_adapt]]]]) -> retval
  ```
  """
  @spec createTonemapReinhard([{:color_adapt, term()} | {:gamma, term()} | {:intensity, term()} | {:light_adapt, term()}] | nil) :: Evision.TonemapReinhard.t() | {:error, String.t()}
  def createTonemapReinhard(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:color_adapt, :gamma, :intensity, :light_adapt])
    positional = [
    ]
    :evision_nif.createTonemapReinhard(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates TonemapReinhard object
  ##### Keyword Arguments
  - **gamma**: `float`.

    gamma value for gamma correction. See createTonemap

  - **intensity**: `float`.

    result intensity in [-8, 8] range. Greater intensity produces brighter results.

  - **light_adapt**: `float`.

    light adaptation in [0, 1] range. If 1 adaptation is based only on pixel
    value, if 0 it's global, otherwise it's a weighted mean of this two cases.

  - **color_adapt**: `float`.

    chromatic adaptation in [0, 1] range. If 1 channels are treated independently,
    if 0 adaptation level is the same for each channel.

  ##### Return
  - **retval**: `Evision.TonemapReinhard.t()`

  Python prototype (for reference only):
  ```python3
  createTonemapReinhard([, gamma[, intensity[, light_adapt[, color_adapt]]]]) -> retval
  ```
  """
  @spec createTonemapReinhard() :: Evision.TonemapReinhard.t() | {:error, String.t()}
  def createTonemapReinhard() do
    positional = [
    ]
    :evision_nif.createTonemapReinhard(positional)
    |> to_struct()
  end

  @doc """
  Computes the cube root of an argument.

  ##### Positional Arguments
  - **val**: `float`.

    A function argument.

  ##### Return
  - **retval**: `float`

  The function cubeRoot computes \\f$\\sqrt\\[3]{\\texttt{val}}\\f$. Negative arguments are handled correctly.
  NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for
  single-precision data.

  Python prototype (for reference only):
  ```python3
  cubeRoot(val) -> retval
  ```
  """
  @spec cubeRoot(number()) :: number() | {:error, String.t()}
  def cubeRoot(val) when is_float(val)
  do
    positional = [
      val: Evision.Internal.Structurise.from_struct(val)
    ]
    :evision_nif.cubeRoot(positional)
    |> to_struct()
  end

  @doc """
  HighGUI backend used.
  ##### Return
  - **retval**: `string`

  The function returns HighGUI backend name used: could be COCOA, GTK2/3, QT, WAYLAND or WIN32.
  Returns empty string if there is no available UI backend.

  Python prototype (for reference only):
  ```python3
  currentUIFramework() -> retval
  ```
  """
  @spec currentUIFramework() :: binary() | {:error, String.t()}
  def currentUIFramework() do
    positional = [
    ]
    :evision_nif.currentUIFramework(positional)
    |> to_struct()
  end

  @doc """
  Converts an image from one color space to another.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
    floating-point.

  - **code**: `integer()`.

    color space conversion code (see #ColorConversionCodes).

  ##### Keyword Arguments
  - **dstCn**: `integer()`.

    number of channels in the destination image; if the parameter is 0, the number of the
    channels is derived automatically from src and code.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and depth as src.

  The function converts an input image from one color space to another. In case of a transformation
  to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
  that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
  bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
  component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
  sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.
  The conventional ranges for R, G, and B channel values are:
  - 0 to 255 for CV_8U images
  - 0 to 65535 for CV_16U images
  - 0 to 1 for CV_32F images

  In case of linear transformations, the range does not matter. But in case of a non-linear
  transformation, an input RGB image should be normalized to the proper value range to get the correct
  results, for example, for RGB \\f$\\rightarrow\\f$ L\\*u\\*v\\* transformation. For example, if you have a
  32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
  have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,
  you need first to scale the image down:
  ```
  img *= 1./255;
  cvtColor(img, img, COLOR_BGR2Luv);
  ```
  If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many
  applications, this will not be noticeable but it is recommended to use 32-bit images in applications
  that need the full range of colors or that convert an image before an operation and then convert
  back.
  If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
  range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.

  @see @ref imgproc_color_conversions

  Python prototype (for reference only):
  ```python3
  cvtColor(src, code[, dst[, dstCn]]) -> dst
  ```
  """
  @spec cvtColor(Evision.Mat.maybe_mat_in(), integer(), [{:dstCn, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def cvtColor(src, code, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(code) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dstCn])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      code: Evision.Internal.Structurise.from_struct(code)
    ]
    :evision_nif.cvtColor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts an image from one color space to another.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
    floating-point.

  - **code**: `integer()`.

    color space conversion code (see #ColorConversionCodes).

  ##### Keyword Arguments
  - **dstCn**: `integer()`.

    number of channels in the destination image; if the parameter is 0, the number of the
    channels is derived automatically from src and code.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and depth as src.

  The function converts an input image from one color space to another. In case of a transformation
  to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
  that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
  bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
  component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
  sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.
  The conventional ranges for R, G, and B channel values are:
  - 0 to 255 for CV_8U images
  - 0 to 65535 for CV_16U images
  - 0 to 1 for CV_32F images

  In case of linear transformations, the range does not matter. But in case of a non-linear
  transformation, an input RGB image should be normalized to the proper value range to get the correct
  results, for example, for RGB \\f$\\rightarrow\\f$ L\\*u\\*v\\* transformation. For example, if you have a
  32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
  have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,
  you need first to scale the image down:
  ```
  img *= 1./255;
  cvtColor(img, img, COLOR_BGR2Luv);
  ```
  If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many
  applications, this will not be noticeable but it is recommended to use 32-bit images in applications
  that need the full range of colors or that convert an image before an operation and then convert
  back.
  If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
  range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.

  @see @ref imgproc_color_conversions

  Python prototype (for reference only):
  ```python3
  cvtColor(src, code[, dst[, dstCn]]) -> dst
  ```
  """
  @spec cvtColor(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def cvtColor(src, code) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(code)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      code: Evision.Internal.Structurise.from_struct(code)
    ]
    :evision_nif.cvtColor(positional)
    |> to_struct()
  end

  @doc """
  Converts an image from one color space to another where the source image is
  stored in two planes.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    8-bit image (#CV_8U) of the Y plane.

  - **src2**: `Evision.Mat`.

    image containing interleaved U/V plane.

  - **code**: `integer()`.

    Specifies the type of conversion. It can take any of the following values:
    - #COLOR_YUV2BGR_NV12
    - #COLOR_YUV2RGB_NV12
    - #COLOR_YUV2BGRA_NV12
    - #COLOR_YUV2RGBA_NV12
    - #COLOR_YUV2BGR_NV21
    - #COLOR_YUV2RGB_NV21
    - #COLOR_YUV2BGRA_NV21
    - #COLOR_YUV2RGBA_NV21

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image.

  This function only supports YUV420 to RGB conversion as of now.

  Python prototype (for reference only):
  ```python3
  cvtColorTwoPlane(src1, src2, code[, dst]) -> dst
  ```
  """
  @spec cvtColorTwoPlane(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def cvtColorTwoPlane(src1, src2, code, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_integer(code) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      code: Evision.Internal.Structurise.from_struct(code)
    ]
    :evision_nif.cvtColorTwoPlane(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Converts an image from one color space to another where the source image is
  stored in two planes.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    8-bit image (#CV_8U) of the Y plane.

  - **src2**: `Evision.Mat`.

    image containing interleaved U/V plane.

  - **code**: `integer()`.

    Specifies the type of conversion. It can take any of the following values:
    - #COLOR_YUV2BGR_NV12
    - #COLOR_YUV2RGB_NV12
    - #COLOR_YUV2BGRA_NV12
    - #COLOR_YUV2RGBA_NV12
    - #COLOR_YUV2BGR_NV21
    - #COLOR_YUV2RGB_NV21
    - #COLOR_YUV2BGRA_NV21
    - #COLOR_YUV2RGBA_NV21

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image.

  This function only supports YUV420 to RGB conversion as of now.

  Python prototype (for reference only):
  ```python3
  cvtColorTwoPlane(src1, src2, code[, dst]) -> dst
  ```
  """
  @spec cvtColorTwoPlane(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def cvtColorTwoPlane(src1, src2, code) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_integer(code)
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      code: Evision.Internal.Structurise.from_struct(code)
    ]
    :evision_nif.cvtColorTwoPlane(positional)
    |> to_struct()
  end

  @doc """
  Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point array.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    transformation flags as a combination of cv::DftFlags (DCT_*)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src .

  The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
  floating-point array:
  - Forward Cosine transform of a 1D vector of N elements:
    \\f[Y = C^{(N)}  \\cdot X\\f]
    where
    \\f[C^{(N)}\\_{jk}= \\sqrt{\\alpha\\_j/N} \\cos \\left ( \\frac{\\pi(2k+1)j}{2N} \\right )\\f]
    and
    \\f$\\alpha\\_0=1\\f$, \\f$\\alpha\\_j=2\\f$ for *j \\> 0*.

  - Inverse Cosine transform of a 1D vector of N elements:
    \\f[X =  \\left (C^{(N)} \\right )^{-1}  \\cdot Y =  \\left (C^{(N)} \\right )^T  \\cdot Y\\f]
    (since \\f$C^{(N)}\\f$ is an orthogonal matrix, \\f$C^{(N)} \\cdot \\left(C^{(N)}\\right)^T = I\\f$ )

  - Forward 2D Cosine transform of M x N matrix:
    \\f[Y = C^{(N)}  \\cdot X  \\cdot \\left (C^{(N)} \\right )^T\\f]

  - Inverse 2D Cosine transform of M x N matrix:
    \\f[X =  \\left (C^{(N)} \\right )^T  \\cdot X  \\cdot C^{(N)}\\f]

  The function chooses the mode of operation by looking at the flags and size of the input array:
  - If (flags & #DCT_INVERSE) == 0, the function does a forward 1D or 2D transform. Otherwise, it
    is an inverse 1D or 2D transform.

  - If (flags & #DCT_ROWS) != 0, the function performs a 1D transform of each row.
  - If the array is a single column or a single row, the function performs a 1D transform.
  - If none of the above is true, the function performs a 2D transform.

  **Note**: Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you
  can pad the array when necessary.
  Also, the function performance depends very much, and not monotonically, on the array size (see
  getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT
  of a vector of size N/2 . Thus, the optimal DCT size N1 \\>= N can be calculated as:
  ```
  size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }
  N1 = getOptimalDCTSize(N);
  ```
  @sa dft, getOptimalDFTSize, idct

  Python prototype (for reference only):
  ```python3
  dct(src[, dst[, flags]]) -> dst
  ```
  """
  @spec dct(Evision.Mat.maybe_mat_in(), [{:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def dct(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.dct(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point array.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    transformation flags as a combination of cv::DftFlags (DCT_*)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src .

  The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
  floating-point array:
  - Forward Cosine transform of a 1D vector of N elements:
    \\f[Y = C^{(N)}  \\cdot X\\f]
    where
    \\f[C^{(N)}\\_{jk}= \\sqrt{\\alpha\\_j/N} \\cos \\left ( \\frac{\\pi(2k+1)j}{2N} \\right )\\f]
    and
    \\f$\\alpha\\_0=1\\f$, \\f$\\alpha\\_j=2\\f$ for *j \\> 0*.

  - Inverse Cosine transform of a 1D vector of N elements:
    \\f[X =  \\left (C^{(N)} \\right )^{-1}  \\cdot Y =  \\left (C^{(N)} \\right )^T  \\cdot Y\\f]
    (since \\f$C^{(N)}\\f$ is an orthogonal matrix, \\f$C^{(N)} \\cdot \\left(C^{(N)}\\right)^T = I\\f$ )

  - Forward 2D Cosine transform of M x N matrix:
    \\f[Y = C^{(N)}  \\cdot X  \\cdot \\left (C^{(N)} \\right )^T\\f]

  - Inverse 2D Cosine transform of M x N matrix:
    \\f[X =  \\left (C^{(N)} \\right )^T  \\cdot X  \\cdot C^{(N)}\\f]

  The function chooses the mode of operation by looking at the flags and size of the input array:
  - If (flags & #DCT_INVERSE) == 0, the function does a forward 1D or 2D transform. Otherwise, it
    is an inverse 1D or 2D transform.

  - If (flags & #DCT_ROWS) != 0, the function performs a 1D transform of each row.
  - If the array is a single column or a single row, the function performs a 1D transform.
  - If none of the above is true, the function performs a 2D transform.

  **Note**: Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you
  can pad the array when necessary.
  Also, the function performance depends very much, and not monotonically, on the array size (see
  getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT
  of a vector of size N/2 . Thus, the optimal DCT size N1 \\>= N can be calculated as:
  ```
  size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }
  N1 = getOptimalDCTSize(N);
  ```
  @sa dft, getOptimalDFTSize, idct

  Python prototype (for reference only):
  ```python3
  dct(src[, dst[, flags]]) -> dst
  ```
  """
  @spec dct(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def dct(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.dct(positional)
    |> to_struct()
  end

  @doc """
  Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized
  black-and-white photograph rendering, and in many single channel image processing applications

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Return
  - **grayscale**: `Evision.Mat.t()`.

    Output 8-bit 1-channel image.

  - **color_boost**: `Evision.Mat.t()`.

    Output 8-bit 3-channel image.

  @cite CL12 .

  This function is to be applied on color images.

  Python prototype (for reference only):
  ```python3
  decolor(src[, grayscale[, color_boost]]) -> grayscale, color_boost
  ```
  """
  @spec decolor(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def decolor(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.decolor(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized
  black-and-white photograph rendering, and in many single channel image processing applications

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Return
  - **grayscale**: `Evision.Mat.t()`.

    Output 8-bit 1-channel image.

  - **color_boost**: `Evision.Mat.t()`.

    Output 8-bit 3-channel image.

  @cite CL12 .

  This function is to be applied on color images.

  Python prototype (for reference only):
  ```python3
  decolor(src[, grayscale[, color_boost]]) -> grayscale, color_boost
  ```
  """
  @spec decolor(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def decolor(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.decolor(positional)
    |> to_struct()
  end

  @doc """
  Decompose an essential matrix to possible rotations and translation.

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  ##### Return
  - **r1**: `Evision.Mat.t()`.

    One possible rotation matrix.

  - **r2**: `Evision.Mat.t()`.

    Another possible rotation matrix.

  - **t**: `Evision.Mat.t()`.

    One possible translation.

  This function decomposes the essential matrix E using svd decomposition @cite HartleyZ00. In
  general, four possible poses exist for the decomposition of E. They are \\f$\\[R\\_1, t]\\f$,
  \\f$\\[R\\_1, -t]\\f$, \\f$\\[R\\_2, t]\\f$, \\f$\\[R\\_2, -t]\\f$.
  If E gives the epipolar constraint \\f$\\[p\\_2; 1]^T A^{-T} E A^{-1} \\[p\\_1; 1] = 0\\f$ between the image
  points \\f$p\\_1\\f$ in the first image and \\f$p\\_2\\f$ in second image, then any of the tuples
  \\f$\\[R\\_1, t]\\f$, \\f$\\[R\\_1, -t]\\f$, \\f$\\[R\\_2, t]\\f$, \\f$\\[R\\_2, -t]\\f$ is a change of basis from the first
  camera's coordinate system to the second camera's coordinate system. However, by decomposing E, one
  can only get the direction of the translation. For this reason, the translation t is returned with
  unit length.

  Python prototype (for reference only):
  ```python3
  decomposeEssentialMat(E[, R1[, R2[, t]]]) -> R1, R2, t
  ```
  """
  @spec decomposeEssentialMat(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def decomposeEssentialMat(e, opts) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e)
    ]
    :evision_nif.decomposeEssentialMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Decompose an essential matrix to possible rotations and translation.

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  ##### Return
  - **r1**: `Evision.Mat.t()`.

    One possible rotation matrix.

  - **r2**: `Evision.Mat.t()`.

    Another possible rotation matrix.

  - **t**: `Evision.Mat.t()`.

    One possible translation.

  This function decomposes the essential matrix E using svd decomposition @cite HartleyZ00. In
  general, four possible poses exist for the decomposition of E. They are \\f$\\[R\\_1, t]\\f$,
  \\f$\\[R\\_1, -t]\\f$, \\f$\\[R\\_2, t]\\f$, \\f$\\[R\\_2, -t]\\f$.
  If E gives the epipolar constraint \\f$\\[p\\_2; 1]^T A^{-T} E A^{-1} \\[p\\_1; 1] = 0\\f$ between the image
  points \\f$p\\_1\\f$ in the first image and \\f$p\\_2\\f$ in second image, then any of the tuples
  \\f$\\[R\\_1, t]\\f$, \\f$\\[R\\_1, -t]\\f$, \\f$\\[R\\_2, t]\\f$, \\f$\\[R\\_2, -t]\\f$ is a change of basis from the first
  camera's coordinate system to the second camera's coordinate system. However, by decomposing E, one
  can only get the direction of the translation. For this reason, the translation t is returned with
  unit length.

  Python prototype (for reference only):
  ```python3
  decomposeEssentialMat(E[, R1[, R2[, t]]]) -> R1, R2, t
  ```
  """
  @spec decomposeEssentialMat(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def decomposeEssentialMat(e) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e))
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e)
    ]
    :evision_nif.decomposeEssentialMat(positional)
    |> to_struct()
  end

  @doc """
  Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).

  ##### Positional Arguments
  - **h**: `Evision.Mat`.

    The input homography matrix between two images.

  - **k**: `Evision.Mat`.

    The input camera intrinsic matrix.

  ##### Return
  - **retval**: `integer()`
  - **rotations**: `[Evision.Mat]`.

    Array of rotation matrices.

  - **translations**: `[Evision.Mat]`.

    Array of translation matrices.

  - **normals**: `[Evision.Mat]`.

    Array of plane normal matrices.

  This function extracts relative camera motion between two views of a planar object and returns up to
  four mathematical solution tuples of rotation, translation, and plane normal. The decomposition of
  the homography matrix H is described in detail in @cite Malis2007.
  If the homography H, induced by the plane, gives the constraint
  \\f[s\\_i \\vecthree{x'\\_i}{y'\\_i}{1} \\sim H \\vecthree{x\\_i}{y\\_i}{1}\\f] on the source image points
  \\f$p\\_i\\f$ and the destination image points \\f$p'\\_i\\f$, then the tuple of rotations[k] and
  translations[k] is a change of basis from the source camera's coordinate system to the destination
  camera's coordinate system. However, by decomposing H, one can only get the translation normalized
  by the (typically unknown) depth of the scene, i.e. its direction but with normalized length.
  If point correspondences are available, at least two solutions may further be invalidated, by
  applying positive depth constraint, i.e. all points must be in front of the camera.

  Python prototype (for reference only):
  ```python3
  decomposeHomographyMat(H, K[, rotations[, translations[, normals]]]) -> retval, rotations, translations, normals
  ```
  """
  @spec decomposeHomographyMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {integer(), list(Evision.Mat.t()), list(Evision.Mat.t()), list(Evision.Mat.t())} | {:error, String.t()}
  def decomposeHomographyMat(h, k, opts) when (is_struct(h, Evision.Mat) or is_struct(h, Nx.Tensor) or is_number(h) or is_tuple(h)) and (is_struct(k, Evision.Mat) or is_struct(k, Nx.Tensor) or is_number(k) or is_tuple(k)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      h: Evision.Internal.Structurise.from_struct(h),
      k: Evision.Internal.Structurise.from_struct(k)
    ]
    :evision_nif.decomposeHomographyMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).

  ##### Positional Arguments
  - **h**: `Evision.Mat`.

    The input homography matrix between two images.

  - **k**: `Evision.Mat`.

    The input camera intrinsic matrix.

  ##### Return
  - **retval**: `integer()`
  - **rotations**: `[Evision.Mat]`.

    Array of rotation matrices.

  - **translations**: `[Evision.Mat]`.

    Array of translation matrices.

  - **normals**: `[Evision.Mat]`.

    Array of plane normal matrices.

  This function extracts relative camera motion between two views of a planar object and returns up to
  four mathematical solution tuples of rotation, translation, and plane normal. The decomposition of
  the homography matrix H is described in detail in @cite Malis2007.
  If the homography H, induced by the plane, gives the constraint
  \\f[s\\_i \\vecthree{x'\\_i}{y'\\_i}{1} \\sim H \\vecthree{x\\_i}{y\\_i}{1}\\f] on the source image points
  \\f$p\\_i\\f$ and the destination image points \\f$p'\\_i\\f$, then the tuple of rotations[k] and
  translations[k] is a change of basis from the source camera's coordinate system to the destination
  camera's coordinate system. However, by decomposing H, one can only get the translation normalized
  by the (typically unknown) depth of the scene, i.e. its direction but with normalized length.
  If point correspondences are available, at least two solutions may further be invalidated, by
  applying positive depth constraint, i.e. all points must be in front of the camera.

  Python prototype (for reference only):
  ```python3
  decomposeHomographyMat(H, K[, rotations[, translations[, normals]]]) -> retval, rotations, translations, normals
  ```
  """
  @spec decomposeHomographyMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), list(Evision.Mat.t()), list(Evision.Mat.t()), list(Evision.Mat.t())} | {:error, String.t()}
  def decomposeHomographyMat(h, k) when (is_struct(h, Evision.Mat) or is_struct(h, Nx.Tensor) or is_number(h) or is_tuple(h)) and (is_struct(k, Evision.Mat) or is_struct(k, Nx.Tensor) or is_number(k) or is_tuple(k))
  do
    positional = [
      h: Evision.Internal.Structurise.from_struct(h),
      k: Evision.Internal.Structurise.from_struct(k)
    ]
    :evision_nif.decomposeHomographyMat(positional)
    |> to_struct()
  end

  @doc """
  Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.

  ##### Positional Arguments
  - **projMatrix**: `Evision.Mat`.

    3x4 input projection matrix P.

  ##### Return
  - **cameraMatrix**: `Evision.Mat.t()`.

    Output 3x3 camera intrinsic matrix \\f$\\cameramatrix{A}\\f$.

  - **rotMatrix**: `Evision.Mat.t()`.

    Output 3x3 external rotation matrix R.

  - **transVect**: `Evision.Mat.t()`.

    Output 4x1 translation vector T.

  - **rotMatrixX**: `Evision.Mat.t()`.

    Optional 3x3 rotation matrix around x-axis.

  - **rotMatrixY**: `Evision.Mat.t()`.

    Optional 3x3 rotation matrix around y-axis.

  - **rotMatrixZ**: `Evision.Mat.t()`.

    Optional 3x3 rotation matrix around z-axis.

  - **eulerAngles**: `Evision.Mat.t()`.

    Optional three-element vector containing three Euler angles of rotation in
    degrees.

  The function computes a decomposition of a projection matrix into a calibration and a rotation
  matrix and the position of a camera.
  It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
  be used in OpenGL. Note, there is always more than one sequence of rotations about the three
  principal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned
  three rotation matrices and corresponding three Euler angles are only one of the possible solutions.
  The function is based on #RQDecomp3x3 .

  Python prototype (for reference only):
  ```python3
  decomposeProjectionMatrix(projMatrix[, cameraMatrix[, rotMatrix[, transVect[, rotMatrixX[, rotMatrixY[, rotMatrixZ[, eulerAngles]]]]]]]) -> cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles
  ```
  """
  @spec decomposeProjectionMatrix(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def decomposeProjectionMatrix(projMatrix, opts) when (is_struct(projMatrix, Evision.Mat) or is_struct(projMatrix, Nx.Tensor) or is_number(projMatrix) or is_tuple(projMatrix)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      projMatrix: Evision.Internal.Structurise.from_struct(projMatrix)
    ]
    :evision_nif.decomposeProjectionMatrix(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.

  ##### Positional Arguments
  - **projMatrix**: `Evision.Mat`.

    3x4 input projection matrix P.

  ##### Return
  - **cameraMatrix**: `Evision.Mat.t()`.

    Output 3x3 camera intrinsic matrix \\f$\\cameramatrix{A}\\f$.

  - **rotMatrix**: `Evision.Mat.t()`.

    Output 3x3 external rotation matrix R.

  - **transVect**: `Evision.Mat.t()`.

    Output 4x1 translation vector T.

  - **rotMatrixX**: `Evision.Mat.t()`.

    Optional 3x3 rotation matrix around x-axis.

  - **rotMatrixY**: `Evision.Mat.t()`.

    Optional 3x3 rotation matrix around y-axis.

  - **rotMatrixZ**: `Evision.Mat.t()`.

    Optional 3x3 rotation matrix around z-axis.

  - **eulerAngles**: `Evision.Mat.t()`.

    Optional three-element vector containing three Euler angles of rotation in
    degrees.

  The function computes a decomposition of a projection matrix into a calibration and a rotation
  matrix and the position of a camera.
  It optionally returns three rotation matrices, one for each axis, and three Euler angles that could
  be used in OpenGL. Note, there is always more than one sequence of rotations about the three
  principal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned
  three rotation matrices and corresponding three Euler angles are only one of the possible solutions.
  The function is based on #RQDecomp3x3 .

  Python prototype (for reference only):
  ```python3
  decomposeProjectionMatrix(projMatrix[, cameraMatrix[, rotMatrix[, transVect[, rotMatrixX[, rotMatrixY[, rotMatrixZ[, eulerAngles]]]]]]]) -> cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles
  ```
  """
  @spec decomposeProjectionMatrix(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def decomposeProjectionMatrix(projMatrix) when (is_struct(projMatrix, Evision.Mat) or is_struct(projMatrix, Nx.Tensor) or is_number(projMatrix) or is_tuple(projMatrix))
  do
    positional = [
      projMatrix: Evision.Internal.Structurise.from_struct(projMatrix)
    ]
    :evision_nif.decomposeProjectionMatrix(positional)
    |> to_struct()
  end

  @doc """
  main function for all demosaicing processes

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image: 8-bit unsigned or 16-bit unsigned.

  - **code**: `integer()`.

    Color space conversion code (see the description below).

  ##### Keyword Arguments
  - **dstCn**: `integer()`.

    number of channels in the destination image; if the parameter is 0, the number of the
    channels is derived automatically from src and code.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and depth as src.

  The function can do the following transformations:
  - Demosaicing using bilinear interpolation

  #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR
  #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY
  - Demosaicing using Variable Number of Gradients.

  #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG
  - Edge-Aware Demosaicing.

  #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA
  - Demosaicing with alpha channel

  #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA
  @sa cvtColor

  Python prototype (for reference only):
  ```python3
  demosaicing(src, code[, dst[, dstCn]]) -> dst
  ```
  """
  @spec demosaicing(Evision.Mat.maybe_mat_in(), integer(), [{:dstCn, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def demosaicing(src, code, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(code) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dstCn])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      code: Evision.Internal.Structurise.from_struct(code)
    ]
    :evision_nif.demosaicing(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  main function for all demosaicing processes

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image: 8-bit unsigned or 16-bit unsigned.

  - **code**: `integer()`.

    Color space conversion code (see the description below).

  ##### Keyword Arguments
  - **dstCn**: `integer()`.

    number of channels in the destination image; if the parameter is 0, the number of the
    channels is derived automatically from src and code.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and depth as src.

  The function can do the following transformations:
  - Demosaicing using bilinear interpolation

  #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR
  #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY
  - Demosaicing using Variable Number of Gradients.

  #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG
  - Edge-Aware Demosaicing.

  #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA
  - Demosaicing with alpha channel

  #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA
  @sa cvtColor

  Python prototype (for reference only):
  ```python3
  demosaicing(src, code[, dst[, dstCn]]) -> dst
  ```
  """
  @spec demosaicing(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def demosaicing(src, code) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(code)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      code: Evision.Internal.Structurise.from_struct(code)
    ]
    :evision_nif.demosaicing(positional)
    |> to_struct()
  end

  @doc """
  This filter enhances the details of a particular image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  Python prototype (for reference only):
  ```python3
  detailEnhance(src[, dst[, sigma_s[, sigma_r]]]) -> dst
  ```
  """
  @spec detailEnhance(Evision.Mat.maybe_mat_in(), [{:sigma_r, term()} | {:sigma_s, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def detailEnhance(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:sigma_r, :sigma_s])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.detailEnhance(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  This filter enhances the details of a particular image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  Python prototype (for reference only):
  ```python3
  detailEnhance(src[, dst[, sigma_s[, sigma_r]]]) -> dst
  ```
  """
  @spec detailEnhance(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def detailEnhance(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.detailEnhance(positional)
    |> to_struct()
  end

  @doc """
  Returns the determinant of a square floating-point matrix.

  ##### Positional Arguments
  - **mtx**: `Evision.Mat`.

    input matrix that must have CV_32FC1 or CV_64FC1 type and
    square size.

  ##### Return
  - **retval**: `double`

  The function cv::determinant calculates and returns the determinant of the
  specified matrix. For small matrices ( mtx.cols=mtx.rows\\<=3 ), the
  direct method is used. For larger matrices, the function uses LU
  factorization with partial pivoting.
  For symmetric positively-determined matrices, it is also possible to use
  eigen decomposition to calculate the determinant.
  @sa trace, invert, solve, eigen, @ref MatrixExpressions

  Python prototype (for reference only):
  ```python3
  determinant(mtx) -> retval
  ```
  """
  @spec determinant(Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def determinant(mtx) when (is_struct(mtx, Evision.Mat) or is_struct(mtx, Nx.Tensor) or is_number(mtx) or is_tuple(mtx))
  do
    positional = [
      mtx: Evision.Internal.Structurise.from_struct(mtx)
    ]
    :evision_nif.determinant(positional)
    |> to_struct()
  end

  @doc """
  Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that could be real or complex.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    transformation flags, representing a combination of the #DftFlags

  - **nonzeroRows**: `integer()`.

    when the parameter is not zero, the function assumes that only the first
    nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the
    output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the
    rows more efficiently and save some time; this technique is very useful for calculating array
    cross-correlation or convolution using DFT.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array whose size and type depends on the flags .

  The function cv::dft performs one of the following:
  - Forward the Fourier transform of a 1D vector of N elements:
    \\f[Y = F^{(N)}  \\cdot X,\\f]
    where \\f$F^{(N)}\\_{jk}=\\exp(-2\\pi i j k/N)\\f$ and \\f$i=\\sqrt{-1}\\f$

  - Inverse the Fourier transform of a 1D vector of N elements:
    \\f[\\begin{array}{l} X'=  \\left (F^{(N)} \\right )^{-1}  \\cdot Y =  \\left (F^{(N)} \\right )^\\*  \\cdot y  \\\\\\\\ X = (1/N)  \\cdot X, \\end{array}\\f]
    where \\f$F^\\*=\\left(\\textrm{Re}(F^{(N)})-\\textrm{Im}(F^{(N)})\\right)^T\\f$

  - Forward the 2D Fourier transform of a M x N matrix:
    \\f[Y = F^{(M)}  \\cdot X  \\cdot F^{(N)}\\f]

  - Inverse the 2D Fourier transform of a M x N matrix:
    \\f[\\begin{array}{l} X'=  \\left (F^{(M)} \\right )^\\*  \\cdot Y  \\cdot \\left (F^{(N)} \\right )^\\* \\\\\\\\ X =  \\frac{1}{M \\cdot N} \\cdot X' \\end{array}\\f]

  In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
  spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
  (complex-conjugate-symmetrical). It was borrowed from IPL (Intel\\* Image Processing Library). Here
  is how 2D *CCS* spectrum looks:
  \\f[\\begin{bmatrix} Re Y\\_{0,0} & Re Y\\_{0,1} & Im Y\\_{0,1} & Re Y\\_{0,2} & Im Y\\_{0,2} &  \\cdots & Re Y\\_{0,N/2-1} & Im Y\\_{0,N/2-1} & Re Y\\_{0,N/2}  \\\\\\\\ Re Y\\_{1,0} & Re Y\\_{1,1} & Im Y\\_{1,1} & Re Y\\_{1,2} & Im Y\\_{1,2} &  \\cdots & Re Y\\_{1,N/2-1} & Im Y\\_{1,N/2-1} & Re Y\\_{1,N/2}  \\\\\\\\ Im Y\\_{1,0} & Re Y\\_{2,1} & Im Y\\_{2,1} & Re Y\\_{2,2} & Im Y\\_{2,2} &  \\cdots & Re Y\\_{2,N/2-1} & Im Y\\_{2,N/2-1} & Im Y\\_{1,N/2}  \\\\\\\\ \\hdotsfor{9} \\\\\\\\ Re Y\\_{M/2-1,0} &  Re Y\\_{M-3,1}  & Im Y\\_{M-3,1} &  \\hdotsfor{3} & Re Y\\_{M-3,N/2-1} & Im Y\\_{M-3,N/2-1}& Re Y\\_{M/2-1,N/2}  \\\\\\\\ Im Y\\_{M/2-1,0} &  Re Y\\_{M-2,1}  & Im Y\\_{M-2,1} &  \\hdotsfor{3} & Re Y\\_{M-2,N/2-1} & Im Y\\_{M-2,N/2-1}& Im Y\\_{M/2-1,N/2}  \\\\\\\\ Re Y\\_{M/2,0}  &  Re Y\\_{M-1,1} &  Im Y\\_{M-1,1} &  \\hdotsfor{3} & Re Y\\_{M-1,N/2-1} & Im Y\\_{M-1,N/2-1}& Re Y\\_{M/2,N/2} \\end{bmatrix}\\f]
  In case of 1D transform of a real vector, the output looks like the first row of the matrix above.
  So, the function chooses an operation mode depending on the flags and size of the input array:
  - If #DFT_ROWS is set or the input array has a single row or single column, the function
    performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set.
    Otherwise, it performs a 2D transform.

  - If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or
    2D transform:

  - When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as
    input.

  - When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as
    input. In case of 2D transform, it uses the packed format as shown above. In case of a
    single 1D transform, it looks like the first row of the matrix above. In case of
    multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix
    looks like the first row of the matrix above.

  - If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the
    output is a complex array of the same size as input. The function performs a forward or
    inverse 1D or 2D transform of the whole input array or each row of the input array
    independently, depending on the flags DFT_INVERSE and DFT_ROWS.

  - When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT
    is set, the output is a real array of the same size as input. The function performs a 1D or 2D
    inverse transformation of the whole input array or each individual row, depending on the flags
    #DFT_INVERSE and #DFT_ROWS.

  If #DFT_SCALE is set, the scaling is done after the transformation.
  Unlike dct, the function supports arrays of arbitrary size. But only those arrays are processed
  efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
  current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize
  method.
  The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:
  ```
  void convolveDFT(InputArray A, InputArray B, OutputArray C)
  {
  // reallocate the output array if needed
  C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
  Size dftSize;
  // calculate the size of DFT transform
  dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
  dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);
  // allocate temporary buffers and initialize them with 0's
  Mat tempA(dftSize, A.type(), Scalar::all(0));
  Mat tempB(dftSize, B.type(), Scalar::all(0));
  // copy A and B to the top-left corners of tempA and tempB, respectively
  Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
  A.copyTo(roiA);
  Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
  B.copyTo(roiB);
  // now transform the padded A & B in-place;
  // use "nonzeroRows" hint for faster processing
  dft(tempA, tempA, 0, A.rows);
  dft(tempB, tempB, 0, B.rows);
  // multiply the spectrums;
  // the function handles packed spectrum representations well
  mulSpectrums(tempA, tempB, tempA);
  // transform the product back from the frequency domain.
  // Even though all the result rows will be non-zero,
  // you need only the first C.rows of them, and thus you
  // pass nonzeroRows == C.rows
  dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);
  // now copy the result back to C.
  tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);
  // all the temporary buffers will be deallocated automatically
  }
  ```
  To optimize this sample, consider the following approaches:
  - Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to
    the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
    tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
    rightmost columns of the matrices.

  - This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
    is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
    To do this, you need to split the output array C into multiple tiles. For each tile, estimate
    which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
    too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
    each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
    algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
    there is also a slowdown because of bad cache locality. So, there is an optimal tile size
    somewhere in the middle.

  - If different tiles in C can be calculated in parallel and, thus, the convolution is done by
    parts, the loop can be threaded.

  All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by
  using them, you can get the performance even better than with the above theoretically optimal
  implementation. Though, those two functions actually calculate cross-correlation, not convolution,
  so you need to "flip" the second convolution operand B vertically and horizontally using flip .
  **Note**: 
  - An example using the discrete fourier transform can be found at
    opencv_source_code/samples/cpp/dft.cpp

  - (Python) An example using the dft functionality to perform Wiener deconvolution can be found
    at opencv_source/samples/python/deconvolution.py

  - (Python) An example rearranging the quadrants of a Fourier image can be found at
    opencv_source/samples/python/dft.py

  @sa dct, getOptimalDFTSize, mulSpectrums, filter2D, matchTemplate, flip, cartToPolar,
  magnitude, phase

  Python prototype (for reference only):
  ```python3
  dft(src[, dst[, flags[, nonzeroRows]]]) -> dst
  ```
  """
  @spec dft(Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:nonzeroRows, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def dft(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :nonzeroRows])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.dft(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that could be real or complex.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    transformation flags, representing a combination of the #DftFlags

  - **nonzeroRows**: `integer()`.

    when the parameter is not zero, the function assumes that only the first
    nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the
    output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the
    rows more efficiently and save some time; this technique is very useful for calculating array
    cross-correlation or convolution using DFT.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array whose size and type depends on the flags .

  The function cv::dft performs one of the following:
  - Forward the Fourier transform of a 1D vector of N elements:
    \\f[Y = F^{(N)}  \\cdot X,\\f]
    where \\f$F^{(N)}\\_{jk}=\\exp(-2\\pi i j k/N)\\f$ and \\f$i=\\sqrt{-1}\\f$

  - Inverse the Fourier transform of a 1D vector of N elements:
    \\f[\\begin{array}{l} X'=  \\left (F^{(N)} \\right )^{-1}  \\cdot Y =  \\left (F^{(N)} \\right )^\\*  \\cdot y  \\\\\\\\ X = (1/N)  \\cdot X, \\end{array}\\f]
    where \\f$F^\\*=\\left(\\textrm{Re}(F^{(N)})-\\textrm{Im}(F^{(N)})\\right)^T\\f$

  - Forward the 2D Fourier transform of a M x N matrix:
    \\f[Y = F^{(M)}  \\cdot X  \\cdot F^{(N)}\\f]

  - Inverse the 2D Fourier transform of a M x N matrix:
    \\f[\\begin{array}{l} X'=  \\left (F^{(M)} \\right )^\\*  \\cdot Y  \\cdot \\left (F^{(N)} \\right )^\\* \\\\\\\\ X =  \\frac{1}{M \\cdot N} \\cdot X' \\end{array}\\f]

  In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
  spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
  (complex-conjugate-symmetrical). It was borrowed from IPL (Intel\\* Image Processing Library). Here
  is how 2D *CCS* spectrum looks:
  \\f[\\begin{bmatrix} Re Y\\_{0,0} & Re Y\\_{0,1} & Im Y\\_{0,1} & Re Y\\_{0,2} & Im Y\\_{0,2} &  \\cdots & Re Y\\_{0,N/2-1} & Im Y\\_{0,N/2-1} & Re Y\\_{0,N/2}  \\\\\\\\ Re Y\\_{1,0} & Re Y\\_{1,1} & Im Y\\_{1,1} & Re Y\\_{1,2} & Im Y\\_{1,2} &  \\cdots & Re Y\\_{1,N/2-1} & Im Y\\_{1,N/2-1} & Re Y\\_{1,N/2}  \\\\\\\\ Im Y\\_{1,0} & Re Y\\_{2,1} & Im Y\\_{2,1} & Re Y\\_{2,2} & Im Y\\_{2,2} &  \\cdots & Re Y\\_{2,N/2-1} & Im Y\\_{2,N/2-1} & Im Y\\_{1,N/2}  \\\\\\\\ \\hdotsfor{9} \\\\\\\\ Re Y\\_{M/2-1,0} &  Re Y\\_{M-3,1}  & Im Y\\_{M-3,1} &  \\hdotsfor{3} & Re Y\\_{M-3,N/2-1} & Im Y\\_{M-3,N/2-1}& Re Y\\_{M/2-1,N/2}  \\\\\\\\ Im Y\\_{M/2-1,0} &  Re Y\\_{M-2,1}  & Im Y\\_{M-2,1} &  \\hdotsfor{3} & Re Y\\_{M-2,N/2-1} & Im Y\\_{M-2,N/2-1}& Im Y\\_{M/2-1,N/2}  \\\\\\\\ Re Y\\_{M/2,0}  &  Re Y\\_{M-1,1} &  Im Y\\_{M-1,1} &  \\hdotsfor{3} & Re Y\\_{M-1,N/2-1} & Im Y\\_{M-1,N/2-1}& Re Y\\_{M/2,N/2} \\end{bmatrix}\\f]
  In case of 1D transform of a real vector, the output looks like the first row of the matrix above.
  So, the function chooses an operation mode depending on the flags and size of the input array:
  - If #DFT_ROWS is set or the input array has a single row or single column, the function
    performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set.
    Otherwise, it performs a 2D transform.

  - If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or
    2D transform:

  - When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as
    input.

  - When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as
    input. In case of 2D transform, it uses the packed format as shown above. In case of a
    single 1D transform, it looks like the first row of the matrix above. In case of
    multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix
    looks like the first row of the matrix above.

  - If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the
    output is a complex array of the same size as input. The function performs a forward or
    inverse 1D or 2D transform of the whole input array or each row of the input array
    independently, depending on the flags DFT_INVERSE and DFT_ROWS.

  - When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT
    is set, the output is a real array of the same size as input. The function performs a 1D or 2D
    inverse transformation of the whole input array or each individual row, depending on the flags
    #DFT_INVERSE and #DFT_ROWS.

  If #DFT_SCALE is set, the scaling is done after the transformation.
  Unlike dct, the function supports arrays of arbitrary size. But only those arrays are processed
  efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
  current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize
  method.
  The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:
  ```
  void convolveDFT(InputArray A, InputArray B, OutputArray C)
  {
  // reallocate the output array if needed
  C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
  Size dftSize;
  // calculate the size of DFT transform
  dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
  dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);
  // allocate temporary buffers and initialize them with 0's
  Mat tempA(dftSize, A.type(), Scalar::all(0));
  Mat tempB(dftSize, B.type(), Scalar::all(0));
  // copy A and B to the top-left corners of tempA and tempB, respectively
  Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
  A.copyTo(roiA);
  Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
  B.copyTo(roiB);
  // now transform the padded A & B in-place;
  // use "nonzeroRows" hint for faster processing
  dft(tempA, tempA, 0, A.rows);
  dft(tempB, tempB, 0, B.rows);
  // multiply the spectrums;
  // the function handles packed spectrum representations well
  mulSpectrums(tempA, tempB, tempA);
  // transform the product back from the frequency domain.
  // Even though all the result rows will be non-zero,
  // you need only the first C.rows of them, and thus you
  // pass nonzeroRows == C.rows
  dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);
  // now copy the result back to C.
  tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);
  // all the temporary buffers will be deallocated automatically
  }
  ```
  To optimize this sample, consider the following approaches:
  - Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to
    the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
    tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
    rightmost columns of the matrices.

  - This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
    is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
    To do this, you need to split the output array C into multiple tiles. For each tile, estimate
    which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
    too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
    each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
    algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
    there is also a slowdown because of bad cache locality. So, there is an optimal tile size
    somewhere in the middle.

  - If different tiles in C can be calculated in parallel and, thus, the convolution is done by
    parts, the loop can be threaded.

  All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by
  using them, you can get the performance even better than with the above theoretically optimal
  implementation. Though, those two functions actually calculate cross-correlation, not convolution,
  so you need to "flip" the second convolution operand B vertically and horizontally using flip .
  **Note**: 
  - An example using the discrete fourier transform can be found at
    opencv_source_code/samples/cpp/dft.cpp

  - (Python) An example using the dft functionality to perform Wiener deconvolution can be found
    at opencv_source/samples/python/deconvolution.py

  - (Python) An example rearranging the quadrants of a Fourier image can be found at
    opencv_source/samples/python/dft.py

  @sa dct, getOptimalDFTSize, mulSpectrums, filter2D, matchTemplate, flip, cartToPolar,
  magnitude, phase

  Python prototype (for reference only):
  ```python3
  dft(src[, dst[, flags[, nonzeroRows]]]) -> dst
  ```
  """
  @spec dft(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def dft(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.dft(positional)
    |> to_struct()
  end

  @doc """
  Dilates an image by using a specific structuring element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; the number of channels can be arbitrary, but the depth should be one of
    CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **kernel**: `Evision.Mat`.

    structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
    structuring element is used. Kernel can be created using #getStructuringElement

  ##### Keyword Arguments
  - **anchor**: `Point`.

    position of the anchor within the element; default value (-1, -1) means that the
    anchor is at the element center.

  - **iterations**: `integer()`.

    number of times dilation is applied.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.

  - **borderValue**: `Evision.scalar()`.

    border value in case of a constant border

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function dilates the source image using the specified structuring element that determines the
  shape of a pixel neighborhood over which the maximum is taken:
  \\f[\\texttt{dst} (x,y) =  \\max \\_{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]
  The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
  case of multi-channel images, each channel is processed independently.
  @sa  erode, morphologyEx, getStructuringElement

  Python prototype (for reference only):
  ```python3
  dilate(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst
  ```
  """
  @spec dilate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:anchor, term()} | {:borderType, term()} | {:borderValue, term()} | {:iterations, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def dilate(src, kernel, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :borderValue, :iterations])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.dilate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Dilates an image by using a specific structuring element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; the number of channels can be arbitrary, but the depth should be one of
    CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **kernel**: `Evision.Mat`.

    structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
    structuring element is used. Kernel can be created using #getStructuringElement

  ##### Keyword Arguments
  - **anchor**: `Point`.

    position of the anchor within the element; default value (-1, -1) means that the
    anchor is at the element center.

  - **iterations**: `integer()`.

    number of times dilation is applied.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.

  - **borderValue**: `Evision.scalar()`.

    border value in case of a constant border

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function dilates the source image using the specified structuring element that determines the
  shape of a pixel neighborhood over which the maximum is taken:
  \\f[\\texttt{dst} (x,y) =  \\max \\_{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]
  The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
  case of multi-channel images, each channel is processed independently.
  @sa  erode, morphologyEx, getStructuringElement

  Python prototype (for reference only):
  ```python3
  dilate(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst
  ```
  """
  @spec dilate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def dilate(src, kernel) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.dilate(positional)
    |> to_struct()
  end

  @doc """
  Displays a text on a window image as an overlay for a specified duration.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **text**: `String`.

    Overlay text to write on a window image.

  ##### Keyword Arguments
  - **delayms**: `integer()`.

    The period (in milliseconds), during which the overlay text is displayed. If this
    function is called before the previous overlay text timed out, the timer is restarted and the text
    is updated. If this value is zero, the text never disappears.

  The function displayOverlay displays useful information/tips on top of the window for a certain
  amount of time *delayms*. The function does not modify the image, displayed in the window, that is,
  after the specified delay the original content of the window is restored.

  Python prototype (for reference only):
  ```python3
  displayOverlay(winname, text[, delayms]) -> None
  ```
  """
  @spec displayOverlay(binary(), binary(), [{:delayms, term()}] | nil) :: :ok | {:error, String.t()}
  def displayOverlay(winname, text, opts) when is_binary(winname) and is_binary(text) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:delayms])
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      text: Evision.Internal.Structurise.from_struct(text)
    ]
    :evision_nif.displayOverlay(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Displays a text on a window image as an overlay for a specified duration.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **text**: `String`.

    Overlay text to write on a window image.

  ##### Keyword Arguments
  - **delayms**: `integer()`.

    The period (in milliseconds), during which the overlay text is displayed. If this
    function is called before the previous overlay text timed out, the timer is restarted and the text
    is updated. If this value is zero, the text never disappears.

  The function displayOverlay displays useful information/tips on top of the window for a certain
  amount of time *delayms*. The function does not modify the image, displayed in the window, that is,
  after the specified delay the original content of the window is restored.

  Python prototype (for reference only):
  ```python3
  displayOverlay(winname, text[, delayms]) -> None
  ```
  """
  @spec displayOverlay(binary(), binary()) :: :ok | {:error, String.t()}
  def displayOverlay(winname, text) when is_binary(winname) and is_binary(text)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      text: Evision.Internal.Structurise.from_struct(text)
    ]
    :evision_nif.displayOverlay(positional)
    |> to_struct()
  end

  @doc """
  Displays a text on the window statusbar during the specified period of time.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **text**: `String`.

    Text to write on the window statusbar.

  ##### Keyword Arguments
  - **delayms**: `integer()`.

    Duration (in milliseconds) to display the text. If this function is called before
    the previous text timed out, the timer is restarted and the text is updated. If this value is
    zero, the text never disappears.

  The function displayStatusBar displays useful information/tips on top of the window for a certain
  amount of time *delayms* . This information is displayed on the window statusbar (the window must be
  created with the CV_GUI_EXPANDED flags).

  Python prototype (for reference only):
  ```python3
  displayStatusBar(winname, text[, delayms]) -> None
  ```
  """
  @spec displayStatusBar(binary(), binary(), [{:delayms, term()}] | nil) :: :ok | {:error, String.t()}
  def displayStatusBar(winname, text, opts) when is_binary(winname) and is_binary(text) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:delayms])
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      text: Evision.Internal.Structurise.from_struct(text)
    ]
    :evision_nif.displayStatusBar(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Displays a text on the window statusbar during the specified period of time.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **text**: `String`.

    Text to write on the window statusbar.

  ##### Keyword Arguments
  - **delayms**: `integer()`.

    Duration (in milliseconds) to display the text. If this function is called before
    the previous text timed out, the timer is restarted and the text is updated. If this value is
    zero, the text never disappears.

  The function displayStatusBar displays useful information/tips on top of the window for a certain
  amount of time *delayms* . This information is displayed on the window statusbar (the window must be
  created with the CV_GUI_EXPANDED flags).

  Python prototype (for reference only):
  ```python3
  displayStatusBar(winname, text[, delayms]) -> None
  ```
  """
  @spec displayStatusBar(binary(), binary()) :: :ok | {:error, String.t()}
  def displayStatusBar(winname, text) when is_binary(winname) and is_binary(text)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      text: Evision.Internal.Structurise.from_struct(text)
    ]
    :evision_nif.displayStatusBar(positional)
    |> to_struct()
  end

  @doc """
  distanceTransform

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    8-bit, single-channel (binary) source image.

  - **distanceType**: `integer()`.

    Type of distance, see #DistanceTypes

  - **maskSize**: `integer()`.

    Size of the distance transform mask, see #DistanceTransformMasks. In case of the
    #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives
    the same result as \\f$5\\times 5\\f$ or any larger aperture.

  ##### Keyword Arguments
  - **dstType**: `integer()`.

    Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
    the first variant of the function and distanceType == #DIST_L1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
    single-channel image of the same size as src .

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  distanceTransform(src, distanceType, maskSize[, dst[, dstType]]) -> dst
  ```
  """
  @spec distanceTransform(Evision.Mat.maybe_mat_in(), integer(), integer(), [{:dstType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def distanceTransform(src, distanceType, maskSize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(distanceType) and is_integer(maskSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dstType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      distanceType: Evision.Internal.Structurise.from_struct(distanceType),
      maskSize: Evision.Internal.Structurise.from_struct(maskSize)
    ]
    :evision_nif.distanceTransform(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  distanceTransform

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    8-bit, single-channel (binary) source image.

  - **distanceType**: `integer()`.

    Type of distance, see #DistanceTypes

  - **maskSize**: `integer()`.

    Size of the distance transform mask, see #DistanceTransformMasks. In case of the
    #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives
    the same result as \\f$5\\times 5\\f$ or any larger aperture.

  ##### Keyword Arguments
  - **dstType**: `integer()`.

    Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
    the first variant of the function and distanceType == #DIST_L1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
    single-channel image of the same size as src .

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  distanceTransform(src, distanceType, maskSize[, dst[, dstType]]) -> dst
  ```
  """
  @spec distanceTransform(Evision.Mat.maybe_mat_in(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def distanceTransform(src, distanceType, maskSize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(distanceType) and is_integer(maskSize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      distanceType: Evision.Internal.Structurise.from_struct(distanceType),
      maskSize: Evision.Internal.Structurise.from_struct(maskSize)
    ]
    :evision_nif.distanceTransform(positional)
    |> to_struct()
  end

  @doc """
  Calculates the distance to the closest zero pixel for each pixel of the source image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    8-bit, single-channel (binary) source image.

  - **distanceType**: `integer()`.

    Type of distance, see #DistanceTypes

  - **maskSize**: `integer()`.

    Size of the distance transform mask, see #DistanceTransformMasks.
    #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,
    the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times
    5\\f$ or any larger aperture.

  ##### Keyword Arguments
  - **labelType**: `integer()`.

    Type of the label array to build, see #DistanceTransformLabelTypes.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
    single-channel image of the same size as src.

  - **labels**: `Evision.Mat.t()`.

    Output 2D array of labels (the discrete Voronoi diagram). It has the type
    CV_32SC1 and the same size as src.

  The function cv::distanceTransform calculates the approximate or precise distance from every binary
  image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.
  When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the
  algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.
  In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function
  finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
  diagonal, or knight's move (the latest is available for a \\f$5\\times 5\\f$ mask). The overall
  distance is calculated as a sum of these basic distances. Since the distance function should be
  symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
  the diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the
  same cost (denoted as `c`). For the #DIST_C and #DIST_L1 types, the distance is calculated
  precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a
  relative error (a \\f$5\\times 5\\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV
  uses the values suggested in the original paper:
  - DIST_L1: `a = 1, b = 2`
  - DIST_L2:
  - `3 x 3`: `a=0.955, b=1.3693`
  - `5 x 5`: `a=1, b=1.4, c=2.1969`
  - DIST_C: `a = 1, b = 1`

  Typically, for a fast, coarse distance estimation #DIST_L2, a \\f$3\\times 3\\f$ mask is used. For a
  more accurate distance estimation #DIST_L2, a \\f$5\\times 5\\f$ mask or the precise algorithm is used.
  Note that both the precise and the approximate algorithms are linear on the number of pixels.
  This variant of the function does not only compute the minimum distance for each pixel \\f$(x, y)\\f$
  but also identifies the nearest connected component consisting of zero pixels
  (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the
  component/pixel is stored in `labels(x, y)`. When labelType==#DIST_LABEL_CCOMP, the function
  automatically finds connected components of zero pixels in the input image and marks them with
  distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and
  marks all the zero pixels with distinct labels.
  In this mode, the complexity is still linear. That is, the function provides a very fast way to
  compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
  approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported
  yet.

  Python prototype (for reference only):
  ```python3
  distanceTransformWithLabels(src, distanceType, maskSize[, dst[, labels[, labelType]]]) -> dst, labels
  ```
  """
  @spec distanceTransformWithLabels(Evision.Mat.maybe_mat_in(), integer(), integer(), [{:labelType, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def distanceTransformWithLabels(src, distanceType, maskSize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(distanceType) and is_integer(maskSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:labelType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      distanceType: Evision.Internal.Structurise.from_struct(distanceType),
      maskSize: Evision.Internal.Structurise.from_struct(maskSize)
    ]
    :evision_nif.distanceTransformWithLabels(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the distance to the closest zero pixel for each pixel of the source image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    8-bit, single-channel (binary) source image.

  - **distanceType**: `integer()`.

    Type of distance, see #DistanceTypes

  - **maskSize**: `integer()`.

    Size of the distance transform mask, see #DistanceTransformMasks.
    #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,
    the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times
    5\\f$ or any larger aperture.

  ##### Keyword Arguments
  - **labelType**: `integer()`.

    Type of the label array to build, see #DistanceTransformLabelTypes.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
    single-channel image of the same size as src.

  - **labels**: `Evision.Mat.t()`.

    Output 2D array of labels (the discrete Voronoi diagram). It has the type
    CV_32SC1 and the same size as src.

  The function cv::distanceTransform calculates the approximate or precise distance from every binary
  image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.
  When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the
  algorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.
  In other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function
  finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
  diagonal, or knight's move (the latest is available for a \\f$5\\times 5\\f$ mask). The overall
  distance is calculated as a sum of these basic distances. Since the distance function should be
  symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
  the diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the
  same cost (denoted as `c`). For the #DIST_C and #DIST_L1 types, the distance is calculated
  precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a
  relative error (a \\f$5\\times 5\\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV
  uses the values suggested in the original paper:
  - DIST_L1: `a = 1, b = 2`
  - DIST_L2:
  - `3 x 3`: `a=0.955, b=1.3693`
  - `5 x 5`: `a=1, b=1.4, c=2.1969`
  - DIST_C: `a = 1, b = 1`

  Typically, for a fast, coarse distance estimation #DIST_L2, a \\f$3\\times 3\\f$ mask is used. For a
  more accurate distance estimation #DIST_L2, a \\f$5\\times 5\\f$ mask or the precise algorithm is used.
  Note that both the precise and the approximate algorithms are linear on the number of pixels.
  This variant of the function does not only compute the minimum distance for each pixel \\f$(x, y)\\f$
  but also identifies the nearest connected component consisting of zero pixels
  (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the
  component/pixel is stored in `labels(x, y)`. When labelType==#DIST_LABEL_CCOMP, the function
  automatically finds connected components of zero pixels in the input image and marks them with
  distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and
  marks all the zero pixels with distinct labels.
  In this mode, the complexity is still linear. That is, the function provides a very fast way to
  compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
  approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported
  yet.

  Python prototype (for reference only):
  ```python3
  distanceTransformWithLabels(src, distanceType, maskSize[, dst[, labels[, labelType]]]) -> dst, labels
  ```
  """
  @spec distanceTransformWithLabels(Evision.Mat.maybe_mat_in(), integer(), integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def distanceTransformWithLabels(src, distanceType, maskSize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(distanceType) and is_integer(maskSize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      distanceType: Evision.Internal.Structurise.from_struct(distanceType),
      maskSize: Evision.Internal.Structurise.from_struct(maskSize)
    ]
    :evision_nif.distanceTransformWithLabels(positional)
    |> to_struct()
  end

  @doc """
  Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    first input array.

  - **b**: `Evision.Mat`.

    second input array of the same size and type as src1 .

  - **flags**: `integer()`.

    operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
    each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.

  ##### Keyword Arguments
  - **conjB**: `bool`.

    optional flag that conjugates the second input array before the multiplication (true)
    or not (false).

  ##### Return
  - **c**: `Evision.Mat.t()`.

    output array of the same size and type as src1 .

  The function cv::divSpectrums performs the per-element division of the first array by the second array.
  The arrays are CCS-packed or complex matrices that are results of a real or complex Fourier transform.

  Python prototype (for reference only):
  ```python3
  divSpectrums(a, b, flags[, c[, conjB]]) -> c
  ```
  """
  @spec divSpectrums(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:conjB, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def divSpectrums(a, b, flags, opts) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (is_struct(b, Evision.Mat) or is_struct(b, Nx.Tensor) or is_number(b) or is_tuple(b)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:conjB])
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.divSpectrums(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    first input array.

  - **b**: `Evision.Mat`.

    second input array of the same size and type as src1 .

  - **flags**: `integer()`.

    operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
    each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.

  ##### Keyword Arguments
  - **conjB**: `bool`.

    optional flag that conjugates the second input array before the multiplication (true)
    or not (false).

  ##### Return
  - **c**: `Evision.Mat.t()`.

    output array of the same size and type as src1 .

  The function cv::divSpectrums performs the per-element division of the first array by the second array.
  The arrays are CCS-packed or complex matrices that are results of a real or complex Fourier transform.

  Python prototype (for reference only):
  ```python3
  divSpectrums(a, b, flags[, c[, conjB]]) -> c
  ```
  """
  @spec divSpectrums(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def divSpectrums(a, b, flags) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (is_struct(b, Evision.Mat) or is_struct(b, Nx.Tensor) or is_number(b) or is_tuple(b)) and is_integer(flags)
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.divSpectrums(positional)
    |> to_struct()
  end

  @doc """
  #### Variant 1:
  divide

  ##### Positional Arguments
  - **scale**: `double`
  - **src2**: `Evision.Mat`

  ##### Keyword Arguments
  - **dtype**: `integer()`.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  divide(scale, src2[, dst[, dtype]]) -> dst
  ```
  #### Variant 2:
  Performs per-element division of two arrays or a scalar by an array.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1.

  ##### Keyword Arguments
  - **scale**: `double`.

    scalar factor.

  - **dtype**: `integer()`.

    optional depth of the output array; if -1, dst will have depth src2.depth(), but in
    case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src2.

  The function cv::divide divides one array by another:
  \\f[\\texttt{dst(I) = saturate(src1(I)\\*scale/src2(I))}\\f]
  or a scalar by an array when there is no src1 :
  \\f[\\texttt{dst(I) = saturate(scale/src2(I))}\\f]
  Different channels of multi-channel arrays are processed independently.
  For integer types when src2(I) is zero, dst(I) will also be zero.
  **Note**: In case of floating point data there is no special defined behavior for zero src2(I) values.
  Regular floating-point division is used.
  Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `divide(src,X)` means `divide(src,(X,X,X,X))`.
  `divide(src,(X,))` means `divide(src,(X,0,0,0))`.
  @sa  multiply, add, subtract

  Python prototype (for reference only):
  ```python3
  divide(src1, src2[, dst[, scale[, dtype]]]) -> dst
  ```

  """
  @spec divide(number(), Evision.Mat.maybe_mat_in(), [{:dtype, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def divide(scale, src2, opts) when is_number(scale) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype])
    positional = [
      scale: Evision.Internal.Structurise.from_struct(scale),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.divide(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec divide(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:dtype, term()} | {:scale, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def divide(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype, :scale])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.divide(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  divide

  ##### Positional Arguments
  - **scale**: `double`
  - **src2**: `Evision.Mat`

  ##### Keyword Arguments
  - **dtype**: `integer()`.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  divide(scale, src2[, dst[, dtype]]) -> dst
  ```
  #### Variant 2:
  Performs per-element division of two arrays or a scalar by an array.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1.

  ##### Keyword Arguments
  - **scale**: `double`.

    scalar factor.

  - **dtype**: `integer()`.

    optional depth of the output array; if -1, dst will have depth src2.depth(), but in
    case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src2.

  The function cv::divide divides one array by another:
  \\f[\\texttt{dst(I) = saturate(src1(I)\\*scale/src2(I))}\\f]
  or a scalar by an array when there is no src1 :
  \\f[\\texttt{dst(I) = saturate(scale/src2(I))}\\f]
  Different channels of multi-channel arrays are processed independently.
  For integer types when src2(I) is zero, dst(I) will also be zero.
  **Note**: In case of floating point data there is no special defined behavior for zero src2(I) values.
  Regular floating-point division is used.
  Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `divide(src,X)` means `divide(src,(X,X,X,X))`.
  `divide(src,(X,))` means `divide(src,(X,0,0,0))`.
  @sa  multiply, add, subtract

  Python prototype (for reference only):
  ```python3
  divide(src1, src2[, dst[, scale[, dtype]]]) -> dst
  ```

  """
  @spec divide(number(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def divide(scale, src2) when is_number(scale) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      scale: Evision.Internal.Structurise.from_struct(scale),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.divide(positional)
    |> to_struct()
  end
  @spec divide(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def divide(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.divide(positional)
    |> to_struct()
  end

  @doc """
  Renders the detected chessboard corners.

  ##### Positional Arguments
  - **patternSize**: `Size`.

    Number of inner corners per a chessboard row and column
    (patternSize = cv::Size(points_per_row,points_per_column)).

  - **corners**: `Evision.Mat`.

    Array of detected corners, the output of #findChessboardCorners.

  - **patternWasFound**: `bool`.

    Parameter indicating whether the complete board was found or not. The
    return value of #findChessboardCorners should be passed here.

  ##### Return
  - **image**: `Evision.Mat.t()`.

    Destination image. It must be an 8-bit color image.

  The function draws individual chessboard corners detected either as red circles if the board was not
  found, or as colored corners connected with lines if the board was found.

  Python prototype (for reference only):
  ```python3
  drawChessboardCorners(image, patternSize, corners, patternWasFound) -> image
  ```
  """
  @spec drawChessboardCorners(Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), boolean()) :: Evision.Mat.t() | {:error, String.t()}
  def drawChessboardCorners(image, patternSize, corners, patternWasFound) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and (is_struct(corners, Evision.Mat) or is_struct(corners, Nx.Tensor) or is_number(corners) or is_tuple(corners)) and is_boolean(patternWasFound)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      corners: Evision.Internal.Structurise.from_struct(corners),
      patternWasFound: Evision.Internal.Structurise.from_struct(patternWasFound)
    ]
    :evision_nif.drawChessboardCorners(positional)
    |> to_struct()
  end

  @doc """
  Draws contours outlines or filled contours.

  ##### Positional Arguments
  - **contours**: `[Evision.Mat]`.

    All the input contours. Each contour is stored as a point vector.

  - **contourIdx**: `integer()`.

    Parameter indicating a contour to draw. If it is negative, all the contours are drawn.

  - **color**: `Evision.scalar()`.

    Color of the contours.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of lines the contours are drawn with. If it is negative (for example,
    thickness=#FILLED ), the contour interiors are drawn.

  - **lineType**: `integer()`.

    Line connectivity. See #LineTypes

  - **hierarchy**: `Evision.Mat`.

    Optional information about hierarchy. It is only needed if you want to draw only
    some of the contours (see maxLevel ).

  - **maxLevel**: `integer()`.

    Maximal level for drawn contours. If it is 0, only the specified contour is drawn.
    If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
    draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
    parameter is only taken into account when there is hierarchy available.

  - **offset**: `Point`.

    Optional contour shift parameter. Shift all the drawn contours by the specified
    \\f$\\texttt{offset}=(dx,dy)\\f$ .

  ##### Return
  - **image**: `Evision.Mat.t()`.

    Destination image.

  The function draws contour outlines in the image if \\f$\\texttt{thickness} \\ge 0\\f$ or fills the area
  bounded by the contours if \\f$\\texttt{thickness}<0\\f$ . The example below shows how to retrieve
  connected components from the binary image and label them: :
  @include snippets/imgproc_drawContours.cpp
  **Note**: When thickness=#FILLED, the function is designed to handle connected components with holes correctly
  even when no hierarchy data is provided. This is done by analyzing all the outlines together
  using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
  contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
  of contours, or iterate over the collection using contourIdx parameter.

  Python prototype (for reference only):
  ```python3
  drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) -> image
  ```
  """
  @spec drawContours(Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), integer(), Evision.scalar(), [{:hierarchy, term()} | {:lineType, term()} | {:maxLevel, term()} | {:offset, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawContours(image, contours, contourIdx, color, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_list(contours) and is_integer(contourIdx) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:hierarchy, :lineType, :maxLevel, :offset, :thickness])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      contours: Evision.Internal.Structurise.from_struct(contours),
      contourIdx: Evision.Internal.Structurise.from_struct(contourIdx),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.drawContours(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws contours outlines or filled contours.

  ##### Positional Arguments
  - **contours**: `[Evision.Mat]`.

    All the input contours. Each contour is stored as a point vector.

  - **contourIdx**: `integer()`.

    Parameter indicating a contour to draw. If it is negative, all the contours are drawn.

  - **color**: `Evision.scalar()`.

    Color of the contours.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of lines the contours are drawn with. If it is negative (for example,
    thickness=#FILLED ), the contour interiors are drawn.

  - **lineType**: `integer()`.

    Line connectivity. See #LineTypes

  - **hierarchy**: `Evision.Mat`.

    Optional information about hierarchy. It is only needed if you want to draw only
    some of the contours (see maxLevel ).

  - **maxLevel**: `integer()`.

    Maximal level for drawn contours. If it is 0, only the specified contour is drawn.
    If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
    draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
    parameter is only taken into account when there is hierarchy available.

  - **offset**: `Point`.

    Optional contour shift parameter. Shift all the drawn contours by the specified
    \\f$\\texttt{offset}=(dx,dy)\\f$ .

  ##### Return
  - **image**: `Evision.Mat.t()`.

    Destination image.

  The function draws contour outlines in the image if \\f$\\texttt{thickness} \\ge 0\\f$ or fills the area
  bounded by the contours if \\f$\\texttt{thickness}<0\\f$ . The example below shows how to retrieve
  connected components from the binary image and label them: :
  @include snippets/imgproc_drawContours.cpp
  **Note**: When thickness=#FILLED, the function is designed to handle connected components with holes correctly
  even when no hierarchy data is provided. This is done by analyzing all the outlines together
  using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
  contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
  of contours, or iterate over the collection using contourIdx parameter.

  Python prototype (for reference only):
  ```python3
  drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) -> image
  ```
  """
  @spec drawContours(Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), integer(), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def drawContours(image, contours, contourIdx, color) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_list(contours) and is_integer(contourIdx) and (is_number(color) or is_tuple(color))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      contours: Evision.Internal.Structurise.from_struct(contours),
      contourIdx: Evision.Internal.Structurise.from_struct(contourIdx),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.drawContours(positional)
    |> to_struct()
  end

  @doc """
  Draw axes of the world/object coordinate system from pose estimation. @sa solvePnP

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input 3x3 floating-point matrix of camera intrinsic parameters.
    \\f$\\cameramatrix{A}\\f$

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is empty, the zero distortion coefficients are assumed.

  - **rvec**: `Evision.Mat`.

    Rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system.

  - **tvec**: `Evision.Mat`.

    Translation vector.

  - **length**: `float`.

    Length of the painted axes in the same unit than tvec (usually in meters).

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Line thickness of the painted axes.

  ##### Return
  - **image**: `Evision.Mat.t()`.

    Input/output image. It must have 1 or 3 channels. The number of channels is not altered.

  This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.
  OX is drawn in red, OY in green and OZ in blue.

  Python prototype (for reference only):
  ```python3
  drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length[, thickness]) -> image
  ```
  """
  @spec drawFrameAxes(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), [{:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec)) and is_float(length) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:thickness])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec),
      length: Evision.Internal.Structurise.from_struct(length)
    ]
    :evision_nif.drawFrameAxes(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draw axes of the world/object coordinate system from pose estimation. @sa solvePnP

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input 3x3 floating-point matrix of camera intrinsic parameters.
    \\f$\\cameramatrix{A}\\f$

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is empty, the zero distortion coefficients are assumed.

  - **rvec**: `Evision.Mat`.

    Rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system.

  - **tvec**: `Evision.Mat`.

    Translation vector.

  - **length**: `float`.

    Length of the painted axes in the same unit than tvec (usually in meters).

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Line thickness of the painted axes.

  ##### Return
  - **image**: `Evision.Mat.t()`.

    Input/output image. It must have 1 or 3 channels. The number of channels is not altered.

  This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.
  OX is drawn in red, OY in green and OZ in blue.

  Python prototype (for reference only):
  ```python3
  drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length[, thickness]) -> image
  ```
  """
  @spec drawFrameAxes(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec)) and is_float(length)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec),
      length: Evision.Internal.Structurise.from_struct(length)
    ]
    :evision_nif.drawFrameAxes(positional)
    |> to_struct()
  end

  @doc """
  Draws keypoints.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source image.

  - **keypoints**: `[Evision.KeyPoint]`.

    Keypoints from the source image.

  ##### Keyword Arguments
  - **color**: `Evision.scalar()`.

    Color of keypoints.

  - **flags**: `DrawMatchesFlags`.

    Flags setting drawing features. Possible flags bit values are defined by
    DrawMatchesFlags. See details above in drawMatches .

  ##### Return
  - **outImage**: `Evision.Mat.t()`.

    Output image. Its content depends on the flags value defining what is drawn in the
    output image. See possible flags bit values below.

  **Note**: 
  For Python API, flags are modified as cv.DRAW_MATCHES_FLAGS_DEFAULT,
  cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG,
  cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS

  Python prototype (for reference only):
  ```python3
  drawKeypoints(image, keypoints, outImage[, color[, flags]]) -> outImage
  ```
  """
  @spec drawKeypoints(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), [{:color, term()} | {:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawKeypoints(image, keypoints, outImage, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_list(keypoints) and (is_struct(outImage, Evision.Mat) or is_struct(outImage, Nx.Tensor) or is_number(outImage) or is_tuple(outImage)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:color, :flags])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      keypoints: Evision.Internal.Structurise.from_struct(keypoints),
      outImage: Evision.Internal.Structurise.from_struct(outImage)
    ]
    :evision_nif.drawKeypoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws keypoints.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source image.

  - **keypoints**: `[Evision.KeyPoint]`.

    Keypoints from the source image.

  ##### Keyword Arguments
  - **color**: `Evision.scalar()`.

    Color of keypoints.

  - **flags**: `DrawMatchesFlags`.

    Flags setting drawing features. Possible flags bit values are defined by
    DrawMatchesFlags. See details above in drawMatches .

  ##### Return
  - **outImage**: `Evision.Mat.t()`.

    Output image. Its content depends on the flags value defining what is drawn in the
    output image. See possible flags bit values below.

  **Note**: 
  For Python API, flags are modified as cv.DRAW_MATCHES_FLAGS_DEFAULT,
  cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG,
  cv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS

  Python prototype (for reference only):
  ```python3
  drawKeypoints(image, keypoints, outImage[, color[, flags]]) -> outImage
  ```
  """
  @spec drawKeypoints(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def drawKeypoints(image, keypoints, outImage) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_list(keypoints) and (is_struct(outImage, Evision.Mat) or is_struct(outImage, Nx.Tensor) or is_number(outImage) or is_tuple(outImage))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      keypoints: Evision.Internal.Structurise.from_struct(keypoints),
      outImage: Evision.Internal.Structurise.from_struct(outImage)
    ]
    :evision_nif.drawKeypoints(positional)
    |> to_struct()
  end

  @doc """
  Draws a marker on a predefined position in an image.

  ##### Positional Arguments
  - **position**: `Point`.

    The point where the crosshair is positioned.

  - **color**: `Evision.scalar()`.

    Line color.

  ##### Keyword Arguments
  - **markerType**: `integer()`.

    The specific type of marker you want to use, see #MarkerTypes

  - **markerSize**: `integer()`.

    The length of the marker axis [default = 20 pixels]

  - **thickness**: `integer()`.

    Line thickness.

  - **line_type**: `integer()`.

    Type of the line, See #LineTypes

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::drawMarker draws a marker on a given position in the image. For the moment several
  marker types are supported, see #MarkerTypes for more information.

  Python prototype (for reference only):
  ```python3
  drawMarker(img, position, color[, markerType[, markerSize[, thickness[, line_type]]]]) -> img
  ```
  """
  @spec drawMarker(Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.scalar(), [{:line_type, term()} | {:markerSize, term()} | {:markerType, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawMarker(img, position, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(position) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:line_type, :markerSize, :markerType, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      position: Evision.Internal.Structurise.from_struct(position),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.drawMarker(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws a marker on a predefined position in an image.

  ##### Positional Arguments
  - **position**: `Point`.

    The point where the crosshair is positioned.

  - **color**: `Evision.scalar()`.

    Line color.

  ##### Keyword Arguments
  - **markerType**: `integer()`.

    The specific type of marker you want to use, see #MarkerTypes

  - **markerSize**: `integer()`.

    The length of the marker axis [default = 20 pixels]

  - **thickness**: `integer()`.

    Line thickness.

  - **line_type**: `integer()`.

    Type of the line, See #LineTypes

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::drawMarker draws a marker on a given position in the image. For the moment several
  marker types are supported, see #MarkerTypes for more information.

  Python prototype (for reference only):
  ```python3
  drawMarker(img, position, color[, markerType[, markerSize[, thickness[, line_type]]]]) -> img
  ```
  """
  @spec drawMarker(Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def drawMarker(img, position, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(position) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      position: Evision.Internal.Structurise.from_struct(position),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.drawMarker(positional)
    |> to_struct()
  end

  @doc """
  drawMatches

  ##### Positional Arguments
  - **img1**: `Evision.Mat`
  - **keypoints1**: `[Evision.KeyPoint]`
  - **img2**: `Evision.Mat`
  - **keypoints2**: `[Evision.KeyPoint]`
  - **matches1to2**: `[Evision.DMatch]`
  - **matchesThickness**: `integer()`

  ##### Keyword Arguments
  - **matchColor**: `Evision.scalar()`.
  - **singlePointColor**: `Evision.scalar()`.
  - **matchesMask**: `[char]`.
  - **flags**: `DrawMatchesFlags`.

  ##### Return
  - **outImg**: `Evision.Mat.t()`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg
  ```
  """
  @spec drawMatches(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), list(Evision.DMatch.t()), Evision.Mat.maybe_mat_in(), integer(), [{:flags, term()} | {:matchColor, term()} | {:matchesMask, term()} | {:singlePointColor, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness, opts) when (is_struct(img1, Evision.Mat) or is_struct(img1, Nx.Tensor) or is_number(img1) or is_tuple(img1)) and is_list(keypoints1) and (is_struct(img2, Evision.Mat) or is_struct(img2, Nx.Tensor) or is_number(img2) or is_tuple(img2)) and is_list(keypoints2) and is_list(matches1to2) and (is_struct(outImg, Evision.Mat) or is_struct(outImg, Nx.Tensor) or is_number(outImg) or is_tuple(outImg)) and is_integer(matchesThickness) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :matchColor, :matchesMask, :singlePointColor])
    positional = [
      img1: Evision.Internal.Structurise.from_struct(img1),
      keypoints1: Evision.Internal.Structurise.from_struct(keypoints1),
      img2: Evision.Internal.Structurise.from_struct(img2),
      keypoints2: Evision.Internal.Structurise.from_struct(keypoints2),
      matches1to2: Evision.Internal.Structurise.from_struct(matches1to2),
      outImg: Evision.Internal.Structurise.from_struct(outImg),
      matchesThickness: Evision.Internal.Structurise.from_struct(matchesThickness)
    ]
    :evision_nif.drawMatches(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  drawMatches

  ##### Positional Arguments
  - **img1**: `Evision.Mat`
  - **keypoints1**: `[Evision.KeyPoint]`
  - **img2**: `Evision.Mat`
  - **keypoints2**: `[Evision.KeyPoint]`
  - **matches1to2**: `[Evision.DMatch]`
  - **matchesThickness**: `integer()`

  ##### Keyword Arguments
  - **matchColor**: `Evision.scalar()`.
  - **singlePointColor**: `Evision.scalar()`.
  - **matchesMask**: `[char]`.
  - **flags**: `DrawMatchesFlags`.

  ##### Return
  - **outImg**: `Evision.Mat.t()`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg
  ```
  #### Variant 2:
  Draws the found matches of keypoints from two images.

  ##### Positional Arguments
  - **img1**: `Evision.Mat`.

    First source image.

  - **keypoints1**: `[Evision.KeyPoint]`.

    Keypoints from the first source image.

  - **img2**: `Evision.Mat`.

    Second source image.

  - **keypoints2**: `[Evision.KeyPoint]`.

    Keypoints from the second source image.

  - **matches1to2**: `[Evision.DMatch]`.

    Matches from the first image to the second one, which means that keypoints1[i]
    has a corresponding point in keypoints2[matches[i]] .

  ##### Keyword Arguments
  - **matchColor**: `Evision.scalar()`.

    Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1)
    , the color is generated randomly.

  - **singlePointColor**: `Evision.scalar()`.

    Color of single keypoints (circles), which means that keypoints do not
    have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.

  - **matchesMask**: `[char]`.

    Mask determining which matches are drawn. If the mask is empty, all matches are
    drawn.

  - **flags**: `DrawMatchesFlags`.

    Flags setting drawing features. Possible flags bit values are defined by
    DrawMatchesFlags.

  ##### Return
  - **outImg**: `Evision.Mat.t()`.

    Output image. Its content depends on the flags value defining what is drawn in the
    output image. See possible flags bit values below.

  This function draws matches of keypoints from two images in the output image. Match is a line
  connecting two keypoints (circles). See cv::DrawMatchesFlags.

  Python prototype (for reference only):
  ```python3
  drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg
  ```

  """
  @spec drawMatches(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), list(Evision.DMatch.t()), Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:matchColor, term()} | {:matchesMask, term()} | {:singlePointColor, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, opts) when (is_struct(img1, Evision.Mat) or is_struct(img1, Nx.Tensor) or is_number(img1) or is_tuple(img1)) and is_list(keypoints1) and (is_struct(img2, Evision.Mat) or is_struct(img2, Nx.Tensor) or is_number(img2) or is_tuple(img2)) and is_list(keypoints2) and is_list(matches1to2) and (is_struct(outImg, Evision.Mat) or is_struct(outImg, Nx.Tensor) or is_number(outImg) or is_tuple(outImg)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :matchColor, :matchesMask, :singlePointColor])
    positional = [
      img1: Evision.Internal.Structurise.from_struct(img1),
      keypoints1: Evision.Internal.Structurise.from_struct(keypoints1),
      img2: Evision.Internal.Structurise.from_struct(img2),
      keypoints2: Evision.Internal.Structurise.from_struct(keypoints2),
      matches1to2: Evision.Internal.Structurise.from_struct(matches1to2),
      outImg: Evision.Internal.Structurise.from_struct(outImg)
    ]
    :evision_nif.drawMatches(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec drawMatches(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), list(Evision.DMatch.t()), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness) when (is_struct(img1, Evision.Mat) or is_struct(img1, Nx.Tensor) or is_number(img1) or is_tuple(img1)) and is_list(keypoints1) and (is_struct(img2, Evision.Mat) or is_struct(img2, Nx.Tensor) or is_number(img2) or is_tuple(img2)) and is_list(keypoints2) and is_list(matches1to2) and (is_struct(outImg, Evision.Mat) or is_struct(outImg, Nx.Tensor) or is_number(outImg) or is_tuple(outImg)) and is_integer(matchesThickness)
  do
    positional = [
      img1: Evision.Internal.Structurise.from_struct(img1),
      keypoints1: Evision.Internal.Structurise.from_struct(keypoints1),
      img2: Evision.Internal.Structurise.from_struct(img2),
      keypoints2: Evision.Internal.Structurise.from_struct(keypoints2),
      matches1to2: Evision.Internal.Structurise.from_struct(matches1to2),
      outImg: Evision.Internal.Structurise.from_struct(outImg),
      matchesThickness: Evision.Internal.Structurise.from_struct(matchesThickness)
    ]
    :evision_nif.drawMatches(positional)
    |> to_struct()
  end

  @doc """
  Draws the found matches of keypoints from two images.

  ##### Positional Arguments
  - **img1**: `Evision.Mat`.

    First source image.

  - **keypoints1**: `[Evision.KeyPoint]`.

    Keypoints from the first source image.

  - **img2**: `Evision.Mat`.

    Second source image.

  - **keypoints2**: `[Evision.KeyPoint]`.

    Keypoints from the second source image.

  - **matches1to2**: `[Evision.DMatch]`.

    Matches from the first image to the second one, which means that keypoints1[i]
    has a corresponding point in keypoints2[matches[i]] .

  ##### Keyword Arguments
  - **matchColor**: `Evision.scalar()`.

    Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1)
    , the color is generated randomly.

  - **singlePointColor**: `Evision.scalar()`.

    Color of single keypoints (circles), which means that keypoints do not
    have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.

  - **matchesMask**: `[char]`.

    Mask determining which matches are drawn. If the mask is empty, all matches are
    drawn.

  - **flags**: `DrawMatchesFlags`.

    Flags setting drawing features. Possible flags bit values are defined by
    DrawMatchesFlags.

  ##### Return
  - **outImg**: `Evision.Mat.t()`.

    Output image. Its content depends on the flags value defining what is drawn in the
    output image. See possible flags bit values below.

  This function draws matches of keypoints from two images in the output image. Match is a line
  connecting two keypoints (circles). See cv::DrawMatchesFlags.

  Python prototype (for reference only):
  ```python3
  drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg
  ```
  """
  @spec drawMatches(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), list(Evision.DMatch.t()), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg) when (is_struct(img1, Evision.Mat) or is_struct(img1, Nx.Tensor) or is_number(img1) or is_tuple(img1)) and is_list(keypoints1) and (is_struct(img2, Evision.Mat) or is_struct(img2, Nx.Tensor) or is_number(img2) or is_tuple(img2)) and is_list(keypoints2) and is_list(matches1to2) and (is_struct(outImg, Evision.Mat) or is_struct(outImg, Nx.Tensor) or is_number(outImg) or is_tuple(outImg))
  do
    positional = [
      img1: Evision.Internal.Structurise.from_struct(img1),
      keypoints1: Evision.Internal.Structurise.from_struct(keypoints1),
      img2: Evision.Internal.Structurise.from_struct(img2),
      keypoints2: Evision.Internal.Structurise.from_struct(keypoints2),
      matches1to2: Evision.Internal.Structurise.from_struct(matches1to2),
      outImg: Evision.Internal.Structurise.from_struct(outImg)
    ]
    :evision_nif.drawMatches(positional)
    |> to_struct()
  end

  @doc """
  drawMatchesKnn

  ##### Positional Arguments
  - **img1**: `Evision.Mat`
  - **keypoints1**: `[Evision.KeyPoint]`
  - **img2**: `Evision.Mat`
  - **keypoints2**: `[Evision.KeyPoint]`
  - **matches1to2**: `[[Evision.DMatch]]`

  ##### Keyword Arguments
  - **matchColor**: `Evision.scalar()`.
  - **singlePointColor**: `Evision.scalar()`.
  - **matchesMask**: `[[char]]`.
  - **flags**: `DrawMatchesFlags`.

  ##### Return
  - **outImg**: `Evision.Mat.t()`

  Python prototype (for reference only):
  ```python3
  drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg
  ```
  """
  @spec drawMatchesKnn(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), list(list(Evision.DMatch.t())), Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:matchColor, term()} | {:matchesMask, term()} | {:singlePointColor, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg, opts) when (is_struct(img1, Evision.Mat) or is_struct(img1, Nx.Tensor) or is_number(img1) or is_tuple(img1)) and is_list(keypoints1) and (is_struct(img2, Evision.Mat) or is_struct(img2, Nx.Tensor) or is_number(img2) or is_tuple(img2)) and is_list(keypoints2) and is_list(matches1to2) and (is_struct(outImg, Evision.Mat) or is_struct(outImg, Nx.Tensor) or is_number(outImg) or is_tuple(outImg)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :matchColor, :matchesMask, :singlePointColor])
    positional = [
      img1: Evision.Internal.Structurise.from_struct(img1),
      keypoints1: Evision.Internal.Structurise.from_struct(keypoints1),
      img2: Evision.Internal.Structurise.from_struct(img2),
      keypoints2: Evision.Internal.Structurise.from_struct(keypoints2),
      matches1to2: Evision.Internal.Structurise.from_struct(matches1to2),
      outImg: Evision.Internal.Structurise.from_struct(outImg)
    ]
    :evision_nif.drawMatchesKnn(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  drawMatchesKnn

  ##### Positional Arguments
  - **img1**: `Evision.Mat`
  - **keypoints1**: `[Evision.KeyPoint]`
  - **img2**: `Evision.Mat`
  - **keypoints2**: `[Evision.KeyPoint]`
  - **matches1to2**: `[[Evision.DMatch]]`

  ##### Keyword Arguments
  - **matchColor**: `Evision.scalar()`.
  - **singlePointColor**: `Evision.scalar()`.
  - **matchesMask**: `[[char]]`.
  - **flags**: `DrawMatchesFlags`.

  ##### Return
  - **outImg**: `Evision.Mat.t()`

  Python prototype (for reference only):
  ```python3
  drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg
  ```
  """
  @spec drawMatchesKnn(Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), Evision.Mat.maybe_mat_in(), list(Evision.KeyPoint.t()), list(list(Evision.DMatch.t())), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg) when (is_struct(img1, Evision.Mat) or is_struct(img1, Nx.Tensor) or is_number(img1) or is_tuple(img1)) and is_list(keypoints1) and (is_struct(img2, Evision.Mat) or is_struct(img2, Nx.Tensor) or is_number(img2) or is_tuple(img2)) and is_list(keypoints2) and is_list(matches1to2) and (is_struct(outImg, Evision.Mat) or is_struct(outImg, Nx.Tensor) or is_number(outImg) or is_tuple(outImg))
  do
    positional = [
      img1: Evision.Internal.Structurise.from_struct(img1),
      keypoints1: Evision.Internal.Structurise.from_struct(keypoints1),
      img2: Evision.Internal.Structurise.from_struct(img2),
      keypoints2: Evision.Internal.Structurise.from_struct(keypoints2),
      matches1to2: Evision.Internal.Structurise.from_struct(matches1to2),
      outImg: Evision.Internal.Structurise.from_struct(outImg)
    ]
    :evision_nif.drawMatchesKnn(positional)
    |> to_struct()
  end

  @doc """
  Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing
  filters are used in many different applications @cite EM11 .

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Edge preserving filters: cv::RECURS_FILTER or cv::NORMCONV_FILTER

  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output 8-bit 3-channel image.

  Python prototype (for reference only):
  ```python3
  edgePreservingFilter(src[, dst[, flags[, sigma_s[, sigma_r]]]]) -> dst
  ```
  """
  @spec edgePreservingFilter(Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:sigma_r, term()} | {:sigma_s, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def edgePreservingFilter(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :sigma_r, :sigma_s])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.edgePreservingFilter(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing
  filters are used in many different applications @cite EM11 .

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Edge preserving filters: cv::RECURS_FILTER or cv::NORMCONV_FILTER

  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output 8-bit 3-channel image.

  Python prototype (for reference only):
  ```python3
  edgePreservingFilter(src[, dst[, flags[, sigma_s[, sigma_r]]]]) -> dst
  ```
  """
  @spec edgePreservingFilter(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def edgePreservingFilter(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.edgePreservingFilter(positional)
    |> to_struct()
  end

  @doc """
  Calculates eigenvalues and eigenvectors of a symmetric matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical
    (src ^T^ == src).

  ##### Return
  - **retval**: `bool`
  - **eigenvalues**: `Evision.Mat.t()`.

    output vector of eigenvalues of the same type as src; the eigenvalues are stored
    in the descending order.

  - **eigenvectors**: `Evision.Mat.t()`.

    output matrix of eigenvectors; it has the same size and type as src; the
    eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding
    eigenvalues.

  The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric
  matrix src:
  ```
  src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()
  ```
  **Note**: Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.
  @sa eigenNonSymmetric, completeSymm, PCA

  Python prototype (for reference only):
  ```python3
  eigen(src[, eigenvalues[, eigenvectors]]) -> retval, eigenvalues, eigenvectors
  ```
  """
  @spec eigen(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def eigen(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.eigen(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates eigenvalues and eigenvectors of a symmetric matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical
    (src ^T^ == src).

  ##### Return
  - **retval**: `bool`
  - **eigenvalues**: `Evision.Mat.t()`.

    output vector of eigenvalues of the same type as src; the eigenvalues are stored
    in the descending order.

  - **eigenvectors**: `Evision.Mat.t()`.

    output matrix of eigenvectors; it has the same size and type as src; the
    eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding
    eigenvalues.

  The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric
  matrix src:
  ```
  src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()
  ```
  **Note**: Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.
  @sa eigenNonSymmetric, completeSymm, PCA

  Python prototype (for reference only):
  ```python3
  eigen(src[, eigenvalues[, eigenvectors]]) -> retval, eigenvalues, eigenvectors
  ```
  """
  @spec eigen(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def eigen(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.eigen(positional)
    |> to_struct()
  end

  @doc """
  Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input matrix (CV_32FC1 or CV_64FC1 type).

  ##### Return
  - **eigenvalues**: `Evision.Mat.t()`.

    output vector of eigenvalues (type is the same type as src).

  - **eigenvectors**: `Evision.Mat.t()`.

    output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.

  **Note**: Assumes real eigenvalues.
  The function calculates eigenvalues and eigenvectors (optional) of the square matrix src:
  ```
  src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()
  ```
  @sa eigen

  Python prototype (for reference only):
  ```python3
  eigenNonSymmetric(src[, eigenvalues[, eigenvectors]]) -> eigenvalues, eigenvectors
  ```
  """
  @spec eigenNonSymmetric(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def eigenNonSymmetric(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.eigenNonSymmetric(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input matrix (CV_32FC1 or CV_64FC1 type).

  ##### Return
  - **eigenvalues**: `Evision.Mat.t()`.

    output vector of eigenvalues (type is the same type as src).

  - **eigenvectors**: `Evision.Mat.t()`.

    output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.

  **Note**: Assumes real eigenvalues.
  The function calculates eigenvalues and eigenvectors (optional) of the square matrix src:
  ```
  src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()
  ```
  @sa eigen

  Python prototype (for reference only):
  ```python3
  eigenNonSymmetric(src[, eigenvalues[, eigenvectors]]) -> eigenvalues, eigenvectors
  ```
  """
  @spec eigenNonSymmetric(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def eigenNonSymmetric(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.eigenNonSymmetric(positional)
    |> to_struct()
  end

  @doc """
  Draws a simple or thick elliptic arc or fills an ellipse sector.

  ##### Positional Arguments
  - **center**: `Point`.

    Center of the ellipse.

  - **axes**: `Size`.

    Half of the size of the ellipse main axes.

  - **angle**: `double`.

    Ellipse rotation angle in degrees.

  - **startAngle**: `double`.

    Starting angle of the elliptic arc in degrees.

  - **endAngle**: `double`.

    Ending angle of the elliptic arc in degrees.

  - **color**: `Evision.scalar()`.

    Ellipse color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
    a filled ellipse sector is to be drawn.

  - **lineType**: `integer()`.

    Type of the ellipse boundary. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the coordinates of the center and values of axes.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
  arc, or a filled ellipse sector. The drawing code uses general parametric form.
  A piecewise-linear curve is used to approximate the elliptic arc
  boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
  #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
  variant of the function and want to draw the whole ellipse, not an arc, pass `startAngle=0` and
  `endAngle=360`. If `startAngle` is greater than `endAngle`, they are swapped. The figure below explains
  the meaning of the parameters to draw the blue arc.
  ![Parameters of Elliptic Arc](pics/ellipse.svg)

  Python prototype (for reference only):
  ```python3
  ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec ellipse(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, number(), number(), number(), Evision.scalar(), [{:lineType, term()} | {:shift, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def ellipse(img, center, axes, angle, startAngle, endAngle, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(center) and is_tuple(axes) and is_number(angle) and is_number(startAngle) and is_number(endAngle) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      center: Evision.Internal.Structurise.from_struct(center),
      axes: Evision.Internal.Structurise.from_struct(axes),
      angle: Evision.Internal.Structurise.from_struct(angle),
      startAngle: Evision.Internal.Structurise.from_struct(startAngle),
      endAngle: Evision.Internal.Structurise.from_struct(endAngle),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.ellipse(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws a simple or thick elliptic arc or fills an ellipse sector.

  ##### Positional Arguments
  - **center**: `Point`.

    Center of the ellipse.

  - **axes**: `Size`.

    Half of the size of the ellipse main axes.

  - **angle**: `double`.

    Ellipse rotation angle in degrees.

  - **startAngle**: `double`.

    Starting angle of the elliptic arc in degrees.

  - **endAngle**: `double`.

    Ending angle of the elliptic arc in degrees.

  - **color**: `Evision.scalar()`.

    Ellipse color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
    a filled ellipse sector is to be drawn.

  - **lineType**: `integer()`.

    Type of the ellipse boundary. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the coordinates of the center and values of axes.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
  arc, or a filled ellipse sector. The drawing code uses general parametric form.
  A piecewise-linear curve is used to approximate the elliptic arc
  boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
  #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
  variant of the function and want to draw the whole ellipse, not an arc, pass `startAngle=0` and
  `endAngle=360`. If `startAngle` is greater than `endAngle`, they are swapped. The figure below explains
  the meaning of the parameters to draw the blue arc.
  ![Parameters of Elliptic Arc](pics/ellipse.svg)

  Python prototype (for reference only):
  ```python3
  ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec ellipse(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, number(), number(), number(), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def ellipse(img, center, axes, angle, startAngle, endAngle, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(center) and is_tuple(axes) and is_number(angle) and is_number(startAngle) and is_number(endAngle) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      center: Evision.Internal.Structurise.from_struct(center),
      axes: Evision.Internal.Structurise.from_struct(axes),
      angle: Evision.Internal.Structurise.from_struct(angle),
      startAngle: Evision.Internal.Structurise.from_struct(startAngle),
      endAngle: Evision.Internal.Structurise.from_struct(endAngle),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.ellipse(positional)
    |> to_struct()
  end

  @doc """
  ellipse

  ##### Positional Arguments
  - **box**: `{centre={x, y}, size={s1, s2}, angle}`.

    Alternative ellipse representation via RotatedRect. This means that the function draws
    an ellipse inscribed in the rotated rectangle.

  - **color**: `Evision.scalar()`.

    Ellipse color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
    a filled ellipse sector is to be drawn.

  - **lineType**: `integer()`.

    Type of the ellipse boundary. See #LineTypes

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  ellipse(img, box, color[, thickness[, lineType]]) -> img
  ```
  """
  @spec ellipse(Evision.Mat.maybe_mat_in(), {{number(), number()}, {number(), number()}, number()}, Evision.scalar(), [{:lineType, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def ellipse(img, box, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(box) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      box: Evision.Internal.Structurise.from_struct(box),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.ellipse(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  ellipse

  ##### Positional Arguments
  - **box**: `{centre={x, y}, size={s1, s2}, angle}`.

    Alternative ellipse representation via RotatedRect. This means that the function draws
    an ellipse inscribed in the rotated rectangle.

  - **color**: `Evision.scalar()`.

    Ellipse color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
    a filled ellipse sector is to be drawn.

  - **lineType**: `integer()`.

    Type of the ellipse boundary. See #LineTypes

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  ellipse(img, box, color[, thickness[, lineType]]) -> img
  ```
  """
  @spec ellipse(Evision.Mat.maybe_mat_in(), {{number(), number()}, {number(), number()}, number()}, Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def ellipse(img, box, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(box) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      box: Evision.Internal.Structurise.from_struct(box),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.ellipse(positional)
    |> to_struct()
  end

  @doc """
  Approximates an elliptic arc with a polyline.

  ##### Positional Arguments
  - **center**: `Point`.

    Center of the arc.

  - **axes**: `Size`.

    Half of the size of the ellipse main axes. See #ellipse for details.

  - **angle**: `integer()`.

    Rotation angle of the ellipse in degrees. See #ellipse for details.

  - **arcStart**: `integer()`.

    Starting angle of the elliptic arc in degrees.

  - **arcEnd**: `integer()`.

    Ending angle of the elliptic arc in degrees.

  - **delta**: `integer()`.

    Angle between the subsequent polyline vertices. It defines the approximation
    accuracy.

  ##### Return
  - **pts**: `[Point]`.

    Output vector of polyline vertices.

  The function ellipse2Poly computes the vertices of a polyline that approximates the specified
  elliptic arc. It is used by #ellipse. If `arcStart` is greater than `arcEnd`, they are swapped.

  Python prototype (for reference only):
  ```python3
  ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta) -> pts
  ```
  """
  @spec ellipse2Poly({number(), number()}, {number(), number()}, integer(), integer(), integer(), integer()) :: list({number(), number()}) | {:error, String.t()}
  def ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta) when is_tuple(center) and is_tuple(axes) and is_integer(angle) and is_integer(arcStart) and is_integer(arcEnd) and is_integer(delta)
  do
    positional = [
      center: Evision.Internal.Structurise.from_struct(center),
      axes: Evision.Internal.Structurise.from_struct(axes),
      angle: Evision.Internal.Structurise.from_struct(angle),
      arcStart: Evision.Internal.Structurise.from_struct(arcStart),
      arcEnd: Evision.Internal.Structurise.from_struct(arcEnd),
      delta: Evision.Internal.Structurise.from_struct(delta)
    ]
    :evision_nif.ellipse2Poly(positional)
    |> to_struct()
  end

  @doc """
  Equalizes the histogram of a grayscale image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source 8-bit single channel image.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and type as src .

  The function equalizes the histogram of the input image using the following algorithm:
  - Calculate the histogram \\f$H\\f$ for src .
  - Normalize the histogram so that the sum of histogram bins is 255.
  - Compute the integral of the histogram:
    \\f[H'\\_i =  \\sum \\_{0  \\le j < i} H(j)\\f]

  - Transform the image using \\f$H'\\f$ as a look-up table: \\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$

  The algorithm normalizes the brightness and increases the contrast of the image.

  Python prototype (for reference only):
  ```python3
  equalizeHist(src[, dst]) -> dst
  ```
  """
  @spec equalizeHist(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def equalizeHist(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.equalizeHist(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Equalizes the histogram of a grayscale image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source 8-bit single channel image.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and type as src .

  The function equalizes the histogram of the input image using the following algorithm:
  - Calculate the histogram \\f$H\\f$ for src .
  - Normalize the histogram so that the sum of histogram bins is 255.
  - Compute the integral of the histogram:
    \\f[H'\\_i =  \\sum \\_{0  \\le j < i} H(j)\\f]

  - Transform the image using \\f$H'\\f$ as a look-up table: \\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$

  The algorithm normalizes the brightness and increases the contrast of the image.

  Python prototype (for reference only):
  ```python3
  equalizeHist(src[, dst]) -> dst
  ```
  """
  @spec equalizeHist(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def equalizeHist(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.equalizeHist(positional)
    |> to_struct()
  end

  @doc """
  Erodes an image by using a specific structuring element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; the number of channels can be arbitrary, but the depth should be one of
    CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **kernel**: `Evision.Mat`.

    structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular
    structuring element is used. Kernel can be created using #getStructuringElement.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    position of the anchor within the element; default value (-1, -1) means that the
    anchor is at the element center.

  - **iterations**: `integer()`.

    number of times erosion is applied.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  - **borderValue**: `Evision.scalar()`.

    border value in case of a constant border

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function erodes the source image using the specified structuring element that determines the
  shape of a pixel neighborhood over which the minimum is taken:
  \\f[\\texttt{dst} (x,y) =  \\min \\_{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]
  The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
  case of multi-channel images, each channel is processed independently.
  @sa  dilate, morphologyEx, getStructuringElement

  Python prototype (for reference only):
  ```python3
  erode(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst
  ```
  """
  @spec erode(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:anchor, term()} | {:borderType, term()} | {:borderValue, term()} | {:iterations, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def erode(src, kernel, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :borderValue, :iterations])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.erode(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Erodes an image by using a specific structuring element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image; the number of channels can be arbitrary, but the depth should be one of
    CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **kernel**: `Evision.Mat`.

    structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular
    structuring element is used. Kernel can be created using #getStructuringElement.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    position of the anchor within the element; default value (-1, -1) means that the
    anchor is at the element center.

  - **iterations**: `integer()`.

    number of times erosion is applied.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  - **borderValue**: `Evision.scalar()`.

    border value in case of a constant border

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function erodes the source image using the specified structuring element that determines the
  shape of a pixel neighborhood over which the minimum is taken:
  \\f[\\texttt{dst} (x,y) =  \\min \\_{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]
  The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
  case of multi-channel images, each channel is processed independently.
  @sa  dilate, morphologyEx, getStructuringElement

  Python prototype (for reference only):
  ```python3
  erode(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst
  ```
  """
  @spec erode(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def erode(src, kernel) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.erode(positional)
    |> to_struct()
  end

  @doc """
  estimateAffine2D

  ##### Positional Arguments
  - **pts1**: `Evision.Mat`
  - **pts2**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **inliers**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  estimateAffine2D(pts1, pts2, params[, inliers]) -> retval, inliers
  ```
  """
  @spec estimateAffine2D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateAffine2D(pts1, pts2, params, opts) when (is_struct(pts1, Evision.Mat) or is_struct(pts1, Nx.Tensor) or is_number(pts1) or is_tuple(pts1)) and (is_struct(pts2, Evision.Mat) or is_struct(pts2, Nx.Tensor) or is_number(pts2) or is_tuple(pts2)) and is_struct(params, Evision.UsacParams) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      pts1: Evision.Internal.Structurise.from_struct(pts1),
      pts2: Evision.Internal.Structurise.from_struct(pts2),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.estimateAffine2D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  estimateAffine2D

  ##### Positional Arguments
  - **pts1**: `Evision.Mat`
  - **pts2**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **inliers**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  estimateAffine2D(pts1, pts2, params[, inliers]) -> retval, inliers
  ```
  #### Variant 2:
  Computes an optimal affine transformation between two 2D point sets.

  ##### Positional Arguments
  - **from**: `Evision.Mat`.

    First input 2D point set containing \\f$(X,Y)\\f$.

  - **to**: `Evision.Mat`.

    Second input 2D point set containing \\f$(x,y)\\f$.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Robust method used to compute transformation. The following methods are possible:
    - @ref RANSAC - RANSAC-based robust method
    - @ref LMEDS - Least-Median robust method
      RANSAC is the default method.

  - **ransacReprojThreshold**: `double`.

    Maximum reprojection error in the RANSAC algorithm to consider
    a point as an inlier. Applies only to RANSAC.

  - **maxIters**: `size_t`.

    The maximum number of robust method iterations.

  - **confidence**: `double`.

    Confidence level, between 0 and 1, for the estimated transformation. Anything
    between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
    significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

  - **refineIters**: `size_t`.

    Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
    Passing 0 will disable refining, so the output matrix will be output of robust method.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **inliers**: `Evision.Mat.t()`.

    Output vector indicating which points are inliers (1-inlier, 0-outlier).

  It computes
  \\f[
  \\begin{bmatrix}
  x\\\\\\\\
  y\\\\\\\\
  \\end{bmatrix}
  \\begin{bmatrix}
  a\\_{11} & a\\_{12}\\\\\\\\
  a\\_{21} & a\\_{22}\\\\\\\\
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\\\\\\\
  Y\\\\\\\\
  \\end{bmatrix}
  +
  \\begin{bmatrix}
  b\\_1\\\\\\\\
  b\\_2\\\\\\\\
  \\end{bmatrix}
  \\f]

  @return Output 2D affine transformation matrix \\f$2 \\times 3\\f$ or empty matrix if transformation
  could not be estimated. The returned matrix has the following form:
  \\f[
  \\begin{bmatrix}
  a\\_{11} & a\\_{12} & b\\_1\\\\\\\\
  a\\_{21} & a\\_{22} & b\\_2\\\\\\\\
  \\end{bmatrix}
  \\f]
  The function estimates an optimal 2D affine transformation between two 2D point sets using the
  selected robust algorithm.
  The computed transformation is then refined further (using only inliers) with the
  Levenberg-Marquardt method to reduce the re-projection error even more.
  **Note**: 
  The RANSAC method can handle practically any ratio of outliers but needs a threshold to
  distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
  correctly only when there are more than 50% of inliers.
  @sa estimateAffinePartial2D, getAffineTransform

  Python prototype (for reference only):
  ```python3
  estimateAffine2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -> retval, inliers
  ```

  """
  @spec estimateAffine2D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:confidence, term()} | {:maxIters, term()} | {:method, term()} | {:ransacReprojThreshold, term()} | {:refineIters, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateAffine2D(from, to, opts) when (is_struct(from, Evision.Mat) or is_struct(from, Nx.Tensor) or is_number(from) or is_tuple(from)) and (is_struct(to, Evision.Mat) or is_struct(to, Nx.Tensor) or is_number(to) or is_tuple(to)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:confidence, :maxIters, :method, :ransacReprojThreshold, :refineIters])
    positional = [
      from: Evision.Internal.Structurise.from_struct(from),
      to: Evision.Internal.Structurise.from_struct(to)
    ]
    :evision_nif.estimateAffine2D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec estimateAffine2D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateAffine2D(pts1, pts2, params) when (is_struct(pts1, Evision.Mat) or is_struct(pts1, Nx.Tensor) or is_number(pts1) or is_tuple(pts1)) and (is_struct(pts2, Evision.Mat) or is_struct(pts2, Nx.Tensor) or is_number(pts2) or is_tuple(pts2)) and is_struct(params, Evision.UsacParams)
  do
    positional = [
      pts1: Evision.Internal.Structurise.from_struct(pts1),
      pts2: Evision.Internal.Structurise.from_struct(pts2),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.estimateAffine2D(positional)
    |> to_struct()
  end

  @doc """
  Computes an optimal affine transformation between two 2D point sets.

  ##### Positional Arguments
  - **from**: `Evision.Mat`.

    First input 2D point set containing \\f$(X,Y)\\f$.

  - **to**: `Evision.Mat`.

    Second input 2D point set containing \\f$(x,y)\\f$.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Robust method used to compute transformation. The following methods are possible:
    - @ref RANSAC - RANSAC-based robust method
    - @ref LMEDS - Least-Median robust method
      RANSAC is the default method.

  - **ransacReprojThreshold**: `double`.

    Maximum reprojection error in the RANSAC algorithm to consider
    a point as an inlier. Applies only to RANSAC.

  - **maxIters**: `size_t`.

    The maximum number of robust method iterations.

  - **confidence**: `double`.

    Confidence level, between 0 and 1, for the estimated transformation. Anything
    between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
    significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

  - **refineIters**: `size_t`.

    Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
    Passing 0 will disable refining, so the output matrix will be output of robust method.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **inliers**: `Evision.Mat.t()`.

    Output vector indicating which points are inliers (1-inlier, 0-outlier).

  It computes
  \\f[
  \\begin{bmatrix}
  x\\\\\\\\
  y\\\\\\\\
  \\end{bmatrix}
  \\begin{bmatrix}
  a\\_{11} & a\\_{12}\\\\\\\\
  a\\_{21} & a\\_{22}\\\\\\\\
  \\end{bmatrix}
  \\begin{bmatrix}
  X\\\\\\\\
  Y\\\\\\\\
  \\end{bmatrix}
  +
  \\begin{bmatrix}
  b\\_1\\\\\\\\
  b\\_2\\\\\\\\
  \\end{bmatrix}
  \\f]

  @return Output 2D affine transformation matrix \\f$2 \\times 3\\f$ or empty matrix if transformation
  could not be estimated. The returned matrix has the following form:
  \\f[
  \\begin{bmatrix}
  a\\_{11} & a\\_{12} & b\\_1\\\\\\\\
  a\\_{21} & a\\_{22} & b\\_2\\\\\\\\
  \\end{bmatrix}
  \\f]
  The function estimates an optimal 2D affine transformation between two 2D point sets using the
  selected robust algorithm.
  The computed transformation is then refined further (using only inliers) with the
  Levenberg-Marquardt method to reduce the re-projection error even more.
  **Note**: 
  The RANSAC method can handle practically any ratio of outliers but needs a threshold to
  distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
  correctly only when there are more than 50% of inliers.
  @sa estimateAffinePartial2D, getAffineTransform

  Python prototype (for reference only):
  ```python3
  estimateAffine2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -> retval, inliers
  ```
  """
  @spec estimateAffine2D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateAffine2D(from, to) when (is_struct(from, Evision.Mat) or is_struct(from, Nx.Tensor) or is_number(from) or is_tuple(from)) and (is_struct(to, Evision.Mat) or is_struct(to, Nx.Tensor) or is_number(to) or is_tuple(to))
  do
    positional = [
      from: Evision.Internal.Structurise.from_struct(from),
      to: Evision.Internal.Structurise.from_struct(to)
    ]
    :evision_nif.estimateAffine2D(positional)
    |> to_struct()
  end

  @doc """
  Computes an optimal affine transformation between two 3D point sets.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    First input 3D point set.

  - **dst**: `Evision.Mat`.

    Second input 3D point set.

  ##### Keyword Arguments
  - **force_rotation**: `bool`.

    If true, the returned rotation will never be a reflection.
    This might be unwanted, e.g. when optimizing a transform between a right- and a
    left-handed coordinate system.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **scale**: `double*`.

    If null is passed, the scale parameter c will be assumed to be 1.0.
    Else the pointed-to variable will be set to the optimal scale.

  It computes \\f$R,s,t\\f$ minimizing \\f$\\sum{i} dst\\_i - c \\cdot R \\cdot src\\_i \\f$
  where \\f$R\\f$ is a 3x3 rotation matrix, \\f$t\\f$ is a 3x1 translation vector and \\f$s\\f$ is a
  scalar size value. This is an implementation of the algorithm by Umeyama \\cite umeyama1991least .
  The estimated affine transform has a homogeneous scale which is a subclass of affine
  transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3
  points each.
  @return 3D affine transformation matrix \\f$3 \\times 4\\f$ of the form
  \\f[T =
  \\begin{bmatrix}
  R & t\\\\\\\\
  \\end{bmatrix}
  \\f]

  Python prototype (for reference only):
  ```python3
  estimateAffine3D(src, dst[, force_rotation]) -> retval, scale
  ```
  """
  @spec estimateAffine3D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:force_rotation, term()}] | nil) :: {Evision.Mat.t(), number()} | {:error, String.t()}
  def estimateAffine3D(src, dst, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:force_rotation])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.estimateAffine3D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes an optimal affine transformation between two 3D point sets.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    First input 3D point set.

  - **dst**: `Evision.Mat`.

    Second input 3D point set.

  ##### Keyword Arguments
  - **force_rotation**: `bool`.

    If true, the returned rotation will never be a reflection.
    This might be unwanted, e.g. when optimizing a transform between a right- and a
    left-handed coordinate system.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **scale**: `double*`.

    If null is passed, the scale parameter c will be assumed to be 1.0.
    Else the pointed-to variable will be set to the optimal scale.

  It computes \\f$R,s,t\\f$ minimizing \\f$\\sum{i} dst\\_i - c \\cdot R \\cdot src\\_i \\f$
  where \\f$R\\f$ is a 3x3 rotation matrix, \\f$t\\f$ is a 3x1 translation vector and \\f$s\\f$ is a
  scalar size value. This is an implementation of the algorithm by Umeyama \\cite umeyama1991least .
  The estimated affine transform has a homogeneous scale which is a subclass of affine
  transformations with 7 degrees of freedom. The paired point sets need to comprise at least 3
  points each.
  @return 3D affine transformation matrix \\f$3 \\times 4\\f$ of the form
  \\f[T =
  \\begin{bmatrix}
  R & t\\\\\\\\
  \\end{bmatrix}
  \\f]

  Python prototype (for reference only):
  ```python3
  estimateAffine3D(src, dst[, force_rotation]) -> retval, scale
  ```
  """
  @spec estimateAffine3D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), number()} | {:error, String.t()}
  def estimateAffine3D(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.estimateAffine3D(positional)
    |> to_struct()
  end

  @doc """
  Computes an optimal limited affine transformation with 4 degrees of freedom between
  two 2D point sets.

  ##### Positional Arguments
  - **from**: `Evision.Mat`.

    First input 2D point set.

  - **to**: `Evision.Mat`.

    Second input 2D point set.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Robust method used to compute transformation. The following methods are possible:
    - @ref RANSAC - RANSAC-based robust method
    - @ref LMEDS - Least-Median robust method
      RANSAC is the default method.

  - **ransacReprojThreshold**: `double`.

    Maximum reprojection error in the RANSAC algorithm to consider
    a point as an inlier. Applies only to RANSAC.

  - **maxIters**: `size_t`.

    The maximum number of robust method iterations.

  - **confidence**: `double`.

    Confidence level, between 0 and 1, for the estimated transformation. Anything
    between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
    significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

  - **refineIters**: `size_t`.

    Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
    Passing 0 will disable refining, so the output matrix will be output of robust method.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **inliers**: `Evision.Mat.t()`.

    Output vector indicating which points are inliers.

  @return Output 2D affine transformation (4 degrees of freedom) matrix \\f$2 \\times 3\\f$ or
  empty matrix if transformation could not be estimated.
  The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
  combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
  estimation.
  The computed transformation is then refined further (using only inliers) with the
  Levenberg-Marquardt method to reduce the re-projection error even more.
  Estimated transformation matrix is:
  \\f[ \\begin{bmatrix} \\cos(\\theta) \\cdot s & -\\sin(\\theta) \\cdot s & t\\_x \\\\\\\\
  \\sin(\\theta) \\cdot s & \\cos(\\theta) \\cdot s & t\\_y
  \\end{bmatrix} \\f]
  Where \\f$ \\theta \\f$ is the rotation angle, \\f$ s \\f$ the scaling factor and \\f$ t\\_x, t\\_y \\f$ are
  translations in \\f$ x, y \\f$ axes respectively.
  **Note**: 
  The RANSAC method can handle practically any ratio of outliers but need a threshold to
  distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
  correctly only when there are more than 50% of inliers.
  @sa estimateAffine2D, getAffineTransform

  Python prototype (for reference only):
  ```python3
  estimateAffinePartial2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -> retval, inliers
  ```
  """
  @spec estimateAffinePartial2D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:confidence, term()} | {:maxIters, term()} | {:method, term()} | {:ransacReprojThreshold, term()} | {:refineIters, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateAffinePartial2D(from, to, opts) when (is_struct(from, Evision.Mat) or is_struct(from, Nx.Tensor) or is_number(from) or is_tuple(from)) and (is_struct(to, Evision.Mat) or is_struct(to, Nx.Tensor) or is_number(to) or is_tuple(to)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:confidence, :maxIters, :method, :ransacReprojThreshold, :refineIters])
    positional = [
      from: Evision.Internal.Structurise.from_struct(from),
      to: Evision.Internal.Structurise.from_struct(to)
    ]
    :evision_nif.estimateAffinePartial2D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes an optimal limited affine transformation with 4 degrees of freedom between
  two 2D point sets.

  ##### Positional Arguments
  - **from**: `Evision.Mat`.

    First input 2D point set.

  - **to**: `Evision.Mat`.

    Second input 2D point set.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Robust method used to compute transformation. The following methods are possible:
    - @ref RANSAC - RANSAC-based robust method
    - @ref LMEDS - Least-Median robust method
      RANSAC is the default method.

  - **ransacReprojThreshold**: `double`.

    Maximum reprojection error in the RANSAC algorithm to consider
    a point as an inlier. Applies only to RANSAC.

  - **maxIters**: `size_t`.

    The maximum number of robust method iterations.

  - **confidence**: `double`.

    Confidence level, between 0 and 1, for the estimated transformation. Anything
    between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
    significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

  - **refineIters**: `size_t`.

    Maximum number of iterations of refining algorithm (Levenberg-Marquardt).
    Passing 0 will disable refining, so the output matrix will be output of robust method.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **inliers**: `Evision.Mat.t()`.

    Output vector indicating which points are inliers.

  @return Output 2D affine transformation (4 degrees of freedom) matrix \\f$2 \\times 3\\f$ or
  empty matrix if transformation could not be estimated.
  The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to
  combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust
  estimation.
  The computed transformation is then refined further (using only inliers) with the
  Levenberg-Marquardt method to reduce the re-projection error even more.
  Estimated transformation matrix is:
  \\f[ \\begin{bmatrix} \\cos(\\theta) \\cdot s & -\\sin(\\theta) \\cdot s & t\\_x \\\\\\\\
  \\sin(\\theta) \\cdot s & \\cos(\\theta) \\cdot s & t\\_y
  \\end{bmatrix} \\f]
  Where \\f$ \\theta \\f$ is the rotation angle, \\f$ s \\f$ the scaling factor and \\f$ t\\_x, t\\_y \\f$ are
  translations in \\f$ x, y \\f$ axes respectively.
  **Note**: 
  The RANSAC method can handle practically any ratio of outliers but need a threshold to
  distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
  correctly only when there are more than 50% of inliers.
  @sa estimateAffine2D, getAffineTransform

  Python prototype (for reference only):
  ```python3
  estimateAffinePartial2D(from, to[, inliers[, method[, ransacReprojThreshold[, maxIters[, confidence[, refineIters]]]]]]) -> retval, inliers
  ```
  """
  @spec estimateAffinePartial2D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateAffinePartial2D(from, to) when (is_struct(from, Evision.Mat) or is_struct(from, Nx.Tensor) or is_number(from) or is_tuple(from)) and (is_struct(to, Evision.Mat) or is_struct(to, Nx.Tensor) or is_number(to) or is_tuple(to))
  do
    positional = [
      from: Evision.Internal.Structurise.from_struct(from),
      to: Evision.Internal.Structurise.from_struct(to)
    ]
    :evision_nif.estimateAffinePartial2D(positional)
    |> to_struct()
  end

  @doc """
  Estimates the sharpness of a detected chessboard.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Gray image used to find chessboard corners

  - **patternSize**: `Size`.

    Size of a found chessboard pattern

  - **corners**: `Evision.Mat`.

    Corners found by #findChessboardCornersSB

  ##### Keyword Arguments
  - **rise_distance**: `float`.

    Rise distance 0.8 means 10% ... 90% of the final signal strength

  - **vertical**: `bool`.

    By default edge responses for horizontal lines are calculated

  ##### Return
  - **retval**: `Evision.scalar().t()`
  - **sharpness**: `Evision.Mat.t()`.

    Optional output array with a sharpness value for calculated edge responses (see description)

  Image sharpness, as well as brightness, are a critical parameter for accuracte
  camera calibration. For accessing these parameters for filtering out
  problematic calibraiton images, this method calculates edge profiles by traveling from
  black to white chessboard cell centers. Based on this, the number of pixels is
  calculated required to transit from black to white. This width of the
  transition area is a good indication of how sharp the chessboard is imaged
  and should be below ~3.0 pixels.

  The optional sharpness array is of type CV_32FC1 and has for each calculated
  profile one row with the following five entries:
   0 = x coordinate of the underlying edge in the image
   1 = y coordinate of the underlying edge in the image
   2 = width of the transition area (sharpness)
   3 = signal strength in the black cell (min brightness)
   4 = signal strength in the white cell (max brightness)
  @return Scalar(average sharpness, average min brightness, average max brightness,0)

  Python prototype (for reference only):
  ```python3
  estimateChessboardSharpness(image, patternSize, corners[, rise_distance[, vertical[, sharpness]]]) -> retval, sharpness
  ```
  """
  @spec estimateChessboardSharpness(Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), [{:rise_distance, term()} | {:vertical, term()}] | nil) :: {Evision.scalar(), Evision.Mat.t()} | {:error, String.t()}
  def estimateChessboardSharpness(image, patternSize, corners, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and (is_struct(corners, Evision.Mat) or is_struct(corners, Nx.Tensor) or is_number(corners) or is_tuple(corners)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:rise_distance, :vertical])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      corners: Evision.Internal.Structurise.from_struct(corners)
    ]
    :evision_nif.estimateChessboardSharpness(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Estimates the sharpness of a detected chessboard.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Gray image used to find chessboard corners

  - **patternSize**: `Size`.

    Size of a found chessboard pattern

  - **corners**: `Evision.Mat`.

    Corners found by #findChessboardCornersSB

  ##### Keyword Arguments
  - **rise_distance**: `float`.

    Rise distance 0.8 means 10% ... 90% of the final signal strength

  - **vertical**: `bool`.

    By default edge responses for horizontal lines are calculated

  ##### Return
  - **retval**: `Evision.scalar().t()`
  - **sharpness**: `Evision.Mat.t()`.

    Optional output array with a sharpness value for calculated edge responses (see description)

  Image sharpness, as well as brightness, are a critical parameter for accuracte
  camera calibration. For accessing these parameters for filtering out
  problematic calibraiton images, this method calculates edge profiles by traveling from
  black to white chessboard cell centers. Based on this, the number of pixels is
  calculated required to transit from black to white. This width of the
  transition area is a good indication of how sharp the chessboard is imaged
  and should be below ~3.0 pixels.

  The optional sharpness array is of type CV_32FC1 and has for each calculated
  profile one row with the following five entries:
   0 = x coordinate of the underlying edge in the image
   1 = y coordinate of the underlying edge in the image
   2 = width of the transition area (sharpness)
   3 = signal strength in the black cell (min brightness)
   4 = signal strength in the white cell (max brightness)
  @return Scalar(average sharpness, average min brightness, average max brightness,0)

  Python prototype (for reference only):
  ```python3
  estimateChessboardSharpness(image, patternSize, corners[, rise_distance[, vertical[, sharpness]]]) -> retval, sharpness
  ```
  """
  @spec estimateChessboardSharpness(Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in()) :: {Evision.scalar(), Evision.Mat.t()} | {:error, String.t()}
  def estimateChessboardSharpness(image, patternSize, corners) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and (is_struct(corners, Evision.Mat) or is_struct(corners, Nx.Tensor) or is_number(corners) or is_tuple(corners))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      corners: Evision.Internal.Structurise.from_struct(corners)
    ]
    :evision_nif.estimateChessboardSharpness(positional)
    |> to_struct()
  end

  @doc """
  Computes an optimal translation between two 3D point sets.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    First input 3D point set containing \\f$(X,Y,Z)\\f$.

  - **dst**: `Evision.Mat`.

    Second input 3D point set containing \\f$(x,y,z)\\f$.

  ##### Keyword Arguments
  - **ransacThreshold**: `double`.

    Maximum reprojection error in the RANSAC algorithm to consider a point as
    an inlier.

  - **confidence**: `double`.

    Confidence level, between 0 and 1, for the estimated transformation. Anything
    between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
    significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

  ##### Return
  - **retval**: `integer()`
  - **out**: `Evision.Mat.t()`.

    Output 3D translation vector \\f$3 \\times 1\\f$ of the form
    \\f[
    \\begin{bmatrix}
    b_1 \\\\\\\\
    b_2 \\\\\\\\
    b_3 \\\\\\\\
    \\end{bmatrix}
    \\f]

  - **inliers**: `Evision.Mat.t()`.

    Output vector indicating which points are inliers (1-inlier, 0-outlier).

   It computes
   \\f[
   \\begin{bmatrix}
   x\\\\\\\\
   y\\\\\\\\
   z\\\\\\\\
   \\end{bmatrix}
   \\begin{bmatrix}
   X\\\\\\\\
   Y\\\\\\\\
   Z\\\\\\\\
   \\end{bmatrix}
   +
   \\begin{bmatrix}
   b\\_1\\\\\\\\
   b\\_2\\\\\\\\
   b\\_3\\\\\\\\
   \\end{bmatrix}
   \\f]

   The function estimates an optimal 3D translation between two 3D point sets using the
   RANSAC algorithm.

  Python prototype (for reference only):
  ```python3
  estimateTranslation3D(src, dst[, out[, inliers[, ransacThreshold[, confidence]]]]) -> retval, out, inliers
  ```
  """
  @spec estimateTranslation3D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:confidence, term()} | {:ransacThreshold, term()}] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateTranslation3D(src, dst, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:confidence, :ransacThreshold])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.estimateTranslation3D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes an optimal translation between two 3D point sets.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    First input 3D point set containing \\f$(X,Y,Z)\\f$.

  - **dst**: `Evision.Mat`.

    Second input 3D point set containing \\f$(x,y,z)\\f$.

  ##### Keyword Arguments
  - **ransacThreshold**: `double`.

    Maximum reprojection error in the RANSAC algorithm to consider a point as
    an inlier.

  - **confidence**: `double`.

    Confidence level, between 0 and 1, for the estimated transformation. Anything
    between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation
    significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.

  ##### Return
  - **retval**: `integer()`
  - **out**: `Evision.Mat.t()`.

    Output 3D translation vector \\f$3 \\times 1\\f$ of the form
    \\f[
    \\begin{bmatrix}
    b_1 \\\\\\\\
    b_2 \\\\\\\\
    b_3 \\\\\\\\
    \\end{bmatrix}
    \\f]

  - **inliers**: `Evision.Mat.t()`.

    Output vector indicating which points are inliers (1-inlier, 0-outlier).

   It computes
   \\f[
   \\begin{bmatrix}
   x\\\\\\\\
   y\\\\\\\\
   z\\\\\\\\
   \\end{bmatrix}
   \\begin{bmatrix}
   X\\\\\\\\
   Y\\\\\\\\
   Z\\\\\\\\
   \\end{bmatrix}
   +
   \\begin{bmatrix}
   b\\_1\\\\\\\\
   b\\_2\\\\\\\\
   b\\_3\\\\\\\\
   \\end{bmatrix}
   \\f]

   The function estimates an optimal 3D translation between two 3D point sets using the
   RANSAC algorithm.

  Python prototype (for reference only):
  ```python3
  estimateTranslation3D(src, dst[, out[, inliers[, ransacThreshold[, confidence]]]]) -> retval, out, inliers
  ```
  """
  @spec estimateTranslation3D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def estimateTranslation3D(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.estimateTranslation3D(positional)
    |> to_struct()
  end

  @doc """
  Calculates the exponent of every array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::exp calculates the exponent of every element of the input
  array:
  \\f[\\texttt{dst} \\[I] = e^{ src(I) }\\f]
  The maximum relative error is about 7e-6 for single-precision input and
  less than 1e-10 for double-precision input. Currently, the function
  converts denormalized values to zeros on output. Special values (NaN,
  Inf) are not handled.
  @sa log, cartToPolar, polarToCart, phase, pow, sqrt, magnitude

  Python prototype (for reference only):
  ```python3
  exp(src[, dst]) -> dst
  ```
  """
  @spec exp(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def exp(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.exp(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the exponent of every array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::exp calculates the exponent of every element of the input
  array:
  \\f[\\texttt{dst} \\[I] = e^{ src(I) }\\f]
  The maximum relative error is about 7e-6 for single-precision input and
  less than 1e-10 for double-precision input. Currently, the function
  converts denormalized values to zeros on output. Special values (NaN,
  Inf) are not handled.
  @sa log, cartToPolar, polarToCart, phase, pow, sqrt, magnitude

  Python prototype (for reference only):
  ```python3
  exp(src[, dst]) -> dst
  ```
  """
  @spec exp(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def exp(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.exp(positional)
    |> to_struct()
  end

  @doc """
  Extracts a single channel from src (coi is 0-based index)

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **coi**: `integer()`.

    index of channel to extract

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array

  @sa mixChannels, split

  Python prototype (for reference only):
  ```python3
  extractChannel(src, coi[, dst]) -> dst
  ```
  """
  @spec extractChannel(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def extractChannel(src, coi, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(coi) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      coi: Evision.Internal.Structurise.from_struct(coi)
    ]
    :evision_nif.extractChannel(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Extracts a single channel from src (coi is 0-based index)

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **coi**: `integer()`.

    index of channel to extract

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array

  @sa mixChannels, split

  Python prototype (for reference only):
  ```python3
  extractChannel(src, coi[, dst]) -> dst
  ```
  """
  @spec extractChannel(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def extractChannel(src, coi) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(coi)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      coi: Evision.Internal.Structurise.from_struct(coi)
    ]
    :evision_nif.extractChannel(positional)
    |> to_struct()
  end

  @doc """
  Calculates the angle of a 2D vector in degrees.

  ##### Positional Arguments
  - **y**: `float`.

    y-coordinate of the vector.

  - **x**: `float`.

    x-coordinate of the vector.

  ##### Return
  - **retval**: `float`

  The function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured
  in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.

  Python prototype (for reference only):
  ```python3
  fastAtan2(y, x) -> retval
  ```
  """
  @spec fastAtan2(number(), number()) :: number() | {:error, String.t()}
  def fastAtan2(y, x) when is_float(y) and is_float(x)
  do
    positional = [
      y: Evision.Internal.Structurise.from_struct(y),
      x: Evision.Internal.Structurise.from_struct(x)
    ]
    :evision_nif.fastAtan2(positional)
    |> to_struct()
  end

  @doc """
  Perform image denoising using Non-local Means Denoising algorithm
  <http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational
  optimizations. Noise expected to be a gaussian white noise

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit or 16-bit (only with NORM_L1) 1-channel,
    2-channel, 3-channel or 4-channel image.

  - **h**: `[float]`.

    Array of parameters regulating filter strength, either one
    parameter applied to all channels or one per channel in dst. Big h value
    perfectly removes noise but also removes image details, smaller h
    value preserves details but also preserves some noise

  ##### Keyword Arguments
  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  - **normType**: `integer()`.

    Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  This function expected to be applied to grayscale images. For colored images look at
  fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored
  image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting
  image to CIELAB colorspace and then separately denoise L and AB components with different h
  parameter.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoising(src, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoising(Evision.Mat.maybe_mat_in(), list(number()), [{:normType, term()} | {:searchWindowSize, term()} | {:templateWindowSize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoising(src, h, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_list(h) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:normType, :searchWindowSize, :templateWindowSize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      h: Evision.Internal.Structurise.from_struct(h)
    ]
    :evision_nif.fastNlMeansDenoising(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Perform image denoising using Non-local Means Denoising algorithm
  <http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational
  optimizations. Noise expected to be a gaussian white noise

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit or 16-bit (only with NORM_L1) 1-channel,
    2-channel, 3-channel or 4-channel image.

  - **h**: `[float]`.

    Array of parameters regulating filter strength, either one
    parameter applied to all channels or one per channel in dst. Big h value
    perfectly removes noise but also removes image details, smaller h
    value preserves details but also preserves some noise

  ##### Keyword Arguments
  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  - **normType**: `integer()`.

    Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  This function expected to be applied to grayscale images. For colored images look at
  fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored
  image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting
  image to CIELAB colorspace and then separately denoise L and AB components with different h
  parameter.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoising(src, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -> dst
  ```
  #### Variant 2:
  Perform image denoising using Non-local Means Denoising algorithm
  <http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational
  optimizations. Noise expected to be a gaussian white noise

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength. Big h value perfectly removes noise but also
    removes image details, smaller h value preserves details but also preserves some noise

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  This function expected to be applied to grayscale images. For colored images look at
  fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored
  image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting
  image to CIELAB colorspace and then separately denoise L and AB components with different h
  parameter.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoising(src[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -> dst
  ```

  """
  @spec fastNlMeansDenoising(Evision.Mat.maybe_mat_in(), [{:h, term()} | {:searchWindowSize, term()} | {:templateWindowSize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoising(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:h, :searchWindowSize, :templateWindowSize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.fastNlMeansDenoising(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec fastNlMeansDenoising(Evision.Mat.maybe_mat_in(), list(number())) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoising(src, h) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_list(h)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      h: Evision.Internal.Structurise.from_struct(h)
    ]
    :evision_nif.fastNlMeansDenoising(positional)
    |> to_struct()
  end

  @doc """
  Perform image denoising using Non-local Means Denoising algorithm
  <http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational
  optimizations. Noise expected to be a gaussian white noise

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength. Big h value perfectly removes noise but also
    removes image details, smaller h value preserves details but also preserves some noise

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  This function expected to be applied to grayscale images. For colored images look at
  fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored
  image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting
  image to CIELAB colorspace and then separately denoise L and AB components with different h
  parameter.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoising(src[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoising(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoising(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.fastNlMeansDenoising(positional)
    |> to_struct()
  end

  @doc """
  Modification of fastNlMeansDenoising function for colored images

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength for luminance component. Bigger h value perfectly
    removes noise but also removes image details, smaller h value preserves details but also preserves
    some noise

  - **hColor**: `float`.

    The same as h but for color components. For most images value equals 10
    will be enough to remove colored noise and do not distort colors

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  The function converts image to CIELAB colorspace and then separately denoise L and AB components
  with given h parameters using fastNlMeansDenoising function.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingColored(src[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoisingColored(Evision.Mat.maybe_mat_in(), [{:h, term()} | {:hColor, term()} | {:searchWindowSize, term()} | {:templateWindowSize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingColored(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:h, :hColor, :searchWindowSize, :templateWindowSize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.fastNlMeansDenoisingColored(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Modification of fastNlMeansDenoising function for colored images

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength for luminance component. Bigger h value perfectly
    removes noise but also removes image details, smaller h value preserves details but also preserves
    some noise

  - **hColor**: `float`.

    The same as h but for color components. For most images value equals 10
    will be enough to remove colored noise and do not distort colors

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  The function converts image to CIELAB colorspace and then separately denoise L and AB components
  with given h parameters using fastNlMeansDenoising function.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingColored(src[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoisingColored(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingColored(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.fastNlMeansDenoisingColored(positional)
    |> to_struct()
  end

  @doc """
  Modification of fastNlMeansDenoisingMulti function for colored images sequences

  ##### Positional Arguments
  - **srcImgs**: `[Evision.Mat]`.

    Input 8-bit 3-channel images sequence. All images should have the same type and
    size.

  - **imgToDenoiseIndex**: `integer()`.

    Target image to denoise index in srcImgs sequence

  - **temporalWindowSize**: `integer()`.

    Number of surrounding images to use for target image denoising. Should
    be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
    imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
    srcImgs[imgToDenoiseIndex] image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength for luminance component. Bigger h value perfectly
    removes noise but also removes image details, smaller h value preserves details but also preserves
    some noise.

  - **hColor**: `float`.

    The same as h but for color components.

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as srcImgs images.

  The function converts images to CIELAB colorspace and then separately denoise L and AB components
  with given h parameters using fastNlMeansDenoisingMulti function.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoisingColoredMulti(list(Evision.Mat.maybe_mat_in()), integer(), integer(), [{:h, term()} | {:hColor, term()} | {:searchWindowSize, term()} | {:templateWindowSize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, opts) when is_list(srcImgs) and is_integer(imgToDenoiseIndex) and is_integer(temporalWindowSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:h, :hColor, :searchWindowSize, :templateWindowSize])
    positional = [
      srcImgs: Evision.Internal.Structurise.from_struct(srcImgs),
      imgToDenoiseIndex: Evision.Internal.Structurise.from_struct(imgToDenoiseIndex),
      temporalWindowSize: Evision.Internal.Structurise.from_struct(temporalWindowSize)
    ]
    :evision_nif.fastNlMeansDenoisingColoredMulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Modification of fastNlMeansDenoisingMulti function for colored images sequences

  ##### Positional Arguments
  - **srcImgs**: `[Evision.Mat]`.

    Input 8-bit 3-channel images sequence. All images should have the same type and
    size.

  - **imgToDenoiseIndex**: `integer()`.

    Target image to denoise index in srcImgs sequence

  - **temporalWindowSize**: `integer()`.

    Number of surrounding images to use for target image denoising. Should
    be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
    imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
    srcImgs[imgToDenoiseIndex] image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength for luminance component. Bigger h value perfectly
    removes noise but also removes image details, smaller h value preserves details but also preserves
    some noise.

  - **hColor**: `float`.

    The same as h but for color components.

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as srcImgs images.

  The function converts images to CIELAB colorspace and then separately denoise L and AB components
  with given h parameters using fastNlMeansDenoisingMulti function.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoisingColoredMulti(list(Evision.Mat.maybe_mat_in()), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize) when is_list(srcImgs) and is_integer(imgToDenoiseIndex) and is_integer(temporalWindowSize)
  do
    positional = [
      srcImgs: Evision.Internal.Structurise.from_struct(srcImgs),
      imgToDenoiseIndex: Evision.Internal.Structurise.from_struct(imgToDenoiseIndex),
      temporalWindowSize: Evision.Internal.Structurise.from_struct(temporalWindowSize)
    ]
    :evision_nif.fastNlMeansDenoisingColoredMulti(positional)
    |> to_struct()
  end

  @doc """
  Modification of fastNlMeansDenoising function for images sequence where consecutive images have been
  captured in small period of time. For example video. This version of the function is for grayscale
  images or for manual manipulation with colorspaces. See @cite Buades2005DenoisingIS for more details
  (open access [here](https://static.aminer.org/pdf/PDF/000/317/196/spatio_temporal_wiener_filtering_of_image_sequences_using_a_parametric.pdf)).

  ##### Positional Arguments
  - **srcImgs**: `[Evision.Mat]`.

    Input 8-bit or 16-bit (only with NORM_L1) 1-channel,
    2-channel, 3-channel or 4-channel images sequence. All images should
    have the same type and size.

  - **imgToDenoiseIndex**: `integer()`.

    Target image to denoise index in srcImgs sequence

  - **temporalWindowSize**: `integer()`.

    Number of surrounding images to use for target image denoising. Should
    be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
    imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
    srcImgs[imgToDenoiseIndex] image.

  - **h**: `[float]`.

    Array of parameters regulating filter strength, either one
    parameter applied to all channels or one per channel in dst. Big h value
    perfectly removes noise but also removes image details, smaller h
    value preserves details but also preserves some noise

  ##### Keyword Arguments
  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  - **normType**: `integer()`.

    Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as srcImgs images.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoisingMulti(list(Evision.Mat.maybe_mat_in()), integer(), integer(), list(number()), [{:normType, term()} | {:searchWindowSize, term()} | {:templateWindowSize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, h, opts) when is_list(srcImgs) and is_integer(imgToDenoiseIndex) and is_integer(temporalWindowSize) and is_list(h) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:normType, :searchWindowSize, :templateWindowSize])
    positional = [
      srcImgs: Evision.Internal.Structurise.from_struct(srcImgs),
      imgToDenoiseIndex: Evision.Internal.Structurise.from_struct(imgToDenoiseIndex),
      temporalWindowSize: Evision.Internal.Structurise.from_struct(temporalWindowSize),
      h: Evision.Internal.Structurise.from_struct(h)
    ]
    :evision_nif.fastNlMeansDenoisingMulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Modification of fastNlMeansDenoising function for images sequence where consecutive images have been
  captured in small period of time. For example video. This version of the function is for grayscale
  images or for manual manipulation with colorspaces. See @cite Buades2005DenoisingIS for more details
  (open access [here](https://static.aminer.org/pdf/PDF/000/317/196/spatio_temporal_wiener_filtering_of_image_sequences_using_a_parametric.pdf)).

  ##### Positional Arguments
  - **srcImgs**: `[Evision.Mat]`.

    Input 8-bit or 16-bit (only with NORM_L1) 1-channel,
    2-channel, 3-channel or 4-channel images sequence. All images should
    have the same type and size.

  - **imgToDenoiseIndex**: `integer()`.

    Target image to denoise index in srcImgs sequence

  - **temporalWindowSize**: `integer()`.

    Number of surrounding images to use for target image denoising. Should
    be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
    imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
    srcImgs[imgToDenoiseIndex] image.

  - **h**: `[float]`.

    Array of parameters regulating filter strength, either one
    parameter applied to all channels or one per channel in dst. Big h value
    perfectly removes noise but also removes image details, smaller h
    value preserves details but also preserves some noise

  ##### Keyword Arguments
  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  - **normType**: `integer()`.

    Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as srcImgs images.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]]) -> dst
  ```
  #### Variant 2:
  Modification of fastNlMeansDenoising function for images sequence where consecutive images have been
  captured in small period of time. For example video. This version of the function is for grayscale
  images or for manual manipulation with colorspaces. See @cite Buades2005DenoisingIS for more details
  (open access [here](https://static.aminer.org/pdf/PDF/000/317/196/spatio_temporal_wiener_filtering_of_image_sequences_using_a_parametric.pdf)).

  ##### Positional Arguments
  - **srcImgs**: `[Evision.Mat]`.

    Input 8-bit 1-channel, 2-channel, 3-channel or
    4-channel images sequence. All images should have the same type and
    size.

  - **imgToDenoiseIndex**: `integer()`.

    Target image to denoise index in srcImgs sequence

  - **temporalWindowSize**: `integer()`.

    Number of surrounding images to use for target image denoising. Should
    be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
    imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
    srcImgs[imgToDenoiseIndex] image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength. Bigger h value
    perfectly removes noise but also removes image details, smaller h
    value preserves details but also preserves some noise

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as srcImgs images.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -> dst
  ```

  """
  @spec fastNlMeansDenoisingMulti(list(Evision.Mat.maybe_mat_in()), integer(), integer(), [{:h, term()} | {:searchWindowSize, term()} | {:templateWindowSize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, opts) when is_list(srcImgs) and is_integer(imgToDenoiseIndex) and is_integer(temporalWindowSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:h, :searchWindowSize, :templateWindowSize])
    positional = [
      srcImgs: Evision.Internal.Structurise.from_struct(srcImgs),
      imgToDenoiseIndex: Evision.Internal.Structurise.from_struct(imgToDenoiseIndex),
      temporalWindowSize: Evision.Internal.Structurise.from_struct(temporalWindowSize)
    ]
    :evision_nif.fastNlMeansDenoisingMulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec fastNlMeansDenoisingMulti(list(Evision.Mat.maybe_mat_in()), integer(), integer(), list(number())) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize, h) when is_list(srcImgs) and is_integer(imgToDenoiseIndex) and is_integer(temporalWindowSize) and is_list(h)
  do
    positional = [
      srcImgs: Evision.Internal.Structurise.from_struct(srcImgs),
      imgToDenoiseIndex: Evision.Internal.Structurise.from_struct(imgToDenoiseIndex),
      temporalWindowSize: Evision.Internal.Structurise.from_struct(temporalWindowSize),
      h: Evision.Internal.Structurise.from_struct(h)
    ]
    :evision_nif.fastNlMeansDenoisingMulti(positional)
    |> to_struct()
  end

  @doc """
  Modification of fastNlMeansDenoising function for images sequence where consecutive images have been
  captured in small period of time. For example video. This version of the function is for grayscale
  images or for manual manipulation with colorspaces. See @cite Buades2005DenoisingIS for more details
  (open access [here](https://static.aminer.org/pdf/PDF/000/317/196/spatio_temporal_wiener_filtering_of_image_sequences_using_a_parametric.pdf)).

  ##### Positional Arguments
  - **srcImgs**: `[Evision.Mat]`.

    Input 8-bit 1-channel, 2-channel, 3-channel or
    4-channel images sequence. All images should have the same type and
    size.

  - **imgToDenoiseIndex**: `integer()`.

    Target image to denoise index in srcImgs sequence

  - **temporalWindowSize**: `integer()`.

    Number of surrounding images to use for target image denoising. Should
    be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
    imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
    srcImgs[imgToDenoiseIndex] image.

  ##### Keyword Arguments
  - **h**: `float`.

    Parameter regulating filter strength. Bigger h value
    perfectly removes noise but also removes image details, smaller h
    value preserves details but also preserves some noise

  - **templateWindowSize**: `integer()`.

    Size in pixels of the template patch that is used to compute weights.
    Should be odd. Recommended value 7 pixels

  - **searchWindowSize**: `integer()`.

    Size in pixels of the window that is used to compute weighted average for
    given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
    denoising time. Recommended value 21 pixels

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as srcImgs images.

  Python prototype (for reference only):
  ```python3
  fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -> dst
  ```
  """
  @spec fastNlMeansDenoisingMulti(list(Evision.Mat.maybe_mat_in()), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize) when is_list(srcImgs) and is_integer(imgToDenoiseIndex) and is_integer(temporalWindowSize)
  do
    positional = [
      srcImgs: Evision.Internal.Structurise.from_struct(srcImgs),
      imgToDenoiseIndex: Evision.Internal.Structurise.from_struct(imgToDenoiseIndex),
      temporalWindowSize: Evision.Internal.Structurise.from_struct(temporalWindowSize)
    ]
    :evision_nif.fastNlMeansDenoisingMulti(positional)
    |> to_struct()
  end

  @doc """
  Fills a convex polygon.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Polygon vertices.

  - **color**: `Evision.scalar()`.

    Polygon color.

  ##### Keyword Arguments
  - **lineType**: `integer()`.

    Type of the polygon boundaries. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the vertex coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the
  function #fillPoly . It can fill not only convex polygons but any monotonic polygon without
  self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
  twice at the most (though, its top-most and/or the bottom edge could be horizontal).

  Python prototype (for reference only):
  ```python3
  fillConvexPoly(img, points, color[, lineType[, shift]]) -> img
  ```
  """
  @spec fillConvexPoly(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.scalar(), [{:lineType, term()} | {:shift, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fillConvexPoly(img, points, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      points: Evision.Internal.Structurise.from_struct(points),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.fillConvexPoly(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Fills a convex polygon.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Polygon vertices.

  - **color**: `Evision.scalar()`.

    Polygon color.

  ##### Keyword Arguments
  - **lineType**: `integer()`.

    Type of the polygon boundaries. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the vertex coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the
  function #fillPoly . It can fill not only convex polygons but any monotonic polygon without
  self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
  twice at the most (though, its top-most and/or the bottom edge could be horizontal).

  Python prototype (for reference only):
  ```python3
  fillConvexPoly(img, points, color[, lineType[, shift]]) -> img
  ```
  """
  @spec fillConvexPoly(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def fillConvexPoly(img, points, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      points: Evision.Internal.Structurise.from_struct(points),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.fillConvexPoly(positional)
    |> to_struct()
  end

  @doc """
  Fills the area bounded by one or more polygons.

  ##### Positional Arguments
  - **pts**: `[Evision.Mat]`.

    Array of polygons where each polygon is represented as an array of points.

  - **color**: `Evision.scalar()`.

    Polygon color.

  ##### Keyword Arguments
  - **lineType**: `integer()`.

    Type of the polygon boundaries. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the vertex coordinates.

  - **offset**: `Point`.

    Optional offset of all points of the contours.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
  complex areas, for example, areas with holes, contours with self-intersections (some of their
  parts), and so forth.

  Python prototype (for reference only):
  ```python3
  fillPoly(img, pts, color[, lineType[, shift[, offset]]]) -> img
  ```
  """
  @spec fillPoly(Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), Evision.scalar(), [{:lineType, term()} | {:offset, term()} | {:shift, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fillPoly(img, pts, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_list(pts) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :offset, :shift])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pts: Evision.Internal.Structurise.from_struct(pts),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.fillPoly(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Fills the area bounded by one or more polygons.

  ##### Positional Arguments
  - **pts**: `[Evision.Mat]`.

    Array of polygons where each polygon is represented as an array of points.

  - **color**: `Evision.scalar()`.

    Polygon color.

  ##### Keyword Arguments
  - **lineType**: `integer()`.

    Type of the polygon boundaries. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the vertex coordinates.

  - **offset**: `Point`.

    Optional offset of all points of the contours.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
  complex areas, for example, areas with holes, contours with self-intersections (some of their
  parts), and so forth.

  Python prototype (for reference only):
  ```python3
  fillPoly(img, pts, color[, lineType[, shift[, offset]]]) -> img
  ```
  """
  @spec fillPoly(Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def fillPoly(img, pts, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_list(pts) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pts: Evision.Internal.Structurise.from_struct(pts),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.fillPoly(positional)
    |> to_struct()
  end

  @doc """
  Convolves an image with the kernel.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    desired depth of the destination image, see @ref filter_depths "combinations"

  - **kernel**: `Evision.Mat`.

    convolution kernel (or rather a correlation kernel), a single-channel floating point
    matrix; if you want to apply different kernels to different channels, split the image into
    separate color planes using split and process them individually.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    anchor of the kernel that indicates the relative position of a filtered point within
    the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
    is at the kernel center.

  - **delta**: `double`.

    optional value added to the filtered pixels before storing them in dst.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and the same number of channels as src.

  The function applies an arbitrary linear filter to an image. In-place operation is supported. When
  the aperture is partially outside the image, the function interpolates outlier pixel values
  according to the specified border mode.
  The function does actually compute correlation, not the convolution:
  \\f[\\texttt{dst} (x,y) =  \\sum \\_{ \\substack{0\\leq x' < \\texttt{kernel.cols}\\\\\\\\\\{0\\leq y' < \\texttt{kernel.rows}}}}  \\texttt{kernel} (x',y')\\* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- \\texttt{anchor.y} )\\f]
  That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
  the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
  anchor.y - 1)`.
  The function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or
  larger) and the direct algorithm for small kernels.
  @sa  sepFilter2D, dft, matchTemplate

  Python prototype (for reference only):
  ```python3
  filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -> dst
  ```
  """
  @spec filter2D(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), [{:anchor, term()} | {:borderType, term()} | {:delta, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def filter2D(src, ddepth, kernel, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :delta])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.filter2D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Convolves an image with the kernel.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **ddepth**: `integer()`.

    desired depth of the destination image, see @ref filter_depths "combinations"

  - **kernel**: `Evision.Mat`.

    convolution kernel (or rather a correlation kernel), a single-channel floating point
    matrix; if you want to apply different kernels to different channels, split the image into
    separate color planes using split and process them individually.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    anchor of the kernel that indicates the relative position of a filtered point within
    the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
    is at the kernel center.

  - **delta**: `double`.

    optional value added to the filtered pixels before storing them in dst.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and the same number of channels as src.

  The function applies an arbitrary linear filter to an image. In-place operation is supported. When
  the aperture is partially outside the image, the function interpolates outlier pixel values
  according to the specified border mode.
  The function does actually compute correlation, not the convolution:
  \\f[\\texttt{dst} (x,y) =  \\sum \\_{ \\substack{0\\leq x' < \\texttt{kernel.cols}\\\\\\\\\\{0\\leq y' < \\texttt{kernel.rows}}}}  \\texttt{kernel} (x',y')\\* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- \\texttt{anchor.y} )\\f]
  That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
  the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
  anchor.y - 1)`.
  The function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or
  larger) and the direct algorithm for small kernels.
  @sa  sepFilter2D, dft, matchTemplate

  Python prototype (for reference only):
  ```python3
  filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -> dst
  ```
  """
  @spec filter2D(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def filter2D(src, ddepth, kernel) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.filter2D(positional)
    |> to_struct()
  end

  @doc """
  Filters homography decompositions based on additional information.

  ##### Positional Arguments
  - **rotations**: `[Evision.Mat]`.

    Vector of rotation matrices.

  - **normals**: `[Evision.Mat]`.

    Vector of plane normal matrices.

  - **beforePoints**: `Evision.Mat`.

    Vector of (rectified) visible reference points before the homography is applied

  - **afterPoints**: `Evision.Mat`.

    Vector of (rectified) visible reference points after the homography is applied

  ##### Keyword Arguments
  - **pointsMask**: `Evision.Mat`.

    optional Mat/Vector of 8u type representing the mask for the inliers as given by the #findHomography function

  ##### Return
  - **possibleSolutions**: `Evision.Mat.t()`.

    Vector of int indices representing the viable solution set after filtering

  This function is intended to filter the output of the #decomposeHomographyMat based on additional
  information as described in @cite Malis2007 . The summary of the method: the #decomposeHomographyMat function
  returns 2 unique solutions and their "opposites" for a total of 4 solutions. If we have access to the
  sets of points visible in the camera frame before and after the homography transformation is applied,
  we can determine which are the true potential solutions and which are the opposites by verifying which
  homographies are consistent with all visible reference points being in front of the camera. The inputs
  are left unchanged; the filtered solution set is returned as indices into the existing one.

  Python prototype (for reference only):
  ```python3
  filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints[, possibleSolutions[, pointsMask]]) -> possibleSolutions
  ```
  """
  @spec filterHomographyDecompByVisibleRefpoints(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:pointsMask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, opts) when is_list(rotations) and is_list(normals) and (is_struct(beforePoints, Evision.Mat) or is_struct(beforePoints, Nx.Tensor) or is_number(beforePoints) or is_tuple(beforePoints)) and (is_struct(afterPoints, Evision.Mat) or is_struct(afterPoints, Nx.Tensor) or is_number(afterPoints) or is_tuple(afterPoints)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:pointsMask])
    positional = [
      rotations: Evision.Internal.Structurise.from_struct(rotations),
      normals: Evision.Internal.Structurise.from_struct(normals),
      beforePoints: Evision.Internal.Structurise.from_struct(beforePoints),
      afterPoints: Evision.Internal.Structurise.from_struct(afterPoints)
    ]
    :evision_nif.filterHomographyDecompByVisibleRefpoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Filters homography decompositions based on additional information.

  ##### Positional Arguments
  - **rotations**: `[Evision.Mat]`.

    Vector of rotation matrices.

  - **normals**: `[Evision.Mat]`.

    Vector of plane normal matrices.

  - **beforePoints**: `Evision.Mat`.

    Vector of (rectified) visible reference points before the homography is applied

  - **afterPoints**: `Evision.Mat`.

    Vector of (rectified) visible reference points after the homography is applied

  ##### Keyword Arguments
  - **pointsMask**: `Evision.Mat`.

    optional Mat/Vector of 8u type representing the mask for the inliers as given by the #findHomography function

  ##### Return
  - **possibleSolutions**: `Evision.Mat.t()`.

    Vector of int indices representing the viable solution set after filtering

  This function is intended to filter the output of the #decomposeHomographyMat based on additional
  information as described in @cite Malis2007 . The summary of the method: the #decomposeHomographyMat function
  returns 2 unique solutions and their "opposites" for a total of 4 solutions. If we have access to the
  sets of points visible in the camera frame before and after the homography transformation is applied,
  we can determine which are the true potential solutions and which are the opposites by verifying which
  homographies are consistent with all visible reference points being in front of the camera. The inputs
  are left unchanged; the filtered solution set is returned as indices into the existing one.

  Python prototype (for reference only):
  ```python3
  filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints[, possibleSolutions[, pointsMask]]) -> possibleSolutions
  ```
  """
  @spec filterHomographyDecompByVisibleRefpoints(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints) when is_list(rotations) and is_list(normals) and (is_struct(beforePoints, Evision.Mat) or is_struct(beforePoints, Nx.Tensor) or is_number(beforePoints) or is_tuple(beforePoints)) and (is_struct(afterPoints, Evision.Mat) or is_struct(afterPoints, Nx.Tensor) or is_number(afterPoints) or is_tuple(afterPoints))
  do
    positional = [
      rotations: Evision.Internal.Structurise.from_struct(rotations),
      normals: Evision.Internal.Structurise.from_struct(normals),
      beforePoints: Evision.Internal.Structurise.from_struct(beforePoints),
      afterPoints: Evision.Internal.Structurise.from_struct(afterPoints)
    ]
    :evision_nif.filterHomographyDecompByVisibleRefpoints(positional)
    |> to_struct()
  end

  @doc """
  Filters off small noise blobs (speckles) in the disparity map

  ##### Positional Arguments
  - **newVal**: `double`.

    The disparity value used to paint-off the speckles

  - **maxSpeckleSize**: `integer()`.

    The maximum speckle size to consider it a speckle. Larger blobs are not
    affected by the algorithm

  - **maxDiff**: `double`.

    Maximum difference between neighbor disparity pixels to put them into the same
    blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point
    disparity map, where disparity values are multiplied by 16, this scale factor should be taken into
    account when specifying this parameter value.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    The input 16-bit signed disparity image

  - **buf**: `Evision.Mat.t()`.

    The optional temporary buffer to avoid memory allocation within the function.

  Python prototype (for reference only):
  ```python3
  filterSpeckles(img, newVal, maxSpeckleSize, maxDiff[, buf]) -> img, buf
  ```
  """
  @spec filterSpeckles(Evision.Mat.maybe_mat_in(), number(), integer(), number(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_number(newVal) and is_integer(maxSpeckleSize) and is_number(maxDiff) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      newVal: Evision.Internal.Structurise.from_struct(newVal),
      maxSpeckleSize: Evision.Internal.Structurise.from_struct(maxSpeckleSize),
      maxDiff: Evision.Internal.Structurise.from_struct(maxDiff)
    ]
    :evision_nif.filterSpeckles(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Filters off small noise blobs (speckles) in the disparity map

  ##### Positional Arguments
  - **newVal**: `double`.

    The disparity value used to paint-off the speckles

  - **maxSpeckleSize**: `integer()`.

    The maximum speckle size to consider it a speckle. Larger blobs are not
    affected by the algorithm

  - **maxDiff**: `double`.

    Maximum difference between neighbor disparity pixels to put them into the same
    blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point
    disparity map, where disparity values are multiplied by 16, this scale factor should be taken into
    account when specifying this parameter value.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    The input 16-bit signed disparity image

  - **buf**: `Evision.Mat.t()`.

    The optional temporary buffer to avoid memory allocation within the function.

  Python prototype (for reference only):
  ```python3
  filterSpeckles(img, newVal, maxSpeckleSize, maxDiff[, buf]) -> img, buf
  ```
  """
  @spec filterSpeckles(Evision.Mat.maybe_mat_in(), number(), integer(), number()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def filterSpeckles(img, newVal, maxSpeckleSize, maxDiff) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_number(newVal) and is_integer(maxSpeckleSize) and is_number(maxDiff)
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      newVal: Evision.Internal.Structurise.from_struct(newVal),
      maxSpeckleSize: Evision.Internal.Structurise.from_struct(maxSpeckleSize),
      maxDiff: Evision.Internal.Structurise.from_struct(maxDiff)
    ]
    :evision_nif.filterSpeckles(positional)
    |> to_struct()
  end

  @doc """
  find4QuadCornerSubpix

  ##### Positional Arguments
  - **img**: `Evision.Mat`
  - **region_size**: `Size`

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`

  Python prototype (for reference only):
  ```python3
  find4QuadCornerSubpix(img, corners, region_size) -> retval, corners
  ```
  """
  @spec find4QuadCornerSubpix(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | false | {:error, String.t()}
  def find4QuadCornerSubpix(img, corners, region_size) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (is_struct(corners, Evision.Mat) or is_struct(corners, Nx.Tensor) or is_number(corners) or is_tuple(corners)) and is_tuple(region_size)
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      corners: Evision.Internal.Structurise.from_struct(corners),
      region_size: Evision.Internal.Structurise.from_struct(region_size)
    ]
    :evision_nif.find4QuadCornerSubpix(positional)
    |> to_struct()
  end

  @doc """
  Finds the positions of internal corners of the chessboard.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source chessboard view. It must be an 8-bit grayscale or color image.

  - **patternSize**: `Size`.

    Number of inner corners per a chessboard row and column
    ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Various operation flags that can be zero or a combination of the following values:
    - @ref CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the image to black
      and white, rather than a fixed threshold level (computed from the average image brightness).
    - @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with #equalizeHist before
      applying fixed or adaptive thresholding.
    - @ref CALIB_CB_FILTER_QUADS Use additional criteria (like contour area, perimeter,
      square-like shape) to filter out false quads extracted at the contour retrieval stage.
    - @ref CALIB_CB_FAST_CHECK Run a fast check on the image that looks for chessboard corners,
      and shortcut the call if none is found. This can drastically speed up the call in the
      degenerate condition when no chessboard is observed.
    - @ref CALIB_CB_PLAIN All other flags are ignored. The input image is taken as is.
      No image processing is done to improve to find the checkerboard. This has the effect of speeding up the
      execution of the function but could lead to not recognizing the checkerboard if the image
      is not previously binarized in the appropriate manner.

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`.

    Output array of detected corners.

  The function attempts to determine whether the input image is a view of the chessboard pattern and
  locate the internal chessboard corners. The function returns a non-zero value if all of the corners
  are found and they are placed in a certain order (row by row, left to right in every row).
  Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example,
  a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black
  squares touch each other. The detected coordinates are approximate, and to determine their positions
  more accurately, the function calls #cornerSubPix. You also may use the function #cornerSubPix with
  different parameters if returned coordinates are not accurate enough.
  Sample usage of detecting and drawing chessboard corners: :
  ```
  Size patternsize(8,6); //interior number of corners
  Mat gray = ....; //source image
  vector<Point2f> corners; //this will be filled by the detected corners
  //CALIB_CB_FAST_CHECK saves a lot of time on images
  //that do not contain any chessboard corners
  bool patternfound = findChessboardCorners(gray, patternsize, corners,
  CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE
  + CALIB_CB_FAST_CHECK);
  if(patternfound)
  cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),
  TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));
  drawChessboardCorners(img, patternsize, Mat(corners), patternfound);
  ```
  **Note**: The function requires white space (like a square-thick border, the wider the better) around
  the board to make the detection more robust in various environments. Otherwise, if there is no
  border and the background is dark, the outer black squares cannot be segmented properly and so the
  square grouping and ordering algorithm fails.
  Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard.

  Python prototype (for reference only):
  ```python3
  findChessboardCorners(image, patternSize[, corners[, flags]]) -> retval, corners
  ```
  """
  @spec findChessboardCorners(Evision.Mat.maybe_mat_in(), {number(), number()}, [{:flags, term()}] | nil) :: Evision.Mat.t() | false | {:error, String.t()}
  def findChessboardCorners(image, patternSize, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize)
    ]
    :evision_nif.findChessboardCorners(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the positions of internal corners of the chessboard.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source chessboard view. It must be an 8-bit grayscale or color image.

  - **patternSize**: `Size`.

    Number of inner corners per a chessboard row and column
    ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Various operation flags that can be zero or a combination of the following values:
    - @ref CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the image to black
      and white, rather than a fixed threshold level (computed from the average image brightness).
    - @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with #equalizeHist before
      applying fixed or adaptive thresholding.
    - @ref CALIB_CB_FILTER_QUADS Use additional criteria (like contour area, perimeter,
      square-like shape) to filter out false quads extracted at the contour retrieval stage.
    - @ref CALIB_CB_FAST_CHECK Run a fast check on the image that looks for chessboard corners,
      and shortcut the call if none is found. This can drastically speed up the call in the
      degenerate condition when no chessboard is observed.
    - @ref CALIB_CB_PLAIN All other flags are ignored. The input image is taken as is.
      No image processing is done to improve to find the checkerboard. This has the effect of speeding up the
      execution of the function but could lead to not recognizing the checkerboard if the image
      is not previously binarized in the appropriate manner.

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`.

    Output array of detected corners.

  The function attempts to determine whether the input image is a view of the chessboard pattern and
  locate the internal chessboard corners. The function returns a non-zero value if all of the corners
  are found and they are placed in a certain order (row by row, left to right in every row).
  Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example,
  a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black
  squares touch each other. The detected coordinates are approximate, and to determine their positions
  more accurately, the function calls #cornerSubPix. You also may use the function #cornerSubPix with
  different parameters if returned coordinates are not accurate enough.
  Sample usage of detecting and drawing chessboard corners: :
  ```
  Size patternsize(8,6); //interior number of corners
  Mat gray = ....; //source image
  vector<Point2f> corners; //this will be filled by the detected corners
  //CALIB_CB_FAST_CHECK saves a lot of time on images
  //that do not contain any chessboard corners
  bool patternfound = findChessboardCorners(gray, patternsize, corners,
  CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE
  + CALIB_CB_FAST_CHECK);
  if(patternfound)
  cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),
  TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));
  drawChessboardCorners(img, patternsize, Mat(corners), patternfound);
  ```
  **Note**: The function requires white space (like a square-thick border, the wider the better) around
  the board to make the detection more robust in various environments. Otherwise, if there is no
  border and the background is dark, the outer black squares cannot be segmented properly and so the
  square grouping and ordering algorithm fails.
  Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard.

  Python prototype (for reference only):
  ```python3
  findChessboardCorners(image, patternSize[, corners[, flags]]) -> retval, corners
  ```
  """
  @spec findChessboardCorners(Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | false | {:error, String.t()}
  def findChessboardCorners(image, patternSize) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize)
    ]
    :evision_nif.findChessboardCorners(positional)
    |> to_struct()
  end

  @doc """
  findChessboardCornersSB

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **patternSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findChessboardCornersSB(image, patternSize[, corners[, flags]]) -> retval, corners
  ```
  """
  @spec findChessboardCornersSB(Evision.Mat.maybe_mat_in(), {number(), number()}, [{:flags, term()}] | nil) :: Evision.Mat.t() | false | {:error, String.t()}
  def findChessboardCornersSB(image, patternSize, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize)
    ]
    :evision_nif.findChessboardCornersSB(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  findChessboardCornersSB

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **patternSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findChessboardCornersSB(image, patternSize[, corners[, flags]]) -> retval, corners
  ```
  """
  @spec findChessboardCornersSB(Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | false | {:error, String.t()}
  def findChessboardCornersSB(image, patternSize) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize)
    ]
    :evision_nif.findChessboardCornersSB(positional)
    |> to_struct()
  end

  @doc """
  Finds the positions of internal corners of the chessboard using a sector based approach.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source chessboard view. It must be an 8-bit grayscale or color image.

  - **patternSize**: `Size`.

    Number of inner corners per a chessboard row and column
    ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).

  - **flags**: `integer()`.

    Various operation flags that can be zero or a combination of the following values:
    - @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before detection.
    - @ref CALIB_CB_EXHAUSTIVE Run an exhaustive search to improve detection rate.
    - @ref CALIB_CB_ACCURACY Up sample input image to improve sub-pixel accuracy due to aliasing effects.
    - @ref CALIB_CB_LARGER The detected pattern is allowed to be larger than patternSize (see description).
    - @ref CALIB_CB_MARKER The detected pattern must have a marker (see description).
      This should be used if an accurate camera calibration is required.

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`.

    Output array of detected corners.

  - **meta**: `Evision.Mat.t()`.

    Optional output arrray of detected corners (CV_8UC1 and size = cv::Size(columns,rows)).
    Each entry stands for one corner of the pattern and can have one of the following values:
    - 0 = no meta data attached
    - 1 = left-top corner of a black cell
    - 2 = left-top corner of a white cell
    - 3 = left-top corner of a black cell with a white marker dot
    - 4 = left-top corner of a white cell with a black marker dot (pattern origin in case of markers otherwise first corner)

  The function is analog to #findChessboardCorners but uses a localized radon
  transformation approximated by box filters being more robust to all sort of
  noise, faster on larger images and is able to directly return the sub-pixel
  position of the internal chessboard corners. The Method is based on the paper
  @cite duda2018 "Accurate Detection and Localization of Checkerboard Corners for
  Calibration" demonstrating that the returned sub-pixel positions are more
  accurate than the one returned by cornerSubPix allowing a precise camera
  calibration for demanding applications.
  In the case, the flags @ref CALIB_CB_LARGER or @ref CALIB_CB_MARKER are given,
  the result can be recovered from the optional meta array. Both flags are
  helpful to use calibration patterns exceeding the field of view of the camera.
  These oversized patterns allow more accurate calibrations as corners can be
  utilized, which are as close as possible to the image borders.  For a
  consistent coordinate system across all images, the optional marker (see image
  below) can be used to move the origin of the board to the location where the
  black circle is located.
  **Note**: The function requires a white boarder with roughly the same width as one
  of the checkerboard fields around the whole board to improve the detection in
  various environments. In addition, because of the localized radon
  transformation it is beneficial to use round corners for the field corners
  which are located on the outside of the board. The following figure illustrates
  a sample checkerboard optimized for the detection. However, any other checkerboard
  can be used as well.
  Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard.
  ![Checkerboard](pics/checkerboard_radon.png)

  Python prototype (for reference only):
  ```python3
  findChessboardCornersSBWithMeta(image, patternSize, flags[, corners[, meta]]) -> retval, corners, meta
  ```
  """
  @spec findChessboardCornersSBWithMeta(Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def findChessboardCornersSBWithMeta(image, patternSize, flags, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.findChessboardCornersSBWithMeta(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the positions of internal corners of the chessboard using a sector based approach.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source chessboard view. It must be an 8-bit grayscale or color image.

  - **patternSize**: `Size`.

    Number of inner corners per a chessboard row and column
    ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).

  - **flags**: `integer()`.

    Various operation flags that can be zero or a combination of the following values:
    - @ref CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before detection.
    - @ref CALIB_CB_EXHAUSTIVE Run an exhaustive search to improve detection rate.
    - @ref CALIB_CB_ACCURACY Up sample input image to improve sub-pixel accuracy due to aliasing effects.
    - @ref CALIB_CB_LARGER The detected pattern is allowed to be larger than patternSize (see description).
    - @ref CALIB_CB_MARKER The detected pattern must have a marker (see description).
      This should be used if an accurate camera calibration is required.

  ##### Return
  - **retval**: `bool`
  - **corners**: `Evision.Mat.t()`.

    Output array of detected corners.

  - **meta**: `Evision.Mat.t()`.

    Optional output arrray of detected corners (CV_8UC1 and size = cv::Size(columns,rows)).
    Each entry stands for one corner of the pattern and can have one of the following values:
    - 0 = no meta data attached
    - 1 = left-top corner of a black cell
    - 2 = left-top corner of a white cell
    - 3 = left-top corner of a black cell with a white marker dot
    - 4 = left-top corner of a white cell with a black marker dot (pattern origin in case of markers otherwise first corner)

  The function is analog to #findChessboardCorners but uses a localized radon
  transformation approximated by box filters being more robust to all sort of
  noise, faster on larger images and is able to directly return the sub-pixel
  position of the internal chessboard corners. The Method is based on the paper
  @cite duda2018 "Accurate Detection and Localization of Checkerboard Corners for
  Calibration" demonstrating that the returned sub-pixel positions are more
  accurate than the one returned by cornerSubPix allowing a precise camera
  calibration for demanding applications.
  In the case, the flags @ref CALIB_CB_LARGER or @ref CALIB_CB_MARKER are given,
  the result can be recovered from the optional meta array. Both flags are
  helpful to use calibration patterns exceeding the field of view of the camera.
  These oversized patterns allow more accurate calibrations as corners can be
  utilized, which are as close as possible to the image borders.  For a
  consistent coordinate system across all images, the optional marker (see image
  below) can be used to move the origin of the board to the location where the
  black circle is located.
  **Note**: The function requires a white boarder with roughly the same width as one
  of the checkerboard fields around the whole board to improve the detection in
  various environments. In addition, because of the localized radon
  transformation it is beneficial to use round corners for the field corners
  which are located on the outside of the board. The following figure illustrates
  a sample checkerboard optimized for the detection. However, any other checkerboard
  can be used as well.
  Use gen_pattern.py (@ref tutorial_camera_calibration_pattern) to create checkerboard.
  ![Checkerboard](pics/checkerboard_radon.png)

  Python prototype (for reference only):
  ```python3
  findChessboardCornersSBWithMeta(image, patternSize, flags[, corners[, meta]]) -> retval, corners, meta
  ```
  """
  @spec findChessboardCornersSBWithMeta(Evision.Mat.maybe_mat_in(), {number(), number()}, integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def findChessboardCornersSBWithMeta(image, patternSize, flags) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and is_integer(flags)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.findChessboardCornersSBWithMeta(positional)
    |> to_struct()
  end

  @doc """
  Finds centers in the grid of circles.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    grid view of input circles; it must be an 8-bit grayscale or color image.

  - **patternSize**: `Size`.

    number of circles per row and column
    ( patternSize = Size(points_per_row, points_per_colum) ).

  - **flags**: `integer()`.

    various operation flags that can be one of the following values:
    - @ref CALIB_CB_SYMMETRIC_GRID uses symmetric pattern of circles.
    - @ref CALIB_CB_ASYMMETRIC_GRID uses asymmetric pattern of circles.
    - @ref CALIB_CB_CLUSTERING uses a special algorithm for grid detection. It is more robust to
      perspective distortions but much more sensitive to background clutter.

  - **blobDetector**: `FeatureDetector`.

    feature detector that finds blobs like dark circles on light background.
    If `blobDetector` is NULL then `image` represents Point2f array of candidates.

  - **parameters**: `Evision.CirclesGridFinderParameters`.

    struct for finding circles in a grid pattern.

  ##### Return
  - **retval**: `bool`
  - **centers**: `Evision.Mat.t()`.

    output array of detected centers.

  The function attempts to determine whether the input image contains a grid of circles. If it is, the
  function locates centers of the circles. The function returns a non-zero value if all of the centers
  have been found and they have been placed in a certain order (row by row, left to right in every
  row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0.
  Sample usage of detecting and drawing the centers of circles: :
  ```
  Size patternsize(7,7); //number of centers
  Mat gray = ...; //source image
  vector<Point2f> centers; //this will be filled by the detected centers
  bool patternfound = findCirclesGrid(gray, patternsize, centers);
  drawChessboardCorners(img, patternsize, Mat(centers), patternfound);
  ```
  **Note**: The function requires white space (like a square-thick border, the wider the better) around
  the board to make the detection more robust in various environments.

  Python prototype (for reference only):
  ```python3
  findCirclesGrid(image, patternSize, flags, blobDetector, parameters[, centers]) -> retval, centers
  ```
  """
  @spec findCirclesGrid(Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), reference() | term(), Evision.CirclesGridFinderParameters.t(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | false | {:error, String.t()}
  def findCirclesGrid(image, patternSize, flags, blobDetector, parameters, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and is_integer(flags) and (is_reference(blobDetector) or is_struct(blobDetector)) and is_struct(parameters, Evision.CirclesGridFinderParameters) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      flags: Evision.Internal.Structurise.from_struct(flags),
      blobDetector: Evision.Internal.Structurise.from_struct(blobDetector),
      parameters: Evision.Internal.Structurise.from_struct(parameters)
    ]
    :evision_nif.findCirclesGrid(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds centers in the grid of circles.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    grid view of input circles; it must be an 8-bit grayscale or color image.

  - **patternSize**: `Size`.

    number of circles per row and column
    ( patternSize = Size(points_per_row, points_per_colum) ).

  - **flags**: `integer()`.

    various operation flags that can be one of the following values:
    - @ref CALIB_CB_SYMMETRIC_GRID uses symmetric pattern of circles.
    - @ref CALIB_CB_ASYMMETRIC_GRID uses asymmetric pattern of circles.
    - @ref CALIB_CB_CLUSTERING uses a special algorithm for grid detection. It is more robust to
      perspective distortions but much more sensitive to background clutter.

  - **blobDetector**: `FeatureDetector`.

    feature detector that finds blobs like dark circles on light background.
    If `blobDetector` is NULL then `image` represents Point2f array of candidates.

  - **parameters**: `Evision.CirclesGridFinderParameters`.

    struct for finding circles in a grid pattern.

  ##### Return
  - **retval**: `bool`
  - **centers**: `Evision.Mat.t()`.

    output array of detected centers.

  The function attempts to determine whether the input image contains a grid of circles. If it is, the
  function locates centers of the circles. The function returns a non-zero value if all of the centers
  have been found and they have been placed in a certain order (row by row, left to right in every
  row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0.
  Sample usage of detecting and drawing the centers of circles: :
  ```
  Size patternsize(7,7); //number of centers
  Mat gray = ...; //source image
  vector<Point2f> centers; //this will be filled by the detected centers
  bool patternfound = findCirclesGrid(gray, patternsize, centers);
  drawChessboardCorners(img, patternsize, Mat(centers), patternfound);
  ```
  **Note**: The function requires white space (like a square-thick border, the wider the better) around
  the board to make the detection more robust in various environments.

  Python prototype (for reference only):
  ```python3
  findCirclesGrid(image, patternSize, flags, blobDetector, parameters[, centers]) -> retval, centers
  ```
  """
  @spec findCirclesGrid(Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), reference() | term(), Evision.CirclesGridFinderParameters.t()) :: Evision.Mat.t() | false | {:error, String.t()}
  def findCirclesGrid(image, patternSize, flags, blobDetector, parameters) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and is_integer(flags) and (is_reference(blobDetector) or is_struct(blobDetector)) and is_struct(parameters, Evision.CirclesGridFinderParameters)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize),
      flags: Evision.Internal.Structurise.from_struct(flags),
      blobDetector: Evision.Internal.Structurise.from_struct(blobDetector),
      parameters: Evision.Internal.Structurise.from_struct(parameters)
    ]
    :evision_nif.findCirclesGrid(positional)
    |> to_struct()
  end

  @doc """
  findCirclesGrid

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **patternSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **blobDetector**: `FeatureDetector`.

  ##### Return
  - **retval**: `bool`
  - **centers**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findCirclesGrid(image, patternSize[, centers[, flags[, blobDetector]]]) -> retval, centers
  ```
  """
  @spec findCirclesGrid(Evision.Mat.maybe_mat_in(), {number(), number()}, [{:blobDetector, term()} | {:flags, term()}] | nil) :: Evision.Mat.t() | false | {:error, String.t()}
  def findCirclesGrid(image, patternSize, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:blobDetector, :flags])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize)
    ]
    :evision_nif.findCirclesGrid(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  findCirclesGrid

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **patternSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **blobDetector**: `FeatureDetector`.

  ##### Return
  - **retval**: `bool`
  - **centers**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findCirclesGrid(image, patternSize[, centers[, flags[, blobDetector]]]) -> retval, centers
  ```
  """
  @spec findCirclesGrid(Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | false | {:error, String.t()}
  def findCirclesGrid(image, patternSize) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patternSize)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patternSize: Evision.Internal.Structurise.from_struct(patternSize)
    ]
    :evision_nif.findCirclesGrid(positional)
    |> to_struct()
  end

  @doc """
  Finds contours in a binary image.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
    pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold ,
    #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.
    If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).

  - **mode**: `integer()`.

    Contour retrieval mode, see #RetrievalModes

  - **method**: `integer()`.

    Contour approximation method, see #ContourApproximationModes

  ##### Keyword Arguments
  - **offset**: `Point`.

    Optional offset by which every contour point is shifted. This is useful if the
    contours are extracted from the image ROI and then they should be analyzed in the whole image
    context.

  ##### Return
  - **contours**: `[Evision.Mat]`.

    Detected contours. Each contour is stored as a vector of points (e.g.
    std::vector<std::vector<cv::Point> >).

  - **hierarchy**: `Evision.Mat.t()`.

    Optional output vector (e.g. std::vector<cv::Vec4i>), containing information about the image topology. It has
    as many elements as the number of contours. For each i-th contour contours[i], the elements
    hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
    in contours of the next and previous contours at the same hierarchical level, the first child
    contour and the parent contour, respectively. If for the contour i there are no next, previous,
    parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.

  The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours
  are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
  OpenCV sample directory.
  **Note**: Since opencv 3.2 source image is not modified by this function.
  **Note**: In Python, hierarchy is nested inside a top level array. Use hierarchy[0][i] to access hierarchical elements of i-th contour.

  Python prototype (for reference only):
  ```python3
  findContours(image, mode, method[, contours[, hierarchy[, offset]]]) -> contours, hierarchy
  ```
  """
  @spec findContours(Evision.Mat.maybe_mat_in(), integer(), integer(), [{:offset, term()}] | nil) :: {list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def findContours(image, mode, method, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(mode) and is_integer(method) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:offset])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      mode: Evision.Internal.Structurise.from_struct(mode),
      method: Evision.Internal.Structurise.from_struct(method)
    ]
    :evision_nif.findContours(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds contours in a binary image.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
    pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold ,
    #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.
    If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).

  - **mode**: `integer()`.

    Contour retrieval mode, see #RetrievalModes

  - **method**: `integer()`.

    Contour approximation method, see #ContourApproximationModes

  ##### Keyword Arguments
  - **offset**: `Point`.

    Optional offset by which every contour point is shifted. This is useful if the
    contours are extracted from the image ROI and then they should be analyzed in the whole image
    context.

  ##### Return
  - **contours**: `[Evision.Mat]`.

    Detected contours. Each contour is stored as a vector of points (e.g.
    std::vector<std::vector<cv::Point> >).

  - **hierarchy**: `Evision.Mat.t()`.

    Optional output vector (e.g. std::vector<cv::Vec4i>), containing information about the image topology. It has
    as many elements as the number of contours. For each i-th contour contours[i], the elements
    hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
    in contours of the next and previous contours at the same hierarchical level, the first child
    contour and the parent contour, respectively. If for the contour i there are no next, previous,
    parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.

  The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours
  are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
  OpenCV sample directory.
  **Note**: Since opencv 3.2 source image is not modified by this function.
  **Note**: In Python, hierarchy is nested inside a top level array. Use hierarchy[0][i] to access hierarchical elements of i-th contour.

  Python prototype (for reference only):
  ```python3
  findContours(image, mode, method[, contours[, hierarchy[, offset]]]) -> contours, hierarchy
  ```
  """
  @spec findContours(Evision.Mat.maybe_mat_in(), integer(), integer()) :: {list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def findContours(image, mode, method) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(mode) and is_integer(method)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      mode: Evision.Internal.Structurise.from_struct(mode),
      method: Evision.Internal.Structurise.from_struct(method)
    ]
    :evision_nif.findContours(positional)
    |> to_struct()
  end

  @doc """
  findContoursLinkRuns

  ##### Positional Arguments
  - **image**: `Evision.Mat`

  ##### Return
  - **contours**: `[Evision.Mat]`.

  Python prototype (for reference only):
  ```python3
  findContoursLinkRuns(image[, contours]) -> contours
  ```
  """
  @spec findContoursLinkRuns(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: list(Evision.Mat.t()) | {:error, String.t()}
  def findContoursLinkRuns(image, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image)
    ]
    :evision_nif.findContoursLinkRuns(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  findContoursLinkRuns

  ##### Positional Arguments
  - **image**: `Evision.Mat`

  ##### Return
  - **contours**: `[Evision.Mat]`.

  Python prototype (for reference only):
  ```python3
  findContoursLinkRuns(image[, contours]) -> contours
  ```
  """
  @spec findContoursLinkRuns(Evision.Mat.maybe_mat_in()) :: list(Evision.Mat.t()) | {:error, String.t()}
  def findContoursLinkRuns(image) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image)
    ]
    :evision_nif.findContoursLinkRuns(positional)
    |> to_struct()
  end

  @doc """
  findEssentialMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`
  - **points2**: `Evision.Mat`
  - **cameraMatrix1**: `Evision.Mat`
  - **cameraMatrix2**: `Evision.Mat`
  - **dist_coeff1**: `Evision.Mat`
  - **dist_coeff2**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, params[, mask]) -> retval, mask
  ```
  """
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, params, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(dist_coeff1, Evision.Mat) or is_struct(dist_coeff1, Nx.Tensor) or is_number(dist_coeff1) or is_tuple(dist_coeff1)) and (is_struct(dist_coeff2, Evision.Mat) or is_struct(dist_coeff2, Nx.Tensor) or is_number(dist_coeff2) or is_tuple(dist_coeff2)) and is_struct(params, Evision.UsacParams) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      dist_coeff1: Evision.Internal.Structurise.from_struct(dist_coeff1),
      dist_coeff2: Evision.Internal.Structurise.from_struct(dist_coeff2),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.findEssentialMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  findEssentialMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`
  - **points2**: `Evision.Mat`
  - **cameraMatrix1**: `Evision.Mat`
  - **cameraMatrix2**: `Evision.Mat`
  - **dist_coeff1**: `Evision.Mat`
  - **dist_coeff2**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, params[, mask]) -> retval, mask
  ```
  #### Variant 2:
  Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N (N \\>= 5) 2D points from the first image. The point coordinates should
    be floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1.

  - **cameraMatrix1**: `Evision.Mat`.

    Camera matrix for the first camera \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs1**: `Evision.Mat`.

    Input vector of distortion coefficients for the first camera
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  - **cameraMatrix2**: `Evision.Mat`.

    Camera matrix for the second camera \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs2**: `Evision.Mat`.

    Input vector of distortion coefficients for the second camera
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method for computing an essential matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Output array of N elements, every element of which is set to 0 for outliers and to 1
    for the other points. The array is computed only in the RANSAC and LMedS methods.

  This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 .
  @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation:
  \\f[\\[p\\_2; 1]^T K^{-T} E K^{-1} \\[p\\_1; 1] = 0\\f]
  where \\f$E\\f$ is an essential matrix, \\f$p\\_1\\f$ and \\f$p\\_2\\f$ are corresponding points in the first and the
  second images, respectively. The result of this function may be passed further to
  #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, method[, prob[, threshold[, mask]]]]) -> retval, mask
  ```

  """
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:method, term()} | {:prob, term()} | {:threshold, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:method, :prob, :threshold])
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2)
    ]
    :evision_nif.findEssentialMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, params) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(dist_coeff1, Evision.Mat) or is_struct(dist_coeff1, Nx.Tensor) or is_number(dist_coeff1) or is_tuple(dist_coeff1)) and (is_struct(dist_coeff2, Evision.Mat) or is_struct(dist_coeff2, Nx.Tensor) or is_number(dist_coeff2) or is_tuple(dist_coeff2)) and is_struct(params, Evision.UsacParams)
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      dist_coeff1: Evision.Internal.Structurise.from_struct(dist_coeff1),
      dist_coeff2: Evision.Internal.Structurise.from_struct(dist_coeff2),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.findEssentialMat(positional)
    |> to_struct()
  end

  @doc """
  Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N (N \\>= 5) 2D points from the first image. The point coordinates should
    be floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1.

  - **cameraMatrix1**: `Evision.Mat`.

    Camera matrix for the first camera \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs1**: `Evision.Mat`.

    Input vector of distortion coefficients for the first camera
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  - **cameraMatrix2**: `Evision.Mat`.

    Camera matrix for the second camera \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs2**: `Evision.Mat`.

    Input vector of distortion coefficients for the second camera
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method for computing an essential matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Output array of N elements, every element of which is set to 0 for outliers and to 1
    for the other points. The array is computed only in the RANSAC and LMedS methods.

  This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 .
  @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation:
  \\f[\\[p\\_2; 1]^T K^{-T} E K^{-1} \\[p\\_1; 1] = 0\\f]
  where \\f$E\\f$ is an essential matrix, \\f$p\\_1\\f$ and \\f$p\\_2\\f$ are corresponding points in the first and the
  second images, respectively. The result of this function may be passed further to
  #decomposeEssentialMat or  #recoverPose to recover the relative pose between cameras.

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, method[, prob[, threshold[, mask]]]]) -> retval, mask
  ```
  """
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2)
    ]
    :evision_nif.findEssentialMat(positional)
    |> to_struct()
  end

  @doc """
  Calculates an essential matrix from the corresponding points in two images.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N (N \\>= 5) 2D points from the first image. The point coordinates should
    be floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1.

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .
    Note that this function assumes that points1 and points2 are feature points from cameras with the
    same camera intrinsic matrix. If this assumption does not hold for your use case, use another
    function overload or #undistortPoints with `P = cv::NoArray()` for both cameras to transform image
    points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
    When passing these coordinates, pass the identity matrix for this parameter.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method for computing an essential matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  - **maxIters**: `integer()`.

    The maximum number of robust method iterations.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Output array of N elements, every element of which is set to 0 for outliers and to 1
    for the other points. The array is computed only in the RANSAC and LMedS methods.

  This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 .
  @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation:
  \\f[\\[p\\_2; 1]^T K^{-T} E K^{-1} \\[p\\_1; 1] = 0\\f]
  where \\f$E\\f$ is an essential matrix, \\f$p\\_1\\f$ and \\f$p\\_2\\f$ are corresponding points in the first and the
  second images, respectively. The result of this function may be passed further to
  #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2, cameraMatrix[, method[, prob[, threshold[, maxIters[, mask]]]]]) -> retval, mask
  ```
  """
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:maxIters, term()} | {:method, term()} | {:prob, term()} | {:threshold, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, cameraMatrix, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxIters, :method, :prob, :threshold])
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix)
    ]
    :evision_nif.findEssentialMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Calculates an essential matrix from the corresponding points in two images.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N (N \\>= 5) 2D points from the first image. The point coordinates should
    be floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1.

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .
    Note that this function assumes that points1 and points2 are feature points from cameras with the
    same camera intrinsic matrix. If this assumption does not hold for your use case, use another
    function overload or #undistortPoints with `P = cv::NoArray()` for both cameras to transform image
    points to normalized image coordinates, which are valid for the identity camera intrinsic matrix.
    When passing these coordinates, pass the identity matrix for this parameter.

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method for computing an essential matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  - **maxIters**: `integer()`.

    The maximum number of robust method iterations.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Output array of N elements, every element of which is set to 0 for outliers and to 1
    for the other points. The array is computed only in the RANSAC and LMedS methods.

  This function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 .
  @cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation:
  \\f[\\[p\\_2; 1]^T K^{-T} E K^{-1} \\[p\\_1; 1] = 0\\f]
  where \\f$E\\f$ is an essential matrix, \\f$p\\_1\\f$ and \\f$p\\_2\\f$ are corresponding points in the first and the
  second images, respectively. The result of this function may be passed further to
  #decomposeEssentialMat or #recoverPose to recover the relative pose between cameras.

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2, cameraMatrix[, method[, prob[, threshold[, maxIters[, mask]]]]]) -> retval, mask
  ```
  #### Variant 2:
  findEssentialMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N (N \\>= 5) 2D points from the first image. The point coordinates should
    be floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  ##### Keyword Arguments
  - **focal**: `double`.

    focal length of the camera. Note that this function assumes that points1 and points2
    are feature points from cameras with same focal length and principal point.

  - **pp**: `Point2d`.

    principal point of the camera.

  - **method**: `integer()`.

    Method for computing a fundamental matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  - **maxIters**: `integer()`.

    The maximum number of robust method iterations.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Output array of N elements, every element of which is set to 0 for outliers and to 1
    for the other points. The array is computed only in the RANSAC and LMedS methods.

  Has overloading in C++

  This function differs from the one above that it computes camera intrinsic matrix from focal length and
  principal point:
  \\f[A =
  \\begin{bmatrix}
  f & 0 & x\\_{pp}  \\\\\\\\
  0 & f & y\\_{pp}  \\\\\\\\
  0 & 0 & 1
  \\end{bmatrix}\\f]

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2[, focal[, pp[, method[, prob[, threshold[, maxIters[, mask]]]]]]]) -> retval, mask
  ```

  """
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:focal, term()} | {:maxIters, term()} | {:method, term()} | {:pp, term()} | {:prob, term()} | {:threshold, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:focal, :maxIters, :method, :pp, :prob, :threshold])
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.findEssentialMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2, cameraMatrix) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix)
    ]
    :evision_nif.findEssentialMat(positional)
    |> to_struct()
  end

  @doc """
  findEssentialMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N (N \\>= 5) 2D points from the first image. The point coordinates should
    be floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  ##### Keyword Arguments
  - **focal**: `double`.

    focal length of the camera. Note that this function assumes that points1 and points2
    are feature points from cameras with same focal length and principal point.

  - **pp**: `Point2d`.

    principal point of the camera.

  - **method**: `integer()`.

    Method for computing a fundamental matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  - **maxIters**: `integer()`.

    The maximum number of robust method iterations.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Output array of N elements, every element of which is set to 0 for outliers and to 1
    for the other points. The array is computed only in the RANSAC and LMedS methods.

  Has overloading in C++

  This function differs from the one above that it computes camera intrinsic matrix from focal length and
  principal point:
  \\f[A =
  \\begin{bmatrix}
  f & 0 & x\\_{pp}  \\\\\\\\
  0 & f & y\\_{pp}  \\\\\\\\
  0 & 0 & 1
  \\end{bmatrix}\\f]

  Python prototype (for reference only):
  ```python3
  findEssentialMat(points1, points2[, focal[, pp[, method[, prob[, threshold[, maxIters[, mask]]]]]]]) -> retval, mask
  ```
  """
  @spec findEssentialMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findEssentialMat(points1, points2) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.findEssentialMat(positional)
    |> to_struct()
  end

  @doc """
  Calculates a fundamental matrix from the corresponding points in two images.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  - **method**: `integer()`.

    Method for computing a fundamental matrix.
    - @ref FM_7POINT for a 7-point algorithm. \\f$N = 7\\f$
    - @ref FM_8POINT for an 8-point algorithm. \\f$N \\ge 8\\f$
    - @ref FM_RANSAC for the RANSAC algorithm. \\f$N \\ge 8\\f$
    - @ref FM_LMEDS for the LMedS algorithm. \\f$N \\ge 8\\f$

  - **ransacReprojThreshold**: `double`.

    Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  - **confidence**: `double`.

    Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level
    of confidence (probability) that the estimated matrix is correct.

  - **maxIters**: `integer()`.

    The maximum number of robust method iterations.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    optional output mask

  The epipolar geometry is described by the following equation:
  \\f[\\[p\\_2; 1]^T F \\[p\\_1; 1] = 0\\f]
  where \\f$F\\f$ is a fundamental matrix, \\f$p\\_1\\f$ and \\f$p\\_2\\f$ are corresponding points in the first and the
  second images, respectively.
  The function calculates the fundamental matrix using one of four methods listed above and returns
  the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point
  algorithm, the function may return up to 3 solutions ( \\f$9 \\times 3\\f$ matrix that stores all 3
  matrices sequentially).
  The calculated fundamental matrix may be passed further to #computeCorrespondEpilines that finds the
  epipolar lines corresponding to the specified points. It can also be passed to
  #stereoRectifyUncalibrated to compute the rectification transformation. :
  ```
  // Example. Estimation of fundamental matrix using the RANSAC algorithm
  int point_count = 100;
  vector<Point2f> points1(point_count);
  vector<Point2f> points2(point_count);
  // initialize the points here ...
  for( int i = 0; i < point_count; i++ )
  {
  points1[i] = ...;
  points2[i] = ...;
  }
  Mat fundamental_matrix =
  findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);
  ```

  Python prototype (for reference only):
  ```python3
  findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters[, mask]) -> retval, mask
  ```
  """
  @spec findFundamentalMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), number(), number(), integer(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and is_integer(method) and is_number(ransacReprojThreshold) and is_number(confidence) and is_integer(maxIters) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      method: Evision.Internal.Structurise.from_struct(method),
      ransacReprojThreshold: Evision.Internal.Structurise.from_struct(ransacReprojThreshold),
      confidence: Evision.Internal.Structurise.from_struct(confidence),
      maxIters: Evision.Internal.Structurise.from_struct(maxIters)
    ]
    :evision_nif.findFundamentalMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates a fundamental matrix from the corresponding points in two images.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  - **method**: `integer()`.

    Method for computing a fundamental matrix.
    - @ref FM_7POINT for a 7-point algorithm. \\f$N = 7\\f$
    - @ref FM_8POINT for an 8-point algorithm. \\f$N \\ge 8\\f$
    - @ref FM_RANSAC for the RANSAC algorithm. \\f$N \\ge 8\\f$
    - @ref FM_LMEDS for the LMedS algorithm. \\f$N \\ge 8\\f$

  - **ransacReprojThreshold**: `double`.

    Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  - **confidence**: `double`.

    Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level
    of confidence (probability) that the estimated matrix is correct.

  - **maxIters**: `integer()`.

    The maximum number of robust method iterations.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    optional output mask

  The epipolar geometry is described by the following equation:
  \\f[\\[p\\_2; 1]^T F \\[p\\_1; 1] = 0\\f]
  where \\f$F\\f$ is a fundamental matrix, \\f$p\\_1\\f$ and \\f$p\\_2\\f$ are corresponding points in the first and the
  second images, respectively.
  The function calculates the fundamental matrix using one of four methods listed above and returns
  the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point
  algorithm, the function may return up to 3 solutions ( \\f$9 \\times 3\\f$ matrix that stores all 3
  matrices sequentially).
  The calculated fundamental matrix may be passed further to #computeCorrespondEpilines that finds the
  epipolar lines corresponding to the specified points. It can also be passed to
  #stereoRectifyUncalibrated to compute the rectification transformation. :
  ```
  // Example. Estimation of fundamental matrix using the RANSAC algorithm
  int point_count = 100;
  vector<Point2f> points1(point_count);
  vector<Point2f> points2(point_count);
  // initialize the points here ...
  for( int i = 0; i < point_count; i++ )
  {
  points1[i] = ...;
  points2[i] = ...;
  }
  Mat fundamental_matrix =
  findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);
  ```

  Python prototype (for reference only):
  ```python3
  findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters[, mask]) -> retval, mask
  ```
  """
  @spec findFundamentalMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), number(), number(), integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and is_integer(method) and is_number(ransacReprojThreshold) and is_number(confidence) and is_integer(maxIters)
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      method: Evision.Internal.Structurise.from_struct(method),
      ransacReprojThreshold: Evision.Internal.Structurise.from_struct(ransacReprojThreshold),
      confidence: Evision.Internal.Structurise.from_struct(confidence),
      maxIters: Evision.Internal.Structurise.from_struct(maxIters)
    ]
    :evision_nif.findFundamentalMat(positional)
    |> to_struct()
  end

  @doc """
  findFundamentalMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`
  - **points2**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findFundamentalMat(points1, points2, params[, mask]) -> retval, mask
  ```
  """
  @spec findFundamentalMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findFundamentalMat(points1, points2, params, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and is_struct(params, Evision.UsacParams) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.findFundamentalMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  findFundamentalMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`
  - **points2**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findFundamentalMat(points1, points2, params[, mask]) -> retval, mask
  ```
  #### Variant 2:
  findFundamentalMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`
  - **points2**: `Evision.Mat`

  ##### Keyword Arguments
  - **method**: `integer()`.
  - **ransacReprojThreshold**: `double`.
  - **confidence**: `double`.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findFundamentalMat(points1, points2[, method[, ransacReprojThreshold[, confidence[, mask]]]]) -> retval, mask
  ```

  """
  @spec findFundamentalMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:confidence, term()} | {:method, term()} | {:ransacReprojThreshold, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findFundamentalMat(points1, points2, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:confidence, :method, :ransacReprojThreshold])
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.findFundamentalMat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec findFundamentalMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findFundamentalMat(points1, points2, params) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and is_struct(params, Evision.UsacParams)
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.findFundamentalMat(positional)
    |> to_struct()
  end

  @doc """
  findFundamentalMat

  ##### Positional Arguments
  - **points1**: `Evision.Mat`
  - **points2**: `Evision.Mat`

  ##### Keyword Arguments
  - **method**: `integer()`.
  - **ransacReprojThreshold**: `double`.
  - **confidence**: `double`.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findFundamentalMat(points1, points2[, method[, ransacReprojThreshold[, confidence[, mask]]]]) -> retval, mask
  ```
  """
  @spec findFundamentalMat(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findFundamentalMat(points1, points2) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.findFundamentalMat(positional)
    |> to_struct()
  end

  @doc """
  findHomography

  ##### Positional Arguments
  - **srcPoints**: `Evision.Mat`
  - **dstPoints**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findHomography(srcPoints, dstPoints, params[, mask]) -> retval, mask
  ```
  """
  @spec findHomography(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findHomography(srcPoints, dstPoints, params, opts) when (is_struct(srcPoints, Evision.Mat) or is_struct(srcPoints, Nx.Tensor) or is_number(srcPoints) or is_tuple(srcPoints)) and (is_struct(dstPoints, Evision.Mat) or is_struct(dstPoints, Nx.Tensor) or is_number(dstPoints) or is_tuple(dstPoints)) and is_struct(params, Evision.UsacParams) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      srcPoints: Evision.Internal.Structurise.from_struct(srcPoints),
      dstPoints: Evision.Internal.Structurise.from_struct(dstPoints),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.findHomography(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  findHomography

  ##### Positional Arguments
  - **srcPoints**: `Evision.Mat`
  - **dstPoints**: `Evision.Mat`
  - **params**: `Evision.UsacParams`

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findHomography(srcPoints, dstPoints, params[, mask]) -> retval, mask
  ```
  #### Variant 2:
  Finds a perspective transformation between two planes.

  ##### Positional Arguments
  - **srcPoints**: `Evision.Mat`.

    Coordinates of the points in the original plane, a matrix of the type CV_32FC2
    or vector\\<Point2f\\> .

  - **dstPoints**: `Evision.Mat`.

    Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
    a vector\\<Point2f\\> .

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method used to compute a homography matrix. The following methods are possible:
    - **0** - a regular method using all the points, i.e., the least squares method
    - @ref RANSAC - RANSAC-based robust method
    - @ref LMEDS - Least-Median robust method
    - @ref RHO - PROSAC-based robust method

  - **ransacReprojThreshold**: `double`.

    Maximum allowed reprojection error to treat a point pair as an inlier
    (used in the RANSAC and RHO methods only). That is, if
    \\f[\\| \\texttt{dstPoints} _i -  \\texttt{convertPointsHomogeneous} ( \\texttt{H} \\cdot \\texttt{srcPoints} _i) \\|_2  >  \\texttt{ransacReprojThreshold}\\f]
    then the point \\f$i\\f$ is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
    it usually makes sense to set this parameter somewhere in the range of 1 to 10.

  - **maxIters**: `integer()`.

    The maximum number of RANSAC iterations.

  - **confidence**: `double`.

    Confidence level, between 0 and 1.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input
    mask values are ignored.

  The function finds and returns the perspective transformation \\f$H\\f$ between the source and the
  destination planes:
  \\f[s\\_i  \\vecthree{x'\\_i}{y'\\_i}{1} \\sim H  \\vecthree{x\\_i}{y\\_i}{1}\\f]
  so that the back-projection error
  \\f[\\sum \\_i \\left ( x'\\_i- \\frac{h\\_{11} x\\_i + h\\_{12} y\\_i + h\\_{13}}{h\\_{31} x\\_i + h\\_{32} y\\_i + h\\_{33}} \\right )^2+ \\left ( y'\\_i- \\frac{h\\_{21} x\\_i + h\\_{22} y\\_i + h\\_{23}}{h\\_{31} x\\_i + h\\_{32} y\\_i + h\\_{33}} \\right )^2\\f]
  is minimized. If the parameter method is set to the default value 0, the function uses all the point
  pairs to compute an initial homography estimate with a simple least-squares scheme.
  However, if not all of the point pairs ( \\f$srcPoints\\_i\\f$, \\f$dstPoints\\_i\\f$ ) fit the rigid perspective
  transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
  you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
  random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
  using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
  computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
  LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
  the mask of inliers/outliers.
  Regardless of the method, robust or not, the computed homography matrix is refined further (using
  inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
  re-projection error even more.
  The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
  distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
  correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
  noise is rather small, use the default method (method=0).
  The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
  determined up to a scale. If \\f$h\\_{33}\\f$ is non-zero, the matrix is normalized so that \\f$h\\_{33}=1\\f$.
  **Note**: Whenever an \\f$H\\f$ matrix cannot be estimated, an empty one will be returned.
  @sa
  getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
  perspectiveTransform

  Python prototype (for reference only):
  ```python3
  findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask[, maxIters[, confidence]]]]]) -> retval, mask
  ```

  """
  @spec findHomography(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:confidence, term()} | {:maxIters, term()} | {:method, term()} | {:ransacReprojThreshold, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findHomography(srcPoints, dstPoints, opts) when (is_struct(srcPoints, Evision.Mat) or is_struct(srcPoints, Nx.Tensor) or is_number(srcPoints) or is_tuple(srcPoints)) and (is_struct(dstPoints, Evision.Mat) or is_struct(dstPoints, Nx.Tensor) or is_number(dstPoints) or is_tuple(dstPoints)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:confidence, :maxIters, :method, :ransacReprojThreshold])
    positional = [
      srcPoints: Evision.Internal.Structurise.from_struct(srcPoints),
      dstPoints: Evision.Internal.Structurise.from_struct(dstPoints)
    ]
    :evision_nif.findHomography(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec findHomography(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.UsacParams.t()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findHomography(srcPoints, dstPoints, params) when (is_struct(srcPoints, Evision.Mat) or is_struct(srcPoints, Nx.Tensor) or is_number(srcPoints) or is_tuple(srcPoints)) and (is_struct(dstPoints, Evision.Mat) or is_struct(dstPoints, Nx.Tensor) or is_number(dstPoints) or is_tuple(dstPoints)) and is_struct(params, Evision.UsacParams)
  do
    positional = [
      srcPoints: Evision.Internal.Structurise.from_struct(srcPoints),
      dstPoints: Evision.Internal.Structurise.from_struct(dstPoints),
      params: Evision.Internal.Structurise.from_struct(params)
    ]
    :evision_nif.findHomography(positional)
    |> to_struct()
  end

  @doc """
  Finds a perspective transformation between two planes.

  ##### Positional Arguments
  - **srcPoints**: `Evision.Mat`.

    Coordinates of the points in the original plane, a matrix of the type CV_32FC2
    or vector\\<Point2f\\> .

  - **dstPoints**: `Evision.Mat`.

    Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or
    a vector\\<Point2f\\> .

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method used to compute a homography matrix. The following methods are possible:
    - **0** - a regular method using all the points, i.e., the least squares method
    - @ref RANSAC - RANSAC-based robust method
    - @ref LMEDS - Least-Median robust method
    - @ref RHO - PROSAC-based robust method

  - **ransacReprojThreshold**: `double`.

    Maximum allowed reprojection error to treat a point pair as an inlier
    (used in the RANSAC and RHO methods only). That is, if
    \\f[\\| \\texttt{dstPoints} _i -  \\texttt{convertPointsHomogeneous} ( \\texttt{H} \\cdot \\texttt{srcPoints} _i) \\|_2  >  \\texttt{ransacReprojThreshold}\\f]
    then the point \\f$i\\f$ is considered as an outlier. If srcPoints and dstPoints are measured in pixels,
    it usually makes sense to set this parameter somewhere in the range of 1 to 10.

  - **maxIters**: `integer()`.

    The maximum number of RANSAC iterations.

  - **confidence**: `double`.

    Confidence level, between 0 and 1.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **mask**: `Evision.Mat.t()`.

    Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input
    mask values are ignored.

  The function finds and returns the perspective transformation \\f$H\\f$ between the source and the
  destination planes:
  \\f[s\\_i  \\vecthree{x'\\_i}{y'\\_i}{1} \\sim H  \\vecthree{x\\_i}{y\\_i}{1}\\f]
  so that the back-projection error
  \\f[\\sum \\_i \\left ( x'\\_i- \\frac{h\\_{11} x\\_i + h\\_{12} y\\_i + h\\_{13}}{h\\_{31} x\\_i + h\\_{32} y\\_i + h\\_{33}} \\right )^2+ \\left ( y'\\_i- \\frac{h\\_{21} x\\_i + h\\_{22} y\\_i + h\\_{23}}{h\\_{31} x\\_i + h\\_{32} y\\_i + h\\_{33}} \\right )^2\\f]
  is minimized. If the parameter method is set to the default value 0, the function uses all the point
  pairs to compute an initial homography estimate with a simple least-squares scheme.
  However, if not all of the point pairs ( \\f$srcPoints\\_i\\f$, \\f$dstPoints\\_i\\f$ ) fit the rigid perspective
  transformation (that is, there are some outliers), this initial estimate will be poor. In this case,
  you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different
  random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix
  using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the
  computed homography (which is the number of inliers for RANSAC or the least median re-projection error for
  LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and
  the mask of inliers/outliers.
  Regardless of the method, robust or not, the computed homography matrix is refined further (using
  inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the
  re-projection error even more.
  The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to
  distinguish inliers from outliers. The method LMeDS does not need any threshold but it works
  correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the
  noise is rather small, use the default method (method=0).
  The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is
  determined up to a scale. If \\f$h\\_{33}\\f$ is non-zero, the matrix is normalized so that \\f$h\\_{33}=1\\f$.
  **Note**: Whenever an \\f$H\\f$ matrix cannot be estimated, an empty one will be returned.
  @sa
  getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,
  perspectiveTransform

  Python prototype (for reference only):
  ```python3
  findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask[, maxIters[, confidence]]]]]) -> retval, mask
  ```
  """
  @spec findHomography(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def findHomography(srcPoints, dstPoints) when (is_struct(srcPoints, Evision.Mat) or is_struct(srcPoints, Nx.Tensor) or is_number(srcPoints) or is_tuple(srcPoints)) and (is_struct(dstPoints, Evision.Mat) or is_struct(dstPoints, Nx.Tensor) or is_number(dstPoints) or is_tuple(dstPoints))
  do
    positional = [
      srcPoints: Evision.Internal.Structurise.from_struct(srcPoints),
      dstPoints: Evision.Internal.Structurise.from_struct(dstPoints)
    ]
    :evision_nif.findHomography(positional)
    |> to_struct()
  end

  @doc """
  Returns the list of locations of non-zero pixels

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    single-channel array

  ##### Return
  - **idx**: `Evision.Mat.t()`.

    the output array, type of cv::Mat or std::vector<Point>, corresponding to non-zero indices in the input

  Given a binary matrix (likely returned from an operation such
  as threshold(), compare(), >, ==, etc, return all of
  the non-zero indices as a cv::Mat or std::vector<cv::Point> (x,y)
  For example:
  ```cpp
  cv::Mat binaryImage; // input, binary image
  cv::Mat locations;   // output, locations of non-zero pixels
  cv::findNonZero(binaryImage, locations);
  // access pixel coordinates
  Point pnt = locations.at<Point>(i);
  ```
  or
  ```cpp
  cv::Mat binaryImage; // input, binary image
  vector<Point> locations;   // output, locations of non-zero pixels
  cv::findNonZero(binaryImage, locations);
  // access pixel coordinates
  Point pnt = locations[i];
  ```
  The function do not work with multi-channel arrays. If you need to find non-zero
  elements across all the channels, use Mat::reshape first to reinterpret the array as
  single-channel. Or you may extract the particular channel using either extractImageCOI, or
  mixChannels, or split.
  **Note**: 
  - If only count of non-zero array elements is important, @ref countNonZero is helpful.
  - If only whether there are non-zero elements is important, @ref hasNonZero is helpful.
  @sa  countNonZero, hasNonZero

  Python prototype (for reference only):
  ```python3
  findNonZero(src[, idx]) -> idx
  ```
  """
  @spec findNonZero(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def findNonZero(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.findNonZero(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns the list of locations of non-zero pixels

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    single-channel array

  ##### Return
  - **idx**: `Evision.Mat.t()`.

    the output array, type of cv::Mat or std::vector<Point>, corresponding to non-zero indices in the input

  Given a binary matrix (likely returned from an operation such
  as threshold(), compare(), >, ==, etc, return all of
  the non-zero indices as a cv::Mat or std::vector<cv::Point> (x,y)
  For example:
  ```cpp
  cv::Mat binaryImage; // input, binary image
  cv::Mat locations;   // output, locations of non-zero pixels
  cv::findNonZero(binaryImage, locations);
  // access pixel coordinates
  Point pnt = locations.at<Point>(i);
  ```
  or
  ```cpp
  cv::Mat binaryImage; // input, binary image
  vector<Point> locations;   // output, locations of non-zero pixels
  cv::findNonZero(binaryImage, locations);
  // access pixel coordinates
  Point pnt = locations[i];
  ```
  The function do not work with multi-channel arrays. If you need to find non-zero
  elements across all the channels, use Mat::reshape first to reinterpret the array as
  single-channel. Or you may extract the particular channel using either extractImageCOI, or
  mixChannels, or split.
  **Note**: 
  - If only count of non-zero array elements is important, @ref countNonZero is helpful.
  - If only whether there are non-zero elements is important, @ref hasNonZero is helpful.
  @sa  countNonZero, hasNonZero

  Python prototype (for reference only):
  ```python3
  findNonZero(src[, idx]) -> idx
  ```
  """
  @spec findNonZero(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def findNonZero(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.findNonZero(positional)
    |> to_struct()
  end

  @doc """
  Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .

  ##### Positional Arguments
  - **templateImage**: `Evision.Mat`.

    single-channel template image; CV_8U or CV_32F array.

  - **inputImage**: `Evision.Mat`.

    single-channel input image which should be warped with the final warpMatrix in
    order to provide an image similar to templateImage, same type as templateImage.

  - **motionType**: `integer()`.

    parameter, specifying the type of motion:
    - **MOTION_TRANSLATION** sets a translational motion model; warpMatrix is \\f$2\\times 3\\f$ with
      the first \\f$2\\times 2\\f$ part being the unity matrix and the rest two parameters being
      estimated.
    - **MOTION_EUCLIDEAN** sets a Euclidean (rigid) transformation as motion model; three
      parameters are estimated; warpMatrix is \\f$2\\times 3\\f$.
    - **MOTION_AFFINE** sets an affine motion model (DEFAULT); six parameters are estimated;
      warpMatrix is \\f$2\\times 3\\f$.
    - **MOTION_HOMOGRAPHY** sets a homography as a motion model; eight parameters are
      estimated;\\`warpMatrix\\` is \\f$3\\times 3\\f$.

  - **criteria**: `TermCriteria`.

    parameter, specifying the termination criteria of the ECC algorithm;
    criteria.epsilon defines the threshold of the increment in the correlation coefficient between two
    iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion).
    Default values are shown in the declaration above.

  - **inputMask**: `Evision.Mat`.

    An optional mask to indicate valid values of inputImage.

  - **gaussFiltSize**: `integer()`.

    An optional value indicating size of gaussian blur filter; (DEFAULT: 5)

  ##### Return
  - **retval**: `double`
  - **warpMatrix**: `Evision.Mat.t()`.

    floating-point \\f$2\\times 3\\f$ or \\f$3\\times 3\\f$ mapping matrix (warp).

  The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion
  (@cite EP08), that is
  \\f[\\texttt{warpMatrix} = \\arg\\max\\_{W} \\texttt{ECC}(\\texttt{templateImage}(x,y),\\texttt{inputImage}(x',y'))\\f]
  where
  \\f[\\begin{bmatrix} x' \\\\\\\\ y' \\end{bmatrix} = W \\cdot \\begin{bmatrix} x \\\\\\\\ y \\\\\\\\ 1 \\end{bmatrix}\\f]
  (the equation holds with homogeneous coordinates for homography). It returns the final enhanced
  correlation coefficient, that is the correlation coefficient between the template image and the
  final warped input image. When a \\f$3\\times 3\\f$ matrix is given with motionType =0, 1 or 2, the third
  row is ignored.
  Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an
  area-based alignment that builds on intensity similarities. In essence, the function updates the
  initial transformation that roughly aligns the images. If this information is missing, the identity
  warp (unity matrix) is used as an initialization. Note that if images undergo strong
  displacements/rotations, an initial transformation that roughly aligns the images is necessary
  (e.g., a simple euclidean/similarity transform that allows for the images showing the same image
  content approximately). Use inverse warping in the second image to take an image close to the first
  one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV
  sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws
  an exception if algorithm does not converges.
  @sa
  computeECC, estimateAffine2D, estimateAffinePartial2D, findHomography

  Python prototype (for reference only):
  ```python3
  findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize) -> retval, warpMatrix
  ```
  """
  @spec findTransformECC(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), {integer(), integer(), number()}, Evision.Mat.maybe_mat_in(), integer()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize) when (is_struct(templateImage, Evision.Mat) or is_struct(templateImage, Nx.Tensor) or is_number(templateImage) or is_tuple(templateImage)) and (is_struct(inputImage, Evision.Mat) or is_struct(inputImage, Nx.Tensor) or is_number(inputImage) or is_tuple(inputImage)) and (is_struct(warpMatrix, Evision.Mat) or is_struct(warpMatrix, Nx.Tensor) or is_number(warpMatrix) or is_tuple(warpMatrix)) and is_integer(motionType) and is_tuple(criteria) and (is_struct(inputMask, Evision.Mat) or is_struct(inputMask, Nx.Tensor) or is_number(inputMask) or is_tuple(inputMask)) and is_integer(gaussFiltSize)
  do
    positional = [
      templateImage: Evision.Internal.Structurise.from_struct(templateImage),
      inputImage: Evision.Internal.Structurise.from_struct(inputImage),
      warpMatrix: Evision.Internal.Structurise.from_struct(warpMatrix),
      motionType: Evision.Internal.Structurise.from_struct(motionType),
      criteria: Evision.Internal.Structurise.from_struct(criteria),
      inputMask: Evision.Internal.Structurise.from_struct(inputMask),
      gaussFiltSize: Evision.Internal.Structurise.from_struct(gaussFiltSize)
    ]
    :evision_nif.findTransformECC(positional)
    |> to_struct()
  end

  @doc """
  findTransformECC

  ##### Positional Arguments
  - **templateImage**: `Evision.Mat`
  - **inputImage**: `Evision.Mat`

  ##### Keyword Arguments
  - **motionType**: `integer()`.
  - **criteria**: `TermCriteria`.
  - **inputMask**: `Evision.Mat`.

  ##### Return
  - **retval**: `double`
  - **warpMatrix**: `Evision.Mat.t()`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findTransformECC(templateImage, inputImage, warpMatrix[, motionType[, criteria[, inputMask]]]) -> retval, warpMatrix
  ```
  """
  @spec findTransformECC(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:inputMask, term()} | {:motionType, term()}] | nil) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def findTransformECC(templateImage, inputImage, warpMatrix, opts) when (is_struct(templateImage, Evision.Mat) or is_struct(templateImage, Nx.Tensor) or is_number(templateImage) or is_tuple(templateImage)) and (is_struct(inputImage, Evision.Mat) or is_struct(inputImage, Nx.Tensor) or is_number(inputImage) or is_tuple(inputImage)) and (is_struct(warpMatrix, Evision.Mat) or is_struct(warpMatrix, Nx.Tensor) or is_number(warpMatrix) or is_tuple(warpMatrix)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :inputMask, :motionType])
    positional = [
      templateImage: Evision.Internal.Structurise.from_struct(templateImage),
      inputImage: Evision.Internal.Structurise.from_struct(inputImage),
      warpMatrix: Evision.Internal.Structurise.from_struct(warpMatrix)
    ]
    :evision_nif.findTransformECC(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  findTransformECC

  ##### Positional Arguments
  - **templateImage**: `Evision.Mat`
  - **inputImage**: `Evision.Mat`

  ##### Keyword Arguments
  - **motionType**: `integer()`.
  - **criteria**: `TermCriteria`.
  - **inputMask**: `Evision.Mat`.

  ##### Return
  - **retval**: `double`
  - **warpMatrix**: `Evision.Mat.t()`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  findTransformECC(templateImage, inputImage, warpMatrix[, motionType[, criteria[, inputMask]]]) -> retval, warpMatrix
  ```
  """
  @spec findTransformECC(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def findTransformECC(templateImage, inputImage, warpMatrix) when (is_struct(templateImage, Evision.Mat) or is_struct(templateImage, Nx.Tensor) or is_number(templateImage) or is_tuple(templateImage)) and (is_struct(inputImage, Evision.Mat) or is_struct(inputImage, Nx.Tensor) or is_number(inputImage) or is_tuple(inputImage)) and (is_struct(warpMatrix, Evision.Mat) or is_struct(warpMatrix, Nx.Tensor) or is_number(warpMatrix) or is_tuple(warpMatrix))
  do
    positional = [
      templateImage: Evision.Internal.Structurise.from_struct(templateImage),
      inputImage: Evision.Internal.Structurise.from_struct(inputImage),
      warpMatrix: Evision.Internal.Structurise.from_struct(warpMatrix)
    ]
    :evision_nif.findTransformECC(positional)
    |> to_struct()
  end

  @doc """
  Fits an ellipse around a set of 2D points.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input 2D point set, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `{centre={x, y}, size={s1, s2}, angle}`

  The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of
  all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by @cite Fitzgibbon95
  is used. Developer should keep in mind that it is possible that the returned
  ellipse/rotatedRect data contains negative indices, due to the data points being close to the
  border of the containing Mat element.

  Python prototype (for reference only):
  ```python3
  fitEllipse(points) -> retval
  ```
  """
  @spec fitEllipse(Evision.Mat.maybe_mat_in()) :: {{number(), number()}, {number(), number()}, number()} | {:error, String.t()}
  def fitEllipse(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.fitEllipse(positional)
    |> to_struct()
  end

  @doc """
  Fits an ellipse around a set of 2D points.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input 2D point set, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `{centre={x, y}, size={s1, s2}, angle}`

  The function calculates the ellipse that fits a set of 2D points.
  It returns the rotated rectangle in which the ellipse is inscribed.
  The Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used.
  For an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$,
  which is a set of six free coefficients \\f$ A^T=\\left\\\\{A\\_{\\text{xx}},A\\_{\\text{xy}},A\\_{\\text{yy}},A\\_x,A\\_y,A\\_0\\right\\\\} \\f$.
  However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$,
  the position \\f$ (x\\_0,y\\_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines,
  quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
  If the fit is found to be a parabolic or hyperbolic function then the standard #fitEllipse method is used.
  The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves
  by imposing the condition that \\f$ A^T ( D\\_x^T D\\_x  +   D\\_y^T D\\_y) A = 1 \\f$ where
  the matrices \\f$ Dx \\f$ and \\f$ Dy \\f$ are the partial derivatives of the design matrix \\f$ D \\f$ with
  respect to x and y. The matrices are formed row by row applying the following to
  each of the points in the set:
  \\f{align*}{
  D(i,:)&=\\left\\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\right\\} &
  D_x(i,:)&=\\left\\{2 x_i,y_i,0,1,0,0\\right\\} &
  D_y(i,:)&=\\left\\{0,x_i,2 y_i,0,1,0\\right\\}
  \\f}
  The AMS method minimizes the cost function
  \\f{equation*}{
  \\epsilon ^2=\\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }
  \\f}
  The minimum cost is found by solving the generalized eigenvalue problem.
  \\f{equation*}{
  D^T D A = \\lambda  \\left( D_x^T D_x +  D_y^T D_y\\right) A
  \\f}

  Python prototype (for reference only):
  ```python3
  fitEllipseAMS(points) -> retval
  ```
  """
  @spec fitEllipseAMS(Evision.Mat.maybe_mat_in()) :: {{number(), number()}, {number(), number()}, number()} | {:error, String.t()}
  def fitEllipseAMS(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.fitEllipseAMS(positional)
    |> to_struct()
  end

  @doc """
  Fits an ellipse around a set of 2D points.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input 2D point set, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `{centre={x, y}, size={s1, s2}, angle}`

  The function calculates the ellipse that fits a set of 2D points.
  It returns the rotated rectangle in which the ellipse is inscribed.
  The Direct least square (Direct) method by @cite Fitzgibbon1999 is used.
  For an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$,
  which is a set of six free coefficients \\f$ A^T=\\left\\\\{A\\_{\\text{xx}},A\\_{\\text{xy}},A\\_{\\text{yy}},A\\_x,A\\_y,A\\_0\\right\\\\} \\f$.
  However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$,
  the position \\f$ (x\\_0,y\\_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines,
  quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
  The Direct method confines the fit to ellipses by ensuring that \\f$ 4 A\\_{xx} A\\_{yy}- A\\_{xy}^2 > 0 \\f$.
  The condition imposed is that \\f$ 4 A\\_{xx} A\\_{yy}- A\\_{xy}^2=1 \\f$ which satisfies the inequality
  and as the coefficients can be arbitrarily scaled is not overly restrictive.
  \\f{equation*}{
  \\epsilon ^2= A^T D^T D A \\quad \\text{with} \\quad A^T C A =1 \\quad \\text{and} \\quad C=\\left(\\begin{matrix}
  0 & 0  & 2  & 0  & 0  &  0  \\\\\\\\
  0 & -1  & 0  & 0  & 0  &  0 \\\\\\\\
  2 & 0  & 0  & 0  & 0  &  0 \\\\\\\\
  0 & 0  & 0  & 0  & 0  &  0 \\\\\\\\
  0 & 0  & 0  & 0  & 0  &  0 \\\\\\\\
  0 & 0  & 0  & 0  & 0  &  0
  \\end{matrix} \\right)
  \\f}
  The minimum cost is found by solving the generalized eigenvalue problem.
  \\f{equation*}{
  D^T D A = \\lambda  \\left( C\\right) A
  \\f}
  The system produces only one positive eigenvalue \\f$ \\lambda\\f$ which is chosen as the solution
  with its eigenvector \\f$\\mathbf{u}\\f$. These are used to find the coefficients
  \\f{equation*}{
  A = \\sqrt{\\frac{1}{\\mathbf{u}^T C \\mathbf{u}}}  \\mathbf{u}
  \\f}
  The scaling factor guarantees that  \\f$A^T C A =1\\f$.

  Python prototype (for reference only):
  ```python3
  fitEllipseDirect(points) -> retval
  ```
  """
  @spec fitEllipseDirect(Evision.Mat.maybe_mat_in()) :: {{number(), number()}, {number(), number()}, number()} | {:error, String.t()}
  def fitEllipseDirect(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.fitEllipseDirect(positional)
    |> to_struct()
  end

  @doc """
  Fits a line to a 2D or 3D point set.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input vector of 2D or 3D points, stored in std::vector\\<\\> or Mat.

  - **distType**: `integer()`.

    Distance used by the M-estimator, see #DistanceTypes

  - **param**: `double`.

    Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value
    is chosen.

  - **reps**: `double`.

    Sufficient accuracy for the radius (distance between the coordinate origin and the line).

  - **aeps**: `double`.

    Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.

  ##### Return
  - **line**: `Evision.Mat.t()`.

    Output line parameters. In case of 2D fitting, it should be a vector of 4 elements
    (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and
    (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like
    Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line
    and (x0, y0, z0) is a point on the line.

  The function fitLine fits a line to a 2D or 3D point set by minimizing \\f$\\sum\\_i \\rho(r\\_i)\\f$ where
  \\f$r\\_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and \\f$\\rho(r)\\f$ is a distance function, one
  of the following:
  - DIST_L2
    \\f[\\rho (r) = r^2/2  \\quad \\text{(the simplest and the fastest least-squares method)}\\f]

  - DIST_L1
    \\f[\\rho (r) = r\\f]

  - DIST_L12
    \\f[\\rho (r) = 2  \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f]

  - DIST_FAIR
    \\f[\\rho \\left (r \\right ) = C^2  \\cdot \\left (  \\frac{r}{C} -  \\log{\\left(1 + \\frac{r}{C}\\right)} \\right )  \\quad \\text{where} \\quad C=1.3998\\f]

  - DIST_WELSCH
    \\f[\\rho \\left (r \\right ) =  \\frac{C^2}{2} \\cdot \\left ( 1 -  \\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right )  \\quad \\text{where} \\quad C=2.9846\\f]

  - DIST_HUBER
    \\f[\\rho (r) =  \\fork{r^2/2}{if \\(r < C\\)}{C \\cdot (r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f]

  The algorithm is based on the M-estimator ( <http://en.wikipedia.org/wiki/M-estimator> ) technique
  that iteratively fits the line using the weighted least-squares algorithm. After each iteration the
  weights \\f$w\\_i\\f$ are adjusted to be inversely proportional to \\f$\\rho(r\\_i)\\f$ .

  Python prototype (for reference only):
  ```python3
  fitLine(points, distType, param, reps, aeps[, line]) -> line
  ```
  """
  @spec fitLine(Evision.Mat.maybe_mat_in(), integer(), number(), number(), number(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def fitLine(points, distType, param, reps, aeps, opts) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and is_integer(distType) and is_number(param) and is_number(reps) and is_number(aeps) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points),
      distType: Evision.Internal.Structurise.from_struct(distType),
      param: Evision.Internal.Structurise.from_struct(param),
      reps: Evision.Internal.Structurise.from_struct(reps),
      aeps: Evision.Internal.Structurise.from_struct(aeps)
    ]
    :evision_nif.fitLine(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Fits a line to a 2D or 3D point set.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input vector of 2D or 3D points, stored in std::vector\\<\\> or Mat.

  - **distType**: `integer()`.

    Distance used by the M-estimator, see #DistanceTypes

  - **param**: `double`.

    Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value
    is chosen.

  - **reps**: `double`.

    Sufficient accuracy for the radius (distance between the coordinate origin and the line).

  - **aeps**: `double`.

    Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.

  ##### Return
  - **line**: `Evision.Mat.t()`.

    Output line parameters. In case of 2D fitting, it should be a vector of 4 elements
    (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and
    (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like
    Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line
    and (x0, y0, z0) is a point on the line.

  The function fitLine fits a line to a 2D or 3D point set by minimizing \\f$\\sum\\_i \\rho(r\\_i)\\f$ where
  \\f$r\\_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and \\f$\\rho(r)\\f$ is a distance function, one
  of the following:
  - DIST_L2
    \\f[\\rho (r) = r^2/2  \\quad \\text{(the simplest and the fastest least-squares method)}\\f]

  - DIST_L1
    \\f[\\rho (r) = r\\f]

  - DIST_L12
    \\f[\\rho (r) = 2  \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f]

  - DIST_FAIR
    \\f[\\rho \\left (r \\right ) = C^2  \\cdot \\left (  \\frac{r}{C} -  \\log{\\left(1 + \\frac{r}{C}\\right)} \\right )  \\quad \\text{where} \\quad C=1.3998\\f]

  - DIST_WELSCH
    \\f[\\rho \\left (r \\right ) =  \\frac{C^2}{2} \\cdot \\left ( 1 -  \\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right )  \\quad \\text{where} \\quad C=2.9846\\f]

  - DIST_HUBER
    \\f[\\rho (r) =  \\fork{r^2/2}{if \\(r < C\\)}{C \\cdot (r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f]

  The algorithm is based on the M-estimator ( <http://en.wikipedia.org/wiki/M-estimator> ) technique
  that iteratively fits the line using the weighted least-squares algorithm. After each iteration the
  weights \\f$w\\_i\\f$ are adjusted to be inversely proportional to \\f$\\rho(r\\_i)\\f$ .

  Python prototype (for reference only):
  ```python3
  fitLine(points, distType, param, reps, aeps[, line]) -> line
  ```
  """
  @spec fitLine(Evision.Mat.maybe_mat_in(), integer(), number(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def fitLine(points, distType, param, reps, aeps) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and is_integer(distType) and is_number(param) and is_number(reps) and is_number(aeps)
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points),
      distType: Evision.Internal.Structurise.from_struct(distType),
      param: Evision.Internal.Structurise.from_struct(param),
      reps: Evision.Internal.Structurise.from_struct(reps),
      aeps: Evision.Internal.Structurise.from_struct(aeps)
    ]
    :evision_nif.fitLine(positional)
    |> to_struct()
  end

  @doc """
  Flips a 2D array around vertical, horizontal, or both axes.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **flipCode**: `integer()`.

    a flag to specify how to flip the array; 0 means
    flipping around the x-axis and positive value (for example, 1) means
    flipping around y-axis. Negative value (for example, -1) means flipping
    around both axes.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::flip flips the array in one of three different ways (row
  and column indices are 0-based):
  \\f[\\texttt{dst} \\_{ij} =
  \\left\\\\{
  \\begin{array}{l l}
  \\texttt{src} \\_{\\texttt{src.rows}-i-1,j} & if\\;  \\texttt{flipCode} = 0 \\\\\\\\
  \\texttt{src} \\_{i, \\texttt{src.cols} -j-1} & if\\;  \\texttt{flipCode} > 0 \\\\\\\\
  \\texttt{src} \\_{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} & if\\; \\texttt{flipCode} < 0 \\\\\\\\
  \\end{array}
  \\right.\\f]
  The example scenarios of using the function are the following:
     Vertical flipping of the image (flipCode == 0) to switch between
  top-left and bottom-left image origin. This is a typical operation
  in video processing on Microsoft Windows\\* OS.
     Horizontal flipping of the image with the subsequent horizontal
  shift and absolute difference calculation to check for a
  vertical-axis symmetry (flipCode \\> 0).
     Simultaneous horizontal and vertical flipping of the image with
  the subsequent shift and absolute difference calculation to check
  for a central symmetry (flipCode \\< 0).
     Reversing the order of point arrays (flipCode \\> 0 or
  flipCode == 0).
  @sa transpose, repeat, completeSymm

  Python prototype (for reference only):
  ```python3
  flip(src, flipCode[, dst]) -> dst
  ```
  """
  @spec flip(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def flip(src, flipCode, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(flipCode) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      flipCode: Evision.Internal.Structurise.from_struct(flipCode)
    ]
    :evision_nif.flip(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Flips a 2D array around vertical, horizontal, or both axes.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **flipCode**: `integer()`.

    a flag to specify how to flip the array; 0 means
    flipping around the x-axis and positive value (for example, 1) means
    flipping around y-axis. Negative value (for example, -1) means flipping
    around both axes.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::flip flips the array in one of three different ways (row
  and column indices are 0-based):
  \\f[\\texttt{dst} \\_{ij} =
  \\left\\\\{
  \\begin{array}{l l}
  \\texttt{src} \\_{\\texttt{src.rows}-i-1,j} & if\\;  \\texttt{flipCode} = 0 \\\\\\\\
  \\texttt{src} \\_{i, \\texttt{src.cols} -j-1} & if\\;  \\texttt{flipCode} > 0 \\\\\\\\
  \\texttt{src} \\_{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} & if\\; \\texttt{flipCode} < 0 \\\\\\\\
  \\end{array}
  \\right.\\f]
  The example scenarios of using the function are the following:
     Vertical flipping of the image (flipCode == 0) to switch between
  top-left and bottom-left image origin. This is a typical operation
  in video processing on Microsoft Windows\\* OS.
     Horizontal flipping of the image with the subsequent horizontal
  shift and absolute difference calculation to check for a
  vertical-axis symmetry (flipCode \\> 0).
     Simultaneous horizontal and vertical flipping of the image with
  the subsequent shift and absolute difference calculation to check
  for a central symmetry (flipCode \\< 0).
     Reversing the order of point arrays (flipCode \\> 0 or
  flipCode == 0).
  @sa transpose, repeat, completeSymm

  Python prototype (for reference only):
  ```python3
  flip(src, flipCode[, dst]) -> dst
  ```
  """
  @spec flip(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def flip(src, flipCode) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(flipCode)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      flipCode: Evision.Internal.Structurise.from_struct(flipCode)
    ]
    :evision_nif.flip(positional)
    |> to_struct()
  end

  @doc """
  Flips a n-dimensional at given axis

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **axis**: `integer()`.

    axis that performs a flip on. 0 <= axis < src.dims.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same shape of src

  Python prototype (for reference only):
  ```python3
  flipND(src, axis[, dst]) -> dst
  ```
  """
  @spec flipND(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def flipND(src, axis, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(axis) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      axis: Evision.Internal.Structurise.from_struct(axis)
    ]
    :evision_nif.flipND(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Flips a n-dimensional at given axis

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **axis**: `integer()`.

    axis that performs a flip on. 0 <= axis < src.dims.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array that has the same shape of src

  Python prototype (for reference only):
  ```python3
  flipND(src, axis[, dst]) -> dst
  ```
  """
  @spec flipND(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def flipND(src, axis) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(axis)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      axis: Evision.Internal.Structurise.from_struct(axis)
    ]
    :evision_nif.flipND(positional)
    |> to_struct()
  end

  @doc """
  Fills a connected component with the given color.

  ##### Positional Arguments
  - **seedPoint**: `Point`.

    Starting point.

  - **newVal**: `Evision.scalar()`.

    New value of the repainted domain pixels.

  ##### Keyword Arguments
  - **loDiff**: `Evision.scalar()`.

    Maximal lower brightness/color difference between the currently observed pixel and
    one of its neighbors belonging to the component, or a seed pixel being added to the component.

  - **upDiff**: `Evision.scalar()`.

    Maximal upper brightness/color difference between the currently observed pixel and
    one of its neighbors belonging to the component, or a seed pixel being added to the component.

  - **flags**: `integer()`.

    Operation flags. The first 8 bits contain a connectivity value. The default value of
    4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
    connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
    will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
    the mask (the default value is 1). For example, 4 | ( 255 \\<\\< 8 ) will consider 4 nearest
    neighbours and fill the mask with a value of 255. The following additional options occupy higher
    bits and therefore may be further combined with the connectivity and mask fill values using
    bit-wise or (|), see #FloodFillFlags.

  ##### Return
  - **retval**: `integer()`
  - **image**: `Evision.Mat.t()`.

    Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
    function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
    the details below.

  - **mask**: `Evision.Mat.t()`.

    Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
    taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
    input and output parameter, you must take responsibility of initializing it.
    Flood-filling cannot go across non-zero pixels in the input mask. For example,
    an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
    mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
    as described below. Additionally, the function fills the border of the mask with ones to simplify
    internal processing. It is therefore possible to use the same mask in multiple calls to the function
    to make sure the filled areas do not overlap.

  - **rect**: `Rect*`.

    Optional output parameter set by the function to the minimum bounding rectangle of the
    repainted domain.

  The function cv::floodFill fills a connected component starting from the seed point with the specified
  color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
  pixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain if:
  - in case of a grayscale image and floating range
    \\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f]

  - in case of a grayscale image and fixed range
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f]

  - in case of a color image and floating range
    \\f[\\texttt{src} (x',y')\\_r- \\texttt{loDiff} \\_r \\leq \\texttt{src} (x,y)\\_r \\leq \\texttt{src} (x',y')\\_r+ \\texttt{upDiff} \\_r,\\f]
    \\f[\\texttt{src} (x',y')\\_g- \\texttt{loDiff} \\_g \\leq \\texttt{src} (x,y)\\_g \\leq \\texttt{src} (x',y')\\_g+ \\texttt{upDiff} \\_g\\f]
    and
    \\f[\\texttt{src} (x',y')\\_b- \\texttt{loDiff} \\_b \\leq \\texttt{src} (x,y)\\_b \\leq \\texttt{src} (x',y')\\_b+ \\texttt{upDiff} \\_b\\f]

  - in case of a color image and fixed range
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_r- \\texttt{loDiff} \\_r \\leq \\texttt{src} (x,y)\\_r \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_r+ \\texttt{upDiff} \\_r,\\f]
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_g- \\texttt{loDiff} \\_g \\leq \\texttt{src} (x,y)\\_g \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_g+ \\texttt{upDiff} \\_g\\f]
    and
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_b- \\texttt{loDiff} \\_b \\leq \\texttt{src} (x,y)\\_b \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_b+ \\texttt{upDiff} \\_b\\f]

  where \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is already known to belong to the
  component. That is, to be added to the connected component, a color/brightness of the pixel should
  be close enough to:
  - Color/brightness of one of its neighbors that already belong to the connected component in case
    of a floating range.

  - Color/brightness of the seed point in case of a fixed range.

  Use these functions to either mark a connected component with the specified color in-place, or build
  a mask and then extract the contour, or copy the region to another image, and so on.

  **Note**: Since the mask is larger than the filled image, a pixel \\f$(x, y)\\f$ in image corresponds to the
  pixel \\f$(x+1, y+1)\\f$ in the mask .
  @sa findContours

  Python prototype (for reference only):
  ```python3
  floodFill(image, mask, seedPoint, newVal[, loDiff[, upDiff[, flags]]]) -> retval, image, mask, rect
  ```
  """
  @spec floodFill(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.scalar(), [{:flags, term()} | {:loDiff, term()} | {:upDiff, term()}] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), {number(), number(), number(), number()}} | {:error, String.t()}
  def floodFill(image, mask, seedPoint, newVal, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_tuple(seedPoint) and (is_number(newVal) or is_tuple(newVal)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :loDiff, :upDiff])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      mask: Evision.Internal.Structurise.from_struct(mask),
      seedPoint: Evision.Internal.Structurise.from_struct(seedPoint),
      newVal: Evision.Internal.Structurise.from_struct(newVal)
    ]
    :evision_nif.floodFill(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Fills a connected component with the given color.

  ##### Positional Arguments
  - **seedPoint**: `Point`.

    Starting point.

  - **newVal**: `Evision.scalar()`.

    New value of the repainted domain pixels.

  ##### Keyword Arguments
  - **loDiff**: `Evision.scalar()`.

    Maximal lower brightness/color difference between the currently observed pixel and
    one of its neighbors belonging to the component, or a seed pixel being added to the component.

  - **upDiff**: `Evision.scalar()`.

    Maximal upper brightness/color difference between the currently observed pixel and
    one of its neighbors belonging to the component, or a seed pixel being added to the component.

  - **flags**: `integer()`.

    Operation flags. The first 8 bits contain a connectivity value. The default value of
    4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
    connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
    will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
    the mask (the default value is 1). For example, 4 | ( 255 \\<\\< 8 ) will consider 4 nearest
    neighbours and fill the mask with a value of 255. The following additional options occupy higher
    bits and therefore may be further combined with the connectivity and mask fill values using
    bit-wise or (|), see #FloodFillFlags.

  ##### Return
  - **retval**: `integer()`
  - **image**: `Evision.Mat.t()`.

    Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
    function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
    the details below.

  - **mask**: `Evision.Mat.t()`.

    Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
    taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
    input and output parameter, you must take responsibility of initializing it.
    Flood-filling cannot go across non-zero pixels in the input mask. For example,
    an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
    mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
    as described below. Additionally, the function fills the border of the mask with ones to simplify
    internal processing. It is therefore possible to use the same mask in multiple calls to the function
    to make sure the filled areas do not overlap.

  - **rect**: `Rect*`.

    Optional output parameter set by the function to the minimum bounding rectangle of the
    repainted domain.

  The function cv::floodFill fills a connected component starting from the seed point with the specified
  color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
  pixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain if:
  - in case of a grayscale image and floating range
    \\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f]

  - in case of a grayscale image and fixed range
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f]

  - in case of a color image and floating range
    \\f[\\texttt{src} (x',y')\\_r- \\texttt{loDiff} \\_r \\leq \\texttt{src} (x,y)\\_r \\leq \\texttt{src} (x',y')\\_r+ \\texttt{upDiff} \\_r,\\f]
    \\f[\\texttt{src} (x',y')\\_g- \\texttt{loDiff} \\_g \\leq \\texttt{src} (x,y)\\_g \\leq \\texttt{src} (x',y')\\_g+ \\texttt{upDiff} \\_g\\f]
    and
    \\f[\\texttt{src} (x',y')\\_b- \\texttt{loDiff} \\_b \\leq \\texttt{src} (x,y)\\_b \\leq \\texttt{src} (x',y')\\_b+ \\texttt{upDiff} \\_b\\f]

  - in case of a color image and fixed range
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_r- \\texttt{loDiff} \\_r \\leq \\texttt{src} (x,y)\\_r \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_r+ \\texttt{upDiff} \\_r,\\f]
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_g- \\texttt{loDiff} \\_g \\leq \\texttt{src} (x,y)\\_g \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_g+ \\texttt{upDiff} \\_g\\f]
    and
    \\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_b- \\texttt{loDiff} \\_b \\leq \\texttt{src} (x,y)\\_b \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)\\_b+ \\texttt{upDiff} \\_b\\f]

  where \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is already known to belong to the
  component. That is, to be added to the connected component, a color/brightness of the pixel should
  be close enough to:
  - Color/brightness of one of its neighbors that already belong to the connected component in case
    of a floating range.

  - Color/brightness of the seed point in case of a fixed range.

  Use these functions to either mark a connected component with the specified color in-place, or build
  a mask and then extract the contour, or copy the region to another image, and so on.

  **Note**: Since the mask is larger than the filled image, a pixel \\f$(x, y)\\f$ in image corresponds to the
  pixel \\f$(x+1, y+1)\\f$ in the mask .
  @sa findContours

  Python prototype (for reference only):
  ```python3
  floodFill(image, mask, seedPoint, newVal[, loDiff[, upDiff[, flags]]]) -> retval, image, mask, rect
  ```
  """
  @spec floodFill(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.scalar()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), {number(), number(), number(), number()}} | {:error, String.t()}
  def floodFill(image, mask, seedPoint, newVal) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_tuple(seedPoint) and (is_number(newVal) or is_tuple(newVal))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      mask: Evision.Internal.Structurise.from_struct(mask),
      seedPoint: Evision.Internal.Structurise.from_struct(seedPoint),
      newVal: Evision.Internal.Structurise.from_struct(newVal)
    ]
    :evision_nif.floodFill(positional)
    |> to_struct()
  end

  @doc """
  Performs generalized matrix multiplication.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first multiplied input matrix that could be real(CV_32FC1,
    CV_64FC1) or complex(CV_32FC2, CV_64FC2).

  - **src2**: `Evision.Mat`.

    second multiplied input matrix of the same type as src1.

  - **alpha**: `double`.

    weight of the matrix product.

  - **src3**: `Evision.Mat`.

    third optional delta matrix added to the matrix product; it
    should have the same type as src1 and src2.

  - **beta**: `double`.

    weight of src3.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    operation flags (cv::GemmFlags)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output matrix; it has the proper size and the same type as
    input matrices.

  The function cv::gemm performs generalized matrix multiplication similar to the
  gemm functions in BLAS level 3. For example,
  `gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`
  corresponds to
  \\f[\\texttt{dst} =  \\texttt{alpha} \\cdot \\texttt{src1} ^T  \\cdot \\texttt{src2} +  \\texttt{beta} \\cdot \\texttt{src3} ^T\\f]
  In case of complex (two-channel) data, performed a complex matrix
  multiplication.
  The function can be replaced with a matrix expression. For example, the
  above call can be replaced with:
  ```cpp
  dst = alpha*src1.t()*src2 + beta*src3.t();
  ```
  @sa mulTransposed, transform

  Python prototype (for reference only):
  ```python3
  gemm(src1, src2, alpha, src3, beta[, dst[, flags]]) -> dst
  ```
  """
  @spec gemm(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), Evision.Mat.maybe_mat_in(), number(), [{:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def gemm(src1, src2, alpha, src3, beta, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_number(alpha) and (is_struct(src3, Evision.Mat) or is_struct(src3, Nx.Tensor) or is_number(src3) or is_tuple(src3)) and is_number(beta) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      src3: Evision.Internal.Structurise.from_struct(src3),
      beta: Evision.Internal.Structurise.from_struct(beta)
    ]
    :evision_nif.gemm(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs generalized matrix multiplication.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first multiplied input matrix that could be real(CV_32FC1,
    CV_64FC1) or complex(CV_32FC2, CV_64FC2).

  - **src2**: `Evision.Mat`.

    second multiplied input matrix of the same type as src1.

  - **alpha**: `double`.

    weight of the matrix product.

  - **src3**: `Evision.Mat`.

    third optional delta matrix added to the matrix product; it
    should have the same type as src1 and src2.

  - **beta**: `double`.

    weight of src3.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    operation flags (cv::GemmFlags)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output matrix; it has the proper size and the same type as
    input matrices.

  The function cv::gemm performs generalized matrix multiplication similar to the
  gemm functions in BLAS level 3. For example,
  `gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`
  corresponds to
  \\f[\\texttt{dst} =  \\texttt{alpha} \\cdot \\texttt{src1} ^T  \\cdot \\texttt{src2} +  \\texttt{beta} \\cdot \\texttt{src3} ^T\\f]
  In case of complex (two-channel) data, performed a complex matrix
  multiplication.
  The function can be replaced with a matrix expression. For example, the
  above call can be replaced with:
  ```cpp
  dst = alpha*src1.t()*src2 + beta*src3.t();
  ```
  @sa mulTransposed, transform

  Python prototype (for reference only):
  ```python3
  gemm(src1, src2, alpha, src3, beta[, dst[, flags]]) -> dst
  ```
  """
  @spec gemm(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), Evision.Mat.maybe_mat_in(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def gemm(src1, src2, alpha, src3, beta) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and is_number(alpha) and (is_struct(src3, Evision.Mat) or is_struct(src3, Nx.Tensor) or is_number(src3) or is_tuple(src3)) and is_number(beta)
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      src3: Evision.Internal.Structurise.from_struct(src3),
      beta: Evision.Internal.Structurise.from_struct(beta)
    ]
    :evision_nif.gemm(positional)
    |> to_struct()
  end

  @doc """
  getAffineTransform

  ##### Positional Arguments
  - **src**: `Evision.Mat`
  - **dst**: `Evision.Mat`

  ##### Return
  - **retval**: `Evision.Mat.t()`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  getAffineTransform(src, dst) -> retval
  ```
  """
  @spec getAffineTransform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def getAffineTransform(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.getAffineTransform(positional)
    |> to_struct()
  end

  @doc """
  Returns full configuration time cmake output.
  ##### Return
  - **retval**: `String`

  Returned value is raw cmake output including version control system revision, compiler version,
  compiler flags, enabled modules and third party libraries, etc. Output format depends on target
  architecture.

  Python prototype (for reference only):
  ```python3
  getBuildInformation() -> retval
  ```
  """
  @spec getBuildInformation() :: binary() | {:error, String.t()}
  def getBuildInformation() do
    positional = [
    ]
    :evision_nif.getBuildInformation(positional)
    |> to_struct()
  end

  @doc """
  Returns list of CPU features enabled during compilation.
  ##### Return
  - **retval**: `string`

  Returned value is a string containing space separated list of CPU features with following markers:
  - no markers - baseline features
  - prefix `*` - features enabled in dispatcher
  - suffix `?` - features enabled but not available in HW

  Example: `SSE SSE2 SSE3 *SSE4.1 *SSE4.2 *FP16 *AVX *AVX2 *AVX512-SKX?`

  Python prototype (for reference only):
  ```python3
  getCPUFeaturesLine() -> retval
  ```
  """
  @spec getCPUFeaturesLine() :: binary() | {:error, String.t()}
  def getCPUFeaturesLine() do
    positional = [
    ]
    :evision_nif.getCPUFeaturesLine(positional)
    |> to_struct()
  end

  @doc """
  Returns the number of CPU ticks.
  ##### Return
  - **retval**: `int64`

  The function returns the current number of CPU ticks on some architectures (such as x86, x64,
  PowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for
  very accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU
  systems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU
  with its own counter. So, theoretically (and practically) the subsequent calls to the function do
  not necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU
  frequency depending on the load, the number of CPU clocks spent in some code cannot be directly
  converted to time units. Therefore, getTickCount is generally a preferable solution for measuring
  execution time.

  Python prototype (for reference only):
  ```python3
  getCPUTickCount() -> retval
  ```
  """
  @spec getCPUTickCount() :: integer() | {:error, String.t()}
  def getCPUTickCount() do
    positional = [
    ]
    :evision_nif.getCPUTickCount(positional)
    |> to_struct()
  end

  @doc """
  Returns the default new camera matrix.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix.

  ##### Keyword Arguments
  - **imgsize**: `Size`.

    Camera view image size in pixels.

  - **centerPrincipalPoint**: `bool`.

    Location of the principal point in the new camera matrix. The
    parameter indicates whether this location should be at the image center or not.

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when
  centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).
  In the latter case, the new camera matrix will be:
  \\f[\\begin{bmatrix} f\\_x && 0 && ( \\texttt{imgSize.width} -1)\\*0.5  \\\\\\\\ 0 && f\\_y && ( \\texttt{imgSize.height} -1)\\*0.5  \\\\\\\\ 0 && 0 && 1 \\end{bmatrix} ,\\f]
  where \\f$f\\_x\\f$ and \\f$f\\_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ elements of cameraMatrix, respectively.
  By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not
  move the principal point. However, when you work with stereo, it is important to move the principal
  points in both views to the same y-coordinate (which is required by most of stereo correspondence
  algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for
  each view where the principal points are located at the center.

  Python prototype (for reference only):
  ```python3
  getDefaultNewCameraMatrix(cameraMatrix[, imgsize[, centerPrincipalPoint]]) -> retval
  ```
  """
  @spec getDefaultNewCameraMatrix(Evision.Mat.maybe_mat_in(), [{:centerPrincipalPoint, term()} | {:imgsize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def getDefaultNewCameraMatrix(cameraMatrix, opts) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:centerPrincipalPoint, :imgsize])
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix)
    ]
    :evision_nif.getDefaultNewCameraMatrix(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns the default new camera matrix.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix.

  ##### Keyword Arguments
  - **imgsize**: `Size`.

    Camera view image size in pixels.

  - **centerPrincipalPoint**: `bool`.

    Location of the principal point in the new camera matrix. The
    parameter indicates whether this location should be at the image center or not.

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when
  centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).
  In the latter case, the new camera matrix will be:
  \\f[\\begin{bmatrix} f\\_x && 0 && ( \\texttt{imgSize.width} -1)\\*0.5  \\\\\\\\ 0 && f\\_y && ( \\texttt{imgSize.height} -1)\\*0.5  \\\\\\\\ 0 && 0 && 1 \\end{bmatrix} ,\\f]
  where \\f$f\\_x\\f$ and \\f$f\\_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ elements of cameraMatrix, respectively.
  By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not
  move the principal point. However, when you work with stereo, it is important to move the principal
  points in both views to the same y-coordinate (which is required by most of stereo correspondence
  algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for
  each view where the principal points are located at the center.

  Python prototype (for reference only):
  ```python3
  getDefaultNewCameraMatrix(cameraMatrix[, imgsize[, centerPrincipalPoint]]) -> retval
  ```
  """
  @spec getDefaultNewCameraMatrix(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def getDefaultNewCameraMatrix(cameraMatrix) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix))
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix)
    ]
    :evision_nif.getDefaultNewCameraMatrix(positional)
    |> to_struct()
  end

  @doc """
  Returns filter coefficients for computing spatial image derivatives.

  ##### Positional Arguments
  - **dx**: `integer()`.

    Derivative order in respect of x.

  - **dy**: `integer()`.

    Derivative order in respect of y.

  - **ksize**: `integer()`.

    Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.

  ##### Keyword Arguments
  - **normalize**: `bool`.

    Flag indicating whether to normalize (scale down) the filter coefficients or not.
    Theoretically, the coefficients should have the denominator \\f$=2^{ksize*2-dx-dy-2}\\f$. If you are
    going to filter floating-point images, you are likely to use the normalized kernels. But if you
    compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
    all the fractional bits, you may want to set normalize=false .

  - **ktype**: `integer()`.

    Type of filter coefficients. It can be CV_32f or CV_64F .

  ##### Return
  - **kx**: `Evision.Mat.t()`.

    Output matrix of row filter coefficients. It has the type ktype .

  - **ky**: `Evision.Mat.t()`.

    Output matrix of column filter coefficients. It has the type ktype .

  The function computes and returns the filter coefficients for spatial image derivatives. When
  `ksize=FILTER_SCHARR`, the Scharr \\f$3 \\times 3\\f$ kernels are generated (see #Scharr). Otherwise, Sobel
  kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to

  Python prototype (for reference only):
  ```python3
  getDerivKernels(dx, dy, ksize[, kx[, ky[, normalize[, ktype]]]]) -> kx, ky
  ```
  """
  @spec getDerivKernels(integer(), integer(), integer(), [{:ktype, term()} | {:normalize, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def getDerivKernels(dx, dy, ksize, opts) when is_integer(dx) and is_integer(dy) and is_integer(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:ktype, :normalize])
    positional = [
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.getDerivKernels(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns filter coefficients for computing spatial image derivatives.

  ##### Positional Arguments
  - **dx**: `integer()`.

    Derivative order in respect of x.

  - **dy**: `integer()`.

    Derivative order in respect of y.

  - **ksize**: `integer()`.

    Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.

  ##### Keyword Arguments
  - **normalize**: `bool`.

    Flag indicating whether to normalize (scale down) the filter coefficients or not.
    Theoretically, the coefficients should have the denominator \\f$=2^{ksize*2-dx-dy-2}\\f$. If you are
    going to filter floating-point images, you are likely to use the normalized kernels. But if you
    compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
    all the fractional bits, you may want to set normalize=false .

  - **ktype**: `integer()`.

    Type of filter coefficients. It can be CV_32f or CV_64F .

  ##### Return
  - **kx**: `Evision.Mat.t()`.

    Output matrix of row filter coefficients. It has the type ktype .

  - **ky**: `Evision.Mat.t()`.

    Output matrix of column filter coefficients. It has the type ktype .

  The function computes and returns the filter coefficients for spatial image derivatives. When
  `ksize=FILTER_SCHARR`, the Scharr \\f$3 \\times 3\\f$ kernels are generated (see #Scharr). Otherwise, Sobel
  kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to

  Python prototype (for reference only):
  ```python3
  getDerivKernels(dx, dy, ksize[, kx[, ky[, normalize[, ktype]]]]) -> kx, ky
  ```
  """
  @spec getDerivKernels(integer(), integer(), integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def getDerivKernels(dx, dy, ksize) when is_integer(dx) and is_integer(dy) and is_integer(ksize)
  do
    positional = [
      dx: Evision.Internal.Structurise.from_struct(dx),
      dy: Evision.Internal.Structurise.from_struct(dy),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.getDerivKernels(positional)
    |> to_struct()
  end

  @doc """
  Calculates the font-specific size to use to achieve a given height in pixels.

  ##### Positional Arguments
  - **fontFace**: `integer()`.

    Font to use, see cv::HersheyFonts.

  - **pixelHeight**: `integer()`.

    Pixel height to compute the fontScale for

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of lines used to render the text.See putText for details.

  ##### Return
  - **retval**: `double`

  @return The fontSize to use for cv::putText
  @see cv::putText

  Python prototype (for reference only):
  ```python3
  getFontScaleFromHeight(fontFace, pixelHeight[, thickness]) -> retval
  ```
  """
  @spec getFontScaleFromHeight(integer(), integer(), [{:thickness, term()}] | nil) :: number() | {:error, String.t()}
  def getFontScaleFromHeight(fontFace, pixelHeight, opts) when is_integer(fontFace) and is_integer(pixelHeight) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:thickness])
    positional = [
      fontFace: Evision.Internal.Structurise.from_struct(fontFace),
      pixelHeight: Evision.Internal.Structurise.from_struct(pixelHeight)
    ]
    :evision_nif.getFontScaleFromHeight(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the font-specific size to use to achieve a given height in pixels.

  ##### Positional Arguments
  - **fontFace**: `integer()`.

    Font to use, see cv::HersheyFonts.

  - **pixelHeight**: `integer()`.

    Pixel height to compute the fontScale for

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of lines used to render the text.See putText for details.

  ##### Return
  - **retval**: `double`

  @return The fontSize to use for cv::putText
  @see cv::putText

  Python prototype (for reference only):
  ```python3
  getFontScaleFromHeight(fontFace, pixelHeight[, thickness]) -> retval
  ```
  """
  @spec getFontScaleFromHeight(integer(), integer()) :: number() | {:error, String.t()}
  def getFontScaleFromHeight(fontFace, pixelHeight) when is_integer(fontFace) and is_integer(pixelHeight)
  do
    positional = [
      fontFace: Evision.Internal.Structurise.from_struct(fontFace),
      pixelHeight: Evision.Internal.Structurise.from_struct(pixelHeight)
    ]
    :evision_nif.getFontScaleFromHeight(positional)
    |> to_struct()
  end

  @doc """
  Returns Gabor filter coefficients.

  ##### Positional Arguments
  - **ksize**: `Size`.

    Size of the filter returned.

  - **sigma**: `double`.

    Standard deviation of the gaussian envelope.

  - **theta**: `double`.

    Orientation of the normal to the parallel stripes of a Gabor function.

  - **lambd**: `double`.

    Wavelength of the sinusoidal factor.

  - **gamma**: `double`.

    Spatial aspect ratio.

  ##### Keyword Arguments
  - **psi**: `double`.

    Phase offset.

  - **ktype**: `integer()`.

    Type of filter coefficients. It can be CV_32F or CV_64F .

  ##### Return
  - **retval**: `Evision.Mat.t()`

  For more details about gabor filter equations and parameters, see: [Gabor
  Filter](http://en.wikipedia.org/wiki/Gabor_filter).

  Python prototype (for reference only):
  ```python3
  getGaborKernel(ksize, sigma, theta, lambd, gamma[, psi[, ktype]]) -> retval
  ```
  """
  @spec getGaborKernel({number(), number()}, number(), number(), number(), number(), [{:ktype, term()} | {:psi, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def getGaborKernel(ksize, sigma, theta, lambd, gamma, opts) when is_tuple(ksize) and is_number(sigma) and is_number(theta) and is_number(lambd) and is_number(gamma) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:ktype, :psi])
    positional = [
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      sigma: Evision.Internal.Structurise.from_struct(sigma),
      theta: Evision.Internal.Structurise.from_struct(theta),
      lambd: Evision.Internal.Structurise.from_struct(lambd),
      gamma: Evision.Internal.Structurise.from_struct(gamma)
    ]
    :evision_nif.getGaborKernel(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns Gabor filter coefficients.

  ##### Positional Arguments
  - **ksize**: `Size`.

    Size of the filter returned.

  - **sigma**: `double`.

    Standard deviation of the gaussian envelope.

  - **theta**: `double`.

    Orientation of the normal to the parallel stripes of a Gabor function.

  - **lambd**: `double`.

    Wavelength of the sinusoidal factor.

  - **gamma**: `double`.

    Spatial aspect ratio.

  ##### Keyword Arguments
  - **psi**: `double`.

    Phase offset.

  - **ktype**: `integer()`.

    Type of filter coefficients. It can be CV_32F or CV_64F .

  ##### Return
  - **retval**: `Evision.Mat.t()`

  For more details about gabor filter equations and parameters, see: [Gabor
  Filter](http://en.wikipedia.org/wiki/Gabor_filter).

  Python prototype (for reference only):
  ```python3
  getGaborKernel(ksize, sigma, theta, lambd, gamma[, psi[, ktype]]) -> retval
  ```
  """
  @spec getGaborKernel({number(), number()}, number(), number(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def getGaborKernel(ksize, sigma, theta, lambd, gamma) when is_tuple(ksize) and is_number(sigma) and is_number(theta) and is_number(lambd) and is_number(gamma)
  do
    positional = [
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      sigma: Evision.Internal.Structurise.from_struct(sigma),
      theta: Evision.Internal.Structurise.from_struct(theta),
      lambd: Evision.Internal.Structurise.from_struct(lambd),
      gamma: Evision.Internal.Structurise.from_struct(gamma)
    ]
    :evision_nif.getGaborKernel(positional)
    |> to_struct()
  end

  @doc """
  Returns Gaussian filter coefficients.

  ##### Positional Arguments
  - **ksize**: `integer()`.

    Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod 2 = 1\\f$ ) and positive.

  - **sigma**: `double`.

    Gaussian standard deviation. If it is non-positive, it is computed from ksize as
    `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.

  ##### Keyword Arguments
  - **ktype**: `integer()`.

    Type of filter coefficients. It can be CV_32F or CV_64F .

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ matrix of Gaussian filter
  coefficients:
  \\f[G\\_i= \\alpha \\*e^{-(i-( \\texttt{ksize} -1)/2)^2/(2\\* \\texttt{sigma}^2)},\\f]
  where \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale factor chosen so that \\f$\\sum\\_i G\\_i=1\\f$.
  Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
  smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
  You may also use the higher-level GaussianBlur.
  @sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur

  Python prototype (for reference only):
  ```python3
  getGaussianKernel(ksize, sigma[, ktype]) -> retval
  ```
  """
  @spec getGaussianKernel(integer(), number(), [{:ktype, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def getGaussianKernel(ksize, sigma, opts) when is_integer(ksize) and is_number(sigma) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:ktype])
    positional = [
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      sigma: Evision.Internal.Structurise.from_struct(sigma)
    ]
    :evision_nif.getGaussianKernel(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns Gaussian filter coefficients.

  ##### Positional Arguments
  - **ksize**: `integer()`.

    Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod 2 = 1\\f$ ) and positive.

  - **sigma**: `double`.

    Gaussian standard deviation. If it is non-positive, it is computed from ksize as
    `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.

  ##### Keyword Arguments
  - **ktype**: `integer()`.

    Type of filter coefficients. It can be CV_32F or CV_64F .

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ matrix of Gaussian filter
  coefficients:
  \\f[G\\_i= \\alpha \\*e^{-(i-( \\texttt{ksize} -1)/2)^2/(2\\* \\texttt{sigma}^2)},\\f]
  where \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale factor chosen so that \\f$\\sum\\_i G\\_i=1\\f$.
  Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
  smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
  You may also use the higher-level GaussianBlur.
  @sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur

  Python prototype (for reference only):
  ```python3
  getGaussianKernel(ksize, sigma[, ktype]) -> retval
  ```
  """
  @spec getGaussianKernel(integer(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def getGaussianKernel(ksize, sigma) when is_integer(ksize) and is_number(sigma)
  do
    positional = [
      ksize: Evision.Internal.Structurise.from_struct(ksize),
      sigma: Evision.Internal.Structurise.from_struct(sigma)
    ]
    :evision_nif.getGaussianKernel(positional)
    |> to_struct()
  end

  @doc """
  Returns feature name by ID

  ##### Positional Arguments
  - **feature**: `integer()`

  ##### Return
  - **retval**: `String`

  Returns empty string if feature is not defined

  Python prototype (for reference only):
  ```python3
  getHardwareFeatureName(feature) -> retval
  ```
  """
  @spec getHardwareFeatureName(integer()) :: binary() | {:error, String.t()}
  def getHardwareFeatureName(feature) when is_integer(feature)
  do
    positional = [
      feature: Evision.Internal.Structurise.from_struct(feature)
    ]
    :evision_nif.getHardwareFeatureName(positional)
    |> to_struct()
  end

  @doc """
  getLogLevel
  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  getLogLevel() -> retval
  ```
  """
  @spec getLogLevel() :: integer() | {:error, String.t()}
  def getLogLevel() do
    positional = [
    ]
    :evision_nif.getLogLevel(positional)
    |> to_struct()
  end

  @doc """
  Returns the number of threads used by OpenCV for parallel regions.
  ##### Return
  - **retval**: `integer()`

  Always returns 1 if OpenCV is built without threading support.
  The exact meaning of return value depends on the threading framework used by OpenCV library:
  - `TBB` - The number of threads, that OpenCV will try to use for parallel regions. If there is
    any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns
    default number of threads used by TBB library.

  - `OpenMP` - An upper bound on the number of threads that could be used to form a new team.
  - `Concurrency` - The number of threads, that OpenCV will try to use for parallel regions.
  - `GCD` - Unsupported; returns the GCD thread pool limit (512) for compatibility.
  - `C=` - The number of threads, that OpenCV will try to use for parallel regions, if before
    called setNumThreads with threads \\> 0, otherwise returns the number of logical CPUs,
    available for the process.

  @sa setNumThreads, getThreadNum

  Python prototype (for reference only):
  ```python3
  getNumThreads() -> retval
  ```
  """
  @spec getNumThreads() :: integer() | {:error, String.t()}
  def getNumThreads() do
    positional = [
    ]
    :evision_nif.getNumThreads(positional)
    |> to_struct()
  end

  @doc """
  Returns the number of logical CPUs available for the process.
  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  getNumberOfCPUs() -> retval
  ```
  """
  @spec getNumberOfCPUs() :: integer() | {:error, String.t()}
  def getNumberOfCPUs() do
    positional = [
    ]
    :evision_nif.getNumberOfCPUs(positional)
    |> to_struct()
  end

  @doc """
  Returns the optimal DFT size for a given vector size.

  ##### Positional Arguments
  - **vecsize**: `integer()`.

    vector size.

  ##### Return
  - **retval**: `integer()`

  DFT performance is not a monotonic function of a vector size. Therefore, when you calculate
  convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to
  pad the input data with zeros to get a bit larger array that can be transformed much faster than the
  original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.
  Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\\*5\\*3\\*2\\*2)
  are also processed quite efficiently.
  The function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize
  so that the DFT of a vector of size N can be processed efficiently. In the current implementation N
  = 2 ^p^ \\* 3 ^q^ \\* 5 ^r^ for some integer p, q, r.
  The function returns a negative number if vecsize is too large (very close to INT_MAX ).
  While the function cannot be used directly to estimate the optimal vector size for DCT transform
  (since the current DCT implementation supports only even-size vectors), it can be easily processed
  as getOptimalDFTSize((vecsize+1)/2)\\*2.
  @sa dft, dct, idft, idct, mulSpectrums

  Python prototype (for reference only):
  ```python3
  getOptimalDFTSize(vecsize) -> retval
  ```
  """
  @spec getOptimalDFTSize(integer()) :: integer() | {:error, String.t()}
  def getOptimalDFTSize(vecsize) when is_integer(vecsize)
  do
    positional = [
      vecsize: Evision.Internal.Structurise.from_struct(vecsize)
    ]
    :evision_nif.getOptimalDFTSize(positional)
    |> to_struct()
  end

  @doc """
  Returns the new camera intrinsic matrix based on the free scaling parameter.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix.

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  - **imageSize**: `Size`.

    Original image size.

  - **alpha**: `double`.

    Free scaling parameter between 0 (when all the pixels in the undistorted image are
    valid) and 1 (when all the source image pixels are retained in the undistorted image). See
    #stereoRectify for details.

  ##### Keyword Arguments
  - **newImgSize**: `Size`.

    Image size after rectification. By default, it is set to imageSize .

  - **centerPrincipalPoint**: `bool`.

    Optional flag that indicates whether in the new camera intrinsic matrix the
    principal point should be at the image center or not. By default, the principal point is chosen to
    best fit a subset of the source image (determined by alpha) to the corrected image.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **validPixROI**: `Rect*`.

    Optional output rectangle that outlines all-good-pixels region in the
    undistorted image. See roi1, roi2 description in #stereoRectify .

  @return new_camera_matrix Output new camera intrinsic matrix.
  The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.
  By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
  image pixels if there is valuable information in the corners alpha=1 , or get something in between.
  When alpha\\>0 , the undistorted result is likely to have some black pixels corresponding to
  "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion
  coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to
  #initUndistortRectifyMap to produce the maps for #remap .

  Python prototype (for reference only):
  ```python3
  getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha[, newImgSize[, centerPrincipalPoint]]) -> retval, validPixROI
  ```
  """
  @spec getOptimalNewCameraMatrix(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, number(), [{:centerPrincipalPoint, term()} | {:newImgSize, term()}] | nil) :: {Evision.Mat.t(), {number(), number(), number(), number()}} | {:error, String.t()}
  def getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, opts) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and is_tuple(imageSize) and is_number(alpha) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:centerPrincipalPoint, :newImgSize])
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      alpha: Evision.Internal.Structurise.from_struct(alpha)
    ]
    :evision_nif.getOptimalNewCameraMatrix(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns the new camera intrinsic matrix based on the free scaling parameter.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix.

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  - **imageSize**: `Size`.

    Original image size.

  - **alpha**: `double`.

    Free scaling parameter between 0 (when all the pixels in the undistorted image are
    valid) and 1 (when all the source image pixels are retained in the undistorted image). See
    #stereoRectify for details.

  ##### Keyword Arguments
  - **newImgSize**: `Size`.

    Image size after rectification. By default, it is set to imageSize .

  - **centerPrincipalPoint**: `bool`.

    Optional flag that indicates whether in the new camera intrinsic matrix the
    principal point should be at the image center or not. By default, the principal point is chosen to
    best fit a subset of the source image (determined by alpha) to the corrected image.

  ##### Return
  - **retval**: `Evision.Mat.t()`
  - **validPixROI**: `Rect*`.

    Optional output rectangle that outlines all-good-pixels region in the
    undistorted image. See roi1, roi2 description in #stereoRectify .

  @return new_camera_matrix Output new camera intrinsic matrix.
  The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.
  By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original
  image pixels if there is valuable information in the corners alpha=1 , or get something in between.
  When alpha\\>0 , the undistorted result is likely to have some black pixels corresponding to
  "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion
  coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to
  #initUndistortRectifyMap to produce the maps for #remap .

  Python prototype (for reference only):
  ```python3
  getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha[, newImgSize[, centerPrincipalPoint]]) -> retval, validPixROI
  ```
  """
  @spec getOptimalNewCameraMatrix(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, number()) :: {Evision.Mat.t(), {number(), number(), number(), number()}} | {:error, String.t()}
  def getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and is_tuple(imageSize) and is_number(alpha)
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      alpha: Evision.Internal.Structurise.from_struct(alpha)
    ]
    :evision_nif.getOptimalNewCameraMatrix(positional)
    |> to_struct()
  end

  @doc """
  Calculates a perspective transform from four pairs of the corresponding points.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Coordinates of quadrangle vertices in the source image.

  - **dst**: `Evision.Mat`.

    Coordinates of the corresponding quadrangle vertices in the destination image.

  ##### Keyword Arguments
  - **solveMethod**: `integer()`.

    method passed to cv::solve (#DecompTypes)

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function calculates the \\f$3 \\times 3\\f$ matrix of a perspective transform so that:
  \\f[\\begin{bmatrix} t\\_i x'\\_i \\\\\\\\ t\\_i y'\\_i \\\\\\\\ t\\_i \\end{bmatrix} = \\texttt{map\\_matrix} \\cdot \\begin{bmatrix} x\\_i \\\\\\\\ y\\_i \\\\\\\\ 1 \\end{bmatrix}\\f]
  where
  \\f[dst(i)=(x'\\_i,y'\\_i), src(i)=(x\\_i, y\\_i), i=0,1,2,3\\f]

  @sa  findHomography, warpPerspective, perspectiveTransform

  Python prototype (for reference only):
  ```python3
  getPerspectiveTransform(src, dst[, solveMethod]) -> retval
  ```
  """
  @spec getPerspectiveTransform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:solveMethod, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def getPerspectiveTransform(src, dst, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:solveMethod])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.getPerspectiveTransform(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates a perspective transform from four pairs of the corresponding points.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Coordinates of quadrangle vertices in the source image.

  - **dst**: `Evision.Mat`.

    Coordinates of the corresponding quadrangle vertices in the destination image.

  ##### Keyword Arguments
  - **solveMethod**: `integer()`.

    method passed to cv::solve (#DecompTypes)

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function calculates the \\f$3 \\times 3\\f$ matrix of a perspective transform so that:
  \\f[\\begin{bmatrix} t\\_i x'\\_i \\\\\\\\ t\\_i y'\\_i \\\\\\\\ t\\_i \\end{bmatrix} = \\texttt{map\\_matrix} \\cdot \\begin{bmatrix} x\\_i \\\\\\\\ y\\_i \\\\\\\\ 1 \\end{bmatrix}\\f]
  where
  \\f[dst(i)=(x'\\_i,y'\\_i), src(i)=(x\\_i, y\\_i), i=0,1,2,3\\f]

  @sa  findHomography, warpPerspective, perspectiveTransform

  Python prototype (for reference only):
  ```python3
  getPerspectiveTransform(src, dst[, solveMethod]) -> retval
  ```
  """
  @spec getPerspectiveTransform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def getPerspectiveTransform(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.getPerspectiveTransform(positional)
    |> to_struct()
  end

  @doc """
  Retrieves a pixel rectangle from an image with sub-pixel accuracy.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source image.

  - **patchSize**: `Size`.

    Size of the extracted patch.

  - **center**: `Point2f`.

    Floating point coordinates of the center of the extracted rectangle within the
    source image. The center must be inside the image.

  ##### Keyword Arguments
  - **patchType**: `integer()`.

    Depth of the extracted pixels. By default, they have the same depth as src .

  ##### Return
  - **patch**: `Evision.Mat.t()`.

    Extracted patch that has the size patchSize and the same number of channels as src .

  The function getRectSubPix extracts pixels from src:
  \\f[patch(x, y) = src(x +  \\texttt{center.x} - ( \\texttt{dst.cols} -1)\\*0.5, y +  \\texttt{center.y} - ( \\texttt{dst.rows} -1)\\*0.5)\\f]
  where the values of the pixels at non-integer coordinates are retrieved using bilinear
  interpolation. Every channel of multi-channel images is processed independently. Also
  the image should be a single channel or three channel image. While the center of the
  rectangle must be inside the image, parts of the rectangle may be outside.

  @sa  warpAffine, warpPerspective

  Python prototype (for reference only):
  ```python3
  getRectSubPix(image, patchSize, center[, patch[, patchType]]) -> patch
  ```
  """
  @spec getRectSubPix(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, [{:patchType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def getRectSubPix(image, patchSize, center, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patchSize) and is_tuple(center) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:patchType])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patchSize: Evision.Internal.Structurise.from_struct(patchSize),
      center: Evision.Internal.Structurise.from_struct(center)
    ]
    :evision_nif.getRectSubPix(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Retrieves a pixel rectangle from an image with sub-pixel accuracy.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Source image.

  - **patchSize**: `Size`.

    Size of the extracted patch.

  - **center**: `Point2f`.

    Floating point coordinates of the center of the extracted rectangle within the
    source image. The center must be inside the image.

  ##### Keyword Arguments
  - **patchType**: `integer()`.

    Depth of the extracted pixels. By default, they have the same depth as src .

  ##### Return
  - **patch**: `Evision.Mat.t()`.

    Extracted patch that has the size patchSize and the same number of channels as src .

  The function getRectSubPix extracts pixels from src:
  \\f[patch(x, y) = src(x +  \\texttt{center.x} - ( \\texttt{dst.cols} -1)\\*0.5, y +  \\texttt{center.y} - ( \\texttt{dst.rows} -1)\\*0.5)\\f]
  where the values of the pixels at non-integer coordinates are retrieved using bilinear
  interpolation. Every channel of multi-channel images is processed independently. Also
  the image should be a single channel or three channel image. While the center of the
  rectangle must be inside the image, parts of the rectangle may be outside.

  @sa  warpAffine, warpPerspective

  Python prototype (for reference only):
  ```python3
  getRectSubPix(image, patchSize, center[, patch[, patchType]]) -> patch
  ```
  """
  @spec getRectSubPix(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def getRectSubPix(image, patchSize, center) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_tuple(patchSize) and is_tuple(center)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      patchSize: Evision.Internal.Structurise.from_struct(patchSize),
      center: Evision.Internal.Structurise.from_struct(center)
    ]
    :evision_nif.getRectSubPix(positional)
    |> to_struct()
  end

  @doc """
  Calculates an affine matrix of 2D rotation.

  ##### Positional Arguments
  - **center**: `Point2f`.

    Center of the rotation in the source image.

  - **angle**: `double`.

    Rotation angle in degrees. Positive values mean counter-clockwise rotation (the
    coordinate origin is assumed to be the top-left corner).

  - **scale**: `double`.

    Isotropic scale factor.

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function calculates the following matrix:
  \\f[\\begin{bmatrix} \\alpha &  \\beta & (1- \\alpha )  \\cdot \\texttt{center.x} -  \\beta \\cdot \\texttt{center.y} \\\\\\\\ - \\beta &  \\alpha &  \\beta \\cdot \\texttt{center.x} + (1- \\alpha )  \\cdot \\texttt{center.y} \\end{bmatrix}\\f]
  where
  \\f[\\begin{array}{l} \\alpha =  \\texttt{scale} \\cdot \\cos \\texttt{angle} , \\\\\\\\ \\beta =  \\texttt{scale} \\cdot \\sin \\texttt{angle} \\end{array}\\f]
  The transformation maps the rotation center to itself. If this is not the target, adjust the shift.

  @sa  getAffineTransform, warpAffine, transform

  Python prototype (for reference only):
  ```python3
  getRotationMatrix2D(center, angle, scale) -> retval
  ```
  """
  @spec getRotationMatrix2D({number(), number()}, number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def getRotationMatrix2D(center, angle, scale) when is_tuple(center) and is_number(angle) and is_number(scale)
  do
    positional = [
      center: Evision.Internal.Structurise.from_struct(center),
      angle: Evision.Internal.Structurise.from_struct(angle),
      scale: Evision.Internal.Structurise.from_struct(scale)
    ]
    :evision_nif.getRotationMatrix2D(positional)
    |> to_struct()
  end

  @doc """
  Returns a structuring element of the specified size and shape for morphological operations.

  ##### Positional Arguments
  - **shape**: `integer()`.

    Element shape that could be one of #MorphShapes

  - **ksize**: `Size`.

    Size of the structuring element.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    Anchor position within the element. The default value \\f$(-1, -1)\\f$ means that the
    anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
    position. In other cases the anchor just regulates how much the result of the morphological
    operation is shifted.

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function constructs and returns the structuring element that can be further passed to #erode,
  #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
  the structuring element.

  Python prototype (for reference only):
  ```python3
  getStructuringElement(shape, ksize[, anchor]) -> retval
  ```
  """
  @spec getStructuringElement(integer(), {number(), number()}, [{:anchor, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def getStructuringElement(shape, ksize, opts) when is_integer(shape) and is_tuple(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor])
    positional = [
      shape: Evision.Internal.Structurise.from_struct(shape),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.getStructuringElement(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns a structuring element of the specified size and shape for morphological operations.

  ##### Positional Arguments
  - **shape**: `integer()`.

    Element shape that could be one of #MorphShapes

  - **ksize**: `Size`.

    Size of the structuring element.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    Anchor position within the element. The default value \\f$(-1, -1)\\f$ means that the
    anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
    position. In other cases the anchor just regulates how much the result of the morphological
    operation is shifted.

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function constructs and returns the structuring element that can be further passed to #erode,
  #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
  the structuring element.

  Python prototype (for reference only):
  ```python3
  getStructuringElement(shape, ksize[, anchor]) -> retval
  ```
  """
  @spec getStructuringElement(integer(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def getStructuringElement(shape, ksize) when is_integer(shape) and is_tuple(ksize)
  do
    positional = [
      shape: Evision.Internal.Structurise.from_struct(shape),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.getStructuringElement(positional)
    |> to_struct()
  end

  @doc """
  Calculates the width and height of a text string.

  ##### Positional Arguments
  - **text**: `String`.

    Input text string.

  - **fontFace**: `integer()`.

    Font to use, see #HersheyFonts.

  - **fontScale**: `double`.

    Font scale factor that is multiplied by the font-specific base size.

  - **thickness**: `integer()`.

    Thickness of lines used to render the text. See #putText for details.

  ##### Return
  - **retval**: `Size`
  - **baseLine**: `int*`.

    y-coordinate of the baseline relative to the bottom-most text
    point.

  The function cv::getTextSize calculates and returns the size of a box that contains the specified text.
  That is, the following code renders some text, the tight box surrounding it, and the baseline: :
  ```
  String text = "Funny text inside the box";
  int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
  double fontScale = 2;
  int thickness = 3;
  Mat img(600, 800, CV_8UC3, Scalar::all(0));
  int baseline=0;
  Size textSize = getTextSize(text, fontFace,
  fontScale, thickness, &baseline);
  baseline += thickness;
  // center the text
  Point textOrg((img.cols - textSize.width)/2,
  (img.rows + textSize.height)/2);
  // draw the box
  rectangle(img, textOrg + Point(0, baseline),
  textOrg + Point(textSize.width, -textSize.height),
  Scalar(0,0,255));
  // ... and the baseline first
  line(img, textOrg + Point(0, thickness),
  textOrg + Point(textSize.width, thickness),
  Scalar(0, 0, 255));
  // then put the text itself
  putText(img, text, textOrg, fontFace, fontScale,
  Scalar::all(255), thickness, 8);
  ```
  @return The size of a box that contains the specified text.
  @see putText

  Python prototype (for reference only):
  ```python3
  getTextSize(text, fontFace, fontScale, thickness) -> retval, baseLine
  ```
  """
  @spec getTextSize(binary(), integer(), number(), integer()) :: {{number(), number()}, integer()} | {:error, String.t()}
  def getTextSize(text, fontFace, fontScale, thickness) when is_binary(text) and is_integer(fontFace) and is_number(fontScale) and is_integer(thickness)
  do
    positional = [
      text: Evision.Internal.Structurise.from_struct(text),
      fontFace: Evision.Internal.Structurise.from_struct(fontFace),
      fontScale: Evision.Internal.Structurise.from_struct(fontScale),
      thickness: Evision.Internal.Structurise.from_struct(thickness)
    ]
    :evision_nif.getTextSize(positional)
    |> to_struct()
  end

  @doc """
  Returns the index of the currently executed thread within the current parallel region. Always
  returns 0 if called outside of parallel region.

  ##### Return
  - **retval**: `integer()`

  @deprecated Current implementation doesn't corresponding to this documentation.
  The exact meaning of the return value depends on the threading framework used by OpenCV library:
  - `TBB` - Unsupported with current 4.1 TBB release. Maybe will be supported in future.
  - `OpenMP` - The thread number, within the current team, of the calling thread.
  - `Concurrency` - An ID for the virtual processor that the current context is executing on (0
    for master thread and unique number for others, but not necessary 1,2,3,...).

  - `GCD` - System calling thread's ID. Never returns 0 inside parallel region.
  - `C=` - The index of the current parallel task.
  @sa setNumThreads, getNumThreads

  Python prototype (for reference only):
  ```python3
  getThreadNum() -> retval
  ```
  """
  @spec getThreadNum() :: integer() | {:error, String.t()}
  def getThreadNum() do
    positional = [
    ]
    :evision_nif.getThreadNum(positional)
    |> to_struct()
  end

  @doc """
  Returns the number of ticks.
  ##### Return
  - **retval**: `int64`

  The function returns the number of ticks after the certain event (for example, when the machine was
  turned on). It can be used to initialize RNG or to measure a function execution time by reading the
  tick count before and after the function call.
  @sa getTickFrequency, TickMeter

  Python prototype (for reference only):
  ```python3
  getTickCount() -> retval
  ```
  """
  @spec getTickCount() :: integer() | {:error, String.t()}
  def getTickCount() do
    positional = [
    ]
    :evision_nif.getTickCount(positional)
    |> to_struct()
  end

  @doc """
  Returns the number of ticks per second.
  ##### Return
  - **retval**: `double`

  The function returns the number of ticks per second. That is, the following code computes the
  execution time in seconds:
  ```
  double t = (double)getTickCount();
  // do something ...
  t = ((double)getTickCount() - t)/getTickFrequency();
  ```
  @sa getTickCount, TickMeter

  Python prototype (for reference only):
  ```python3
  getTickFrequency() -> retval
  ```
  """
  @spec getTickFrequency() :: number() | {:error, String.t()}
  def getTickFrequency() do
    positional = [
    ]
    :evision_nif.getTickFrequency(positional)
    |> to_struct()
  end

  @doc """
  Returns the trackbar position.

  ##### Positional Arguments
  - **trackbarname**: `String`.

    Name of the trackbar.

  - **winname**: `String`.

    Name of the window that is the parent of the trackbar.

  ##### Return
  - **retval**: `integer()`

  The function returns the current position of the specified trackbar.
  **Note**: [__Qt Backend Only__] winname can be empty if the trackbar is attached to the control
  panel.

  Python prototype (for reference only):
  ```python3
  getTrackbarPos(trackbarname, winname) -> retval
  ```
  """
  @spec getTrackbarPos(binary(), binary()) :: integer() | {:error, String.t()}
  def getTrackbarPos(trackbarname, winname) when is_binary(trackbarname) and is_binary(winname)
  do
    positional = [
      trackbarname: Evision.Internal.Structurise.from_struct(trackbarname),
      winname: Evision.Internal.Structurise.from_struct(winname)
    ]
    :evision_nif.getTrackbarPos(positional)
    |> to_struct()
  end

  @doc """
  getValidDisparityROI

  ##### Positional Arguments
  - **roi1**: `Rect`
  - **roi2**: `Rect`
  - **minDisparity**: `integer()`
  - **numberOfDisparities**: `integer()`
  - **blockSize**: `integer()`

  ##### Return
  - **retval**: `Rect`

  Python prototype (for reference only):
  ```python3
  getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, blockSize) -> retval
  ```
  """
  @spec getValidDisparityROI({number(), number(), number(), number()}, {number(), number(), number(), number()}, integer(), integer(), integer()) :: {number(), number(), number(), number()} | {:error, String.t()}
  def getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, blockSize) when is_tuple(roi1) and is_tuple(roi2) and is_integer(minDisparity) and is_integer(numberOfDisparities) and is_integer(blockSize)
  do
    positional = [
      roi1: Evision.Internal.Structurise.from_struct(roi1),
      roi2: Evision.Internal.Structurise.from_struct(roi2),
      minDisparity: Evision.Internal.Structurise.from_struct(minDisparity),
      numberOfDisparities: Evision.Internal.Structurise.from_struct(numberOfDisparities),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize)
    ]
    :evision_nif.getValidDisparityROI(positional)
    |> to_struct()
  end

  @doc """
  Returns major library version
  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  getVersionMajor() -> retval
  ```
  """
  @spec getVersionMajor() :: integer() | {:error, String.t()}
  def getVersionMajor() do
    positional = [
    ]
    :evision_nif.getVersionMajor(positional)
    |> to_struct()
  end

  @doc """
  Returns minor library version
  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  getVersionMinor() -> retval
  ```
  """
  @spec getVersionMinor() :: integer() | {:error, String.t()}
  def getVersionMinor() do
    positional = [
    ]
    :evision_nif.getVersionMinor(positional)
    |> to_struct()
  end

  @doc """
  Returns revision field of the library version
  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  getVersionRevision() -> retval
  ```
  """
  @spec getVersionRevision() :: integer() | {:error, String.t()}
  def getVersionRevision() do
    positional = [
    ]
    :evision_nif.getVersionRevision(positional)
    |> to_struct()
  end

  @doc """
  Returns library version string
  ##### Return
  - **retval**: `String`

  For example "3.4.1-dev".
  @sa getMajorVersion, getMinorVersion, getRevisionVersion

  Python prototype (for reference only):
  ```python3
  getVersionString() -> retval
  ```
  """
  @spec getVersionString() :: binary() | {:error, String.t()}
  def getVersionString() do
    positional = [
    ]
    :evision_nif.getVersionString(positional)
    |> to_struct()
  end

  @doc """
  Provides rectangle of image in the window.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  ##### Return
  - **retval**: `Rect`

  The function getWindowImageRect returns the client screen coordinates, width and height of the image rendering area.

  @sa resizeWindow moveWindow
  **Note**: [__Wayland Backend Only__] This function is not supported by the Wayland protocol limitation.

  Python prototype (for reference only):
  ```python3
  getWindowImageRect(winname) -> retval
  ```
  """
  @spec getWindowImageRect(binary()) :: {number(), number(), number(), number()} | {:error, String.t()}
  def getWindowImageRect(winname) when is_binary(winname)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname)
    ]
    :evision_nif.getWindowImageRect(positional)
    |> to_struct()
  end

  @doc """
  Provides parameters of a window.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **prop_id**: `integer()`.

    Window property to retrieve. The following operation flags are available: (cv::WindowPropertyFlags)

  ##### Return
  - **retval**: `double`

  The function getWindowProperty returns properties of a window.

  @sa setWindowProperty
  **Note**: [__Wayland Backend Only__] This function is not supported.

  Python prototype (for reference only):
  ```python3
  getWindowProperty(winname, prop_id) -> retval
  ```
  """
  @spec getWindowProperty(binary(), integer()) :: number() | {:error, String.t()}
  def getWindowProperty(winname, prop_id) when is_binary(winname) and is_integer(prop_id)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      prop_id: Evision.Internal.Structurise.from_struct(prop_id)
    ]
    :evision_nif.getWindowProperty(positional)
    |> to_struct()
  end

  @doc """
  goodFeaturesToTrack

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **maxCorners**: `integer()`
  - **qualityLevel**: `double`
  - **minDistance**: `double`
  - **mask**: `Evision.Mat`
  - **blockSize**: `integer()`
  - **gradientSize**: `integer()`

  ##### Keyword Arguments
  - **useHarrisDetector**: `bool`.
  - **k**: `double`.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize[, corners[, useHarrisDetector[, k]]]) -> corners
  ```
  """
  @spec goodFeaturesToTrack(Evision.Mat.maybe_mat_in(), integer(), number(), number(), Evision.Mat.maybe_mat_in(), integer(), integer(), [{:k, term()} | {:useHarrisDetector, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(maxCorners) and is_number(qualityLevel) and is_number(minDistance) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_integer(blockSize) and is_integer(gradientSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:k, :useHarrisDetector])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      maxCorners: Evision.Internal.Structurise.from_struct(maxCorners),
      qualityLevel: Evision.Internal.Structurise.from_struct(qualityLevel),
      minDistance: Evision.Internal.Structurise.from_struct(minDistance),
      mask: Evision.Internal.Structurise.from_struct(mask),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      gradientSize: Evision.Internal.Structurise.from_struct(gradientSize)
    ]
    :evision_nif.goodFeaturesToTrack(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  goodFeaturesToTrack

  ##### Positional Arguments
  - **image**: `Evision.Mat`
  - **maxCorners**: `integer()`
  - **qualityLevel**: `double`
  - **minDistance**: `double`
  - **mask**: `Evision.Mat`
  - **blockSize**: `integer()`
  - **gradientSize**: `integer()`

  ##### Keyword Arguments
  - **useHarrisDetector**: `bool`.
  - **k**: `double`.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize[, corners[, useHarrisDetector[, k]]]) -> corners
  ```
  """
  @spec goodFeaturesToTrack(Evision.Mat.maybe_mat_in(), integer(), number(), number(), Evision.Mat.maybe_mat_in(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(maxCorners) and is_number(qualityLevel) and is_number(minDistance) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_integer(blockSize) and is_integer(gradientSize)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      maxCorners: Evision.Internal.Structurise.from_struct(maxCorners),
      qualityLevel: Evision.Internal.Structurise.from_struct(qualityLevel),
      minDistance: Evision.Internal.Structurise.from_struct(minDistance),
      mask: Evision.Internal.Structurise.from_struct(mask),
      blockSize: Evision.Internal.Structurise.from_struct(blockSize),
      gradientSize: Evision.Internal.Structurise.from_struct(gradientSize)
    ]
    :evision_nif.goodFeaturesToTrack(positional)
    |> to_struct()
  end

  @doc """
  Determines strong corners on an image.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Input 8-bit or floating-point 32-bit, single-channel image.

  - **maxCorners**: `integer()`.

    Maximum number of corners to return. If there are more corners than are found,
    the strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set
    and all detected corners are returned.

  - **qualityLevel**: `double`.

    Parameter characterizing the minimal accepted quality of image corners. The
    parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
    (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
    quality measure less than the product are rejected. For example, if the best corner has the
    quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
    less than 15 are rejected.

  - **minDistance**: `double`.

    Minimum possible Euclidean distance between the returned corners.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional region of interest. If the image is not empty (it needs to have the type
    CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.

  - **blockSize**: `integer()`.

    Size of an average block for computing a derivative covariation matrix over each
    pixel neighborhood. See cornerEigenValsAndVecs .

  - **useHarrisDetector**: `bool`.

    Parameter indicating whether to use a Harris detector (see #cornerHarris)
    or #cornerMinEigenVal.

  - **k**: `double`.

    Free parameter of the Harris detector.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

    Output vector of detected corners.

  The function finds the most prominent corners in the image or in the specified image region, as
  described in @cite Shi94
  - Function calculates the corner quality measure at every source image pixel using the
    #cornerMinEigenVal or #cornerHarris .

  - Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
    retained).

  - The corners with the minimal eigenvalue less than
    \\f$\\texttt{qualityLevel} \\cdot \\max\\_{x,y} qualityMeasureMap(x,y)\\f$ are rejected.

  - The remaining corners are sorted by the quality measure in the descending order.
  - Function throws away each corner for which there is a stronger corner at a distance less than
    maxDistance.

  The function can be used to initialize a point-based tracker of an object.
  **Note**: If the function is called with different values A and B of the parameter qualityLevel , and
  A \\> B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
  with qualityLevel=B .

  @sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,

  Python prototype (for reference only):
  ```python3
  goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]]) -> corners
  ```
  """
  @spec goodFeaturesToTrack(Evision.Mat.maybe_mat_in(), integer(), number(), number(), [{:blockSize, term()} | {:k, term()} | {:mask, term()} | {:useHarrisDetector, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(maxCorners) and is_number(qualityLevel) and is_number(minDistance) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:blockSize, :k, :mask, :useHarrisDetector])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      maxCorners: Evision.Internal.Structurise.from_struct(maxCorners),
      qualityLevel: Evision.Internal.Structurise.from_struct(qualityLevel),
      minDistance: Evision.Internal.Structurise.from_struct(minDistance)
    ]
    :evision_nif.goodFeaturesToTrack(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Determines strong corners on an image.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Input 8-bit or floating-point 32-bit, single-channel image.

  - **maxCorners**: `integer()`.

    Maximum number of corners to return. If there are more corners than are found,
    the strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set
    and all detected corners are returned.

  - **qualityLevel**: `double`.

    Parameter characterizing the minimal accepted quality of image corners. The
    parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
    (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
    quality measure less than the product are rejected. For example, if the best corner has the
    quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
    less than 15 are rejected.

  - **minDistance**: `double`.

    Minimum possible Euclidean distance between the returned corners.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional region of interest. If the image is not empty (it needs to have the type
    CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.

  - **blockSize**: `integer()`.

    Size of an average block for computing a derivative covariation matrix over each
    pixel neighborhood. See cornerEigenValsAndVecs .

  - **useHarrisDetector**: `bool`.

    Parameter indicating whether to use a Harris detector (see #cornerHarris)
    or #cornerMinEigenVal.

  - **k**: `double`.

    Free parameter of the Harris detector.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

    Output vector of detected corners.

  The function finds the most prominent corners in the image or in the specified image region, as
  described in @cite Shi94
  - Function calculates the corner quality measure at every source image pixel using the
    #cornerMinEigenVal or #cornerHarris .

  - Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
    retained).

  - The corners with the minimal eigenvalue less than
    \\f$\\texttt{qualityLevel} \\cdot \\max\\_{x,y} qualityMeasureMap(x,y)\\f$ are rejected.

  - The remaining corners are sorted by the quality measure in the descending order.
  - Function throws away each corner for which there is a stronger corner at a distance less than
    maxDistance.

  The function can be used to initialize a point-based tracker of an object.
  **Note**: If the function is called with different values A and B of the parameter qualityLevel , and
  A \\> B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
  with qualityLevel=B .

  @sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,

  Python prototype (for reference only):
  ```python3
  goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]]) -> corners
  ```
  """
  @spec goodFeaturesToTrack(Evision.Mat.maybe_mat_in(), integer(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(maxCorners) and is_number(qualityLevel) and is_number(minDistance)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      maxCorners: Evision.Internal.Structurise.from_struct(maxCorners),
      qualityLevel: Evision.Internal.Structurise.from_struct(qualityLevel),
      minDistance: Evision.Internal.Structurise.from_struct(minDistance)
    ]
    :evision_nif.goodFeaturesToTrack(positional)
    |> to_struct()
  end

  @doc """
  Same as above, but returns also quality measure of the detected corners.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Input 8-bit or floating-point 32-bit, single-channel image.

  - **maxCorners**: `integer()`.

    Maximum number of corners to return. If there are more corners than are found,
    the strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set
    and all detected corners are returned.

  - **qualityLevel**: `double`.

    Parameter characterizing the minimal accepted quality of image corners. The
    parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
    (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
    quality measure less than the product are rejected. For example, if the best corner has the
    quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
    less than 15 are rejected.

  - **minDistance**: `double`.

    Minimum possible Euclidean distance between the returned corners.

  - **mask**: `Evision.Mat`.

    Region of interest. If the image is not empty (it needs to have the type
    CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.

  ##### Keyword Arguments
  - **blockSize**: `integer()`.

    Size of an average block for computing a derivative covariation matrix over each
    pixel neighborhood. See cornerEigenValsAndVecs .

  - **gradientSize**: `integer()`.

    Aperture parameter for the Sobel operator used for derivatives computation.
    See cornerEigenValsAndVecs .

  - **useHarrisDetector**: `bool`.

    Parameter indicating whether to use a Harris detector (see #cornerHarris)
    or #cornerMinEigenVal.

  - **k**: `double`.

    Free parameter of the Harris detector.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

    Output vector of detected corners.

  - **cornersQuality**: `Evision.Mat.t()`.

    Output vector of quality measure of the detected corners.

  Python prototype (for reference only):
  ```python3
  goodFeaturesToTrackWithQuality(image, maxCorners, qualityLevel, minDistance, mask[, corners[, cornersQuality[, blockSize[, gradientSize[, useHarrisDetector[, k]]]]]]) -> corners, cornersQuality
  ```
  """
  @spec goodFeaturesToTrackWithQuality(Evision.Mat.maybe_mat_in(), integer(), number(), number(), Evision.Mat.maybe_mat_in(), [{:blockSize, term()} | {:gradientSize, term()} | {:k, term()} | {:useHarrisDetector, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def goodFeaturesToTrackWithQuality(image, maxCorners, qualityLevel, minDistance, mask, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(maxCorners) and is_number(qualityLevel) and is_number(minDistance) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:blockSize, :gradientSize, :k, :useHarrisDetector])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      maxCorners: Evision.Internal.Structurise.from_struct(maxCorners),
      qualityLevel: Evision.Internal.Structurise.from_struct(qualityLevel),
      minDistance: Evision.Internal.Structurise.from_struct(minDistance),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.goodFeaturesToTrackWithQuality(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Same as above, but returns also quality measure of the detected corners.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Input 8-bit or floating-point 32-bit, single-channel image.

  - **maxCorners**: `integer()`.

    Maximum number of corners to return. If there are more corners than are found,
    the strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set
    and all detected corners are returned.

  - **qualityLevel**: `double`.

    Parameter characterizing the minimal accepted quality of image corners. The
    parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
    (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
    quality measure less than the product are rejected. For example, if the best corner has the
    quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
    less than 15 are rejected.

  - **minDistance**: `double`.

    Minimum possible Euclidean distance between the returned corners.

  - **mask**: `Evision.Mat`.

    Region of interest. If the image is not empty (it needs to have the type
    CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.

  ##### Keyword Arguments
  - **blockSize**: `integer()`.

    Size of an average block for computing a derivative covariation matrix over each
    pixel neighborhood. See cornerEigenValsAndVecs .

  - **gradientSize**: `integer()`.

    Aperture parameter for the Sobel operator used for derivatives computation.
    See cornerEigenValsAndVecs .

  - **useHarrisDetector**: `bool`.

    Parameter indicating whether to use a Harris detector (see #cornerHarris)
    or #cornerMinEigenVal.

  - **k**: `double`.

    Free parameter of the Harris detector.

  ##### Return
  - **corners**: `Evision.Mat.t()`.

    Output vector of detected corners.

  - **cornersQuality**: `Evision.Mat.t()`.

    Output vector of quality measure of the detected corners.

  Python prototype (for reference only):
  ```python3
  goodFeaturesToTrackWithQuality(image, maxCorners, qualityLevel, minDistance, mask[, corners[, cornersQuality[, blockSize[, gradientSize[, useHarrisDetector[, k]]]]]]) -> corners, cornersQuality
  ```
  """
  @spec goodFeaturesToTrackWithQuality(Evision.Mat.maybe_mat_in(), integer(), number(), number(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def goodFeaturesToTrackWithQuality(image, maxCorners, qualityLevel, minDistance, mask) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and is_integer(maxCorners) and is_number(qualityLevel) and is_number(minDistance) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      maxCorners: Evision.Internal.Structurise.from_struct(maxCorners),
      qualityLevel: Evision.Internal.Structurise.from_struct(qualityLevel),
      minDistance: Evision.Internal.Structurise.from_struct(minDistance),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.goodFeaturesToTrackWithQuality(positional)
    |> to_struct()
  end

  @doc """
  Runs the GrabCut algorithm.

  ##### Positional Arguments
  - **img**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **rect**: `Rect`.

    ROI containing a segmented object. The pixels outside of the ROI are marked as
    "obvious background". The parameter is only used when mode==#GC_INIT_WITH_RECT .

  - **iterCount**: `integer()`.

    Number of iterations the algorithm should make before returning the result. Note
    that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or
    mode==GC_EVAL .

  ##### Keyword Arguments
  - **mode**: `integer()`.

    Operation mode that could be one of the #GrabCutModes

  ##### Return
  - **mask**: `Evision.Mat.t()`.

    Input/output 8-bit single-channel mask. The mask is initialized by the function when
    mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.

  - **bgdModel**: `Evision.Mat.t()`.

    Temporary array for the background model. Do not modify it while you are
    processing the same image.

  - **fgdModel**: `Evision.Mat.t()`.

    Temporary arrays for the foreground model. Do not modify it while you are
    processing the same image.

  The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).

  Python prototype (for reference only):
  ```python3
  grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode]) -> mask, bgdModel, fgdModel
  ```
  """
  @spec grabCut(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number(), number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:mode, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_tuple(rect) and (is_struct(bgdModel, Evision.Mat) or is_struct(bgdModel, Nx.Tensor) or is_number(bgdModel) or is_tuple(bgdModel)) and (is_struct(fgdModel, Evision.Mat) or is_struct(fgdModel, Nx.Tensor) or is_number(fgdModel) or is_tuple(fgdModel)) and is_integer(iterCount) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mode])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      mask: Evision.Internal.Structurise.from_struct(mask),
      rect: Evision.Internal.Structurise.from_struct(rect),
      bgdModel: Evision.Internal.Structurise.from_struct(bgdModel),
      fgdModel: Evision.Internal.Structurise.from_struct(fgdModel),
      iterCount: Evision.Internal.Structurise.from_struct(iterCount)
    ]
    :evision_nif.grabCut(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Runs the GrabCut algorithm.

  ##### Positional Arguments
  - **img**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **rect**: `Rect`.

    ROI containing a segmented object. The pixels outside of the ROI are marked as
    "obvious background". The parameter is only used when mode==#GC_INIT_WITH_RECT .

  - **iterCount**: `integer()`.

    Number of iterations the algorithm should make before returning the result. Note
    that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or
    mode==GC_EVAL .

  ##### Keyword Arguments
  - **mode**: `integer()`.

    Operation mode that could be one of the #GrabCutModes

  ##### Return
  - **mask**: `Evision.Mat.t()`.

    Input/output 8-bit single-channel mask. The mask is initialized by the function when
    mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.

  - **bgdModel**: `Evision.Mat.t()`.

    Temporary array for the background model. Do not modify it while you are
    processing the same image.

  - **fgdModel**: `Evision.Mat.t()`.

    Temporary arrays for the foreground model. Do not modify it while you are
    processing the same image.

  The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).

  Python prototype (for reference only):
  ```python3
  grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode]) -> mask, bgdModel, fgdModel
  ```
  """
  @spec grabCut(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number(), number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def grabCut(img, mask, rect, bgdModel, fgdModel, iterCount) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_tuple(rect) and (is_struct(bgdModel, Evision.Mat) or is_struct(bgdModel, Nx.Tensor) or is_number(bgdModel) or is_tuple(bgdModel)) and (is_struct(fgdModel, Evision.Mat) or is_struct(fgdModel, Nx.Tensor) or is_number(fgdModel) or is_tuple(fgdModel)) and is_integer(iterCount)
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      mask: Evision.Internal.Structurise.from_struct(mask),
      rect: Evision.Internal.Structurise.from_struct(rect),
      bgdModel: Evision.Internal.Structurise.from_struct(bgdModel),
      fgdModel: Evision.Internal.Structurise.from_struct(fgdModel),
      iterCount: Evision.Internal.Structurise.from_struct(iterCount)
    ]
    :evision_nif.grabCut(positional)
    |> to_struct()
  end

  @doc """
  groupRectangles

  ##### Positional Arguments
  - **groupThreshold**: `integer()`

  ##### Keyword Arguments
  - **eps**: `double`.

  ##### Return
  - **rectList**: `[Rect]`
  - **weights**: `[integer()]`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  groupRectangles(rectList, groupThreshold[, eps]) -> rectList, weights
  ```
  """
  @spec groupRectangles(list({number(), number(), number(), number()}), integer(), [{:eps, term()}] | nil) :: {list({number(), number(), number(), number()}), list(integer())} | {:error, String.t()}
  def groupRectangles(rectList, groupThreshold, opts) when is_list(rectList) and is_integer(groupThreshold) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:eps])
    positional = [
      rectList: Evision.Internal.Structurise.from_struct(rectList),
      groupThreshold: Evision.Internal.Structurise.from_struct(groupThreshold)
    ]
    :evision_nif.groupRectangles(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  groupRectangles

  ##### Positional Arguments
  - **groupThreshold**: `integer()`

  ##### Keyword Arguments
  - **eps**: `double`.

  ##### Return
  - **rectList**: `[Rect]`
  - **weights**: `[integer()]`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  groupRectangles(rectList, groupThreshold[, eps]) -> rectList, weights
  ```
  """
  @spec groupRectangles(list({number(), number(), number(), number()}), integer()) :: {list({number(), number(), number(), number()}), list(integer())} | {:error, String.t()}
  def groupRectangles(rectList, groupThreshold) when is_list(rectList) and is_integer(groupThreshold)
  do
    positional = [
      rectList: Evision.Internal.Structurise.from_struct(rectList),
      groupThreshold: Evision.Internal.Structurise.from_struct(groupThreshold)
    ]
    :evision_nif.groupRectangles(positional)
    |> to_struct()
  end

  @doc """
  Checks for the presence of at least one non-zero array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    single-channel array.

  ##### Return
  - **retval**: `bool`

  The function returns whether there are non-zero elements in src
  The function do not work with multi-channel arrays. If you need to check non-zero array
  elements across all the channels, use Mat::reshape first to reinterpret the array as
  single-channel. Or you may extract the particular channel using either extractImageCOI, or
  mixChannels, or split.
  **Note**: 
  - If the location of non-zero array elements is important, @ref findNonZero is helpful.
  - If the count of non-zero array elements is important, @ref countNonZero is helpful.
  @sa  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix
  @sa  findNonZero, countNonZero

  Python prototype (for reference only):
  ```python3
  hasNonZero(src) -> retval
  ```
  """
  @spec hasNonZero(Evision.Mat.maybe_mat_in()) :: boolean() | {:error, String.t()}
  def hasNonZero(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.hasNonZero(positional)
    |> to_struct()
  end

  @doc """
  Returns true if the specified image can be decoded by OpenCV

  ##### Positional Arguments
  - **filename**: `String`.

    File name of the image

  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  haveImageReader(filename) -> retval
  ```
  """
  @spec haveImageReader(binary()) :: boolean() | {:error, String.t()}
  def haveImageReader(filename) when is_binary(filename)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.haveImageReader(positional)
    |> to_struct()
  end

  @doc """
  Returns true if an image with the specified filename can be encoded by OpenCV

  ##### Positional Arguments
  - **filename**: `String`.

    File name of the image

  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  haveImageWriter(filename) -> retval
  ```
  """
  @spec haveImageWriter(binary()) :: boolean() | {:error, String.t()}
  def haveImageWriter(filename) when is_binary(filename)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.haveImageWriter(positional)
    |> to_struct()
  end

  @doc """
  haveOpenVX
  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  haveOpenVX() -> retval
  ```
  """
  @spec haveOpenVX() :: boolean() | {:error, String.t()}
  def haveOpenVX() do
    positional = [
    ]
    :evision_nif.haveOpenVX(positional)
    |> to_struct()
  end

  @doc """
  hconcat

  ##### Positional Arguments
  - **src**: `[Evision.Mat]`.

    input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array. It has the same number of rows and depth as the src, and the sum of cols of the src.
    same depth.

  Has overloading in C++

  ```cpp
  std::vector<cv::Mat> matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
  cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
  cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};
  cv::Mat out;
  cv::hconcat( matrices, out );
  //out:
  //[1, 2, 3;
  // 1, 2, 3;
  // 1, 2, 3;
  // 1, 2, 3]
  ```

  Python prototype (for reference only):
  ```python3
  hconcat(src[, dst]) -> dst
  ```
  """
  @spec hconcat(list(Evision.Mat.maybe_mat_in()), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def hconcat(src, opts) when is_list(src) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.hconcat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  hconcat

  ##### Positional Arguments
  - **src**: `[Evision.Mat]`.

    input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array. It has the same number of rows and depth as the src, and the sum of cols of the src.
    same depth.

  Has overloading in C++

  ```cpp
  std::vector<cv::Mat> matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
  cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
  cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};
  cv::Mat out;
  cv::hconcat( matrices, out );
  //out:
  //[1, 2, 3;
  // 1, 2, 3;
  // 1, 2, 3;
  // 1, 2, 3]
  ```

  Python prototype (for reference only):
  ```python3
  hconcat(src[, dst]) -> dst
  ```
  """
  @spec hconcat(list(Evision.Mat.maybe_mat_in())) :: Evision.Mat.t() | {:error, String.t()}
  def hconcat(src) when is_list(src)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.hconcat(positional)
    |> to_struct()
  end

  @doc """
  Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point single-channel array.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    operation flags.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).
  @sa  dct, dft, idft, getOptimalDFTSize

  Python prototype (for reference only):
  ```python3
  idct(src[, dst[, flags]]) -> dst
  ```
  """
  @spec idct(Evision.Mat.maybe_mat_in(), [{:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def idct(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.idct(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point single-channel array.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    operation flags.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).
  @sa  dct, dft, idft, getOptimalDFTSize

  Python prototype (for reference only):
  ```python3
  idct(src[, dst[, flags]]) -> dst
  ```
  """
  @spec idct(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def idct(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.idct(positional)
    |> to_struct()
  end

  @doc """
  Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point real or complex array.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    operation flags (see dft and #DftFlags).

  - **nonzeroRows**: `integer()`.

    number of dst rows to process; the rest of the rows have undefined content (see
    the convolution sample in dft description.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array whose size and type depend on the flags.

  idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) .
  **Note**: None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of
  dft or idft explicitly to make these transforms mutually inverse.
  @sa dft, dct, idct, mulSpectrums, getOptimalDFTSize

  Python prototype (for reference only):
  ```python3
  idft(src[, dst[, flags[, nonzeroRows]]]) -> dst
  ```
  """
  @spec idft(Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:nonzeroRows, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def idft(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :nonzeroRows])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.idft(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point real or complex array.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    operation flags (see dft and #DftFlags).

  - **nonzeroRows**: `integer()`.

    number of dst rows to process; the rest of the rows have undefined content (see
    the convolution sample in dft description.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array whose size and type depend on the flags.

  idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) .
  **Note**: None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of
  dft or idft explicitly to make these transforms mutually inverse.
  @sa dft, dct, idct, mulSpectrums, getOptimalDFTSize

  Python prototype (for reference only):
  ```python3
  idft(src[, dst[, flags[, nonzeroRows]]]) -> dst
  ```
  """
  @spec idft(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def idft(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.idft(positional)
    |> to_struct()
  end

  @doc """
  Applying an appropriate non-linear transformation to the gradient field inside the selection and
  then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  ##### Keyword Arguments
  - **alpha**: `float`.

    Value ranges between 0-2.

  - **beta**: `float`.

    Value ranges between 0-2.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  This is useful to highlight under-exposed foreground objects or to reduce specular reflections.

  Python prototype (for reference only):
  ```python3
  illuminationChange(src, mask[, dst[, alpha[, beta]]]) -> dst
  ```
  """
  @spec illuminationChange(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:alpha, term()} | {:beta, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def illuminationChange(src, mask, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:alpha, :beta])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.illuminationChange(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applying an appropriate non-linear transformation to the gradient field inside the selection and
  then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  ##### Keyword Arguments
  - **alpha**: `float`.

    Value ranges between 0-2.

  - **beta**: `float`.

    Value ranges between 0-2.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  This is useful to highlight under-exposed foreground objects or to reduce specular reflections.

  Python prototype (for reference only):
  ```python3
  illuminationChange(src, mask[, dst[, alpha[, beta]]]) -> dst
  ```
  """
  @spec illuminationChange(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def illuminationChange(src, mask) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.illuminationChange(positional)
    |> to_struct()
  end

  @doc """
  Returns the number of images inside the give file

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.

  ##### Return
  - **retval**: `size_t`

  The function imcount will return the number of pages in a multi-page image, or 1 for single-page images

  Python prototype (for reference only):
  ```python3
  imcount(filename[, flags]) -> retval
  ```
  """
  @spec imcount(binary(), [{:flags, term()}] | nil) :: integer() | {:error, String.t()}
  def imcount(filename, opts) when is_binary(filename) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.imcount(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Returns the number of images inside the give file

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.

  ##### Return
  - **retval**: `size_t`

  The function imcount will return the number of pages in a multi-page image, or 1 for single-page images

  Python prototype (for reference only):
  ```python3
  imcount(filename[, flags]) -> retval
  ```
  """
  @spec imcount(binary()) :: integer() | {:error, String.t()}
  def imcount(filename) when is_binary(filename)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.imcount(positional)
    |> to_struct()
  end

  @doc """
  Reads a multi-page image from a buffer in memory.

  ##### Positional Arguments
  - **buf**: `Evision.Mat`.

    Input array or vector of bytes.

  - **flags**: `integer()`.

    The same flags as in cv::imread, see cv::ImreadModes.

  ##### Keyword Arguments
  - **range**: `Range`.

    A continuous selection of pages.

  ##### Return
  - **retval**: `bool`
  - **mats**: `[Evision.Mat]`.

    A vector of Mat objects holding each page, if more than one.

  The function imdecodemulti reads a multi-page image from the specified buffer in the memory. If the buffer is too short or
  contains invalid data, the function returns false.
  See cv::imreadmulti for the list of supported formats and flags description.
  **Note**: In the case of color images, the decoded images will have the channels stored in **B G R** order.

  Python prototype (for reference only):
  ```python3
  imdecodemulti(buf, flags[, mats[, range]]) -> retval, mats
  ```
  """
  @spec imdecodemulti(Evision.Mat.maybe_mat_in(), integer(), [{:range, term()}] | nil) :: list(Evision.Mat.t()) | false | {:error, String.t()}
  def imdecodemulti(buf, flags, opts) when (is_struct(buf, Evision.Mat) or is_struct(buf, Nx.Tensor) or is_number(buf) or is_tuple(buf)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:range])
    positional = [
      buf: Evision.Internal.Structurise.from_struct(buf),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.imdecodemulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Reads a multi-page image from a buffer in memory.

  ##### Positional Arguments
  - **buf**: `Evision.Mat`.

    Input array or vector of bytes.

  - **flags**: `integer()`.

    The same flags as in cv::imread, see cv::ImreadModes.

  ##### Keyword Arguments
  - **range**: `Range`.

    A continuous selection of pages.

  ##### Return
  - **retval**: `bool`
  - **mats**: `[Evision.Mat]`.

    A vector of Mat objects holding each page, if more than one.

  The function imdecodemulti reads a multi-page image from the specified buffer in the memory. If the buffer is too short or
  contains invalid data, the function returns false.
  See cv::imreadmulti for the list of supported formats and flags description.
  **Note**: In the case of color images, the decoded images will have the channels stored in **B G R** order.

  Python prototype (for reference only):
  ```python3
  imdecodemulti(buf, flags[, mats[, range]]) -> retval, mats
  ```
  """
  @spec imdecodemulti(Evision.Mat.maybe_mat_in(), integer()) :: list(Evision.Mat.t()) | false | {:error, String.t()}
  def imdecodemulti(buf, flags) when (is_struct(buf, Evision.Mat) or is_struct(buf, Nx.Tensor) or is_number(buf) or is_tuple(buf)) and is_integer(flags)
  do
    positional = [
      buf: Evision.Internal.Structurise.from_struct(buf),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.imdecodemulti(positional)
    |> to_struct()
  end

  @doc """
  Encodes an image into a memory buffer.

  ##### Positional Arguments
  - **ext**: `String`.

    File extension that defines the output format. Must include a leading period.

  - **img**: `Evision.Mat`.

    Image to be written.

  ##### Keyword Arguments
  - **params**: `[integer()]`.

    Format-specific parameters. See cv::imwrite and cv::ImwriteFlags.

  ##### Return
  - **retval**: `bool`
  - **buf**: `[uchar]`.

    Output buffer resized to fit the compressed image.

  The function imencode compresses the image and stores it in the memory buffer that is resized to fit the
  result. See cv::imwrite for the list of supported formats and flags description.

  Python prototype (for reference only):
  ```python3
  imencode(ext, img[, params]) -> retval, buf
  ```
  """
  @spec imencode(binary(), Evision.Mat.maybe_mat_in(), [{:params, term()}] | nil) :: binary() | false | {:error, String.t()}
  def imencode(ext, img, opts) when is_binary(ext) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:params])
    positional = [
      ext: Evision.Internal.Structurise.from_struct(ext),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.imencode(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Encodes an image into a memory buffer.

  ##### Positional Arguments
  - **ext**: `String`.

    File extension that defines the output format. Must include a leading period.

  - **img**: `Evision.Mat`.

    Image to be written.

  ##### Keyword Arguments
  - **params**: `[integer()]`.

    Format-specific parameters. See cv::imwrite and cv::ImwriteFlags.

  ##### Return
  - **retval**: `bool`
  - **buf**: `[uchar]`.

    Output buffer resized to fit the compressed image.

  The function imencode compresses the image and stores it in the memory buffer that is resized to fit the
  result. See cv::imwrite for the list of supported formats and flags description.

  Python prototype (for reference only):
  ```python3
  imencode(ext, img[, params]) -> retval, buf
  ```
  """
  @spec imencode(binary(), Evision.Mat.maybe_mat_in()) :: binary() | false | {:error, String.t()}
  def imencode(ext, img) when is_binary(ext) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img))
  do
    positional = [
      ext: Evision.Internal.Structurise.from_struct(ext),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.imencode(positional)
    |> to_struct()
  end

  @doc """
  Loads an image from a file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    object in which the image will be loaded.

  This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts and the return value.
  **Note**: 
  The image passing through the img parameter can be pre-allocated. The memory is reused if the shape and the type match with the load image.

  Python prototype (for reference only):
  ```python3
  imread(filename[, dst[, flags]]) -> dst
  ```
  """
  @spec imread(binary(), [{:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def imread(filename, opts) when is_binary(filename) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.imread(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Loads an image from a file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    object in which the image will be loaded.

  This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts and the return value.
  **Note**: 
  The image passing through the img parameter can be pre-allocated. The memory is reused if the shape and the type match with the load image.

  Python prototype (for reference only):
  ```python3
  imread(filename[, dst[, flags]]) -> dst
  ```
  """
  @spec imread(binary()) :: Evision.Mat.t() | {:error, String.t()}
  def imread(filename) when is_binary(filename)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.imread(positional)
    |> to_struct()
  end

  @doc """
  Loads a of images of a multi-page image from a file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  - **start**: `integer()`.

    Start index of the image to load

  - **count**: `integer()`.

    Count number of images to load

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.

  ##### Return
  - **retval**: `bool`
  - **mats**: `[Evision.Mat]`.

    A vector of Mat objects holding each page.

  The function imreadmulti loads a specified range from a multi-page image from the specified file into a vector of Mat objects.
  @sa cv::imread

  Python prototype (for reference only):
  ```python3
  imreadmulti(filename, start, count[, mats[, flags]]) -> retval, mats
  ```
  """
  @spec imreadmulti(binary(), integer(), integer(), [{:flags, term()}] | nil) :: list(Evision.Mat.t()) | false | {:error, String.t()}
  def imreadmulti(filename, start, count, opts) when is_binary(filename) and is_integer(start) and is_integer(count) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename),
      start: Evision.Internal.Structurise.from_struct(start),
      count: Evision.Internal.Structurise.from_struct(count)
    ]
    :evision_nif.imreadmulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Loads a of images of a multi-page image from a file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  - **start**: `integer()`.

    Start index of the image to load

  - **count**: `integer()`.

    Count number of images to load

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.

  ##### Return
  - **retval**: `bool`
  - **mats**: `[Evision.Mat]`.

    A vector of Mat objects holding each page.

  The function imreadmulti loads a specified range from a multi-page image from the specified file into a vector of Mat objects.
  @sa cv::imread

  Python prototype (for reference only):
  ```python3
  imreadmulti(filename, start, count[, mats[, flags]]) -> retval, mats
  ```
  """
  @spec imreadmulti(binary(), integer(), integer()) :: list(Evision.Mat.t()) | false | {:error, String.t()}
  def imreadmulti(filename, start, count) when is_binary(filename) and is_integer(start) and is_integer(count)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename),
      start: Evision.Internal.Structurise.from_struct(start),
      count: Evision.Internal.Structurise.from_struct(count)
    ]
    :evision_nif.imreadmulti(positional)
    |> to_struct()
  end

  @doc """
  Loads a multi-page image from a file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.

  ##### Return
  - **retval**: `bool`
  - **mats**: `[Evision.Mat]`.

    A vector of Mat objects holding each page.

  The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects.
  @sa cv::imread

  Python prototype (for reference only):
  ```python3
  imreadmulti(filename[, mats[, flags]]) -> retval, mats
  ```
  """
  @spec imreadmulti(binary(), [{:flags, term()}] | nil) :: list(Evision.Mat.t()) | false | {:error, String.t()}
  def imreadmulti(filename, opts) when is_binary(filename) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.imreadmulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Loads a multi-page image from a file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of file to be loaded.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.

  ##### Return
  - **retval**: `bool`
  - **mats**: `[Evision.Mat]`.

    A vector of Mat objects holding each page.

  The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects.
  @sa cv::imread

  Python prototype (for reference only):
  ```python3
  imreadmulti(filename[, mats[, flags]]) -> retval, mats
  ```
  """
  @spec imreadmulti(binary()) :: list(Evision.Mat.t()) | false | {:error, String.t()}
  def imreadmulti(filename) when is_binary(filename)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename)
    ]
    :evision_nif.imreadmulti(positional)
    |> to_struct()
  end

  @doc """
  Saves an image to a specified file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of the file.

  - **img**: `Evision.Mat`.

    (Mat or vector of Mat) Image or Images to be saved.

  ##### Keyword Arguments
  - **params**: `[integer()]`.

    Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::ImwriteFlags

  ##### Return
  - **retval**: `bool`

  The function imwrite saves the image to the specified file. The image format is chosen based on the
  filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U)
  single-channel or 3-channel (with 'BGR' channel order) images
  can be saved using this function, with these exceptions:
  - With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.
  - 8-bit unsigned (CV_8U) images are not supported.
  - With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.
  - All images will be converted to 32-bit float (CV_32F).
  - With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - PNG images with an alpha channel can be saved using this function. To do this, create
    8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels
    should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).

  - With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - With TIFF encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U),
    32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.

  - Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).
  - 32-bit float 3-channel (CV_32FC3) TIFF images will be saved
    using the LogLuv high dynamic range encoding (4 bytes per pixel)

  If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way.
  If the format, depth or channel order is different, use
  Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O
  functions to save the image to XML or YAML format.
  The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file.
  It also demonstrates how to save multiple images in a TIFF file:
  @include snippets/imgcodecs_imwrite.cpp

  Python prototype (for reference only):
  ```python3
  imwrite(filename, img[, params]) -> retval
  ```
  """
  @spec imwrite(binary(), Evision.Mat.maybe_mat_in(), [{:params, term()}] | nil) :: boolean() | {:error, String.t()}
  def imwrite(filename, img, opts) when is_binary(filename) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:params])
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.imwrite(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Saves an image to a specified file.

  ##### Positional Arguments
  - **filename**: `String`.

    Name of the file.

  - **img**: `Evision.Mat`.

    (Mat or vector of Mat) Image or Images to be saved.

  ##### Keyword Arguments
  - **params**: `[integer()]`.

    Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::ImwriteFlags

  ##### Return
  - **retval**: `bool`

  The function imwrite saves the image to the specified file. The image format is chosen based on the
  filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U)
  single-channel or 3-channel (with 'BGR' channel order) images
  can be saved using this function, with these exceptions:
  - With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.
  - 8-bit unsigned (CV_8U) images are not supported.
  - With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.
  - All images will be converted to 32-bit float (CV_32F).
  - With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - PNG images with an alpha channel can be saved using this function. To do this, create
    8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels
    should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).

  - With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.
  - With TIFF encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U),
    32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.

  - Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).
  - 32-bit float 3-channel (CV_32FC3) TIFF images will be saved
    using the LogLuv high dynamic range encoding (4 bytes per pixel)

  If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way.
  If the format, depth or channel order is different, use
  Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O
  functions to save the image to XML or YAML format.
  The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file.
  It also demonstrates how to save multiple images in a TIFF file:
  @include snippets/imgcodecs_imwrite.cpp

  Python prototype (for reference only):
  ```python3
  imwrite(filename, img[, params]) -> retval
  ```
  """
  @spec imwrite(binary(), Evision.Mat.maybe_mat_in()) :: boolean() | {:error, String.t()}
  def imwrite(filename, img) when is_binary(filename) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img))
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.imwrite(positional)
    |> to_struct()
  end

  @doc """
  imwritemulti

  ##### Positional Arguments
  - **filename**: `String`
  - **img**: `[Evision.Mat]`

  ##### Keyword Arguments
  - **params**: `[integer()]`.

  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  imwritemulti(filename, img[, params]) -> retval
  ```
  """
  @spec imwritemulti(binary(), list(Evision.Mat.maybe_mat_in()), [{:params, term()}] | nil) :: boolean() | {:error, String.t()}
  def imwritemulti(filename, img, opts) when is_binary(filename) and is_list(img) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:params])
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.imwritemulti(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  imwritemulti

  ##### Positional Arguments
  - **filename**: `String`
  - **img**: `[Evision.Mat]`

  ##### Keyword Arguments
  - **params**: `[integer()]`.

  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  imwritemulti(filename, img[, params]) -> retval
  ```
  """
  @spec imwritemulti(binary(), list(Evision.Mat.maybe_mat_in())) :: boolean() | {:error, String.t()}
  def imwritemulti(filename, img) when is_binary(filename) and is_list(img)
  do
    positional = [
      filename: Evision.Internal.Structurise.from_struct(filename),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.imwritemulti(positional)
    |> to_struct()
  end

  @doc """
  Checks if array elements lie between the elements of two other arrays.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    first input array.

  - **lowerb**: `Evision.Mat`.

    inclusive lower boundary array or a scalar.

  - **upperb**: `Evision.Mat`.

    inclusive upper boundary array or a scalar.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size as src and CV_8U type.

  The function checks the range as follows:
  - For every element of a single-channel input array:
    \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)\\_0  \\leq \\texttt{src} (I)\\_0 \\leq  \\texttt{upperb} (I)\\_0\\f]

  - For two-channel arrays:
    \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)\\_0  \\leq \\texttt{src} (I)\\_0 \\leq  \\texttt{upperb} (I)\\_0  \\land \\texttt{lowerb} (I)\\_1  \\leq \\texttt{src} (I)\\_1 \\leq  \\texttt{upperb} (I)\\_1\\f]

  - and so forth.

  That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the
  specified 1D, 2D, 3D, ... box and 0 otherwise.
  When the lower and/or upper boundary parameters are scalars, the indexes
  (I) at lowerb and upperb in the above formulas should be omitted.

  Python prototype (for reference only):
  ```python3
  inRange(src, lowerb, upperb[, dst]) -> dst
  ```
  """
  @spec inRange(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def inRange(src, lowerb, upperb, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(lowerb, Evision.Mat) or is_struct(lowerb, Nx.Tensor) or is_number(lowerb) or is_tuple(lowerb)) and (is_struct(upperb, Evision.Mat) or is_struct(upperb, Nx.Tensor) or is_number(upperb) or is_tuple(upperb)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      lowerb: Evision.Internal.Structurise.from_struct(lowerb),
      upperb: Evision.Internal.Structurise.from_struct(upperb)
    ]
    :evision_nif.inRange(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Checks if array elements lie between the elements of two other arrays.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    first input array.

  - **lowerb**: `Evision.Mat`.

    inclusive lower boundary array or a scalar.

  - **upperb**: `Evision.Mat`.

    inclusive upper boundary array or a scalar.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size as src and CV_8U type.

  The function checks the range as follows:
  - For every element of a single-channel input array:
    \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)\\_0  \\leq \\texttt{src} (I)\\_0 \\leq  \\texttt{upperb} (I)\\_0\\f]

  - For two-channel arrays:
    \\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)\\_0  \\leq \\texttt{src} (I)\\_0 \\leq  \\texttt{upperb} (I)\\_0  \\land \\texttt{lowerb} (I)\\_1  \\leq \\texttt{src} (I)\\_1 \\leq  \\texttt{upperb} (I)\\_1\\f]

  - and so forth.

  That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the
  specified 1D, 2D, 3D, ... box and 0 otherwise.
  When the lower and/or upper boundary parameters are scalars, the indexes
  (I) at lowerb and upperb in the above formulas should be omitted.

  Python prototype (for reference only):
  ```python3
  inRange(src, lowerb, upperb[, dst]) -> dst
  ```
  """
  @spec inRange(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def inRange(src, lowerb, upperb) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(lowerb, Evision.Mat) or is_struct(lowerb, Nx.Tensor) or is_number(lowerb) or is_tuple(lowerb)) and (is_struct(upperb, Evision.Mat) or is_struct(upperb, Nx.Tensor) or is_number(upperb) or is_tuple(upperb))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      lowerb: Evision.Internal.Structurise.from_struct(lowerb),
      upperb: Evision.Internal.Structurise.from_struct(upperb)
    ]
    :evision_nif.inRange(positional)
    |> to_struct()
  end

  @doc """
  Finds an initial camera intrinsic matrix from 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    Vector of vectors of the calibration pattern points in the calibration pattern
    coordinate space. In the old interface all the per-view vectors are concatenated. See
    #calibrateCamera for details.

  - **imagePoints**: `[Evision.Mat]`.

    Vector of vectors of the projections of the calibration pattern points. In the
    old interface all the per-view vectors are concatenated.

  - **imageSize**: `Size`.

    Image size in pixels used to initialize the principal point.

  ##### Keyword Arguments
  - **aspectRatio**: `double`.

    If it is zero or negative, both \\f$f_x\\f$ and \\f$f_y\\f$ are estimated independently.
    Otherwise, \\f$f_x = f_y \\cdot \\texttt{aspectRatio}\\f$ .

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function estimates and returns an initial camera intrinsic matrix for the camera calibration process.
  Currently, the function only supports planar calibration patterns, which are patterns where each
  object point has z-coordinate =0.

  Python prototype (for reference only):
  ```python3
  initCameraMatrix2D(objectPoints, imagePoints, imageSize[, aspectRatio]) -> retval
  ```
  """
  @spec initCameraMatrix2D(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, [{:aspectRatio, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def initCameraMatrix2D(objectPoints, imagePoints, imageSize, opts) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:aspectRatio])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize)
    ]
    :evision_nif.initCameraMatrix2D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds an initial camera intrinsic matrix from 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    Vector of vectors of the calibration pattern points in the calibration pattern
    coordinate space. In the old interface all the per-view vectors are concatenated. See
    #calibrateCamera for details.

  - **imagePoints**: `[Evision.Mat]`.

    Vector of vectors of the projections of the calibration pattern points. In the
    old interface all the per-view vectors are concatenated.

  - **imageSize**: `Size`.

    Image size in pixels used to initialize the principal point.

  ##### Keyword Arguments
  - **aspectRatio**: `double`.

    If it is zero or negative, both \\f$f_x\\f$ and \\f$f_y\\f$ are estimated independently.
    Otherwise, \\f$f_x = f_y \\cdot \\texttt{aspectRatio}\\f$ .

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function estimates and returns an initial camera intrinsic matrix for the camera calibration process.
  Currently, the function only supports planar calibration patterns, which are patterns where each
  object point has z-coordinate =0.

  Python prototype (for reference only):
  ```python3
  initCameraMatrix2D(objectPoints, imagePoints, imageSize[, aspectRatio]) -> retval
  ```
  """
  @spec initCameraMatrix2D(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def initCameraMatrix2D(objectPoints, imagePoints, imageSize) when is_list(objectPoints) and is_list(imagePoints) and is_tuple(imageSize)
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize)
    ]
    :evision_nif.initCameraMatrix2D(positional)
    |> to_struct()
  end

  @doc """
  Computes the projection and inverse-rectification transformation map. In essense, this is the inverse of
  #initUndistortRectifyMap to accomodate stereo-rectification of projectors ('inverse-cameras') in projector-camera pairs.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  - **r**: `Evision.Mat`.

    Optional rectification transformation in the object space (3x3 matrix). R1 or R2,
    computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation
    is assumed.

  - **newCameraMatrix**: `Evision.Mat`.

    New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.

  - **size**: `Size`.

    Distorted image size.

  - **m1type**: `integer()`.

    Type of the first output map. Can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps

  ##### Return
  - **map1**: `Evision.Mat.t()`.

    The first output map for #remap.

  - **map2**: `Evision.Mat.t()`.

    The second output map for #remap.

  The function computes the joint projection and inverse rectification transformation and represents the
  result in the form of maps for #remap. The projected image looks like a distorted version of the original which,
  once projected by a projector, should visually match the original. In case of a monocular camera, newCameraMatrix
  is usually equal to cameraMatrix, or it can be computed by
  #getOptimalNewCameraMatrix for a better control over scaling. In case of a projector-camera pair,
  newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .
  The projector is oriented differently in the coordinate space, according to R. In case of projector-camera pairs,
  this helps align the projector (in the same manner as #initUndistortRectifyMap for the camera) to create a stereo-rectified pair. This
  allows epipolar lines on both images to become horizontal and have the same y-coordinate (in case of a horizontally aligned projector-camera pair).
  The function builds the maps for the inverse mapping algorithm that is used by #remap. That
  is, for each pixel \\f$(u, v)\\f$ in the destination (projected and inverse-rectified) image, the function
  computes the corresponding coordinates in the source image (that is, in the original digital image). The following process is applied:
  \\f[
  \\begin{array}{l}
  \\text{newCameraMatrix}\\\\\\\\
  x  \\leftarrow (u - {c'}\\_x)/{f'}\\_x  \\\\\\\\
  y  \\leftarrow (v - {c'}\\_y)/{f'}\\_y  \\\\\\\\
  \\\\\\\\\\text{Undistortion}
  \\\\\\\\\\scriptsize{\\textit{though equation shown is for radial undistortion, function implements cv::undistortPoints()}}\\\\\\\\
  r^2  \\leftarrow x^2 + y^2 \\\\\\\\
  \\theta \\leftarrow \\frac{1 + k\\_1 r^2 + k\\_2 r^4 + k\\_3 r^6}{1 + k\\_4 r^2 + k\\_5 r^4 + k\\_6 r^6}\\\\\\\\
  x' \\leftarrow \\frac{x}{\\theta} \\\\\\\\
  y'  \\leftarrow \\frac{y}{\\theta} \\\\\\\\
  \\\\\\\\\\text{Rectification}\\\\\\\\
  {\\[X\\,Y\\,W]} ^T  \\leftarrow R\\*\\[x' \\, y' \\, 1]^T  \\\\\\\\
  x''  \\leftarrow X/W  \\\\\\\\
  y''  \\leftarrow Y/W  \\\\\\\\
  \\\\\\\\\\text{cameraMatrix}\\\\\\\\
  map\\_x(u,v)  \\leftarrow x'' f\\_x + c\\_x  \\\\\\\\
  map\\_y(u,v)  \\leftarrow y'' f\\_y + c\\_y
  \\end{array}
  \\f]
  where \\f$(k\\_1, k\\_2, p\\_1, p\\_2\\[, k\\_3\\[, k\\_4, k\\_5, k\\_6\\[, s\\_1, s\\_2, s\\_3, s\\_4\\[, \\tau\\_x, \\tau\\_y]]]])\\f$
  are the distortion coefficients vector distCoeffs.
  In case of a stereo-rectified projector-camera pair, this function is called for the projector while #initUndistortRectifyMap is called for the camera head.
  This is done after #stereoRectify, which in turn is called after #stereoCalibrate. If the projector-camera pair
  is not calibrated, it is still possible to compute the rectification transformations directly from
  the fundamental matrix using #stereoRectifyUncalibrated. For the projector and camera, the function computes
  homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
  space. R can be computed from H as
  \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f]
  where cameraMatrix can be chosen arbitrarily.

  Python prototype (for reference only):
  ```python3
  initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -> map1, map2
  ```
  """
  @spec initInverseRectificationMap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def initInverseRectificationMap(cameraMatrix, distCoeffs, r, newCameraMatrix, size, m1type, opts) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(newCameraMatrix, Evision.Mat) or is_struct(newCameraMatrix, Nx.Tensor) or is_number(newCameraMatrix) or is_tuple(newCameraMatrix)) and is_tuple(size) and is_integer(m1type) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      r: Evision.Internal.Structurise.from_struct(r),
      newCameraMatrix: Evision.Internal.Structurise.from_struct(newCameraMatrix),
      size: Evision.Internal.Structurise.from_struct(size),
      m1type: Evision.Internal.Structurise.from_struct(m1type)
    ]
    :evision_nif.initInverseRectificationMap(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes the projection and inverse-rectification transformation map. In essense, this is the inverse of
  #initUndistortRectifyMap to accomodate stereo-rectification of projectors ('inverse-cameras') in projector-camera pairs.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  - **r**: `Evision.Mat`.

    Optional rectification transformation in the object space (3x3 matrix). R1 or R2,
    computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation
    is assumed.

  - **newCameraMatrix**: `Evision.Mat`.

    New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.

  - **size**: `Size`.

    Distorted image size.

  - **m1type**: `integer()`.

    Type of the first output map. Can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps

  ##### Return
  - **map1**: `Evision.Mat.t()`.

    The first output map for #remap.

  - **map2**: `Evision.Mat.t()`.

    The second output map for #remap.

  The function computes the joint projection and inverse rectification transformation and represents the
  result in the form of maps for #remap. The projected image looks like a distorted version of the original which,
  once projected by a projector, should visually match the original. In case of a monocular camera, newCameraMatrix
  is usually equal to cameraMatrix, or it can be computed by
  #getOptimalNewCameraMatrix for a better control over scaling. In case of a projector-camera pair,
  newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .
  The projector is oriented differently in the coordinate space, according to R. In case of projector-camera pairs,
  this helps align the projector (in the same manner as #initUndistortRectifyMap for the camera) to create a stereo-rectified pair. This
  allows epipolar lines on both images to become horizontal and have the same y-coordinate (in case of a horizontally aligned projector-camera pair).
  The function builds the maps for the inverse mapping algorithm that is used by #remap. That
  is, for each pixel \\f$(u, v)\\f$ in the destination (projected and inverse-rectified) image, the function
  computes the corresponding coordinates in the source image (that is, in the original digital image). The following process is applied:
  \\f[
  \\begin{array}{l}
  \\text{newCameraMatrix}\\\\\\\\
  x  \\leftarrow (u - {c'}\\_x)/{f'}\\_x  \\\\\\\\
  y  \\leftarrow (v - {c'}\\_y)/{f'}\\_y  \\\\\\\\
  \\\\\\\\\\text{Undistortion}
  \\\\\\\\\\scriptsize{\\textit{though equation shown is for radial undistortion, function implements cv::undistortPoints()}}\\\\\\\\
  r^2  \\leftarrow x^2 + y^2 \\\\\\\\
  \\theta \\leftarrow \\frac{1 + k\\_1 r^2 + k\\_2 r^4 + k\\_3 r^6}{1 + k\\_4 r^2 + k\\_5 r^4 + k\\_6 r^6}\\\\\\\\
  x' \\leftarrow \\frac{x}{\\theta} \\\\\\\\
  y'  \\leftarrow \\frac{y}{\\theta} \\\\\\\\
  \\\\\\\\\\text{Rectification}\\\\\\\\
  {\\[X\\,Y\\,W]} ^T  \\leftarrow R\\*\\[x' \\, y' \\, 1]^T  \\\\\\\\
  x''  \\leftarrow X/W  \\\\\\\\
  y''  \\leftarrow Y/W  \\\\\\\\
  \\\\\\\\\\text{cameraMatrix}\\\\\\\\
  map\\_x(u,v)  \\leftarrow x'' f\\_x + c\\_x  \\\\\\\\
  map\\_y(u,v)  \\leftarrow y'' f\\_y + c\\_y
  \\end{array}
  \\f]
  where \\f$(k\\_1, k\\_2, p\\_1, p\\_2\\[, k\\_3\\[, k\\_4, k\\_5, k\\_6\\[, s\\_1, s\\_2, s\\_3, s\\_4\\[, \\tau\\_x, \\tau\\_y]]]])\\f$
  are the distortion coefficients vector distCoeffs.
  In case of a stereo-rectified projector-camera pair, this function is called for the projector while #initUndistortRectifyMap is called for the camera head.
  This is done after #stereoRectify, which in turn is called after #stereoCalibrate. If the projector-camera pair
  is not calibrated, it is still possible to compute the rectification transformations directly from
  the fundamental matrix using #stereoRectifyUncalibrated. For the projector and camera, the function computes
  homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
  space. R can be computed from H as
  \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f]
  where cameraMatrix can be chosen arbitrarily.

  Python prototype (for reference only):
  ```python3
  initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -> map1, map2
  ```
  """
  @spec initInverseRectificationMap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def initInverseRectificationMap(cameraMatrix, distCoeffs, r, newCameraMatrix, size, m1type) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(newCameraMatrix, Evision.Mat) or is_struct(newCameraMatrix, Nx.Tensor) or is_number(newCameraMatrix) or is_tuple(newCameraMatrix)) and is_tuple(size) and is_integer(m1type)
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      r: Evision.Internal.Structurise.from_struct(r),
      newCameraMatrix: Evision.Internal.Structurise.from_struct(newCameraMatrix),
      size: Evision.Internal.Structurise.from_struct(size),
      m1type: Evision.Internal.Structurise.from_struct(m1type)
    ]
    :evision_nif.initInverseRectificationMap(positional)
    |> to_struct()
  end

  @doc """
  Computes the undistortion and rectification transformation map.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  - **r**: `Evision.Mat`.

    Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,
    computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation
    is assumed. In #initUndistortRectifyMap R assumed to be an identity matrix.

  - **newCameraMatrix**: `Evision.Mat`.

    New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.

  - **size**: `Size`.

    Undistorted image size.

  - **m1type**: `integer()`.

    Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps

  ##### Return
  - **map1**: `Evision.Mat.t()`.

    The first output map.

  - **map2**: `Evision.Mat.t()`.

    The second output map.

  The function computes the joint undistortion and rectification transformation and represents the
  result in the form of maps for #remap. The undistorted image looks like original, as if it is
  captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a
  monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by
  #getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,
  newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .
  Also, this new camera is oriented differently in the coordinate space, according to R. That, for
  example, helps to align two heads of a stereo camera so that the epipolar lines on both images
  become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).
  The function actually builds the maps for the inverse mapping algorithm that is used by #remap. That
  is, for each pixel \\f$(u, v)\\f$ in the destination (corrected and rectified) image, the function
  computes the corresponding coordinates in the source image (that is, in the original image from
  camera). The following process is applied:
  \\f[
  \\begin{array}{l}
  x  \\leftarrow (u - {c'}\\_x)/{f'}\\_x  \\\\\\\\
  y  \\leftarrow (v - {c'}\\_y)/{f'}\\_y  \\\\\\\\
  {\\[X\\,Y\\,W]} ^T  \\leftarrow R^{-1}\\*\\[x \\, y \\, 1]^T  \\\\\\\\
  x'  \\leftarrow X/W  \\\\\\\\
  y'  \\leftarrow Y/W  \\\\\\\\
  r^2  \\leftarrow x'^2 + y'^2 \\\\\\\\
  x''  \\leftarrow x' \\frac{1 + k\\_1 r^2 + k\\_2 r^4 + k\\_3 r^6}{1 + k\\_4 r^2 + k\\_5 r^4 + k\\_6 r^6}
  \\+ 2p\\_1 x' y' + p\\_2(r^2 + 2 x'^2)  + s\\_1 r^2 + s\\_2 r^4\\\\\\\\
  y''  \\leftarrow y' \\frac{1 + k\\_1 r^2 + k\\_2 r^4 + k\\_3 r^6}{1 + k\\_4 r^2 + k\\_5 r^4 + k\\_6 r^6}
  \\+ p\\_1 (r^2 + 2 y'^2) + 2 p\\_2 x' y' + s\\_3 r^2 + s\\_4 r^4 \\\\\\\\
  s\\vecthree{x'''}{y'''}{1} =
  \\vecthreethree{R\\_{33}(\\tau\\_x, \\tau\\_y)}{0}{-R\\_{13}((\\tau\\_x, \\tau\\_y)}
  {0}{R\\_{33}(\\tau\\_x, \\tau\\_y)}{-R\\_{23}(\\tau\\_x, \\tau\\_y)}
  {0}{0}{1} R(\\tau\\_x, \\tau\\_y) \\vecthree{x''}{y''}{1}\\\\\\\\
  map\\_x(u,v)  \\leftarrow x''' f\\_x + c\\_x  \\\\\\\\
  map\\_y(u,v)  \\leftarrow y''' f\\_y + c\\_y
  \\end{array}
  \\f]
  where \\f$(k\\_1, k\\_2, p\\_1, p\\_2\\[, k\\_3\\[, k\\_4, k\\_5, k\\_6\\[, s\\_1, s\\_2, s\\_3, s\\_4\\[, \\tau\\_x, \\tau\\_y]]]])\\f$
  are the distortion coefficients.
  In case of a stereo camera, this function is called twice: once for each camera head, after
  #stereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera
  was not calibrated, it is still possible to compute the rectification transformations directly from
  the fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes
  homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
  space. R can be computed from H as
  \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f]
  where cameraMatrix can be chosen arbitrarily.

  Python prototype (for reference only):
  ```python3
  initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -> map1, map2
  ```
  """
  @spec initUndistortRectifyMap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def initUndistortRectifyMap(cameraMatrix, distCoeffs, r, newCameraMatrix, size, m1type, opts) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(newCameraMatrix, Evision.Mat) or is_struct(newCameraMatrix, Nx.Tensor) or is_number(newCameraMatrix) or is_tuple(newCameraMatrix)) and is_tuple(size) and is_integer(m1type) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      r: Evision.Internal.Structurise.from_struct(r),
      newCameraMatrix: Evision.Internal.Structurise.from_struct(newCameraMatrix),
      size: Evision.Internal.Structurise.from_struct(size),
      m1type: Evision.Internal.Structurise.from_struct(m1type)
    ]
    :evision_nif.initUndistortRectifyMap(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes the undistortion and rectification transformation map.

  ##### Positional Arguments
  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  - **r**: `Evision.Mat`.

    Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,
    computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation
    is assumed. In #initUndistortRectifyMap R assumed to be an identity matrix.

  - **newCameraMatrix**: `Evision.Mat`.

    New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.

  - **size**: `Size`.

    Undistorted image size.

  - **m1type**: `integer()`.

    Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps

  ##### Return
  - **map1**: `Evision.Mat.t()`.

    The first output map.

  - **map2**: `Evision.Mat.t()`.

    The second output map.

  The function computes the joint undistortion and rectification transformation and represents the
  result in the form of maps for #remap. The undistorted image looks like original, as if it is
  captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a
  monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by
  #getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,
  newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .
  Also, this new camera is oriented differently in the coordinate space, according to R. That, for
  example, helps to align two heads of a stereo camera so that the epipolar lines on both images
  become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).
  The function actually builds the maps for the inverse mapping algorithm that is used by #remap. That
  is, for each pixel \\f$(u, v)\\f$ in the destination (corrected and rectified) image, the function
  computes the corresponding coordinates in the source image (that is, in the original image from
  camera). The following process is applied:
  \\f[
  \\begin{array}{l}
  x  \\leftarrow (u - {c'}\\_x)/{f'}\\_x  \\\\\\\\
  y  \\leftarrow (v - {c'}\\_y)/{f'}\\_y  \\\\\\\\
  {\\[X\\,Y\\,W]} ^T  \\leftarrow R^{-1}\\*\\[x \\, y \\, 1]^T  \\\\\\\\
  x'  \\leftarrow X/W  \\\\\\\\
  y'  \\leftarrow Y/W  \\\\\\\\
  r^2  \\leftarrow x'^2 + y'^2 \\\\\\\\
  x''  \\leftarrow x' \\frac{1 + k\\_1 r^2 + k\\_2 r^4 + k\\_3 r^6}{1 + k\\_4 r^2 + k\\_5 r^4 + k\\_6 r^6}
  \\+ 2p\\_1 x' y' + p\\_2(r^2 + 2 x'^2)  + s\\_1 r^2 + s\\_2 r^4\\\\\\\\
  y''  \\leftarrow y' \\frac{1 + k\\_1 r^2 + k\\_2 r^4 + k\\_3 r^6}{1 + k\\_4 r^2 + k\\_5 r^4 + k\\_6 r^6}
  \\+ p\\_1 (r^2 + 2 y'^2) + 2 p\\_2 x' y' + s\\_3 r^2 + s\\_4 r^4 \\\\\\\\
  s\\vecthree{x'''}{y'''}{1} =
  \\vecthreethree{R\\_{33}(\\tau\\_x, \\tau\\_y)}{0}{-R\\_{13}((\\tau\\_x, \\tau\\_y)}
  {0}{R\\_{33}(\\tau\\_x, \\tau\\_y)}{-R\\_{23}(\\tau\\_x, \\tau\\_y)}
  {0}{0}{1} R(\\tau\\_x, \\tau\\_y) \\vecthree{x''}{y''}{1}\\\\\\\\
  map\\_x(u,v)  \\leftarrow x''' f\\_x + c\\_x  \\\\\\\\
  map\\_y(u,v)  \\leftarrow y''' f\\_y + c\\_y
  \\end{array}
  \\f]
  where \\f$(k\\_1, k\\_2, p\\_1, p\\_2\\[, k\\_3\\[, k\\_4, k\\_5, k\\_6\\[, s\\_1, s\\_2, s\\_3, s\\_4\\[, \\tau\\_x, \\tau\\_y]]]])\\f$
  are the distortion coefficients.
  In case of a stereo camera, this function is called twice: once for each camera head, after
  #stereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera
  was not calibrated, it is still possible to compute the rectification transformations directly from
  the fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes
  homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D
  space. R can be computed from H as
  \\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f]
  where cameraMatrix can be chosen arbitrarily.

  Python prototype (for reference only):
  ```python3
  initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -> map1, map2
  ```
  """
  @spec initUndistortRectifyMap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, integer()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def initUndistortRectifyMap(cameraMatrix, distCoeffs, r, newCameraMatrix, size, m1type) when (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(newCameraMatrix, Evision.Mat) or is_struct(newCameraMatrix, Nx.Tensor) or is_number(newCameraMatrix) or is_tuple(newCameraMatrix)) and is_tuple(size) and is_integer(m1type)
  do
    positional = [
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      r: Evision.Internal.Structurise.from_struct(r),
      newCameraMatrix: Evision.Internal.Structurise.from_struct(newCameraMatrix),
      size: Evision.Internal.Structurise.from_struct(size),
      m1type: Evision.Internal.Structurise.from_struct(m1type)
    ]
    :evision_nif.initUndistortRectifyMap(positional)
    |> to_struct()
  end

  @doc """
  Restores the selected region in an image using the region neighborhood.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image.

  - **inpaintMask**: `Evision.Mat`.

    Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that
    needs to be inpainted.

  - **inpaintRadius**: `double`.

    Radius of a circular neighborhood of each point inpainted that is considered
    by the algorithm.

  - **flags**: `integer()`.

    Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  The function reconstructs the selected image area from the pixel near the area boundary. The
  function may be used to remove dust and scratches from a scanned photo, or to remove undesirable
  objects from still images or video. See <http://en.wikipedia.org/wiki/Inpainting> for more details.
  **Note**: 
  - An example using the inpainting technique can be found at
    opencv_source_code/samples/cpp/inpaint.cpp

  - (Python) An example using the inpainting technique can be found at
    opencv_source_code/samples/python/inpaint.py

  Python prototype (for reference only):
  ```python3
  inpaint(src, inpaintMask, inpaintRadius, flags[, dst]) -> dst
  ```
  """
  @spec inpaint(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def inpaint(src, inpaintMask, inpaintRadius, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(inpaintMask, Evision.Mat) or is_struct(inpaintMask, Nx.Tensor) or is_number(inpaintMask) or is_tuple(inpaintMask)) and is_number(inpaintRadius) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      inpaintMask: Evision.Internal.Structurise.from_struct(inpaintMask),
      inpaintRadius: Evision.Internal.Structurise.from_struct(inpaintRadius),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.inpaint(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Restores the selected region in an image using the region neighborhood.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image.

  - **inpaintMask**: `Evision.Mat`.

    Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that
    needs to be inpainted.

  - **inpaintRadius**: `double`.

    Radius of a circular neighborhood of each point inpainted that is considered
    by the algorithm.

  - **flags**: `integer()`.

    Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src .

  The function reconstructs the selected image area from the pixel near the area boundary. The
  function may be used to remove dust and scratches from a scanned photo, or to remove undesirable
  objects from still images or video. See <http://en.wikipedia.org/wiki/Inpainting> for more details.
  **Note**: 
  - An example using the inpainting technique can be found at
    opencv_source_code/samples/cpp/inpaint.cpp

  - (Python) An example using the inpainting technique can be found at
    opencv_source_code/samples/python/inpaint.py

  Python prototype (for reference only):
  ```python3
  inpaint(src, inpaintMask, inpaintRadius, flags[, dst]) -> dst
  ```
  """
  @spec inpaint(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def inpaint(src, inpaintMask, inpaintRadius, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(inpaintMask, Evision.Mat) or is_struct(inpaintMask, Nx.Tensor) or is_number(inpaintMask) or is_tuple(inpaintMask)) and is_number(inpaintRadius) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      inpaintMask: Evision.Internal.Structurise.from_struct(inpaintMask),
      inpaintRadius: Evision.Internal.Structurise.from_struct(inpaintRadius),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.inpaint(positional)
    |> to_struct()
  end

  @doc """
  Inserts a single channel to dst (coi is 0-based index)

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array

  - **coi**: `integer()`.

    index of channel for insertion

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array

  @sa mixChannels, merge

  Python prototype (for reference only):
  ```python3
  insertChannel(src, dst, coi) -> dst
  ```
  """
  @spec insertChannel(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def insertChannel(src, dst, coi) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and is_integer(coi)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst),
      coi: Evision.Internal.Structurise.from_struct(coi)
    ]
    :evision_nif.insertChannel(positional)
    |> to_struct()
  end

  @doc """
  integral

  ##### Positional Arguments
  - **src**: `Evision.Mat`

  ##### Keyword Arguments
  - **sdepth**: `integer()`.

  ##### Return
  - **sum**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  integral(src[, sum[, sdepth]]) -> sum
  ```
  """
  @spec integral(Evision.Mat.maybe_mat_in(), [{:sdepth, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def integral(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:sdepth])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.integral(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  integral

  ##### Positional Arguments
  - **src**: `Evision.Mat`

  ##### Keyword Arguments
  - **sdepth**: `integer()`.

  ##### Return
  - **sum**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  integral(src[, sum[, sdepth]]) -> sum
  ```
  """
  @spec integral(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def integral(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.integral(positional)
    |> to_struct()
  end

  @doc """
  integral2

  ##### Positional Arguments
  - **src**: `Evision.Mat`

  ##### Keyword Arguments
  - **sdepth**: `integer()`.
  - **sqdepth**: `integer()`.

  ##### Return
  - **sum**: `Evision.Mat.t()`.
  - **sqsum**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  integral2(src[, sum[, sqsum[, sdepth[, sqdepth]]]]) -> sum, sqsum
  ```
  """
  @spec integral2(Evision.Mat.maybe_mat_in(), [{:sdepth, term()} | {:sqdepth, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def integral2(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:sdepth, :sqdepth])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.integral2(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  integral2

  ##### Positional Arguments
  - **src**: `Evision.Mat`

  ##### Keyword Arguments
  - **sdepth**: `integer()`.
  - **sqdepth**: `integer()`.

  ##### Return
  - **sum**: `Evision.Mat.t()`.
  - **sqsum**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  integral2(src[, sum[, sqsum[, sdepth[, sqdepth]]]]) -> sum, sqsum
  ```
  """
  @spec integral2(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def integral2(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.integral2(positional)
    |> to_struct()
  end

  @doc """
  Calculates the integral of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image as \\f$W \\times H\\f$, 8-bit or floating-point (32f or 64f).

  ##### Keyword Arguments
  - **sdepth**: `integer()`.

    desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or
    CV_64F.

  - **sqdepth**: `integer()`.

    desired depth of the integral image of squared pixel values, CV_32F or CV_64F.

  ##### Return
  - **sum**: `Evision.Mat.t()`.

    integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer or floating-point (32f or 64f).

  - **sqsum**: `Evision.Mat.t()`.

    integral image for squared pixel values; it is \\f$(W+1)\\times (H+1)\\f$, double-precision
    floating-point (64f) array.

  - **tilted**: `Evision.Mat.t()`.

    integral for the image rotated by 45 degrees; it is \\f$(W+1)\\times (H+1)\\f$ array with
    the same data type as sum.

  The function calculates one or more integral images for the source image as follows:
  \\f[\\texttt{sum} (X,Y) =  \\sum \\_{x<X,y<Y}  \\texttt{image} (x,y)\\f]
  \\f[\\texttt{sqsum} (X,Y) =  \\sum \\_{x<X,y<Y}  \\texttt{image} (x,y)^2\\f]
  \\f[\\texttt{tilted} (X,Y) =  \\sum \\_{y<Y,abs(x-X+1) \\leq Y-y-1}  \\texttt{image} (x,y)\\f]
  Using these integral images, you can calculate sum, mean, and standard deviation over a specific
  up-right or rotated rectangular region of the image in a constant time, for example:
  \\f[\\sum \\_{x\\_1 \\leq x < x\\_2,  \\, y\\_1  \\leq y < y\\_2}  \\texttt{image} (x,y) =  \\texttt{sum} (x\\_2,y\\_2)- \\texttt{sum} (x\\_1,y\\_2)- \\texttt{sum} (x\\_2,y\\_1)+ \\texttt{sum} (x\\_1,y\\_1)\\f]
  It makes possible to do a fast blurring or fast block correlation with a variable window size, for
  example. In case of multi-channel images, sums for each channel are accumulated independently.
  As a practical example, the next figure shows the calculation of the integral of a straight
  rectangle Rect(4,4,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
  original image are shown, as well as the relative pixels in the integral images sum and tilted .
  ![integral calculation example](pics/integral.png)

  Python prototype (for reference only):
  ```python3
  integral3(src[, sum[, sqsum[, tilted[, sdepth[, sqdepth]]]]]) -> sum, sqsum, tilted
  ```
  """
  @spec integral3(Evision.Mat.maybe_mat_in(), [{:sdepth, term()} | {:sqdepth, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def integral3(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:sdepth, :sqdepth])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.integral3(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the integral of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image as \\f$W \\times H\\f$, 8-bit or floating-point (32f or 64f).

  ##### Keyword Arguments
  - **sdepth**: `integer()`.

    desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or
    CV_64F.

  - **sqdepth**: `integer()`.

    desired depth of the integral image of squared pixel values, CV_32F or CV_64F.

  ##### Return
  - **sum**: `Evision.Mat.t()`.

    integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer or floating-point (32f or 64f).

  - **sqsum**: `Evision.Mat.t()`.

    integral image for squared pixel values; it is \\f$(W+1)\\times (H+1)\\f$, double-precision
    floating-point (64f) array.

  - **tilted**: `Evision.Mat.t()`.

    integral for the image rotated by 45 degrees; it is \\f$(W+1)\\times (H+1)\\f$ array with
    the same data type as sum.

  The function calculates one or more integral images for the source image as follows:
  \\f[\\texttt{sum} (X,Y) =  \\sum \\_{x<X,y<Y}  \\texttt{image} (x,y)\\f]
  \\f[\\texttt{sqsum} (X,Y) =  \\sum \\_{x<X,y<Y}  \\texttt{image} (x,y)^2\\f]
  \\f[\\texttt{tilted} (X,Y) =  \\sum \\_{y<Y,abs(x-X+1) \\leq Y-y-1}  \\texttt{image} (x,y)\\f]
  Using these integral images, you can calculate sum, mean, and standard deviation over a specific
  up-right or rotated rectangular region of the image in a constant time, for example:
  \\f[\\sum \\_{x\\_1 \\leq x < x\\_2,  \\, y\\_1  \\leq y < y\\_2}  \\texttt{image} (x,y) =  \\texttt{sum} (x\\_2,y\\_2)- \\texttt{sum} (x\\_1,y\\_2)- \\texttt{sum} (x\\_2,y\\_1)+ \\texttt{sum} (x\\_1,y\\_1)\\f]
  It makes possible to do a fast blurring or fast block correlation with a variable window size, for
  example. In case of multi-channel images, sums for each channel are accumulated independently.
  As a practical example, the next figure shows the calculation of the integral of a straight
  rectangle Rect(4,4,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
  original image are shown, as well as the relative pixels in the integral images sum and tilted .
  ![integral calculation example](pics/integral.png)

  Python prototype (for reference only):
  ```python3
  integral3(src[, sum[, sqsum[, tilted[, sdepth[, sqdepth]]]]]) -> sum, sqsum, tilted
  ```
  """
  @spec integral3(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def integral3(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.integral3(positional)
    |> to_struct()
  end

  @doc """
  Finds intersection of two convex polygons

  ##### Positional Arguments
  - **p1**: `Evision.Mat`.

    First polygon

  - **p2**: `Evision.Mat`.

    Second polygon

  ##### Keyword Arguments
  - **handleNested**: `bool`.

    When true, an intersection is found if one of the polygons is fully enclosed in the other.
    When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge
    of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.

  ##### Return
  - **retval**: `float`
  - **p12**: `Evision.Mat.t()`.

    Output polygon describing the intersecting area

  @returns Absolute value of area of intersecting polygon
  **Note**: intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't.

  Python prototype (for reference only):
  ```python3
  intersectConvexConvex(p1, p2[, p12[, handleNested]]) -> retval, p12
  ```
  """
  @spec intersectConvexConvex(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:handleNested, term()}] | nil) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def intersectConvexConvex(p1, p2, opts) when (is_struct(p1, Evision.Mat) or is_struct(p1, Nx.Tensor) or is_number(p1) or is_tuple(p1)) and (is_struct(p2, Evision.Mat) or is_struct(p2, Nx.Tensor) or is_number(p2) or is_tuple(p2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:handleNested])
    positional = [
      p1: Evision.Internal.Structurise.from_struct(p1),
      p2: Evision.Internal.Structurise.from_struct(p2)
    ]
    :evision_nif.intersectConvexConvex(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds intersection of two convex polygons

  ##### Positional Arguments
  - **p1**: `Evision.Mat`.

    First polygon

  - **p2**: `Evision.Mat`.

    Second polygon

  ##### Keyword Arguments
  - **handleNested**: `bool`.

    When true, an intersection is found if one of the polygons is fully enclosed in the other.
    When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge
    of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.

  ##### Return
  - **retval**: `float`
  - **p12**: `Evision.Mat.t()`.

    Output polygon describing the intersecting area

  @returns Absolute value of area of intersecting polygon
  **Note**: intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't.

  Python prototype (for reference only):
  ```python3
  intersectConvexConvex(p1, p2[, p12[, handleNested]]) -> retval, p12
  ```
  """
  @spec intersectConvexConvex(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def intersectConvexConvex(p1, p2) when (is_struct(p1, Evision.Mat) or is_struct(p1, Nx.Tensor) or is_number(p1) or is_tuple(p1)) and (is_struct(p2, Evision.Mat) or is_struct(p2, Nx.Tensor) or is_number(p2) or is_tuple(p2))
  do
    positional = [
      p1: Evision.Internal.Structurise.from_struct(p1),
      p2: Evision.Internal.Structurise.from_struct(p2)
    ]
    :evision_nif.intersectConvexConvex(positional)
    |> to_struct()
  end

  @doc """
  Finds the inverse or pseudo-inverse of a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point M x N matrix.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    inversion method (cv::DecompTypes)

  ##### Return
  - **retval**: `double`
  - **dst**: `Evision.Mat.t()`.

    output matrix of N x M size and the same type as src.

  The function cv::invert inverts the matrix src and stores the result in dst
  . When the matrix src is singular or non-square, the function calculates
  the pseudo-inverse matrix (the dst matrix) so that norm(src\\*dst - I) is
  minimal, where I is an identity matrix.
  In case of the #DECOMP_LU method, the function returns non-zero value if
  the inverse has been successfully calculated and 0 if src is singular.
  In case of the #DECOMP_SVD method, the function returns the inverse
  condition number of src (the ratio of the smallest singular value to the
  largest singular value) and 0 if src is singular. The SVD method
  calculates a pseudo-inverse matrix if src is singular.
  Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with
  non-singular square matrices that should also be symmetrical and
  positively defined. In this case, the function stores the inverted
  matrix in dst and returns non-zero. Otherwise, it returns 0.
  @sa solve, SVD

  Python prototype (for reference only):
  ```python3
  invert(src[, dst[, flags]]) -> retval, dst
  ```
  """
  @spec invert(Evision.Mat.maybe_mat_in(), [{:flags, term()}] | nil) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def invert(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.invert(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the inverse or pseudo-inverse of a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point M x N matrix.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    inversion method (cv::DecompTypes)

  ##### Return
  - **retval**: `double`
  - **dst**: `Evision.Mat.t()`.

    output matrix of N x M size and the same type as src.

  The function cv::invert inverts the matrix src and stores the result in dst
  . When the matrix src is singular or non-square, the function calculates
  the pseudo-inverse matrix (the dst matrix) so that norm(src\\*dst - I) is
  minimal, where I is an identity matrix.
  In case of the #DECOMP_LU method, the function returns non-zero value if
  the inverse has been successfully calculated and 0 if src is singular.
  In case of the #DECOMP_SVD method, the function returns the inverse
  condition number of src (the ratio of the smallest singular value to the
  largest singular value) and 0 if src is singular. The SVD method
  calculates a pseudo-inverse matrix if src is singular.
  Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with
  non-singular square matrices that should also be symmetrical and
  positively defined. In this case, the function stores the inverted
  matrix in dst and returns non-zero. Otherwise, it returns 0.
  @sa solve, SVD

  Python prototype (for reference only):
  ```python3
  invert(src[, dst[, flags]]) -> retval, dst
  ```
  """
  @spec invert(Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def invert(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.invert(positional)
    |> to_struct()
  end

  @doc """
  Inverts an affine transformation.

  ##### Positional Arguments
  - **m**: `Evision.Mat`.

    Original affine transformation.

  ##### Return
  - **iM**: `Evision.Mat.t()`.

    Output reverse affine transformation.

  The function computes an inverse affine transformation represented by \\f$2 \\times 3\\f$ matrix M:
  \\f[\\begin{bmatrix} a\\_{11} & a\\_{12} & b\\_1  \\\\\\\\ a\\_{21} & a\\_{22} & b\\_2 \\end{bmatrix}\\f]
  The result is also a \\f$2 \\times 3\\f$ matrix of the same type as M.

  Python prototype (for reference only):
  ```python3
  invertAffineTransform(M[, iM]) -> iM
  ```
  """
  @spec invertAffineTransform(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def invertAffineTransform(m, opts) when (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.invertAffineTransform(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Inverts an affine transformation.

  ##### Positional Arguments
  - **m**: `Evision.Mat`.

    Original affine transformation.

  ##### Return
  - **iM**: `Evision.Mat.t()`.

    Output reverse affine transformation.

  The function computes an inverse affine transformation represented by \\f$2 \\times 3\\f$ matrix M:
  \\f[\\begin{bmatrix} a\\_{11} & a\\_{12} & b\\_1  \\\\\\\\ a\\_{21} & a\\_{22} & b\\_2 \\end{bmatrix}\\f]
  The result is also a \\f$2 \\times 3\\f$ matrix of the same type as M.

  Python prototype (for reference only):
  ```python3
  invertAffineTransform(M[, iM]) -> iM
  ```
  """
  @spec invertAffineTransform(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def invertAffineTransform(m) when (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m))
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.invertAffineTransform(positional)
    |> to_struct()
  end

  @doc """
  Tests a contour convexity.

  ##### Positional Arguments
  - **contour**: `Evision.Mat`.

    Input vector of 2D points, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `bool`

  The function tests whether the input contour is convex or not. The contour must be simple, that is,
  without self-intersections. Otherwise, the function output is undefined.

  Python prototype (for reference only):
  ```python3
  isContourConvex(contour) -> retval
  ```
  """
  @spec isContourConvex(Evision.Mat.maybe_mat_in()) :: boolean() | {:error, String.t()}
  def isContourConvex(contour) when (is_struct(contour, Evision.Mat) or is_struct(contour, Nx.Tensor) or is_number(contour) or is_tuple(contour))
  do
    positional = [
      contour: Evision.Internal.Structurise.from_struct(contour)
    ]
    :evision_nif.isContourConvex(positional)
    |> to_struct()
  end

  @doc """
  Finds centers of clusters and groups input samples around the clusters.

  ##### Positional Arguments
  - **data**: `Evision.Mat`.

    Data for clustering. An array of N-Dimensional points with float coordinates is needed.
    Examples of this array can be:
    - Mat points(count, 2, CV_32F);
    - Mat points(count, 1, CV_32FC2);
    - Mat points(1, count, CV_32FC2);
    - std::vector\\<cv::Point2f\\> points(sampleCount);

  - **k**: `integer()`.

    Number of clusters to split the set by.

  - **criteria**: `TermCriteria`.

    The algorithm termination criteria, that is, the maximum number of iterations and/or
    the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster
    centers moves by less than criteria.epsilon on some iteration, the algorithm stops.

  - **attempts**: `integer()`.

    Flag to specify the number of times the algorithm is executed using different
    initial labellings. The algorithm returns the labels that yield the best compactness (see the last
    function parameter).

  - **flags**: `integer()`.

    Flag that can take values of cv::KmeansFlags

  ##### Return
  - **retval**: `double`
  - **bestLabels**: `Evision.Mat.t()`.

    Input/output integer array that stores the cluster indices for every sample.

  - **centers**: `Evision.Mat.t()`.

    Output matrix of the cluster centers, one row per each cluster center.

  The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters
  and groups the input samples around the clusters. As an output, \\f$\\texttt{bestLabels}\\_i\\f$ contains a
  0-based cluster index for the sample stored in the \\f$i^{th}\\f$ row of the samples matrix.
  **Note**: 
  - (Python) An example on K-means clustering can be found at
    opencv_source_code/samples/python/kmeans.py

  @return The function returns the compactness measure that is computed as
  \\f[\\sum \\_i  \\| \\texttt{samples} \\_i -  \\texttt{centers} \\_{ \\texttt{labels} \\_i} \\| ^2\\f]
  after every attempt. The best (minimum) value is chosen and the corresponding labels and the
  compactness value are returned by the function. Basically, you can use only the core of the
  function, set the number of attempts to 1, initialize labels each time using a custom algorithm,
  pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best
  (most-compact) clustering.

  Python prototype (for reference only):
  ```python3
  kmeans(data, K, bestLabels, criteria, attempts, flags[, centers]) -> retval, bestLabels, centers
  ```
  """
  @spec kmeans(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), {integer(), integer(), number()}, integer(), integer(), [{atom(), term()},...] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def kmeans(data, k, bestLabels, criteria, attempts, flags, opts) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and is_integer(k) and (is_struct(bestLabels, Evision.Mat) or is_struct(bestLabels, Nx.Tensor) or is_number(bestLabels) or is_tuple(bestLabels)) and is_tuple(criteria) and is_integer(attempts) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      k: Evision.Internal.Structurise.from_struct(k),
      bestLabels: Evision.Internal.Structurise.from_struct(bestLabels),
      criteria: Evision.Internal.Structurise.from_struct(criteria),
      attempts: Evision.Internal.Structurise.from_struct(attempts),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.kmeans(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds centers of clusters and groups input samples around the clusters.

  ##### Positional Arguments
  - **data**: `Evision.Mat`.

    Data for clustering. An array of N-Dimensional points with float coordinates is needed.
    Examples of this array can be:
    - Mat points(count, 2, CV_32F);
    - Mat points(count, 1, CV_32FC2);
    - Mat points(1, count, CV_32FC2);
    - std::vector\\<cv::Point2f\\> points(sampleCount);

  - **k**: `integer()`.

    Number of clusters to split the set by.

  - **criteria**: `TermCriteria`.

    The algorithm termination criteria, that is, the maximum number of iterations and/or
    the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster
    centers moves by less than criteria.epsilon on some iteration, the algorithm stops.

  - **attempts**: `integer()`.

    Flag to specify the number of times the algorithm is executed using different
    initial labellings. The algorithm returns the labels that yield the best compactness (see the last
    function parameter).

  - **flags**: `integer()`.

    Flag that can take values of cv::KmeansFlags

  ##### Return
  - **retval**: `double`
  - **bestLabels**: `Evision.Mat.t()`.

    Input/output integer array that stores the cluster indices for every sample.

  - **centers**: `Evision.Mat.t()`.

    Output matrix of the cluster centers, one row per each cluster center.

  The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters
  and groups the input samples around the clusters. As an output, \\f$\\texttt{bestLabels}\\_i\\f$ contains a
  0-based cluster index for the sample stored in the \\f$i^{th}\\f$ row of the samples matrix.
  **Note**: 
  - (Python) An example on K-means clustering can be found at
    opencv_source_code/samples/python/kmeans.py

  @return The function returns the compactness measure that is computed as
  \\f[\\sum \\_i  \\| \\texttt{samples} \\_i -  \\texttt{centers} \\_{ \\texttt{labels} \\_i} \\| ^2\\f]
  after every attempt. The best (minimum) value is chosen and the corresponding labels and the
  compactness value are returned by the function. Basically, you can use only the core of the
  function, set the number of attempts to 1, initialize labels each time using a custom algorithm,
  pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best
  (most-compact) clustering.

  Python prototype (for reference only):
  ```python3
  kmeans(data, K, bestLabels, criteria, attempts, flags[, centers]) -> retval, bestLabels, centers
  ```
  """
  @spec kmeans(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), {integer(), integer(), number()}, integer(), integer()) :: {number(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def kmeans(data, k, bestLabels, criteria, attempts, flags) when (is_struct(data, Evision.Mat) or is_struct(data, Nx.Tensor) or is_number(data) or is_tuple(data)) and is_integer(k) and (is_struct(bestLabels, Evision.Mat) or is_struct(bestLabels, Nx.Tensor) or is_number(bestLabels) or is_tuple(bestLabels)) and is_tuple(criteria) and is_integer(attempts) and is_integer(flags)
  do
    positional = [
      data: Evision.Internal.Structurise.from_struct(data),
      k: Evision.Internal.Structurise.from_struct(k),
      bestLabels: Evision.Internal.Structurise.from_struct(bestLabels),
      criteria: Evision.Internal.Structurise.from_struct(criteria),
      attempts: Evision.Internal.Structurise.from_struct(attempts),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.kmeans(positional)
    |> to_struct()
  end

  @doc """
  Draws a line segment connecting two points.

  ##### Positional Arguments
  - **pt1**: `Point`.

    First point of the line segment.

  - **pt2**: `Point`.

    Second point of the line segment.

  - **color**: `Evision.scalar()`.

    Line color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Line thickness.

  - **lineType**: `integer()`.

    Type of the line. See #LineTypes.

  - **shift**: `integer()`.

    Number of fractional bits in the point coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function line draws the line segment between pt1 and pt2 points in the image. The line is
  clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
  or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
  lines are drawn using Gaussian filtering.

  Python prototype (for reference only):
  ```python3
  line(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec line(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, Evision.scalar(), [{:lineType, term()} | {:shift, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def line(img, pt1, pt2, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(pt1) and is_tuple(pt2) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.line(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws a line segment connecting two points.

  ##### Positional Arguments
  - **pt1**: `Point`.

    First point of the line segment.

  - **pt2**: `Point`.

    Second point of the line segment.

  - **color**: `Evision.scalar()`.

    Line color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Line thickness.

  - **lineType**: `integer()`.

    Type of the line. See #LineTypes.

  - **shift**: `integer()`.

    Number of fractional bits in the point coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function line draws the line segment between pt1 and pt2 points in the image. The line is
  clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
  or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
  lines are drawn using Gaussian filtering.

  Python prototype (for reference only):
  ```python3
  line(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec line(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def line(img, pt1, pt2, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(pt1) and is_tuple(pt2) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.line(positional)
    |> to_struct()
  end

  @doc """
  Remaps an image to polar coordinates space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image

  - **center**: `Point2f`.

    The transformation center;

  - **maxRadius**: `double`.

    The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.

  - **flags**: `integer()`.

    A combination of interpolation methods, see #InterpolationFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It will have same size and type as src.

  @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags)
  @internal
  Transform the source image using the following transformation (See @ref polar_remaps_reference_image "Polar remaps reference image c)"):
  \\f[\\begin{array}{l}
  dst( \\rho , \\phi ) = src(x,y) \\\\\\\\
  dst.size() \\leftarrow src.size()
  \\end{array}\\f]
  where
  \\f[\\begin{array}{l}
  I = (dx,dy) = (x - center.x,y - center.y) \\\\\\\\
  \\rho = Kmag \\cdot \\texttt{magnitude} (I) ,\\\\\\\\
  \\phi = angle \\cdot \\texttt{angle} (I)
  \\end{array}\\f]
  and
  \\f[\\begin{array}{l}
  Kx = src.cols / maxRadius \\\\\\\\
  Ky = src.rows / 2\\Pi
  \\end{array}\\f]

  **Note**: 
  - The function can not operate in-place.
  - To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.

  @sa cv::logPolar
  @endinternal

  Python prototype (for reference only):
  ```python3
  linearPolar(src, center, maxRadius, flags[, dst]) -> dst
  ```
  """
  @spec linearPolar(Evision.Mat.maybe_mat_in(), {number(), number()}, number(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def linearPolar(src, center, maxRadius, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(center) and is_number(maxRadius) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      center: Evision.Internal.Structurise.from_struct(center),
      maxRadius: Evision.Internal.Structurise.from_struct(maxRadius),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.linearPolar(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Remaps an image to polar coordinates space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image

  - **center**: `Point2f`.

    The transformation center;

  - **maxRadius**: `double`.

    The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.

  - **flags**: `integer()`.

    A combination of interpolation methods, see #InterpolationFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It will have same size and type as src.

  @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags)
  @internal
  Transform the source image using the following transformation (See @ref polar_remaps_reference_image "Polar remaps reference image c)"):
  \\f[\\begin{array}{l}
  dst( \\rho , \\phi ) = src(x,y) \\\\\\\\
  dst.size() \\leftarrow src.size()
  \\end{array}\\f]
  where
  \\f[\\begin{array}{l}
  I = (dx,dy) = (x - center.x,y - center.y) \\\\\\\\
  \\rho = Kmag \\cdot \\texttt{magnitude} (I) ,\\\\\\\\
  \\phi = angle \\cdot \\texttt{angle} (I)
  \\end{array}\\f]
  and
  \\f[\\begin{array}{l}
  Kx = src.cols / maxRadius \\\\\\\\
  Ky = src.rows / 2\\Pi
  \\end{array}\\f]

  **Note**: 
  - The function can not operate in-place.
  - To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.

  @sa cv::logPolar
  @endinternal

  Python prototype (for reference only):
  ```python3
  linearPolar(src, center, maxRadius, flags[, dst]) -> dst
  ```
  """
  @spec linearPolar(Evision.Mat.maybe_mat_in(), {number(), number()}, number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def linearPolar(src, center, maxRadius, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(center) and is_number(maxRadius) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      center: Evision.Internal.Structurise.from_struct(center),
      maxRadius: Evision.Internal.Structurise.from_struct(maxRadius),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.linearPolar(positional)
    |> to_struct()
  end

  @doc """
  Calculates the natural logarithm of every array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src .

  The function cv::log calculates the natural logarithm of every element of the input array:
  \\f[\\texttt{dst} (I) =  \\log (\\texttt{src}(I)) \\f]
  Output on zero, negative and special (NaN, Inf) values is undefined.
  @sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude

  Python prototype (for reference only):
  ```python3
  log(src[, dst]) -> dst
  ```
  """
  @spec log(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def log(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.log(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the natural logarithm of every array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src .

  The function cv::log calculates the natural logarithm of every element of the input array:
  \\f[\\texttt{dst} (I) =  \\log (\\texttt{src}(I)) \\f]
  Output on zero, negative and special (NaN, Inf) values is undefined.
  @sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude

  Python prototype (for reference only):
  ```python3
  log(src[, dst]) -> dst
  ```
  """
  @spec log(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def log(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.log(positional)
    |> to_struct()
  end

  @doc """
  Remaps an image to semilog-polar coordinates space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image

  - **center**: `Point2f`.

    The transformation center; where the output precision is maximal

  - **m**: `double`.

    Magnitude scale parameter. It determines the radius of the bounding circle to transform too.

  - **flags**: `integer()`.

    A combination of interpolation methods, see #InterpolationFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It will have same size and type as src.

  @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);
  @internal
  Transform the source image using the following transformation (See @ref polar_remaps_reference_image "Polar remaps reference image d)"):
  \\f[\\begin{array}{l}
  dst( \\rho , \\phi ) = src(x,y) \\\\\\\\
  dst.size() \\leftarrow src.size()
  \\end{array}\\f]
  where
  \\f[\\begin{array}{l}
  I = (dx,dy) = (x - center.x,y - center.y) \\\\\\\\
  \\rho = M \\cdot log\\_e(\\texttt{magnitude} (I)) ,\\\\\\\\
  \\phi = Kangle \\cdot \\texttt{angle} (I) \\\\\\\\
  \\end{array}\\f]
  and
  \\f[\\begin{array}{l}
  M = src.cols / log\\_e(maxRadius) \\\\\\\\
  Kangle = src.rows / 2\\Pi \\\\\\\\
  \\end{array}\\f]
  The function emulates the human "foveal" vision and can be used for fast scale and
  rotation-invariant template matching, for object tracking and so forth.

  **Note**: 
  - The function can not operate in-place.
  - To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.

  @sa cv::linearPolar
  @endinternal

  Python prototype (for reference only):
  ```python3
  logPolar(src, center, M, flags[, dst]) -> dst
  ```
  """
  @spec logPolar(Evision.Mat.maybe_mat_in(), {number(), number()}, number(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def logPolar(src, center, m, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(center) and is_number(m) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      center: Evision.Internal.Structurise.from_struct(center),
      m: Evision.Internal.Structurise.from_struct(m),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.logPolar(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Remaps an image to semilog-polar coordinates space.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image

  - **center**: `Point2f`.

    The transformation center; where the output precision is maximal

  - **m**: `double`.

    Magnitude scale parameter. It determines the radius of the bounding circle to transform too.

  - **flags**: `integer()`.

    A combination of interpolation methods, see #InterpolationFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It will have same size and type as src.

  @deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);
  @internal
  Transform the source image using the following transformation (See @ref polar_remaps_reference_image "Polar remaps reference image d)"):
  \\f[\\begin{array}{l}
  dst( \\rho , \\phi ) = src(x,y) \\\\\\\\
  dst.size() \\leftarrow src.size()
  \\end{array}\\f]
  where
  \\f[\\begin{array}{l}
  I = (dx,dy) = (x - center.x,y - center.y) \\\\\\\\
  \\rho = M \\cdot log\\_e(\\texttt{magnitude} (I)) ,\\\\\\\\
  \\phi = Kangle \\cdot \\texttt{angle} (I) \\\\\\\\
  \\end{array}\\f]
  and
  \\f[\\begin{array}{l}
  M = src.cols / log\\_e(maxRadius) \\\\\\\\
  Kangle = src.rows / 2\\Pi \\\\\\\\
  \\end{array}\\f]
  The function emulates the human "foveal" vision and can be used for fast scale and
  rotation-invariant template matching, for object tracking and so forth.

  **Note**: 
  - The function can not operate in-place.
  - To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.

  @sa cv::linearPolar
  @endinternal

  Python prototype (for reference only):
  ```python3
  logPolar(src, center, M, flags[, dst]) -> dst
  ```
  """
  @spec logPolar(Evision.Mat.maybe_mat_in(), {number(), number()}, number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def logPolar(src, center, m, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(center) and is_number(m) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      center: Evision.Internal.Structurise.from_struct(center),
      m: Evision.Internal.Structurise.from_struct(m),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.logPolar(positional)
    |> to_struct()
  end

  @doc """
  Calculates the magnitude of 2D vectors.

  ##### Positional Arguments
  - **x**: `Evision.Mat`.

    floating-point array of x-coordinates of the vectors.

  - **y**: `Evision.Mat`.

    floating-point array of y-coordinates of the vectors; it must
    have the same size as x.

  ##### Return
  - **magnitude**: `Evision.Mat.t()`.

    output array of the same size and type as x.

  The function cv::magnitude calculates the magnitude of 2D vectors formed
  from the corresponding elements of x and y arrays:
  \\f[\\texttt{dst} (I) =  \\sqrt{\\texttt{x}(I)^2 + \\texttt{y}(I)^2}\\f]
  @sa cartToPolar, polarToCart, phase, sqrt

  Python prototype (for reference only):
  ```python3
  magnitude(x, y[, magnitude]) -> magnitude
  ```
  """
  @spec magnitude(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def magnitude(x, y, opts) when (is_struct(x, Evision.Mat) or is_struct(x, Nx.Tensor) or is_number(x) or is_tuple(x)) and (is_struct(y, Evision.Mat) or is_struct(y, Nx.Tensor) or is_number(y) or is_tuple(y)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.magnitude(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the magnitude of 2D vectors.

  ##### Positional Arguments
  - **x**: `Evision.Mat`.

    floating-point array of x-coordinates of the vectors.

  - **y**: `Evision.Mat`.

    floating-point array of y-coordinates of the vectors; it must
    have the same size as x.

  ##### Return
  - **magnitude**: `Evision.Mat.t()`.

    output array of the same size and type as x.

  The function cv::magnitude calculates the magnitude of 2D vectors formed
  from the corresponding elements of x and y arrays:
  \\f[\\texttt{dst} (I) =  \\sqrt{\\texttt{x}(I)^2 + \\texttt{y}(I)^2}\\f]
  @sa cartToPolar, polarToCart, phase, sqrt

  Python prototype (for reference only):
  ```python3
  magnitude(x, y[, magnitude]) -> magnitude
  ```
  """
  @spec magnitude(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def magnitude(x, y) when (is_struct(x, Evision.Mat) or is_struct(x, Nx.Tensor) or is_number(x) or is_tuple(x)) and (is_struct(y, Evision.Mat) or is_struct(y, Nx.Tensor) or is_number(y) or is_tuple(y))
  do
    positional = [
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.magnitude(positional)
    |> to_struct()
  end

  @doc """
  Computes partial derivatives of the matrix product for each multiplied matrix.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    First multiplied matrix.

  - **b**: `Evision.Mat`.

    Second multiplied matrix.

  ##### Return
  - **dABdA**: `Evision.Mat.t()`.

    First output derivative matrix d(A\\*B)/dA of size
    \\f$\\texttt{A.rows*B.cols} \\times {A.rows*A.cols}\\f$ .

  - **dABdB**: `Evision.Mat.t()`.

    Second output derivative matrix d(A\\*B)/dB of size
    \\f$\\texttt{A.rows*B.cols} \\times {B.rows*B.cols}\\f$ .

  The function computes partial derivatives of the elements of the matrix product \\f$A\\*B\\f$ with regard to
  the elements of each of the two input matrices. The function is used to compute the Jacobian
  matrices in #stereoCalibrate but can also be used in any other similar optimization function.

  Python prototype (for reference only):
  ```python3
  matMulDeriv(A, B[, dABdA[, dABdB]]) -> dABdA, dABdB
  ```
  """
  @spec matMulDeriv(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def matMulDeriv(a, b, opts) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (is_struct(b, Evision.Mat) or is_struct(b, Nx.Tensor) or is_number(b) or is_tuple(b)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b)
    ]
    :evision_nif.matMulDeriv(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes partial derivatives of the matrix product for each multiplied matrix.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    First multiplied matrix.

  - **b**: `Evision.Mat`.

    Second multiplied matrix.

  ##### Return
  - **dABdA**: `Evision.Mat.t()`.

    First output derivative matrix d(A\\*B)/dA of size
    \\f$\\texttt{A.rows*B.cols} \\times {A.rows*A.cols}\\f$ .

  - **dABdB**: `Evision.Mat.t()`.

    Second output derivative matrix d(A\\*B)/dB of size
    \\f$\\texttt{A.rows*B.cols} \\times {B.rows*B.cols}\\f$ .

  The function computes partial derivatives of the elements of the matrix product \\f$A\\*B\\f$ with regard to
  the elements of each of the two input matrices. The function is used to compute the Jacobian
  matrices in #stereoCalibrate but can also be used in any other similar optimization function.

  Python prototype (for reference only):
  ```python3
  matMulDeriv(A, B[, dABdA[, dABdB]]) -> dABdA, dABdB
  ```
  """
  @spec matMulDeriv(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def matMulDeriv(a, b) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (is_struct(b, Evision.Mat) or is_struct(b, Nx.Tensor) or is_number(b) or is_tuple(b))
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b)
    ]
    :evision_nif.matMulDeriv(positional)
    |> to_struct()
  end

  @doc """
  Compares two shapes.

  ##### Positional Arguments
  - **contour1**: `Evision.Mat`.

    First contour or grayscale image.

  - **contour2**: `Evision.Mat`.

    Second contour or grayscale image.

  - **method**: `integer()`.

    Comparison method, see #ShapeMatchModes

  - **parameter**: `double`.

    Method-specific parameter (not supported now).

  ##### Return
  - **retval**: `double`

  The function compares two shapes. All three implemented methods use the Hu invariants (see #HuMoments)

  Python prototype (for reference only):
  ```python3
  matchShapes(contour1, contour2, method, parameter) -> retval
  ```
  """
  @spec matchShapes(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), number()) :: number() | {:error, String.t()}
  def matchShapes(contour1, contour2, method, parameter) when (is_struct(contour1, Evision.Mat) or is_struct(contour1, Nx.Tensor) or is_number(contour1) or is_tuple(contour1)) and (is_struct(contour2, Evision.Mat) or is_struct(contour2, Nx.Tensor) or is_number(contour2) or is_tuple(contour2)) and is_integer(method) and is_number(parameter)
  do
    positional = [
      contour1: Evision.Internal.Structurise.from_struct(contour1),
      contour2: Evision.Internal.Structurise.from_struct(contour2),
      method: Evision.Internal.Structurise.from_struct(method),
      parameter: Evision.Internal.Structurise.from_struct(parameter)
    ]
    :evision_nif.matchShapes(positional)
    |> to_struct()
  end

  @doc """
  Compares a template against overlapped image regions.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Image where the search is running. It must be 8-bit or 32-bit floating-point.

  - **templ**: `Evision.Mat`.

    Searched template. It must be not greater than the source image and have the same
    data type.

  - **method**: `integer()`.

    Parameter specifying the comparison method, see #TemplateMatchModes

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional mask. It must have the same size as templ. It must either have the same number
    of channels as template or only one channel, which is then used for all template and
    image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask,
    meaning only elements where mask is nonzero are used and are kept unchanged independent
    of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are
    used as weights. The exact formulas are documented in #TemplateMatchModes.

  ##### Return
  - **result**: `Evision.Mat.t()`.

    Map of comparison results. It must be single-channel 32-bit floating-point. If image
    is \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is \\f$(W-w+1) \\times (H-h+1)\\f$ .

  The function slides through image , compares the overlapped patches of size \\f$w \\times h\\f$ against
  templ using the specified method and stores the comparison results in result . #TemplateMatchModes
  describes the formulae for the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$
  template, \\f$R\\f$ result, \\f$M\\f$ the optional mask ). The summation is done over template and/or
  the image patch: \\f$x' = 0...w-1, y' = 0...h-1\\f$
  After the function finishes the comparison, the best matches can be found as global minimums (when
  #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the
  #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
  the denominator is done over all of the channels and separate mean values are used for each channel.
  That is, the function can take a color template and a color image. The result will still be a
  single-channel image, which is easier to analyze.

  Python prototype (for reference only):
  ```python3
  matchTemplate(image, templ, method[, result[, mask]]) -> result
  ```
  """
  @spec matchTemplate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def matchTemplate(image, templ, method, opts) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(templ, Evision.Mat) or is_struct(templ, Nx.Tensor) or is_number(templ) or is_tuple(templ)) and is_integer(method) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      templ: Evision.Internal.Structurise.from_struct(templ),
      method: Evision.Internal.Structurise.from_struct(method)
    ]
    :evision_nif.matchTemplate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Compares a template against overlapped image regions.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Image where the search is running. It must be 8-bit or 32-bit floating-point.

  - **templ**: `Evision.Mat`.

    Searched template. It must be not greater than the source image and have the same
    data type.

  - **method**: `integer()`.

    Parameter specifying the comparison method, see #TemplateMatchModes

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    Optional mask. It must have the same size as templ. It must either have the same number
    of channels as template or only one channel, which is then used for all template and
    image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask,
    meaning only elements where mask is nonzero are used and are kept unchanged independent
    of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are
    used as weights. The exact formulas are documented in #TemplateMatchModes.

  ##### Return
  - **result**: `Evision.Mat.t()`.

    Map of comparison results. It must be single-channel 32-bit floating-point. If image
    is \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is \\f$(W-w+1) \\times (H-h+1)\\f$ .

  The function slides through image , compares the overlapped patches of size \\f$w \\times h\\f$ against
  templ using the specified method and stores the comparison results in result . #TemplateMatchModes
  describes the formulae for the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$
  template, \\f$R\\f$ result, \\f$M\\f$ the optional mask ). The summation is done over template and/or
  the image patch: \\f$x' = 0...w-1, y' = 0...h-1\\f$
  After the function finishes the comparison, the best matches can be found as global minimums (when
  #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the
  #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
  the denominator is done over all of the channels and separate mean values are used for each channel.
  That is, the function can take a color template and a color image. The result will still be a
  single-channel image, which is easier to analyze.

  Python prototype (for reference only):
  ```python3
  matchTemplate(image, templ, method[, result[, mask]]) -> result
  ```
  """
  @spec matchTemplate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def matchTemplate(image, templ, method) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(templ, Evision.Mat) or is_struct(templ, Nx.Tensor) or is_number(templ) or is_tuple(templ)) and is_integer(method)
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      templ: Evision.Internal.Structurise.from_struct(templ),
      method: Evision.Internal.Structurise.from_struct(method)
    ]
    :evision_nif.matchTemplate(positional)
    |> to_struct()
  end

  @doc """
  Calculates per-element maximum of two arrays or an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1 .

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function cv::max calculates the per-element maximum of two arrays:
  \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]
  or array and a scalar:
  \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{value} )\\f]
  @sa  min, compare, inRange, minMaxLoc, @ref MatrixExpressions

  Python prototype (for reference only):
  ```python3
  max(src1, src2[, dst]) -> dst
  ```
  """
  @spec max(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def max(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.max(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates per-element maximum of two arrays or an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1 .

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function cv::max calculates the per-element maximum of two arrays:
  \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]
  or array and a scalar:
  \\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{value} )\\f]
  @sa  min, compare, inRange, minMaxLoc, @ref MatrixExpressions

  Python prototype (for reference only):
  ```python3
  max(src1, src2[, dst]) -> dst
  ```
  """
  @spec max(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def max(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.max(positional)
    |> to_struct()
  end

  @doc """
  Calculates an average (mean) of array elements.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that should have from 1 to 4 channels so that the result can be stored in
    Scalar_ .

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask.

  ##### Return
  - **retval**: `Evision.scalar().t()`

  The function cv::mean calculates the mean value M of array elements,
  independently for each channel, and return it:
  \\f[\\begin{array}{l} N =  \\sum \\_{I: \\; \\texttt{mask} (I) \\ne 0} 1 \\\\\\\\ M\\_c =  \\left ( \\sum \\_{I: \\; \\texttt{mask} (I) \\ne 0}{ \\texttt{mtx} (I)\\_c} \\right )/N \\end{array}\\f]
  When all the mask elements are 0's, the function returns Scalar::all(0)
  @sa  countNonZero, meanStdDev, norm, minMaxLoc

  Python prototype (for reference only):
  ```python3
  mean(src[, mask]) -> retval
  ```
  """
  @spec mean(Evision.Mat.maybe_mat_in(), [{:mask, term()}] | nil) :: Evision.scalar() | {:error, String.t()}
  def mean(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.mean(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates an average (mean) of array elements.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that should have from 1 to 4 channels so that the result can be stored in
    Scalar_ .

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask.

  ##### Return
  - **retval**: `Evision.scalar().t()`

  The function cv::mean calculates the mean value M of array elements,
  independently for each channel, and return it:
  \\f[\\begin{array}{l} N =  \\sum \\_{I: \\; \\texttt{mask} (I) \\ne 0} 1 \\\\\\\\ M\\_c =  \\left ( \\sum \\_{I: \\; \\texttt{mask} (I) \\ne 0}{ \\texttt{mtx} (I)\\_c} \\right )/N \\end{array}\\f]
  When all the mask elements are 0's, the function returns Scalar::all(0)
  @sa  countNonZero, meanStdDev, norm, minMaxLoc

  Python prototype (for reference only):
  ```python3
  mean(src[, mask]) -> retval
  ```
  """
  @spec mean(Evision.Mat.maybe_mat_in()) :: Evision.scalar() | {:error, String.t()}
  def mean(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.mean(positional)
    |> to_struct()
  end

  @doc """
  Finds an object on a back projection image.

  ##### Positional Arguments
  - **probImage**: `Evision.Mat`.

    Back projection of the object histogram. See calcBackProject for details.

  - **criteria**: `TermCriteria`.

    Stop criteria for the iterative search algorithm.
    returns
    :   Number of iterations CAMSHIFT took to converge.
    The function implements the iterative object search algorithm. It takes the input back projection of
    an object and the initial position. The mass center in window of the back projection image is
    computed and the search window center shifts to the mass center. The procedure is repeated until the
    specified number of iterations criteria.maxCount is done or until the window center shifts by less
    than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search
    window size or orientation do not change during the search. You can simply pass the output of
    calcBackProject to this function. But better results can be obtained if you pre-filter the back
    projection and remove the noise. For example, you can do this by retrieving connected components
    with findContours , throwing away contours with small area ( contourArea ), and rendering the
    remaining contours with drawContours.

  ##### Return
  - **retval**: `integer()`
  - **window**: `Rect`.

    Initial search window.

  Python prototype (for reference only):
  ```python3
  meanShift(probImage, window, criteria) -> retval, window
  ```
  """
  @spec meanShift(Evision.Mat.maybe_mat_in(), {number(), number(), number(), number()}, {integer(), integer(), number()}) :: {integer(), {number(), number(), number(), number()}} | {:error, String.t()}
  def meanShift(probImage, window, criteria) when (is_struct(probImage, Evision.Mat) or is_struct(probImage, Nx.Tensor) or is_number(probImage) or is_tuple(probImage)) and is_tuple(window) and is_tuple(criteria)
  do
    positional = [
      probImage: Evision.Internal.Structurise.from_struct(probImage),
      window: Evision.Internal.Structurise.from_struct(window),
      criteria: Evision.Internal.Structurise.from_struct(criteria)
    ]
    :evision_nif.meanShift(positional)
    |> to_struct()
  end

  @doc """
  meanStdDev

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that should have from 1 to 4 channels so that the results can be stored in
    Scalar_ 's.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask.

  ##### Return
  - **mean**: `Evision.Mat.t()`.

    output parameter: calculated mean value.

  - **stddev**: `Evision.Mat.t()`.

    output parameter: calculated standard deviation.

  Calculates a mean and standard deviation of array elements.
  The function cv::meanStdDev calculates the mean and the standard deviation M
  of array elements independently for each channel and returns it via the
  output parameters:
  \\f[\\begin{array}{l} N =  \\sum \\_{I, \\texttt{mask} (I)  \\ne 0} 1 \\\\\\\\ \\texttt{mean} \\_c =  \\frac{\\sum\\_{ I: \\; \\texttt{mask}(I) \\ne 0} \\texttt{src} (I)\\_c}{N} \\\\\\\\ \\texttt{stddev} \\_c =  \\sqrt{\\frac{\\sum\\_{ I: \\; \\texttt{mask}(I) \\ne 0} \\left ( \\texttt{src} (I)\\_c -  \\texttt{mean} \\_c \\right )^2}{N}} \\end{array}\\f]
  When all the mask elements are 0's, the function returns
  mean=stddev=Scalar::all(0).
  **Note**: The calculated standard deviation is only the diagonal of the
  complete normalized covariance matrix. If the full matrix is needed, you
  can reshape the multi-channel array M x N to the single-channel array
  M\\*N x mtx.channels() (only possible when the matrix is continuous) and
  then pass the matrix to calcCovarMatrix .
  @sa  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix

  Python prototype (for reference only):
  ```python3
  meanStdDev(src[, mean[, stddev[, mask]]]) -> mean, stddev
  ```
  """
  @spec meanStdDev(Evision.Mat.maybe_mat_in(), [{:mask, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def meanStdDev(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.meanStdDev(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  meanStdDev

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that should have from 1 to 4 channels so that the results can be stored in
    Scalar_ 's.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask.

  ##### Return
  - **mean**: `Evision.Mat.t()`.

    output parameter: calculated mean value.

  - **stddev**: `Evision.Mat.t()`.

    output parameter: calculated standard deviation.

  Calculates a mean and standard deviation of array elements.
  The function cv::meanStdDev calculates the mean and the standard deviation M
  of array elements independently for each channel and returns it via the
  output parameters:
  \\f[\\begin{array}{l} N =  \\sum \\_{I, \\texttt{mask} (I)  \\ne 0} 1 \\\\\\\\ \\texttt{mean} \\_c =  \\frac{\\sum\\_{ I: \\; \\texttt{mask}(I) \\ne 0} \\texttt{src} (I)\\_c}{N} \\\\\\\\ \\texttt{stddev} \\_c =  \\sqrt{\\frac{\\sum\\_{ I: \\; \\texttt{mask}(I) \\ne 0} \\left ( \\texttt{src} (I)\\_c -  \\texttt{mean} \\_c \\right )^2}{N}} \\end{array}\\f]
  When all the mask elements are 0's, the function returns
  mean=stddev=Scalar::all(0).
  **Note**: The calculated standard deviation is only the diagonal of the
  complete normalized covariance matrix. If the full matrix is needed, you
  can reshape the multi-channel array M x N to the single-channel array
  M\\*N x mtx.channels() (only possible when the matrix is continuous) and
  then pass the matrix to calcCovarMatrix .
  @sa  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix

  Python prototype (for reference only):
  ```python3
  meanStdDev(src[, mean[, stddev[, mask]]]) -> mean, stddev
  ```
  """
  @spec meanStdDev(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def meanStdDev(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.meanStdDev(positional)
    |> to_struct()
  end

  @doc """
  Blurs an image using the median filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be
    CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.

  - **ksize**: `integer()`.

    aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    destination array of the same size and type as src.

  The function smoothes an image using the median filter with the \\f$\\texttt{ksize} \\times
  \\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is processed independently.
  In-place operation is supported.
  **Note**: The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes
  @sa  bilateralFilter, blur, boxFilter, GaussianBlur

  Python prototype (for reference only):
  ```python3
  medianBlur(src, ksize[, dst]) -> dst
  ```
  """
  @spec medianBlur(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def medianBlur(src, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.medianBlur(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Blurs an image using the median filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be
    CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.

  - **ksize**: `integer()`.

    aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    destination array of the same size and type as src.

  The function smoothes an image using the median filter with the \\f$\\texttt{ksize} \\times
  \\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is processed independently.
  In-place operation is supported.
  **Note**: The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes
  @sa  bilateralFilter, blur, boxFilter, GaussianBlur

  Python prototype (for reference only):
  ```python3
  medianBlur(src, ksize[, dst]) -> dst
  ```
  """
  @spec medianBlur(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def medianBlur(src, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.medianBlur(positional)
    |> to_struct()
  end

  @doc """
  merge

  ##### Positional Arguments
  - **mv**: `[Evision.Mat]`.

    input vector of matrices to be merged; all the matrices in mv must have the same
    size and the same depth.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and the same depth as mv[0]; The number of channels will
    be the total number of channels in the matrix array.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  merge(mv[, dst]) -> dst
  ```
  """
  @spec merge(list(Evision.Mat.maybe_mat_in()), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def merge(mv, opts) when is_list(mv) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      mv: Evision.Internal.Structurise.from_struct(mv)
    ]
    :evision_nif.merge(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  merge

  ##### Positional Arguments
  - **mv**: `[Evision.Mat]`.

    input vector of matrices to be merged; all the matrices in mv must have the same
    size and the same depth.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and the same depth as mv[0]; The number of channels will
    be the total number of channels in the matrix array.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  merge(mv[, dst]) -> dst
  ```
  """
  @spec merge(list(Evision.Mat.maybe_mat_in())) :: Evision.Mat.t() | {:error, String.t()}
  def merge(mv) when is_list(mv)
  do
    positional = [
      mv: Evision.Internal.Structurise.from_struct(mv)
    ]
    :evision_nif.merge(positional)
    |> to_struct()
  end

  @doc """
  Calculates per-element minimum of two arrays or an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function cv::min calculates the per-element minimum of two arrays:
  \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]
  or array and a scalar:
  \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{value} )\\f]
  @sa max, compare, inRange, minMaxLoc

  Python prototype (for reference only):
  ```python3
  min(src1, src2[, dst]) -> dst
  ```
  """
  @spec min(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def min(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.min(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates per-element minimum of two arrays or an array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function cv::min calculates the per-element minimum of two arrays:
  \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]
  or array and a scalar:
  \\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{value} )\\f]
  @sa max, compare, inRange, minMaxLoc

  Python prototype (for reference only):
  ```python3
  min(src1, src2[, dst]) -> dst
  ```
  """
  @spec min(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def min(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.min(positional)
    |> to_struct()
  end

  @doc """
  Finds a rotated rectangle of the minimum area enclosing the input 2D point set.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input vector of 2D points, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `{centre={x, y}, size={s1, s2}, angle}`

  The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a
  specified point set. Developer should keep in mind that the returned RotatedRect can contain negative
  indices when data is close to the containing Mat element boundary.

  Python prototype (for reference only):
  ```python3
  minAreaRect(points) -> retval
  ```
  """
  @spec minAreaRect(Evision.Mat.maybe_mat_in()) :: {{number(), number()}, {number(), number()}, number()} | {:error, String.t()}
  def minAreaRect(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.minAreaRect(positional)
    |> to_struct()
  end

  @doc """
  Finds a circle of the minimum area enclosing a 2D point set.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input vector of 2D points, stored in std::vector\\<\\> or Mat

  ##### Return
  - **center**: `Point2f`.

    Output center of the circle.

  - **radius**: `float`.

    Output radius of the circle.

  The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.

  Python prototype (for reference only):
  ```python3
  minEnclosingCircle(points) -> center, radius
  ```
  """
  @spec minEnclosingCircle(Evision.Mat.maybe_mat_in()) :: {{number(), number()}, number()} | {:error, String.t()}
  def minEnclosingCircle(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.minEnclosingCircle(positional)
    |> to_struct()
  end

  @doc """
  Finds a triangle of minimum area enclosing a 2D point set and returns its area.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `double`
  - **triangle**: `Evision.Mat.t()`.

    Output vector of three 2D points defining the vertices of the triangle. The depth
    of the OutputArray must be CV_32F.

  The function finds a triangle of minimum area enclosing the given set of 2D points and returns its
  area. The output for a given 2D point set is shown in the image below. 2D points are depicted in
  red* and the enclosing triangle in *yellow*.
  ![Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)
  The implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's
  @cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ algorithm for finding the minimal
  enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function
  takes a 2D point set as input an additional preprocessing step of computing the convex hull of the
  2D point set is required. The complexity of the #convexHull function is \\f$O(n log(n))\\f$ which is higher
  than \\f$\\theta(n)\\f$. Thus the overall complexity of the function is \\f$O(n log(n))\\f$.

  Python prototype (for reference only):
  ```python3
  minEnclosingTriangle(points[, triangle]) -> retval, triangle
  ```
  """
  @spec minEnclosingTriangle(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def minEnclosingTriangle(points, opts) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.minEnclosingTriangle(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds a triangle of minimum area enclosing a 2D point set and returns its area.

  ##### Positional Arguments
  - **points**: `Evision.Mat`.

    Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\\<\\> or Mat

  ##### Return
  - **retval**: `double`
  - **triangle**: `Evision.Mat.t()`.

    Output vector of three 2D points defining the vertices of the triangle. The depth
    of the OutputArray must be CV_32F.

  The function finds a triangle of minimum area enclosing the given set of 2D points and returns its
  area. The output for a given 2D point set is shown in the image below. 2D points are depicted in
  red* and the enclosing triangle in *yellow*.
  ![Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)
  The implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's
  @cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ algorithm for finding the minimal
  enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function
  takes a 2D point set as input an additional preprocessing step of computing the convex hull of the
  2D point set is required. The complexity of the #convexHull function is \\f$O(n log(n))\\f$ which is higher
  than \\f$\\theta(n)\\f$. Thus the overall complexity of the function is \\f$O(n log(n))\\f$.

  Python prototype (for reference only):
  ```python3
  minEnclosingTriangle(points[, triangle]) -> retval, triangle
  ```
  """
  @spec minEnclosingTriangle(Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def minEnclosingTriangle(points) when (is_struct(points, Evision.Mat) or is_struct(points, Nx.Tensor) or is_number(points) or is_tuple(points))
  do
    positional = [
      points: Evision.Internal.Structurise.from_struct(points)
    ]
    :evision_nif.minEnclosingTriangle(positional)
    |> to_struct()
  end

  @doc """
  Finds the global minimum and maximum in an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional mask used to select a sub-array.

  ##### Return
  - **minVal**: `double*`.

    pointer to the returned minimum value; NULL is used if not required.

  - **maxVal**: `double*`.

    pointer to the returned maximum value; NULL is used if not required.

  - **minLoc**: `Point*`.

    pointer to the returned minimum location (in 2D case); NULL is used if not required.

  - **maxLoc**: `Point*`.

    pointer to the returned maximum location (in 2D case); NULL is used if not required.

  The function cv::minMaxLoc finds the minimum and maximum element values and their positions. The
  extremums are searched across the whole array or, if mask is not an empty array, in the specified
  array region.
  The function do not work with multi-channel arrays. If you need to find minimum or maximum
  elements across all the channels, use Mat::reshape first to reinterpret the array as
  single-channel. Or you may extract the particular channel using either extractImageCOI, or
  mixChannels, or split.
  @sa max, min, reduceArgMin, reduceArgMax, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape

  Python prototype (for reference only):
  ```python3
  minMaxLoc(src[, mask]) -> minVal, maxVal, minLoc, maxLoc
  ```
  """
  @spec minMaxLoc(Evision.Mat.maybe_mat_in(), [{:mask, term()}] | nil) :: {number(), number(), {number(), number()}, {number(), number()}} | {:error, String.t()}
  def minMaxLoc(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.minMaxLoc(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the global minimum and maximum in an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional mask used to select a sub-array.

  ##### Return
  - **minVal**: `double*`.

    pointer to the returned minimum value; NULL is used if not required.

  - **maxVal**: `double*`.

    pointer to the returned maximum value; NULL is used if not required.

  - **minLoc**: `Point*`.

    pointer to the returned minimum location (in 2D case); NULL is used if not required.

  - **maxLoc**: `Point*`.

    pointer to the returned maximum location (in 2D case); NULL is used if not required.

  The function cv::minMaxLoc finds the minimum and maximum element values and their positions. The
  extremums are searched across the whole array or, if mask is not an empty array, in the specified
  array region.
  The function do not work with multi-channel arrays. If you need to find minimum or maximum
  elements across all the channels, use Mat::reshape first to reinterpret the array as
  single-channel. Or you may extract the particular channel using either extractImageCOI, or
  mixChannels, or split.
  @sa max, min, reduceArgMin, reduceArgMax, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape

  Python prototype (for reference only):
  ```python3
  minMaxLoc(src[, mask]) -> minVal, maxVal, minLoc, maxLoc
  ```
  """
  @spec minMaxLoc(Evision.Mat.maybe_mat_in()) :: {number(), number(), {number(), number()}, {number(), number()}} | {:error, String.t()}
  def minMaxLoc(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.minMaxLoc(positional)
    |> to_struct()
  end

  @doc """
  mixChannels

  ##### Positional Arguments
  - **src**: `[Evision.Mat]`.

    input array or vector of matrices; all of the matrices must have the same size and the
    same depth.

  - **fromTo**: `[integer()]`.

    array of index pairs specifying which channels are copied and where; fromTo[k\\*2] is
    a 0-based index of the input channel in src, fromTo[k\\*2+1] is an index of the output channel in
    dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
    src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
    src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
    channels; as a special case, when fromTo[k\\*2] is negative, the corresponding output channel is
    filled with zero .

  ##### Return
  - **dst**: `[Evision.Mat]`.

    output array or vector of matrices; all the matrices **must be allocated**; their size and
    depth must be the same as in src[0].

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  mixChannels(src, dst, fromTo) -> dst
  ```
  """
  @spec mixChannels(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(integer())) :: list(Evision.Mat.t()) | {:error, String.t()}
  def mixChannels(src, dst, fromTo) when is_list(src) and is_list(dst) and is_list(fromTo)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst),
      fromTo: Evision.Internal.Structurise.from_struct(fromTo)
    ]
    :evision_nif.mixChannels(positional)
    |> to_struct()
  end

  @doc """
  Calculates all of the moments up to the third order of a polygon or rasterized shape.

  ##### Positional Arguments
  - **array**: `Evision.Mat`.

    Single chanel raster image (CV_8U, CV_16U, CV_16S, CV_32F, CV_64F) or an array (
    \\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or Point2f).

  ##### Keyword Arguments
  - **binaryImage**: `bool`.

    If it is true, all non-zero image pixels are treated as 1's. The parameter is
    used for images only.

  ##### Return
  - **retval**: `Moments`

  The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
  results are returned in the structure cv::Moments.
  @returns moments.
  **Note**: Only applicable to contour moments calculations from Python bindings: Note that the numpy
  type for the input array should be either np.int32 or np.float32.
  @sa  contourArea, arcLength

  Python prototype (for reference only):
  ```python3
  moments(array[, binaryImage]) -> retval
  ```
  """
  @spec moments(Evision.Mat.maybe_mat_in(), [{:binaryImage, term()}] | nil) :: map() | {:error, String.t()}
  def moments(array, opts) when (is_struct(array, Evision.Mat) or is_struct(array, Nx.Tensor) or is_number(array) or is_tuple(array)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:binaryImage])
    positional = [
      array: Evision.Internal.Structurise.from_struct(array)
    ]
    :evision_nif.moments(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates all of the moments up to the third order of a polygon or rasterized shape.

  ##### Positional Arguments
  - **array**: `Evision.Mat`.

    Single chanel raster image (CV_8U, CV_16U, CV_16S, CV_32F, CV_64F) or an array (
    \\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or Point2f).

  ##### Keyword Arguments
  - **binaryImage**: `bool`.

    If it is true, all non-zero image pixels are treated as 1's. The parameter is
    used for images only.

  ##### Return
  - **retval**: `Moments`

  The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
  results are returned in the structure cv::Moments.
  @returns moments.
  **Note**: Only applicable to contour moments calculations from Python bindings: Note that the numpy
  type for the input array should be either np.int32 or np.float32.
  @sa  contourArea, arcLength

  Python prototype (for reference only):
  ```python3
  moments(array[, binaryImage]) -> retval
  ```
  """
  @spec moments(Evision.Mat.maybe_mat_in()) :: map() | {:error, String.t()}
  def moments(array) when (is_struct(array, Evision.Mat) or is_struct(array, Nx.Tensor) or is_number(array) or is_tuple(array))
  do
    positional = [
      array: Evision.Internal.Structurise.from_struct(array)
    ]
    :evision_nif.moments(positional)
    |> to_struct()
  end

  @doc """
  Performs advanced morphological transformations.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image. The number of channels can be arbitrary. The depth should be one of
    CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **op**: `integer()`.

    Type of a morphological operation, see #MorphTypes

  - **kernel**: `Evision.Mat`.

    Structuring element. It can be created using #getStructuringElement.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    Anchor position with the kernel. Negative values mean that the anchor is at the
    kernel center.

  - **iterations**: `integer()`.

    Number of times erosion and dilation are applied.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  - **borderValue**: `Evision.scalar()`.

    Border value in case of a constant border. The default value has a special
    meaning.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and type as source image.

  The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
  basic operations.
  Any of the operations can be done in-place. In case of multi-channel images, each channel is
  processed independently.
  @sa  dilate, erode, getStructuringElement
  **Note**: The number of iterations is the number of times erosion or dilatation operation will be applied.
  For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
  successively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).

  Python prototype (for reference only):
  ```python3
  morphologyEx(src, op, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst
  ```
  """
  @spec morphologyEx(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), [{:anchor, term()} | {:borderType, term()} | {:borderValue, term()} | {:iterations, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def morphologyEx(src, op, kernel, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(op) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :borderValue, :iterations])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      op: Evision.Internal.Structurise.from_struct(op),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.morphologyEx(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs advanced morphological transformations.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image. The number of channels can be arbitrary. The depth should be one of
    CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.

  - **op**: `integer()`.

    Type of a morphological operation, see #MorphTypes

  - **kernel**: `Evision.Mat`.

    Structuring element. It can be created using #getStructuringElement.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    Anchor position with the kernel. Negative values mean that the anchor is at the
    kernel center.

  - **iterations**: `integer()`.

    Number of times erosion and dilation are applied.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  - **borderValue**: `Evision.scalar()`.

    Border value in case of a constant border. The default value has a special
    meaning.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and type as source image.

  The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
  basic operations.
  Any of the operations can be done in-place. In case of multi-channel images, each channel is
  processed independently.
  @sa  dilate, erode, getStructuringElement
  **Note**: The number of iterations is the number of times erosion or dilatation operation will be applied.
  For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
  successively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).

  Python prototype (for reference only):
  ```python3
  morphologyEx(src, op, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst
  ```
  """
  @spec morphologyEx(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def morphologyEx(src, op, kernel) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(op) and (is_struct(kernel, Evision.Mat) or is_struct(kernel, Nx.Tensor) or is_number(kernel) or is_tuple(kernel))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      op: Evision.Internal.Structurise.from_struct(op),
      kernel: Evision.Internal.Structurise.from_struct(kernel)
    ]
    :evision_nif.morphologyEx(positional)
    |> to_struct()
  end

  @doc """
  Moves the window to the specified position

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **x**: `integer()`.

    The new x-coordinate of the window.

  - **y**: `integer()`.

    The new y-coordinate of the window.

  **Note**: [__Wayland Backend Only__] This function is not supported by the Wayland protocol limitation.

  Python prototype (for reference only):
  ```python3
  moveWindow(winname, x, y) -> None
  ```
  """
  @spec moveWindow(binary(), integer(), integer()) :: :ok | {:error, String.t()}
  def moveWindow(winname, x, y) when is_binary(winname) and is_integer(x) and is_integer(y)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.moveWindow(positional)
    |> to_struct()
  end

  @doc """
  Performs the per-element multiplication of two Fourier spectrums.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    first input array.

  - **b**: `Evision.Mat`.

    second input array of the same size and type as src1 .

  - **flags**: `integer()`.

    operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
    each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.

  ##### Keyword Arguments
  - **conjB**: `bool`.

    optional flag that conjugates the second input array before the multiplication (true)
    or not (false).

  ##### Return
  - **c**: `Evision.Mat.t()`.

    output array of the same size and type as src1 .

  The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex
  matrices that are results of a real or complex Fourier transform.
  The function, together with dft and idft, may be used to calculate convolution (pass conjB=false )
  or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are
  simply multiplied (per element) with an optional conjugation of the second-array elements. When the
  arrays are real, they are assumed to be CCS-packed (see dft for details).

  Python prototype (for reference only):
  ```python3
  mulSpectrums(a, b, flags[, c[, conjB]]) -> c
  ```
  """
  @spec mulSpectrums(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:conjB, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def mulSpectrums(a, b, flags, opts) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (is_struct(b, Evision.Mat) or is_struct(b, Nx.Tensor) or is_number(b) or is_tuple(b)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:conjB])
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.mulSpectrums(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs the per-element multiplication of two Fourier spectrums.

  ##### Positional Arguments
  - **a**: `Evision.Mat`.

    first input array.

  - **b**: `Evision.Mat`.

    second input array of the same size and type as src1 .

  - **flags**: `integer()`.

    operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
    each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.

  ##### Keyword Arguments
  - **conjB**: `bool`.

    optional flag that conjugates the second input array before the multiplication (true)
    or not (false).

  ##### Return
  - **c**: `Evision.Mat.t()`.

    output array of the same size and type as src1 .

  The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex
  matrices that are results of a real or complex Fourier transform.
  The function, together with dft and idft, may be used to calculate convolution (pass conjB=false )
  or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are
  simply multiplied (per element) with an optional conjugation of the second-array elements. When the
  arrays are real, they are assumed to be CCS-packed (see dft for details).

  Python prototype (for reference only):
  ```python3
  mulSpectrums(a, b, flags[, c[, conjB]]) -> c
  ```
  """
  @spec mulSpectrums(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def mulSpectrums(a, b, flags) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (is_struct(b, Evision.Mat) or is_struct(b, Nx.Tensor) or is_number(b) or is_tuple(b)) and is_integer(flags)
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.mulSpectrums(positional)
    |> to_struct()
  end

  @doc """
  Calculates the product of a matrix and its transposition.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel matrix. Note that unlike gemm, the
    function can multiply not only floating-point matrices.

  - **aTa**: `bool`.

    Flag specifying the multiplication ordering. See the
    description below.

  ##### Keyword Arguments
  - **delta**: `Evision.Mat`.

    Optional delta matrix subtracted from src before the
    multiplication. When the matrix is empty ( delta=noArray() ), it is
    assumed to be zero, that is, nothing is subtracted. If it has the same
    size as src, it is simply subtracted. Otherwise, it is "repeated" (see
    repeat ) to cover the full src and then subtracted. Type of the delta
    matrix, when it is not empty, must be the same as the type of created
    output matrix. See the dtype parameter description below.

  - **scale**: `double`.

    Optional scale factor for the matrix product.

  - **dtype**: `integer()`.

    Optional type of the output matrix. When it is negative,
    the output matrix will have the same type as src . Otherwise, it will be
    type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output square matrix.

  The function cv::mulTransposed calculates the product of src and its
  transposition:
  \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} )^T ( \\texttt{src} - \\texttt{delta} )\\f]
  if aTa=true, and
  \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} ) ( \\texttt{src} - \\texttt{delta} )^T\\f]
  otherwise. The function is used to calculate the covariance matrix. With
  zero delta, it can be used as a faster substitute for general matrix
  product A\\*B when B=A'
  @sa calcCovarMatrix, gemm, repeat, reduce

  Python prototype (for reference only):
  ```python3
  mulTransposed(src, aTa[, dst[, delta[, scale[, dtype]]]]) -> dst
  ```
  """
  @spec mulTransposed(Evision.Mat.maybe_mat_in(), boolean(), [{:delta, term()} | {:dtype, term()} | {:scale, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def mulTransposed(src, aTa, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_boolean(aTa) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:delta, :dtype, :scale])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      aTa: Evision.Internal.Structurise.from_struct(aTa)
    ]
    :evision_nif.mulTransposed(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the product of a matrix and its transposition.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel matrix. Note that unlike gemm, the
    function can multiply not only floating-point matrices.

  - **aTa**: `bool`.

    Flag specifying the multiplication ordering. See the
    description below.

  ##### Keyword Arguments
  - **delta**: `Evision.Mat`.

    Optional delta matrix subtracted from src before the
    multiplication. When the matrix is empty ( delta=noArray() ), it is
    assumed to be zero, that is, nothing is subtracted. If it has the same
    size as src, it is simply subtracted. Otherwise, it is "repeated" (see
    repeat ) to cover the full src and then subtracted. Type of the delta
    matrix, when it is not empty, must be the same as the type of created
    output matrix. See the dtype parameter description below.

  - **scale**: `double`.

    Optional scale factor for the matrix product.

  - **dtype**: `integer()`.

    Optional type of the output matrix. When it is negative,
    the output matrix will have the same type as src . Otherwise, it will be
    type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output square matrix.

  The function cv::mulTransposed calculates the product of src and its
  transposition:
  \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} )^T ( \\texttt{src} - \\texttt{delta} )\\f]
  if aTa=true, and
  \\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} ) ( \\texttt{src} - \\texttt{delta} )^T\\f]
  otherwise. The function is used to calculate the covariance matrix. With
  zero delta, it can be used as a faster substitute for general matrix
  product A\\*B when B=A'
  @sa calcCovarMatrix, gemm, repeat, reduce

  Python prototype (for reference only):
  ```python3
  mulTransposed(src, aTa[, dst[, delta[, scale[, dtype]]]]) -> dst
  ```
  """
  @spec mulTransposed(Evision.Mat.maybe_mat_in(), boolean()) :: Evision.Mat.t() | {:error, String.t()}
  def mulTransposed(src, aTa) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_boolean(aTa)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      aTa: Evision.Internal.Structurise.from_struct(aTa)
    ]
    :evision_nif.mulTransposed(positional)
    |> to_struct()
  end

  @doc """
  Calculates the per-element scaled product of two arrays.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and the same type as src1.

  ##### Keyword Arguments
  - **scale**: `double`.

    optional scale factor.

  - **dtype**: `integer()`.

    optional depth of the output array

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function multiply calculates the per-element product of two arrays:
  \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{scale} \\cdot \\texttt{src1} (I)  \\cdot \\texttt{src2} (I))\\f]
  There is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul .
  For a not-per-element matrix product, see gemm .
  **Note**: Saturation is not applied when the output array has the depth
  CV_32S. You may even get result of an incorrect sign in the case of
  overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `multiply(src,X)` means `multiply(src,(X,X,X,X))`.
  `multiply(src,(X,))` means `multiply(src,(X,0,0,0))`.
  @sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
  Mat::convertTo

  Python prototype (for reference only):
  ```python3
  multiply(src1, src2[, dst[, scale[, dtype]]]) -> dst
  ```
  """
  @spec multiply(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:dtype, term()} | {:scale, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def multiply(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype, :scale])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.multiply(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the per-element scaled product of two arrays.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and the same type as src1.

  ##### Keyword Arguments
  - **scale**: `double`.

    optional scale factor.

  - **dtype**: `integer()`.

    optional depth of the output array

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function multiply calculates the per-element product of two arrays:
  \\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{scale} \\cdot \\texttt{src1} (I)  \\cdot \\texttt{src2} (I))\\f]
  There is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul .
  For a not-per-element matrix product, see gemm .
  **Note**: Saturation is not applied when the output array has the depth
  CV_32S. You may even get result of an incorrect sign in the case of
  overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `multiply(src,X)` means `multiply(src,(X,X,X,X))`.
  `multiply(src,(X,))` means `multiply(src,(X,0,0,0))`.
  @sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
  Mat::convertTo

  Python prototype (for reference only):
  ```python3
  multiply(src1, src2[, dst[, scale[, dtype]]]) -> dst
  ```
  """
  @spec multiply(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def multiply(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.multiply(positional)
    |> to_struct()
  end

  @doc """
  Creates a window.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window in the window caption that may be used as a window identifier.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flags of the window. The supported flags are: (cv::WindowFlags)

  The function namedWindow creates a window that can be used as a placeholder for images and
  trackbars. Created windows are referred to by their names.
  If a window with the same name already exists, the function does nothing.
  You can call cv::destroyWindow or cv::destroyAllWindows to close the window and de-allocate any associated
  memory usage. For a simple program, you do not really have to call these functions because all the
  resources and windows of the application are closed automatically by the operating system upon exit.
  **Note**: Qt backend supports additional flags:
  - **WINDOW_NORMAL or WINDOW_AUTOSIZE:** WINDOW_NORMAL enables you to resize the
    window, whereas WINDOW_AUTOSIZE adjusts automatically the window size to fit the
    displayed image (see imshow ), and you cannot change the window size manually.

  - **WINDOW_FREERATIO or WINDOW_KEEPRATIO:** WINDOW_FREERATIO adjusts the image
    with no respect to its ratio, whereas WINDOW_KEEPRATIO keeps the image ratio.

  - **WINDOW_GUI_NORMAL or WINDOW_GUI_EXPANDED:** WINDOW_GUI_NORMAL is the old way to draw the window
    without statusbar and toolbar, whereas WINDOW_GUI_EXPANDED is a new enhanced GUI.
    By default, flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED

  Python prototype (for reference only):
  ```python3
  namedWindow(winname[, flags]) -> None
  ```
  """
  @spec namedWindow(binary(), [{:flags, term()}] | nil) :: :ok | {:error, String.t()}
  def namedWindow(winname, opts) when is_binary(winname) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname)
    ]
    :evision_nif.namedWindow(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Creates a window.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window in the window caption that may be used as a window identifier.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Flags of the window. The supported flags are: (cv::WindowFlags)

  The function namedWindow creates a window that can be used as a placeholder for images and
  trackbars. Created windows are referred to by their names.
  If a window with the same name already exists, the function does nothing.
  You can call cv::destroyWindow or cv::destroyAllWindows to close the window and de-allocate any associated
  memory usage. For a simple program, you do not really have to call these functions because all the
  resources and windows of the application are closed automatically by the operating system upon exit.
  **Note**: Qt backend supports additional flags:
  - **WINDOW_NORMAL or WINDOW_AUTOSIZE:** WINDOW_NORMAL enables you to resize the
    window, whereas WINDOW_AUTOSIZE adjusts automatically the window size to fit the
    displayed image (see imshow ), and you cannot change the window size manually.

  - **WINDOW_FREERATIO or WINDOW_KEEPRATIO:** WINDOW_FREERATIO adjusts the image
    with no respect to its ratio, whereas WINDOW_KEEPRATIO keeps the image ratio.

  - **WINDOW_GUI_NORMAL or WINDOW_GUI_EXPANDED:** WINDOW_GUI_NORMAL is the old way to draw the window
    without statusbar and toolbar, whereas WINDOW_GUI_EXPANDED is a new enhanced GUI.
    By default, flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED

  Python prototype (for reference only):
  ```python3
  namedWindow(winname[, flags]) -> None
  ```
  """
  @spec namedWindow(binary()) :: :ok | {:error, String.t()}
  def namedWindow(winname) when is_binary(winname)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname)
    ]
    :evision_nif.namedWindow(positional)
    |> to_struct()
  end

  @doc """
  Calculates an absolute difference norm or a relative difference norm.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and the same type as src1.

  ##### Keyword Arguments
  - **normType**: `integer()`.

    type of the norm (see #NormTypes).

  - **mask**: `Evision.Mat`.

    optional operation mask; it must have the same size as src1 and CV_8UC1 type.

  ##### Return
  - **retval**: `double`

  This version of cv::norm calculates the absolute difference norm
  or the relative difference norm of arrays src1 and src2.
  The type of norm to calculate is specified using #NormTypes.

  Python prototype (for reference only):
  ```python3
  norm(src1, src2[, normType[, mask]]) -> retval
  ```
  """
  @spec norm(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:mask, term()} | {:normType, term()}] | nil) :: number() | {:error, String.t()}
  def norm(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask, :normType])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.norm(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Calculates an absolute difference norm or a relative difference norm.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and the same type as src1.

  ##### Keyword Arguments
  - **normType**: `integer()`.

    type of the norm (see #NormTypes).

  - **mask**: `Evision.Mat`.

    optional operation mask; it must have the same size as src1 and CV_8UC1 type.

  ##### Return
  - **retval**: `double`

  This version of cv::norm calculates the absolute difference norm
  or the relative difference norm of arrays src1 and src2.
  The type of norm to calculate is specified using #NormTypes.

  Python prototype (for reference only):
  ```python3
  norm(src1, src2[, normType[, mask]]) -> retval
  ```
  #### Variant 2:
  Calculates the  absolute norm of an array.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  ##### Keyword Arguments
  - **normType**: `integer()`.

    type of the norm (see #NormTypes).

  - **mask**: `Evision.Mat`.

    optional operation mask; it must have the same size as src1 and CV_8UC1 type.

  ##### Return
  - **retval**: `double`

  This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.
  As example for one array consider the function \\f$r(x)= \\begin{pmatrix} x \\\\\\\\ 1-x \\end{pmatrix}, x \\in \\[-1;1]\\f$.
  The \\f$ L\\_{1}, L\\_{2} \\f$ and \\f$ L\\_{\\infty} \\f$ norm for the sample value \\f$r(-1) = \\begin{pmatrix} -1 \\\\\\\\ 2 \\end{pmatrix}\\f$
  is calculated as follows
  \\f{align*}
  \\| r(-1) \\|_{L_1} &= |-1| + |2| = 3 \\\\\\\\
  \\| r(-1) \\|_{L_2} &= \\sqrt{(-1)^{2} + (2)^{2}} = \\sqrt{5} \\\\\\\\
  \\| r(-1) \\|_{L_\\infty} &= \\max(|-1|,|2|) = 2
  \\f}
  and for \\f$r(0.5) = \\begin{pmatrix} 0.5 \\\\\\\\ 0.5 \\end{pmatrix}\\f$ the calculation is
  \\f{align*}
  \\| r(0.5) \\|_{L_1} &= |0.5| + |0.5| = 1 \\\\\\\\
  \\| r(0.5) \\|_{L_2} &= \\sqrt{(0.5)^{2} + (0.5)^{2}} = \\sqrt{0.5} \\\\\\\\
  \\| r(0.5) \\|_{L_\\infty} &= \\max(|0.5|,|0.5|) = 0.5.
  \\f}
  The following graphic shows all values for the three norm functions \\f$\\| r(x) \\|\\_{L\\_1}, \\| r(x) \\|\\_{L\\_2}\\f$ and \\f$\\| r(x) \\|\\_{L\\_\\infty}\\f$.
  It is notable that the \\f$ L\\_{1} \\f$ norm forms the upper and the \\f$ L\\_{\\infty} \\f$ norm forms the lower border for the example function \\f$ r(x) \\f$.
  ![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)
  When the mask parameter is specified and it is not empty, the norm is
  If normType is not specified, #NORM_L2 is used.
  calculated only over the region specified by the mask.
  Multi-channel input arrays are treated as single-channel arrays, that is,
  the results for all channels are combined.
  Hamming norms can only be calculated with CV_8U depth arrays.

  Python prototype (for reference only):
  ```python3
  norm(src1[, normType[, mask]]) -> retval
  ```

  """
  @spec norm(Evision.Mat.maybe_mat_in(), [{:mask, term()} | {:normType, term()}] | nil) :: number() | {:error, String.t()}
  def norm(src1, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:mask, :normType])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1)
    ]
    :evision_nif.norm(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec norm(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def norm(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.norm(positional)
    |> to_struct()
  end

  @doc """
  Calculates the  absolute norm of an array.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  ##### Keyword Arguments
  - **normType**: `integer()`.

    type of the norm (see #NormTypes).

  - **mask**: `Evision.Mat`.

    optional operation mask; it must have the same size as src1 and CV_8UC1 type.

  ##### Return
  - **retval**: `double`

  This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.
  As example for one array consider the function \\f$r(x)= \\begin{pmatrix} x \\\\\\\\ 1-x \\end{pmatrix}, x \\in \\[-1;1]\\f$.
  The \\f$ L\\_{1}, L\\_{2} \\f$ and \\f$ L\\_{\\infty} \\f$ norm for the sample value \\f$r(-1) = \\begin{pmatrix} -1 \\\\\\\\ 2 \\end{pmatrix}\\f$
  is calculated as follows
  \\f{align*}
  \\| r(-1) \\|_{L_1} &= |-1| + |2| = 3 \\\\\\\\
  \\| r(-1) \\|_{L_2} &= \\sqrt{(-1)^{2} + (2)^{2}} = \\sqrt{5} \\\\\\\\
  \\| r(-1) \\|_{L_\\infty} &= \\max(|-1|,|2|) = 2
  \\f}
  and for \\f$r(0.5) = \\begin{pmatrix} 0.5 \\\\\\\\ 0.5 \\end{pmatrix}\\f$ the calculation is
  \\f{align*}
  \\| r(0.5) \\|_{L_1} &= |0.5| + |0.5| = 1 \\\\\\\\
  \\| r(0.5) \\|_{L_2} &= \\sqrt{(0.5)^{2} + (0.5)^{2}} = \\sqrt{0.5} \\\\\\\\
  \\| r(0.5) \\|_{L_\\infty} &= \\max(|0.5|,|0.5|) = 0.5.
  \\f}
  The following graphic shows all values for the three norm functions \\f$\\| r(x) \\|\\_{L\\_1}, \\| r(x) \\|\\_{L\\_2}\\f$ and \\f$\\| r(x) \\|\\_{L\\_\\infty}\\f$.
  It is notable that the \\f$ L\\_{1} \\f$ norm forms the upper and the \\f$ L\\_{\\infty} \\f$ norm forms the lower border for the example function \\f$ r(x) \\f$.
  ![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)
  When the mask parameter is specified and it is not empty, the norm is
  If normType is not specified, #NORM_L2 is used.
  calculated only over the region specified by the mask.
  Multi-channel input arrays are treated as single-channel arrays, that is,
  the results for all channels are combined.
  Hamming norms can only be calculated with CV_8U depth arrays.

  Python prototype (for reference only):
  ```python3
  norm(src1[, normType[, mask]]) -> retval
  ```
  """
  @spec norm(Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def norm(src1) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1)
    ]
    :evision_nif.norm(positional)
    |> to_struct()
  end

  @doc """
  Normalizes the norm or value range of an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Keyword Arguments
  - **alpha**: `double`.

    norm value to normalize to or the lower range boundary in case of the range
    normalization.

  - **beta**: `double`.

    upper range boundary in case of the range normalization; it is not used for the norm
    normalization.

  - **norm_type**: `integer()`.

    normalization type (see cv::NormTypes).

  - **dtype**: `integer()`.

    when negative, the output array has the same type as src; otherwise, it has the same
    number of channels as src and the depth =CV_MAT_DEPTH(dtype).

  - **mask**: `Evision.Mat`.

    optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size as src .

  The function cv::normalize normalizes scale and shift the input array elements so that
  \\f[\\| \\texttt{dst} \\| \\_{L\\_p}= \\texttt{alpha}\\f]
  (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
  \\f[\\min \\_I  \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max \\_I  \\texttt{dst} (I)= \\texttt{beta}\\f]
  when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
  normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
  sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
  min-max but modify the whole array, you can use norm and Mat::convertTo.
  In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
  the range transformation for sparse matrices is not allowed since it can shift the zero level.
  Possible usage with some positive example data:
  ```cpp
  vector<double> positiveData = { 2.0, 8.0, 10.0 };
  vector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;
  // Norm to probability (total count)
  // sum(numbers) = 20.0
  // 2.0      0.1     (2.0/20.0)
  // 8.0      0.4     (8.0/20.0)
  // 10.0     0.5     (10.0/20.0)
  normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);
  // Norm to unit vector: ||positiveData|| = 1.0
  // 2.0      0.15
  // 8.0      0.62
  // 10.0     0.77
  normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);
  // Norm to max element
  // 2.0      0.2     (2.0/10.0)
  // 8.0      0.8     (8.0/10.0)
  // 10.0     1.0     (10.0/10.0)
  normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);
  // Norm to range [0.0;1.0]
  // 2.0      0.0     (shift to left border)
  // 8.0      0.75    (6.0/8.0)
  // 10.0     1.0     (shift to right border)
  normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
  ```
  @sa norm, Mat::convertTo, SparseMat::convertTo

  Python prototype (for reference only):
  ```python3
  normalize(src, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]) -> dst
  ```
  """
  @spec normalize(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:alpha, term()} | {:beta, term()} | {:dtype, term()} | {:mask, term()} | {:norm_type, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def normalize(src, dst, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:alpha, :beta, :dtype, :mask, :norm_type])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.normalize(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Normalizes the norm or value range of an array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Keyword Arguments
  - **alpha**: `double`.

    norm value to normalize to or the lower range boundary in case of the range
    normalization.

  - **beta**: `double`.

    upper range boundary in case of the range normalization; it is not used for the norm
    normalization.

  - **norm_type**: `integer()`.

    normalization type (see cv::NormTypes).

  - **dtype**: `integer()`.

    when negative, the output array has the same type as src; otherwise, it has the same
    number of channels as src and the depth =CV_MAT_DEPTH(dtype).

  - **mask**: `Evision.Mat`.

    optional operation mask.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size as src .

  The function cv::normalize normalizes scale and shift the input array elements so that
  \\f[\\| \\texttt{dst} \\| \\_{L\\_p}= \\texttt{alpha}\\f]
  (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
  \\f[\\min \\_I  \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max \\_I  \\texttt{dst} (I)= \\texttt{beta}\\f]
  when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
  normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
  sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
  min-max but modify the whole array, you can use norm and Mat::convertTo.
  In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
  the range transformation for sparse matrices is not allowed since it can shift the zero level.
  Possible usage with some positive example data:
  ```cpp
  vector<double> positiveData = { 2.0, 8.0, 10.0 };
  vector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;
  // Norm to probability (total count)
  // sum(numbers) = 20.0
  // 2.0      0.1     (2.0/20.0)
  // 8.0      0.4     (8.0/20.0)
  // 10.0     0.5     (10.0/20.0)
  normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);
  // Norm to unit vector: ||positiveData|| = 1.0
  // 2.0      0.15
  // 8.0      0.62
  // 10.0     0.77
  normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);
  // Norm to max element
  // 2.0      0.2     (2.0/10.0)
  // 8.0      0.8     (8.0/10.0)
  // 10.0     1.0     (10.0/10.0)
  normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);
  // Norm to range [0.0;1.0]
  // 2.0      0.0     (shift to left border)
  // 8.0      0.75    (6.0/8.0)
  // 10.0     1.0     (shift to right border)
  normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
  ```
  @sa norm, Mat::convertTo, SparseMat::convertTo

  Python prototype (for reference only):
  ```python3
  normalize(src, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]) -> dst
  ```
  """
  @spec normalize(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def normalize(src, dst) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.normalize(positional)
    |> to_struct()
  end

  @doc """
  Replaces NaNs by given number
  ##### Keyword Arguments
  - **val**: `double`.

    value to convert the NaNs

  ##### Return
  - **a**: `Evision.Mat.t()`.

    input/output matrix (CV_32F type).

  Python prototype (for reference only):
  ```python3
  patchNaNs(a[, val]) -> a
  ```
  """
  @spec patchNaNs(Evision.Mat.maybe_mat_in(), [{:val, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def patchNaNs(a, opts) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:val])
    positional = [
      a: Evision.Internal.Structurise.from_struct(a)
    ]
    :evision_nif.patchNaNs(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Replaces NaNs by given number
  ##### Keyword Arguments
  - **val**: `double`.

    value to convert the NaNs

  ##### Return
  - **a**: `Evision.Mat.t()`.

    input/output matrix (CV_32F type).

  Python prototype (for reference only):
  ```python3
  patchNaNs(a[, val]) -> a
  ```
  """
  @spec patchNaNs(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def patchNaNs(a) when (is_struct(a, Evision.Mat) or is_struct(a, Nx.Tensor) or is_number(a) or is_tuple(a))
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a)
    ]
    :evision_nif.patchNaNs(positional)
    |> to_struct()
  end

  @doc """
  Pencil-like non-photorealistic line drawing

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  - **shade_factor**: `float`.

    %Range between 0 to 0.1.

  ##### Return
  - **dst1**: `Evision.Mat.t()`.

    Output 8-bit 1-channel image.

  - **dst2**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  Python prototype (for reference only):
  ```python3
  pencilSketch(src[, dst1[, dst2[, sigma_s[, sigma_r[, shade_factor]]]]]) -> dst1, dst2
  ```
  """
  @spec pencilSketch(Evision.Mat.maybe_mat_in(), [{:shade_factor, term()} | {:sigma_r, term()} | {:sigma_s, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pencilSketch(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:shade_factor, :sigma_r, :sigma_s])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.pencilSketch(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Pencil-like non-photorealistic line drawing

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  - **shade_factor**: `float`.

    %Range between 0 to 0.1.

  ##### Return
  - **dst1**: `Evision.Mat.t()`.

    Output 8-bit 1-channel image.

  - **dst2**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  Python prototype (for reference only):
  ```python3
  pencilSketch(src[, dst1[, dst2[, sigma_s[, sigma_r[, shade_factor]]]]]) -> dst1, dst2
  ```
  """
  @spec pencilSketch(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def pencilSketch(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.pencilSketch(positional)
    |> to_struct()
  end

  @doc """
  Performs the perspective matrix transformation of vectors.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input two-channel or three-channel floating-point array; each
    element is a 2D/3D vector to be transformed.

  - **m**: `Evision.Mat`.

    3x3 or 4x4 floating-point transformation matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::perspectiveTransform transforms every element of src by
  treating it as a 2D or 3D vector, in the following way:
  \\f[(x, y, z)  \\rightarrow (x'/w, y'/w, z'/w)\\f]
  where
  \\f[(x', y', z', w') =  \\texttt{mat} \\cdot \\begin{bmatrix} x & y & z & 1  \\end{bmatrix}\\f]
  and
  \\f[w =  \\fork{w'}{if \\(w' \\ne 0\\)}{\\infty}{otherwise}\\f]
  Here a 3D vector transformation is shown. In case of a 2D vector
  transformation, the z component is omitted.
  **Note**: The function transforms a sparse set of 2D or 3D vectors. If you
  want to transform an image using perspective transformation, use
  warpPerspective . If you have an inverse problem, that is, you want to
  compute the most probable perspective transformation out of several
  pairs of corresponding points, you can use getPerspectiveTransform or
  findHomography .
  @sa  transform, warpPerspective, getPerspectiveTransform, findHomography

  Python prototype (for reference only):
  ```python3
  perspectiveTransform(src, m[, dst]) -> dst
  ```
  """
  @spec perspectiveTransform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def perspectiveTransform(src, m, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.perspectiveTransform(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs the perspective matrix transformation of vectors.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input two-channel or three-channel floating-point array; each
    element is a 2D/3D vector to be transformed.

  - **m**: `Evision.Mat`.

    3x3 or 4x4 floating-point transformation matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::perspectiveTransform transforms every element of src by
  treating it as a 2D or 3D vector, in the following way:
  \\f[(x, y, z)  \\rightarrow (x'/w, y'/w, z'/w)\\f]
  where
  \\f[(x', y', z', w') =  \\texttt{mat} \\cdot \\begin{bmatrix} x & y & z & 1  \\end{bmatrix}\\f]
  and
  \\f[w =  \\fork{w'}{if \\(w' \\ne 0\\)}{\\infty}{otherwise}\\f]
  Here a 3D vector transformation is shown. In case of a 2D vector
  transformation, the z component is omitted.
  **Note**: The function transforms a sparse set of 2D or 3D vectors. If you
  want to transform an image using perspective transformation, use
  warpPerspective . If you have an inverse problem, that is, you want to
  compute the most probable perspective transformation out of several
  pairs of corresponding points, you can use getPerspectiveTransform or
  findHomography .
  @sa  transform, warpPerspective, getPerspectiveTransform, findHomography

  Python prototype (for reference only):
  ```python3
  perspectiveTransform(src, m[, dst]) -> dst
  ```
  """
  @spec perspectiveTransform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def perspectiveTransform(src, m) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.perspectiveTransform(positional)
    |> to_struct()
  end

  @doc """
  Calculates the rotation angle of 2D vectors.

  ##### Positional Arguments
  - **x**: `Evision.Mat`.

    input floating-point array of x-coordinates of 2D vectors.

  - **y**: `Evision.Mat`.

    input array of y-coordinates of 2D vectors; it must have the
    same size and the same type as x.

  ##### Keyword Arguments
  - **angleInDegrees**: `bool`.

    when true, the function calculates the angle in
    degrees, otherwise, they are measured in radians.

  ##### Return
  - **angle**: `Evision.Mat.t()`.

    output array of vector angles; it has the same size and
    same type as x .

  The function cv::phase calculates the rotation angle of each 2D vector that
  is formed from the corresponding elements of x and y :
  \\f[\\texttt{angle} (I) =  \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\f]
  The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
  the corresponding angle(I) is set to 0.

  Python prototype (for reference only):
  ```python3
  phase(x, y[, angle[, angleInDegrees]]) -> angle
  ```
  """
  @spec phase(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:angleInDegrees, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def phase(x, y, opts) when (is_struct(x, Evision.Mat) or is_struct(x, Nx.Tensor) or is_number(x) or is_tuple(x)) and (is_struct(y, Evision.Mat) or is_struct(y, Nx.Tensor) or is_number(y) or is_tuple(y)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:angleInDegrees])
    positional = [
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.phase(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the rotation angle of 2D vectors.

  ##### Positional Arguments
  - **x**: `Evision.Mat`.

    input floating-point array of x-coordinates of 2D vectors.

  - **y**: `Evision.Mat`.

    input array of y-coordinates of 2D vectors; it must have the
    same size and the same type as x.

  ##### Keyword Arguments
  - **angleInDegrees**: `bool`.

    when true, the function calculates the angle in
    degrees, otherwise, they are measured in radians.

  ##### Return
  - **angle**: `Evision.Mat.t()`.

    output array of vector angles; it has the same size and
    same type as x .

  The function cv::phase calculates the rotation angle of each 2D vector that
  is formed from the corresponding elements of x and y :
  \\f[\\texttt{angle} (I) =  \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\f]
  The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
  the corresponding angle(I) is set to 0.

  Python prototype (for reference only):
  ```python3
  phase(x, y[, angle[, angleInDegrees]]) -> angle
  ```
  """
  @spec phase(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def phase(x, y) when (is_struct(x, Evision.Mat) or is_struct(x, Nx.Tensor) or is_number(x) or is_tuple(x)) and (is_struct(y, Evision.Mat) or is_struct(y, Nx.Tensor) or is_number(y) or is_tuple(y))
  do
    positional = [
      x: Evision.Internal.Structurise.from_struct(x),
      y: Evision.Internal.Structurise.from_struct(y)
    ]
    :evision_nif.phase(positional)
    |> to_struct()
  end

  @doc """
  The function is used to detect translational shifts that occur between two images.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    Source floating point array (CV_32FC1 or CV_64FC1)

  - **src2**: `Evision.Mat`.

    Source floating point array (CV_32FC1 or CV_64FC1)

  ##### Keyword Arguments
  - **window**: `Evision.Mat`.

    Floating point array with windowing coefficients to reduce edge effects (optional).

  ##### Return
  - **retval**: `Point2d`
  - **response**: `double*`.

    Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).

  The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
  the frequency domain. It can be used for fast image registration as well as motion estimation. For
  more information please see <http://en.wikipedia.org/wiki/Phase_correlation>
  Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
  with getOptimalDFTSize.
  The function performs the following equations:
  - First it applies a Hanning window (see <http://en.wikipedia.org/wiki/Hann_function>) to each
    image to remove possible edge effects. This window is cached until the array size changes to speed
    up processing time.

  - Next it computes the forward DFTs of each source array:
    \\f[\\mathbf{G}\\_a = \\mathcal{F}\\\\{src\\_1\\\\}, \\; \\mathbf{G}\\_b = \\mathcal{F}\\\\{src\\_2\\\\}\\f]
    where \\f$\\mathcal{F}\\f$ is the forward DFT.

  - It then computes the cross-power spectrum of each frequency domain array:
    \\f[R = \\frac{ \\mathbf{G}\\_a \\mathbf{G}\\_b^\\*}{|\\mathbf{G}\\_a \\mathbf{G}\\_b^\\*|}\\f]

  - Next the cross-correlation is converted back into the time domain via the inverse DFT:
    \\f[r = \\mathcal{F}^{-1}\\\\{R\\\\}\\f]

  - Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
    achieve sub-pixel accuracy.
    \\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\\\{\\arg \\max\\_{(x, y)}\\\\{r\\\\}\\\\}\\f]

  - If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
    centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
    peak) and will be smaller when there are multiple peaks.

  @returns detected phase shift (sub-pixel) between the two arrays.
  @sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow

  Python prototype (for reference only):
  ```python3
  phaseCorrelate(src1, src2[, window]) -> retval, response
  ```
  """
  @spec phaseCorrelate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:window, term()}] | nil) :: {{number(), number()}, number()} | {:error, String.t()}
  def phaseCorrelate(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:window])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.phaseCorrelate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  The function is used to detect translational shifts that occur between two images.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    Source floating point array (CV_32FC1 or CV_64FC1)

  - **src2**: `Evision.Mat`.

    Source floating point array (CV_32FC1 or CV_64FC1)

  ##### Keyword Arguments
  - **window**: `Evision.Mat`.

    Floating point array with windowing coefficients to reduce edge effects (optional).

  ##### Return
  - **retval**: `Point2d`
  - **response**: `double*`.

    Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).

  The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
  the frequency domain. It can be used for fast image registration as well as motion estimation. For
  more information please see <http://en.wikipedia.org/wiki/Phase_correlation>
  Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
  with getOptimalDFTSize.
  The function performs the following equations:
  - First it applies a Hanning window (see <http://en.wikipedia.org/wiki/Hann_function>) to each
    image to remove possible edge effects. This window is cached until the array size changes to speed
    up processing time.

  - Next it computes the forward DFTs of each source array:
    \\f[\\mathbf{G}\\_a = \\mathcal{F}\\\\{src\\_1\\\\}, \\; \\mathbf{G}\\_b = \\mathcal{F}\\\\{src\\_2\\\\}\\f]
    where \\f$\\mathcal{F}\\f$ is the forward DFT.

  - It then computes the cross-power spectrum of each frequency domain array:
    \\f[R = \\frac{ \\mathbf{G}\\_a \\mathbf{G}\\_b^\\*}{|\\mathbf{G}\\_a \\mathbf{G}\\_b^\\*|}\\f]

  - Next the cross-correlation is converted back into the time domain via the inverse DFT:
    \\f[r = \\mathcal{F}^{-1}\\\\{R\\\\}\\f]

  - Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
    achieve sub-pixel accuracy.
    \\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\\\{\\arg \\max\\_{(x, y)}\\\\{r\\\\}\\\\}\\f]

  - If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
    centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
    peak) and will be smaller when there are multiple peaks.

  @returns detected phase shift (sub-pixel) between the two arrays.
  @sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow

  Python prototype (for reference only):
  ```python3
  phaseCorrelate(src1, src2[, window]) -> retval, response
  ```
  """
  @spec phaseCorrelate(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {{number(), number()}, number()} | {:error, String.t()}
  def phaseCorrelate(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.phaseCorrelate(positional)
    |> to_struct()
  end

  @doc """
  Performs a point-in-contour test.

  ##### Positional Arguments
  - **contour**: `Evision.Mat`.

    Input contour.

  - **pt**: `Point2f`.

    Point tested against the contour.

  - **measureDist**: `bool`.

    If true, the function estimates the signed distance from the point to the
    nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.

  ##### Return
  - **retval**: `double`

  The function determines whether the point is inside a contour, outside, or lies on an edge (or
  coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)
  value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.
  Otherwise, the return value is a signed distance between the point and the nearest contour edge.
  See below a sample output of the function where each image pixel is tested against the contour:
  ![sample output](pics/pointpolygon.png)

  Python prototype (for reference only):
  ```python3
  pointPolygonTest(contour, pt, measureDist) -> retval
  ```
  """
  @spec pointPolygonTest(Evision.Mat.maybe_mat_in(), {number(), number()}, boolean()) :: number() | {:error, String.t()}
  def pointPolygonTest(contour, pt, measureDist) when (is_struct(contour, Evision.Mat) or is_struct(contour, Nx.Tensor) or is_number(contour) or is_tuple(contour)) and is_tuple(pt) and is_boolean(measureDist)
  do
    positional = [
      contour: Evision.Internal.Structurise.from_struct(contour),
      pt: Evision.Internal.Structurise.from_struct(pt),
      measureDist: Evision.Internal.Structurise.from_struct(measureDist)
    ]
    :evision_nif.pointPolygonTest(positional)
    |> to_struct()
  end

  @doc """
  Calculates x and y coordinates of 2D vectors from their magnitude and angle.

  ##### Positional Arguments
  - **magnitude**: `Evision.Mat`.

    input floating-point array of magnitudes of 2D vectors;
    it can be an empty matrix (=Mat()), in this case, the function assumes
    that all the magnitudes are =1; if it is not empty, it must have the
    same size and type as angle.

  - **angle**: `Evision.Mat`.

    input floating-point array of angles of 2D vectors.

  ##### Keyword Arguments
  - **angleInDegrees**: `bool`.

    when true, the input angles are measured in
    degrees, otherwise, they are measured in radians.

  ##### Return
  - **x**: `Evision.Mat.t()`.

    output array of x-coordinates of 2D vectors; it has the same
    size and type as angle.

  - **y**: `Evision.Mat.t()`.

    output array of y-coordinates of 2D vectors; it has the same
    size and type as angle.

  The function cv::polarToCart calculates the Cartesian coordinates of each 2D
  vector represented by the corresponding elements of magnitude and angle:
  \\f[\\begin{array}{l} \\texttt{x} (I) =  \\texttt{magnitude} (I) \\cos ( \\texttt{angle} (I)) \\\\\\\\ \\texttt{y} (I) =  \\texttt{magnitude} (I) \\sin ( \\texttt{angle} (I)) \\\\\\\\ \\end{array}\\f]
  The relative accuracy of the estimated coordinates is about 1e-6.
  @sa cartToPolar, magnitude, phase, exp, log, pow, sqrt

  Python prototype (for reference only):
  ```python3
  polarToCart(magnitude, angle[, x[, y[, angleInDegrees]]]) -> x, y
  ```
  """
  @spec polarToCart(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:angleInDegrees, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def polarToCart(magnitude, angle, opts) when (is_struct(magnitude, Evision.Mat) or is_struct(magnitude, Nx.Tensor) or is_number(magnitude) or is_tuple(magnitude)) and (is_struct(angle, Evision.Mat) or is_struct(angle, Nx.Tensor) or is_number(angle) or is_tuple(angle)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:angleInDegrees])
    positional = [
      magnitude: Evision.Internal.Structurise.from_struct(magnitude),
      angle: Evision.Internal.Structurise.from_struct(angle)
    ]
    :evision_nif.polarToCart(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates x and y coordinates of 2D vectors from their magnitude and angle.

  ##### Positional Arguments
  - **magnitude**: `Evision.Mat`.

    input floating-point array of magnitudes of 2D vectors;
    it can be an empty matrix (=Mat()), in this case, the function assumes
    that all the magnitudes are =1; if it is not empty, it must have the
    same size and type as angle.

  - **angle**: `Evision.Mat`.

    input floating-point array of angles of 2D vectors.

  ##### Keyword Arguments
  - **angleInDegrees**: `bool`.

    when true, the input angles are measured in
    degrees, otherwise, they are measured in radians.

  ##### Return
  - **x**: `Evision.Mat.t()`.

    output array of x-coordinates of 2D vectors; it has the same
    size and type as angle.

  - **y**: `Evision.Mat.t()`.

    output array of y-coordinates of 2D vectors; it has the same
    size and type as angle.

  The function cv::polarToCart calculates the Cartesian coordinates of each 2D
  vector represented by the corresponding elements of magnitude and angle:
  \\f[\\begin{array}{l} \\texttt{x} (I) =  \\texttt{magnitude} (I) \\cos ( \\texttt{angle} (I)) \\\\\\\\ \\texttt{y} (I) =  \\texttt{magnitude} (I) \\sin ( \\texttt{angle} (I)) \\\\\\\\ \\end{array}\\f]
  The relative accuracy of the estimated coordinates is about 1e-6.
  @sa cartToPolar, magnitude, phase, exp, log, pow, sqrt

  Python prototype (for reference only):
  ```python3
  polarToCart(magnitude, angle[, x[, y[, angleInDegrees]]]) -> x, y
  ```
  """
  @spec polarToCart(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def polarToCart(magnitude, angle) when (is_struct(magnitude, Evision.Mat) or is_struct(magnitude, Nx.Tensor) or is_number(magnitude) or is_tuple(magnitude)) and (is_struct(angle, Evision.Mat) or is_struct(angle, Nx.Tensor) or is_number(angle) or is_tuple(angle))
  do
    positional = [
      magnitude: Evision.Internal.Structurise.from_struct(magnitude),
      angle: Evision.Internal.Structurise.from_struct(angle)
    ]
    :evision_nif.polarToCart(positional)
    |> to_struct()
  end

  @doc """
  Polls for a pressed key.
  ##### Return
  - **retval**: `integer()`

  The function pollKey polls for a key event without waiting. It returns the code of the pressed key
  or -1 if no key was pressed since the last invocation. To wait until a key was pressed, use #waitKey.
  **Note**: The functions #waitKey and #pollKey are the only methods in HighGUI that can fetch and handle
  GUI events, so one of them needs to be called periodically for normal event processing unless
  HighGUI is used within an environment that takes care of event processing.
  **Note**: The function only works if there is at least one HighGUI window created and the window is
  active. If there are several HighGUI windows, any of them can be active.

  Python prototype (for reference only):
  ```python3
  pollKey() -> retval
  ```
  """
  @spec pollKey() :: integer() | {:error, String.t()}
  def pollKey() do
    positional = [
    ]
    :evision_nif.pollKey(positional)
    |> to_struct()
  end

  @doc """
  Draws several polygonal curves.

  ##### Positional Arguments
  - **pts**: `[Evision.Mat]`.

    Array of polygonal curves.

  - **isClosed**: `bool`.

    Flag indicating whether the drawn polylines are closed or not. If they are closed,
    the function draws a line from the last vertex of each curve to its first vertex.

  - **color**: `Evision.scalar()`.

    Polyline color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the polyline edges.

  - **lineType**: `integer()`.

    Type of the line segments. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the vertex coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::polylines draws one or more polygonal curves.

  Python prototype (for reference only):
  ```python3
  polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec polylines(Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), boolean(), Evision.scalar(), [{:lineType, term()} | {:shift, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def polylines(img, pts, isClosed, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_list(pts) and is_boolean(isClosed) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pts: Evision.Internal.Structurise.from_struct(pts),
      isClosed: Evision.Internal.Structurise.from_struct(isClosed),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.polylines(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws several polygonal curves.

  ##### Positional Arguments
  - **pts**: `[Evision.Mat]`.

    Array of polygonal curves.

  - **isClosed**: `bool`.

    Flag indicating whether the drawn polylines are closed or not. If they are closed,
    the function draws a line from the last vertex of each curve to its first vertex.

  - **color**: `Evision.scalar()`.

    Polyline color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the polyline edges.

  - **lineType**: `integer()`.

    Type of the line segments. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the vertex coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::polylines draws one or more polygonal curves.

  Python prototype (for reference only):
  ```python3
  polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec polylines(Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), boolean(), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def polylines(img, pts, isClosed, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_list(pts) and is_boolean(isClosed) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pts: Evision.Internal.Structurise.from_struct(pts),
      isClosed: Evision.Internal.Structurise.from_struct(isClosed),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.polylines(positional)
    |> to_struct()
  end

  @doc """
  Raises every array element to a power.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **power**: `double`.

    exponent of power.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::pow raises every element of the input array to power :
  \\f[\\texttt{dst} (I) =  \\fork{\\texttt{src}(I)^{power}}{if \\(\\texttt{power}\\) is integer}{|\\texttt{src}(I)|^{power}}{otherwise}\\f]
  So, for a non-integer power exponent, the absolute values of input array
  elements are used. However, it is possible to get true values for
  negative values using some extra operations. In the example below,
  computing the 5th root of array src shows:
  ```cpp
  Mat mask = src < 0;
  pow(src, 1./5, dst);
  subtract(Scalar::all(0), dst, dst, mask);
  ```
  For some values of power, such as integer values, 0.5 and -0.5,
  specialized faster algorithms are used.
  Special values (NaN, Inf) are not handled.
  @sa sqrt, exp, log, cartToPolar, polarToCart

  Python prototype (for reference only):
  ```python3
  pow(src, power[, dst]) -> dst
  ```
  """
  @spec pow(Evision.Mat.maybe_mat_in(), number(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def pow(src, power, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(power) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      power: Evision.Internal.Structurise.from_struct(power)
    ]
    :evision_nif.pow(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Raises every array element to a power.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **power**: `double`.

    exponent of power.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::pow raises every element of the input array to power :
  \\f[\\texttt{dst} (I) =  \\fork{\\texttt{src}(I)^{power}}{if \\(\\texttt{power}\\) is integer}{|\\texttt{src}(I)|^{power}}{otherwise}\\f]
  So, for a non-integer power exponent, the absolute values of input array
  elements are used. However, it is possible to get true values for
  negative values using some extra operations. In the example below,
  computing the 5th root of array src shows:
  ```cpp
  Mat mask = src < 0;
  pow(src, 1./5, dst);
  subtract(Scalar::all(0), dst, dst, mask);
  ```
  For some values of power, such as integer values, 0.5 and -0.5,
  specialized faster algorithms are used.
  Special values (NaN, Inf) are not handled.
  @sa sqrt, exp, log, cartToPolar, polarToCart

  Python prototype (for reference only):
  ```python3
  pow(src, power[, dst]) -> dst
  ```
  """
  @spec pow(Evision.Mat.maybe_mat_in(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def pow(src, power) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(power)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      power: Evision.Internal.Structurise.from_struct(power)
    ]
    :evision_nif.pow(positional)
    |> to_struct()
  end

  @doc """
  Calculates a feature map for corner detection.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source single-channel 8-bit of floating-point image.

  - **ksize**: `integer()`.

    %Aperture size of the Sobel .

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image that has the type CV_32F and the same size as src .

  The function calculates the complex spatial derivative-based function of the source image
  \\f[\\texttt{dst} = (D\\_x  \\texttt{src} )^2  \\cdot D\\_{yy}  \\texttt{src} + (D\\_y  \\texttt{src} )^2  \\cdot D\\_{xx}  \\texttt{src} - 2 D\\_x  \\texttt{src} \\cdot D\\_y  \\texttt{src} \\cdot D\\_{xy}  \\texttt{src}\\f]
  where \\f$D\\_x\\f$,\\f$D\\_y\\f$ are the first image derivatives, \\f$D\\_{xx}\\f$,\\f$D\\_{yy}\\f$ are the second image
  derivatives, and \\f$D\\_{xy}\\f$ is the mixed derivative.
  The corners can be found as local maximums of the functions, as shown below:
  ```
  Mat corners, dilated_corners;
  preCornerDetect(image, corners, 3);
  // dilation with 3x3 rectangular structuring element
  dilate(corners, dilated_corners, Mat(), 1);
  Mat corner_mask = corners == dilated_corners;
  ```

  Python prototype (for reference only):
  ```python3
  preCornerDetect(src, ksize[, dst[, borderType]]) -> dst
  ```
  """
  @spec preCornerDetect(Evision.Mat.maybe_mat_in(), integer(), [{:borderType, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def preCornerDetect(src, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.preCornerDetect(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates a feature map for corner detection.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source single-channel 8-bit of floating-point image.

  - **ksize**: `integer()`.

    %Aperture size of the Sobel .

  ##### Keyword Arguments
  - **borderType**: `integer()`.

    Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image that has the type CV_32F and the same size as src .

  The function calculates the complex spatial derivative-based function of the source image
  \\f[\\texttt{dst} = (D\\_x  \\texttt{src} )^2  \\cdot D\\_{yy}  \\texttt{src} + (D\\_y  \\texttt{src} )^2  \\cdot D\\_{xx}  \\texttt{src} - 2 D\\_x  \\texttt{src} \\cdot D\\_y  \\texttt{src} \\cdot D\\_{xy}  \\texttt{src}\\f]
  where \\f$D\\_x\\f$,\\f$D\\_y\\f$ are the first image derivatives, \\f$D\\_{xx}\\f$,\\f$D\\_{yy}\\f$ are the second image
  derivatives, and \\f$D\\_{xy}\\f$ is the mixed derivative.
  The corners can be found as local maximums of the functions, as shown below:
  ```
  Mat corners, dilated_corners;
  preCornerDetect(image, corners, 3);
  // dilation with 3x3 rectangular structuring element
  dilate(corners, dilated_corners, Mat(), 1);
  Mat corner_mask = corners == dilated_corners;
  ```

  Python prototype (for reference only):
  ```python3
  preCornerDetect(src, ksize[, dst[, borderType]]) -> dst
  ```
  """
  @spec preCornerDetect(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def preCornerDetect(src, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.preCornerDetect(positional)
    |> to_struct()
  end

  @doc """
  Projects 3D points to an image plane.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3
    1-channel or 1xN/Nx1 3-channel (or vector\\<Point3f\\> ), where N is the number of points in the view.

  - **rvec**: `Evision.Mat`.

    The rotation vector (@ref Rodrigues) that, together with tvec, performs a change of
    basis from world to camera coordinate system, see @ref calibrateCamera for details.

  - **tvec**: `Evision.Mat`.

    The translation vector, see parameter description above.

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$ . If the vector is empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **aspectRatio**: `double`.

    Optional "fixed aspect ratio" parameter. If the parameter is not 0, the
    function assumes that the aspect ratio (\\f$f_x / f_y\\f$) is fixed and correspondingly adjusts the
    jacobian matrix.

  ##### Return
  - **imagePoints**: `Evision.Mat.t()`.

    Output array of image points, 1xN/Nx1 2-channel, or
    vector\\<Point2f\\> .

  - **jacobian**: `Evision.Mat.t()`.

    Optional output 2Nx(10+\\<numDistCoeffs\\>) jacobian matrix of derivatives of image
    points with respect to components of the rotation vector, translation vector, focal lengths,
    coordinates of the principal point and the distortion coefficients. In the old interface different
    components of the jacobian are returned via different output parameters.

  The function computes the 2D projections of 3D points to the image plane, given intrinsic and
  extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial
  derivatives of image points coordinates (as functions of all the input parameters) with respect to
  the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global
  optimization in @ref calibrateCamera, @ref solvePnP, and @ref stereoCalibrate. The function itself
  can also be used to compute a re-projection error, given the current intrinsic and extrinsic
  parameters.
  **Note**: By setting rvec = tvec = \\f$\\[0, 0, 0]\\f$, or by setting cameraMatrix to a 3x3 identity matrix,
  or by passing zero distortion coefficients, one can get various useful partial cases of the
  function. This means, one can compute the distorted coordinates for a sparse set of points or apply
  a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.

  Python prototype (for reference only):
  ```python3
  projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs[, imagePoints[, jacobian[, aspectRatio]]]) -> imagePoints, jacobian
  ```
  """
  @spec projectPoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:aspectRatio, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:aspectRatio])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.projectPoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Projects 3D points to an image plane.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3
    1-channel or 1xN/Nx1 3-channel (or vector\\<Point3f\\> ), where N is the number of points in the view.

  - **rvec**: `Evision.Mat`.

    The rotation vector (@ref Rodrigues) that, together with tvec, performs a change of
    basis from world to camera coordinate system, see @ref calibrateCamera for details.

  - **tvec**: `Evision.Mat`.

    The translation vector, see parameter description above.

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$ . If the vector is empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **aspectRatio**: `double`.

    Optional "fixed aspect ratio" parameter. If the parameter is not 0, the
    function assumes that the aspect ratio (\\f$f_x / f_y\\f$) is fixed and correspondingly adjusts the
    jacobian matrix.

  ##### Return
  - **imagePoints**: `Evision.Mat.t()`.

    Output array of image points, 1xN/Nx1 2-channel, or
    vector\\<Point2f\\> .

  - **jacobian**: `Evision.Mat.t()`.

    Optional output 2Nx(10+\\<numDistCoeffs\\>) jacobian matrix of derivatives of image
    points with respect to components of the rotation vector, translation vector, focal lengths,
    coordinates of the principal point and the distortion coefficients. In the old interface different
    components of the jacobian are returned via different output parameters.

  The function computes the 2D projections of 3D points to the image plane, given intrinsic and
  extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial
  derivatives of image points coordinates (as functions of all the input parameters) with respect to
  the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global
  optimization in @ref calibrateCamera, @ref solvePnP, and @ref stereoCalibrate. The function itself
  can also be used to compute a re-projection error, given the current intrinsic and extrinsic
  parameters.
  **Note**: By setting rvec = tvec = \\f$\\[0, 0, 0]\\f$, or by setting cameraMatrix to a 3x3 identity matrix,
  or by passing zero distortion coefficients, one can get various useful partial cases of the
  function. This means, one can compute the distorted coordinates for a sparse set of points or apply
  a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.

  Python prototype (for reference only):
  ```python3
  projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs[, imagePoints[, jacobian[, aspectRatio]]]) -> imagePoints, jacobian
  ```
  """
  @spec projectPoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.projectPoints(positional)
    |> to_struct()
  end

  @doc """
  Draws a text string.

  ##### Positional Arguments
  - **text**: `String`.

    Text string to be drawn.

  - **org**: `Point`.

    Bottom-left corner of the text string in the image.

  - **fontFace**: `integer()`.

    Font type, see #HersheyFonts.

  - **fontScale**: `double`.

    Font scale factor that is multiplied by the font-specific base size.

  - **color**: `Evision.scalar()`.

    Text color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the lines used to draw a text.

  - **lineType**: `integer()`.

    Line type. See #LineTypes

  - **bottomLeftOrigin**: `bool`.

    When true, the image data origin is at the bottom-left corner. Otherwise,
    it is at the top-left corner.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
  using the specified font are replaced by question marks. See #getTextSize for a text rendering code
  example.

  Python prototype (for reference only):
  ```python3
  putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) -> img
  ```
  """
  @spec putText(Evision.Mat.maybe_mat_in(), binary(), {number(), number()}, integer(), number(), Evision.scalar(), [{:bottomLeftOrigin, term()} | {:lineType, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def putText(img, text, org, fontFace, fontScale, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_binary(text) and is_tuple(org) and is_integer(fontFace) and is_number(fontScale) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:bottomLeftOrigin, :lineType, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      text: Evision.Internal.Structurise.from_struct(text),
      org: Evision.Internal.Structurise.from_struct(org),
      fontFace: Evision.Internal.Structurise.from_struct(fontFace),
      fontScale: Evision.Internal.Structurise.from_struct(fontScale),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.putText(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Draws a text string.

  ##### Positional Arguments
  - **text**: `String`.

    Text string to be drawn.

  - **org**: `Point`.

    Bottom-left corner of the text string in the image.

  - **fontFace**: `integer()`.

    Font type, see #HersheyFonts.

  - **fontScale**: `double`.

    Font scale factor that is multiplied by the font-specific base size.

  - **color**: `Evision.scalar()`.

    Text color.

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of the lines used to draw a text.

  - **lineType**: `integer()`.

    Line type. See #LineTypes

  - **bottomLeftOrigin**: `bool`.

    When true, the image data origin is at the bottom-left corner. Otherwise,
    it is at the top-left corner.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
  using the specified font are replaced by question marks. See #getTextSize for a text rendering code
  example.

  Python prototype (for reference only):
  ```python3
  putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) -> img
  ```
  """
  @spec putText(Evision.Mat.maybe_mat_in(), binary(), {number(), number()}, integer(), number(), Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def putText(img, text, org, fontFace, fontScale, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_binary(text) and is_tuple(org) and is_integer(fontFace) and is_number(fontScale) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      text: Evision.Internal.Structurise.from_struct(text),
      org: Evision.Internal.Structurise.from_struct(org),
      fontFace: Evision.Internal.Structurise.from_struct(fontFace),
      fontScale: Evision.Internal.Structurise.from_struct(fontScale),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.putText(positional)
    |> to_struct()
  end

  @doc """
  Blurs an image and downsamples it.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  ##### Keyword Arguments
  - **dstsize**: `Size`.

    size of the output image.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image; it has the specified size and the same type as src.

  By default, size of the output image is computed as `Size((src.cols+1)/2, (src.rows+1)/2)`, but in
  any case, the following conditions should be satisfied:
  \\f[\\begin{array}{l} | \\texttt{dstsize.width} \\*2-src.cols| \\leq 2 \\\\\\\\ | \\texttt{dstsize.height} \\*2-src.rows| \\leq 2 \\end{array}\\f]
  The function performs the downsampling step of the Gaussian pyramid construction. First, it
  convolves the source image with the kernel:
  \\f[\\frac{1}{256} \\begin{bmatrix} 1 & 4 & 6 & 4 & 1  \\\\\\\\ 4 & 16 & 24 & 16 & 4  \\\\\\\\ 6 & 24 & 36 & 24 & 6  \\\\\\\\ 4 & 16 & 24 & 16 & 4  \\\\\\\\ 1 & 4 & 6 & 4 & 1 \\end{bmatrix}\\f]
  Then, it downsamples the image by rejecting even rows and columns.

  Python prototype (for reference only):
  ```python3
  pyrDown(src[, dst[, dstsize[, borderType]]]) -> dst
  ```
  """
  @spec pyrDown(Evision.Mat.maybe_mat_in(), [{:borderType, term()} | {:dstsize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def pyrDown(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :dstsize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.pyrDown(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Blurs an image and downsamples it.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  ##### Keyword Arguments
  - **dstsize**: `Size`.

    size of the output image.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image; it has the specified size and the same type as src.

  By default, size of the output image is computed as `Size((src.cols+1)/2, (src.rows+1)/2)`, but in
  any case, the following conditions should be satisfied:
  \\f[\\begin{array}{l} | \\texttt{dstsize.width} \\*2-src.cols| \\leq 2 \\\\\\\\ | \\texttt{dstsize.height} \\*2-src.rows| \\leq 2 \\end{array}\\f]
  The function performs the downsampling step of the Gaussian pyramid construction. First, it
  convolves the source image with the kernel:
  \\f[\\frac{1}{256} \\begin{bmatrix} 1 & 4 & 6 & 4 & 1  \\\\\\\\ 4 & 16 & 24 & 16 & 4  \\\\\\\\ 6 & 24 & 36 & 24 & 6  \\\\\\\\ 4 & 16 & 24 & 16 & 4  \\\\\\\\ 1 & 4 & 6 & 4 & 1 \\end{bmatrix}\\f]
  Then, it downsamples the image by rejecting even rows and columns.

  Python prototype (for reference only):
  ```python3
  pyrDown(src[, dst[, dstsize[, borderType]]]) -> dst
  ```
  """
  @spec pyrDown(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def pyrDown(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.pyrDown(positional)
    |> to_struct()
  end

  @doc """
  Performs initial step of meanshift segmentation of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    The source 8-bit, 3-channel image.

  - **sp**: `double`.

    The spatial window radius.

  - **sr**: `double`.

    The color window radius.

  ##### Keyword Arguments
  - **maxLevel**: `integer()`.

    Maximum level of the pyramid for the segmentation.

  - **termcrit**: `TermCriteria`.

    Termination criteria: when to stop meanshift iterations.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    The destination image of the same format and the same size as the source.

  The function implements the filtering stage of meanshift segmentation, that is, the output of the
  function is the filtered "posterized" image with color gradients and fine-grain texture flattened.
  At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
  meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
  considered:
  \\f[(x,y): X- \\texttt{sp} \\le x  \\le X+ \\texttt{sp} , Y- \\texttt{sp} \\le y  \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)||   \\le \\texttt{sr}\\f]
  where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
  (though, the algorithm does not depend on the color space used, so any 3-component color space can
  be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
  (R',G',B') are found and they act as the neighborhood center on the next iteration:
  \\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\\f]
  After the iterations over, the color components of the initial pixel (that is, the pixel from where
  the iterations started) are set to the final value (average color at the last iteration):
  \\f[I(X,Y) <- (R\\*,G\\*,B\\*)\\f]
  When maxLevel \\> 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
  run on the smallest layer first. After that, the results are propagated to the larger layer and the
  iterations are run again only on those pixels where the layer colors differ by more than sr from the
  lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
  results will be actually different from the ones obtained by running the meanshift procedure on the
  whole original image (i.e. when maxLevel==0).

  Python prototype (for reference only):
  ```python3
  pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) -> dst
  ```
  """
  @spec pyrMeanShiftFiltering(Evision.Mat.maybe_mat_in(), number(), number(), [{:maxLevel, term()} | {:termcrit, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def pyrMeanShiftFiltering(src, sp, sr, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(sp) and is_number(sr) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxLevel, :termcrit])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      sp: Evision.Internal.Structurise.from_struct(sp),
      sr: Evision.Internal.Structurise.from_struct(sr)
    ]
    :evision_nif.pyrMeanShiftFiltering(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs initial step of meanshift segmentation of an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    The source 8-bit, 3-channel image.

  - **sp**: `double`.

    The spatial window radius.

  - **sr**: `double`.

    The color window radius.

  ##### Keyword Arguments
  - **maxLevel**: `integer()`.

    Maximum level of the pyramid for the segmentation.

  - **termcrit**: `TermCriteria`.

    Termination criteria: when to stop meanshift iterations.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    The destination image of the same format and the same size as the source.

  The function implements the filtering stage of meanshift segmentation, that is, the output of the
  function is the filtered "posterized" image with color gradients and fine-grain texture flattened.
  At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
  meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
  considered:
  \\f[(x,y): X- \\texttt{sp} \\le x  \\le X+ \\texttt{sp} , Y- \\texttt{sp} \\le y  \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)||   \\le \\texttt{sr}\\f]
  where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
  (though, the algorithm does not depend on the color space used, so any 3-component color space can
  be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
  (R',G',B') are found and they act as the neighborhood center on the next iteration:
  \\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\\f]
  After the iterations over, the color components of the initial pixel (that is, the pixel from where
  the iterations started) are set to the final value (average color at the last iteration):
  \\f[I(X,Y) <- (R\\*,G\\*,B\\*)\\f]
  When maxLevel \\> 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
  run on the smallest layer first. After that, the results are propagated to the larger layer and the
  iterations are run again only on those pixels where the layer colors differ by more than sr from the
  lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
  results will be actually different from the ones obtained by running the meanshift procedure on the
  whole original image (i.e. when maxLevel==0).

  Python prototype (for reference only):
  ```python3
  pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) -> dst
  ```
  """
  @spec pyrMeanShiftFiltering(Evision.Mat.maybe_mat_in(), number(), number()) :: Evision.Mat.t() | {:error, String.t()}
  def pyrMeanShiftFiltering(src, sp, sr) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(sp) and is_number(sr)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      sp: Evision.Internal.Structurise.from_struct(sp),
      sr: Evision.Internal.Structurise.from_struct(sr)
    ]
    :evision_nif.pyrMeanShiftFiltering(positional)
    |> to_struct()
  end

  @doc """
  Upsamples an image and then blurs it.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  ##### Keyword Arguments
  - **dstsize**: `Size`.

    size of the output image.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image. It has the specified size and the same type as src .

  By default, size of the output image is computed as `Size(src.cols\\*2, (src.rows\\*2)`, but in any
  case, the following conditions should be satisfied:
  \\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols\\*2| \\leq  ( \\texttt{dstsize.width}   \\mod  2)  \\\\\\\\ | \\texttt{dstsize.height} -src.rows\\*2| \\leq  ( \\texttt{dstsize.height}   \\mod  2) \\end{array}\\f]
  The function performs the upsampling step of the Gaussian pyramid construction, though it can
  actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
  injecting even zero rows and columns and then convolves the result with the same kernel as in
  pyrDown multiplied by 4.

  Python prototype (for reference only):
  ```python3
  pyrUp(src[, dst[, dstsize[, borderType]]]) -> dst
  ```
  """
  @spec pyrUp(Evision.Mat.maybe_mat_in(), [{:borderType, term()} | {:dstsize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def pyrUp(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :dstsize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.pyrUp(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Upsamples an image and then blurs it.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  ##### Keyword Arguments
  - **dstsize**: `Size`.

    size of the output image.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported)

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image. It has the specified size and the same type as src .

  By default, size of the output image is computed as `Size(src.cols\\*2, (src.rows\\*2)`, but in any
  case, the following conditions should be satisfied:
  \\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols\\*2| \\leq  ( \\texttt{dstsize.width}   \\mod  2)  \\\\\\\\ | \\texttt{dstsize.height} -src.rows\\*2| \\leq  ( \\texttt{dstsize.height}   \\mod  2) \\end{array}\\f]
  The function performs the upsampling step of the Gaussian pyramid construction, though it can
  actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
  injecting even zero rows and columns and then convolves the result with the same kernel as in
  pyrDown multiplied by 4.

  Python prototype (for reference only):
  ```python3
  pyrUp(src[, dst[, dstsize[, borderType]]]) -> dst
  ```
  """
  @spec pyrUp(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def pyrUp(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.pyrUp(positional)
    |> to_struct()
  end

  @doc """
  Shuffles the array elements randomly.
  ##### Keyword Arguments
  - **iterFactor**: `double`.

    scale factor that determines the number of random swap operations (see the details
    below).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    input/output numerical 1D array.

  The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and
  swapping them. The number of such swap operations will be dst.rows\\*dst.cols\\*iterFactor .
  @sa RNG, sort

  Python prototype (for reference only):
  ```python3
  randShuffle(dst[, iterFactor]) -> dst
  ```
  """
  @spec randShuffle(Evision.Mat.maybe_mat_in(), [{:iterFactor, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def randShuffle(dst, opts) when (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:iterFactor])
    positional = [
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.randShuffle(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Shuffles the array elements randomly.
  ##### Keyword Arguments
  - **iterFactor**: `double`.

    scale factor that determines the number of random swap operations (see the details
    below).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    input/output numerical 1D array.

  The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and
  swapping them. The number of such swap operations will be dst.rows\\*dst.cols\\*iterFactor .
  @sa RNG, sort

  Python prototype (for reference only):
  ```python3
  randShuffle(dst[, iterFactor]) -> dst
  ```
  """
  @spec randShuffle(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def randShuffle(dst) when (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst))
  do
    positional = [
      dst: Evision.Internal.Structurise.from_struct(dst)
    ]
    :evision_nif.randShuffle(positional)
    |> to_struct()
  end

  @doc """
  Fills the array with normally distributed random numbers.

  ##### Positional Arguments
  - **mean**: `Evision.Mat`.

    mean value (expectation) of the generated random numbers.

  - **stddev**: `Evision.Mat`.

    standard deviation of the generated random numbers; it can be either a vector (in
    which case a diagonal standard deviation matrix is assumed) or a square matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.

  The function cv::randn fills the matrix dst with normally distributed random numbers with the specified
  mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the
  value range of the output array data type.
  @sa RNG, randu

  Python prototype (for reference only):
  ```python3
  randn(dst, mean, stddev) -> dst
  ```
  """
  @spec randn(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def randn(dst, mean, stddev) when (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (is_struct(mean, Evision.Mat) or is_struct(mean, Nx.Tensor) or is_number(mean) or is_tuple(mean)) and (is_struct(stddev, Evision.Mat) or is_struct(stddev, Nx.Tensor) or is_number(stddev) or is_tuple(stddev))
  do
    positional = [
      dst: Evision.Internal.Structurise.from_struct(dst),
      mean: Evision.Internal.Structurise.from_struct(mean),
      stddev: Evision.Internal.Structurise.from_struct(stddev)
    ]
    :evision_nif.randn(positional)
    |> to_struct()
  end

  @doc """
  Generates a single uniformly-distributed random number or an array of random numbers.

  ##### Positional Arguments
  - **low**: `Evision.Mat`.

    inclusive lower boundary of the generated random numbers.

  - **high**: `Evision.Mat`.

    exclusive upper boundary of the generated random numbers.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of random numbers; the array must be pre-allocated.

  Non-template variant of the function fills the matrix dst with uniformly-distributed
  random numbers from the specified range:
  \\f[\\texttt{low} \\_c  \\leq \\texttt{dst} (I)\\_c <  \\texttt{high} \\_c\\f]
  @sa RNG, randn, theRNG

  Python prototype (for reference only):
  ```python3
  randu(dst, low, high) -> dst
  ```
  """
  @spec randu(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def randu(dst, low, high) when (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (is_struct(low, Evision.Mat) or is_struct(low, Nx.Tensor) or is_number(low) or is_tuple(low)) and (is_struct(high, Evision.Mat) or is_struct(high, Nx.Tensor) or is_number(high) or is_tuple(high))
  do
    positional = [
      dst: Evision.Internal.Structurise.from_struct(dst),
      low: Evision.Internal.Structurise.from_struct(low),
      high: Evision.Internal.Structurise.from_struct(high)
    ]
    :evision_nif.randu(positional)
    |> to_struct()
  end

  @doc """
  Read a .flo file

  ##### Positional Arguments
  - **path**: `String`.

    Path to the file to be loaded

  ##### Return
  - **retval**: `Evision.Mat.t()`

  The function readOpticalFlow loads a flow field from a file and returns it as a single matrix.
  Resulting Mat has a type CV_32FC2 - floating-point, 2-channel. First channel corresponds to the
  flow in the horizontal direction (u), second - vertical (v).

  Python prototype (for reference only):
  ```python3
  readOpticalFlow(path) -> retval
  ```
  """
  @spec readOpticalFlow(binary()) :: Evision.Mat.t() | {:error, String.t()}
  def readOpticalFlow(path) when is_binary(path)
  do
    positional = [
      path: Evision.Internal.Structurise.from_struct(path)
    ]
    :evision_nif.readOpticalFlow(positional)
    |> to_struct()
  end

  @doc """
  Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using cheirality check. Returns the number of
  inliers that pass the check.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  - **cameraMatrix1**: `Evision.Mat`.

    Input/output camera matrix for the first camera, the same as in

  - **distCoeffs1**: `Evision.Mat`.

    Input/output vector of distortion coefficients, the same as in

  - **cameraMatrix2**: `Evision.Mat`.

    Input/output camera matrix for the first camera, the same as in

  - **distCoeffs2**: `Evision.Mat`.

    Input/output vector of distortion coefficients, the same as in

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method for computing an essential matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  ##### Return
  - **retval**: `integer()`
  - **e**: `Evision.Mat.t()`.

    The output essential matrix.

  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    described below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the cheirality check.

  @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.
  @ref calibrateCamera.
  @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.
  @ref calibrateCamera.

  This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies
  possible pose hypotheses by doing cheirality check. The cheirality check means that the
  triangulated 3D points should have positive depth. Some details can be found in @cite Nister03.
  This function can be used to process the output E and mask from @ref findEssentialMat. In this
  scenario, points1 and points2 are the same input for findEssentialMat.:
  ```
  // Example. Estimation of fundamental matrix using the RANSAC algorithm
  int point_count = 100;
  vector<Point2f> points1(point_count);
  vector<Point2f> points2(point_count);
  // initialize the points here ...
  for( int i = 0; i < point_count; i++ )
  {
  points1[i] = ...;
  points2[i] = ...;
  }
  // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
  Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;
  // Output: Essential matrix, relative rotation and relative translation.
  Mat E, R, t, mask;
  recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
  ```

  Python prototype (for reference only):
  ```python3
  recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, E[, R[, t[, method[, prob[, threshold[, mask]]]]]]]) -> retval, E, R, t, mask
  ```
  """
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:method, term()} | {:prob, term()} | {:threshold, term()}] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:method, :prob, :threshold])
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2)
    ]
    :evision_nif.recoverPose(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Recovers the relative camera rotation and the translation from corresponding points in two images from two different cameras, using cheirality check. Returns the number of
  inliers that pass the check.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  - **cameraMatrix1**: `Evision.Mat`.

    Input/output camera matrix for the first camera, the same as in

  - **distCoeffs1**: `Evision.Mat`.

    Input/output vector of distortion coefficients, the same as in

  - **cameraMatrix2**: `Evision.Mat`.

    Input/output camera matrix for the first camera, the same as in

  - **distCoeffs2**: `Evision.Mat`.

    Input/output vector of distortion coefficients, the same as in

  ##### Keyword Arguments
  - **method**: `integer()`.

    Method for computing an essential matrix.
    - @ref RANSAC for the RANSAC algorithm.
    - @ref LMEDS for the LMedS algorithm.

  - **prob**: `double`.

    Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of
    confidence (probability) that the estimated matrix is correct.

  - **threshold**: `double`.

    Parameter used for RANSAC. It is the maximum distance from a point to an epipolar
    line in pixels, beyond which the point is considered an outlier and is not used for computing the
    final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the
    point localization, image resolution, and the image noise.

  ##### Return
  - **retval**: `integer()`
  - **e**: `Evision.Mat.t()`.

    The output essential matrix.

  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    described below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the cheirality check.

  @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.
  @ref calibrateCamera.
  @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.
  @ref calibrateCamera.

  This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies
  possible pose hypotheses by doing cheirality check. The cheirality check means that the
  triangulated 3D points should have positive depth. Some details can be found in @cite Nister03.
  This function can be used to process the output E and mask from @ref findEssentialMat. In this
  scenario, points1 and points2 are the same input for findEssentialMat.:
  ```
  // Example. Estimation of fundamental matrix using the RANSAC algorithm
  int point_count = 100;
  vector<Point2f> points1(point_count);
  vector<Point2f> points2(point_count);
  // initialize the points here ...
  for( int i = 0; i < point_count; i++ )
  {
  points1[i] = ...;
  points2[i] = ...;
  }
  // Input: camera calibration of both cameras, for example using intrinsic chessboard calibration.
  Mat cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2;
  // Output: Essential matrix, relative rotation and relative translation.
  Mat E, R, t, mask;
  recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, mask);
  ```

  Python prototype (for reference only):
  ```python3
  recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2[, E[, R[, t[, method[, prob[, threshold[, mask]]]]]]]) -> retval, E, R, t, mask
  ```
  #### Variant 2:
  recoverPose

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1.

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .
    Note that this function assumes that points1 and points2 are feature points from cameras with the
    same camera intrinsic matrix.

  - **distanceThresh**: `double`.

    threshold distance which is used to filter out far away points (i.e. infinite
    points).

  ##### Return
  - **retval**: `integer()`
  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    description below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the chirality check.

  - **triangulatedPoints**: `Evision.Mat.t()`.

    3D points which were reconstructed by triangulation.

  Has overloading in C++

  This function differs from the one above that it outputs the triangulated 3D point that are used for
  the chirality check.

  Python prototype (for reference only):
  ```python3
  recoverPose(E, points1, points2, cameraMatrix, distanceThresh[, R[, t[, mask[, triangulatedPoints]]]]) -> retval, R, t, mask, triangulatedPoints
  ```

  """
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(e, points1, points2, cameraMatrix, distanceThresh, opts) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and is_number(distanceThresh) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distanceThresh: Evision.Internal.Structurise.from_struct(distanceThresh)
    ]
    :evision_nif.recoverPose(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2))
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2)
    ]
    :evision_nif.recoverPose(positional)
    |> to_struct()
  end

  @doc """
  #### Variant 1:
  recoverPose

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1.

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .
    Note that this function assumes that points1 and points2 are feature points from cameras with the
    same camera intrinsic matrix.

  - **distanceThresh**: `double`.

    threshold distance which is used to filter out far away points (i.e. infinite
    points).

  ##### Return
  - **retval**: `integer()`
  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    description below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the chirality check.

  - **triangulatedPoints**: `Evision.Mat.t()`.

    3D points which were reconstructed by triangulation.

  Has overloading in C++

  This function differs from the one above that it outputs the triangulated 3D point that are used for
  the chirality check.

  Python prototype (for reference only):
  ```python3
  recoverPose(E, points1, points2, cameraMatrix, distanceThresh[, R[, t[, mask[, triangulatedPoints]]]]) -> retval, R, t, mask, triangulatedPoints
  ```
  #### Variant 2:
  Recovers the relative camera rotation and the translation from an estimated essential
  matrix and the corresponding points in two images, using chirality check. Returns the number of
  inliers that pass the check.

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .
    Note that this function assumes that points1 and points2 are feature points from cameras with the
    same camera intrinsic matrix.

  ##### Return
  - **retval**: `integer()`
  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    described below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the chirality check.

  This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies
  possible pose hypotheses by doing chirality check. The chirality check means that the
  triangulated 3D points should have positive depth. Some details can be found in @cite Nister03.
  This function can be used to process the output E and mask from @ref findEssentialMat. In this
  scenario, points1 and points2 are the same input for #findEssentialMat :
  ```
  // Example. Estimation of fundamental matrix using the RANSAC algorithm
  int point_count = 100;
  vector<Point2f> points1(point_count);
  vector<Point2f> points2(point_count);
  // initialize the points here ...
  for( int i = 0; i < point_count; i++ )
  {
  points1[i] = ...;
  points2[i] = ...;
  }
  // cametra matrix with both focal lengths = 1, and principal point = (0, 0)
  Mat cameraMatrix = Mat::eye(3, 3, CV_64F);
  Mat E, R, t, mask;
  E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);
  recoverPose(E, points1, points2, cameraMatrix, R, t, mask);
  ```

  Python prototype (for reference only):
  ```python3
  recoverPose(E, points1, points2, cameraMatrix[, R[, t[, mask]]]) -> retval, R, t, mask
  ```

  """
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(e, points1, points2, cameraMatrix, opts) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix)
    ]
    :evision_nif.recoverPose(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(e, points1, points2, cameraMatrix, distanceThresh) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and is_number(distanceThresh)
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distanceThresh: Evision.Internal.Structurise.from_struct(distanceThresh)
    ]
    :evision_nif.recoverPose(positional)
    |> to_struct()
  end

  @doc """
  #### Variant 1:
  Recovers the relative camera rotation and the translation from an estimated essential
  matrix and the corresponding points in two images, using chirality check. Returns the number of
  inliers that pass the check.

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  - **cameraMatrix**: `Evision.Mat`.

    Camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .
    Note that this function assumes that points1 and points2 are feature points from cameras with the
    same camera intrinsic matrix.

  ##### Return
  - **retval**: `integer()`
  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    described below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the chirality check.

  This function decomposes an essential matrix using @ref decomposeEssentialMat and then verifies
  possible pose hypotheses by doing chirality check. The chirality check means that the
  triangulated 3D points should have positive depth. Some details can be found in @cite Nister03.
  This function can be used to process the output E and mask from @ref findEssentialMat. In this
  scenario, points1 and points2 are the same input for #findEssentialMat :
  ```
  // Example. Estimation of fundamental matrix using the RANSAC algorithm
  int point_count = 100;
  vector<Point2f> points1(point_count);
  vector<Point2f> points2(point_count);
  // initialize the points here ...
  for( int i = 0; i < point_count; i++ )
  {
  points1[i] = ...;
  points2[i] = ...;
  }
  // cametra matrix with both focal lengths = 1, and principal point = (0, 0)
  Mat cameraMatrix = Mat::eye(3, 3, CV_64F);
  Mat E, R, t, mask;
  E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);
  recoverPose(E, points1, points2, cameraMatrix, R, t, mask);
  ```

  Python prototype (for reference only):
  ```python3
  recoverPose(E, points1, points2, cameraMatrix[, R[, t[, mask]]]) -> retval, R, t, mask
  ```
  #### Variant 2:
  recoverPose

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  ##### Keyword Arguments
  - **focal**: `double`.

    Focal length of the camera. Note that this function assumes that points1 and points2
    are feature points from cameras with same focal length and principal point.

  - **pp**: `Point2d`.

    principal point of the camera.

  ##### Return
  - **retval**: `integer()`
  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    description below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the chirality check.

  Has overloading in C++

  This function differs from the one above that it computes camera intrinsic matrix from focal length and
  principal point:
  \\f[A =
  \\begin{bmatrix}
  f & 0 & x\\_{pp}  \\\\\\\\
  0 & f & y\\_{pp}  \\\\\\\\
  0 & 0 & 1
  \\end{bmatrix}\\f]

  Python prototype (for reference only):
  ```python3
  recoverPose(E, points1, points2[, R[, t[, focal[, pp[, mask]]]]]) -> retval, R, t, mask
  ```

  """
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:focal, term()} | {:pp, term()}] | nil) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(e, points1, points2, opts) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:focal, :pp])
    positional = [
      e: Evision.Internal.Structurise.from_struct(e),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.recoverPose(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(e, points1, points2, cameraMatrix) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix))
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix)
    ]
    :evision_nif.recoverPose(positional)
    |> to_struct()
  end

  @doc """
  recoverPose

  ##### Positional Arguments
  - **e**: `Evision.Mat`.

    The input essential matrix.

  - **points1**: `Evision.Mat`.

    Array of N 2D points from the first image. The point coordinates should be
    floating-point (single or double precision).

  - **points2**: `Evision.Mat`.

    Array of the second image points of the same size and format as points1 .

  ##### Keyword Arguments
  - **focal**: `double`.

    Focal length of the camera. Note that this function assumes that points1 and points2
    are feature points from cameras with same focal length and principal point.

  - **pp**: `Point2d`.

    principal point of the camera.

  ##### Return
  - **retval**: `integer()`
  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector, this matrix makes up a tuple
    that performs a change of basis from the first camera's coordinate system to the second camera's
    coordinate system. Note that, in general, t can not be used for this tuple, see the parameter
    description below.

  - **t**: `Evision.Mat.t()`.

    Output translation vector. This vector is obtained by @ref decomposeEssentialMat and
    therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit
    length.

  - **mask**: `Evision.Mat.t()`.

    Input/output mask for inliers in points1 and points2. If it is not empty, then it marks
    inliers in points1 and points2 for the given essential matrix E. Only these inliers will be used to
    recover pose. In the output mask only inliers which pass the chirality check.

  Has overloading in C++

  This function differs from the one above that it computes camera intrinsic matrix from focal length and
  principal point:
  \\f[A =
  \\begin{bmatrix}
  f & 0 & x\\_{pp}  \\\\\\\\
  0 & f & y\\_{pp}  \\\\\\\\
  0 & 0 & 1
  \\end{bmatrix}\\f]

  Python prototype (for reference only):
  ```python3
  recoverPose(E, points1, points2[, R[, t[, focal[, pp[, mask]]]]]) -> retval, R, t, mask
  ```
  """
  @spec recoverPose(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def recoverPose(e, points1, points2) when (is_struct(e, Evision.Mat) or is_struct(e, Nx.Tensor) or is_number(e) or is_tuple(e)) and (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2))
  do
    positional = [
      e: Evision.Internal.Structurise.from_struct(e),
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2)
    ]
    :evision_nif.recoverPose(positional)
    |> to_struct()
  end

  @doc """
  Draws a simple, thick, or filled up-right rectangle.

  ##### Positional Arguments
  - **pt1**: `Point`.

    Vertex of the rectangle.

  - **pt2**: `Point`.

    Vertex of the rectangle opposite to pt1 .

  - **color**: `Evision.scalar()`.

    Rectangle color or brightness (grayscale image).

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of lines that make up the rectangle. Negative values, like #FILLED,
    mean that the function has to draw a filled rectangle.

  - **lineType**: `integer()`.

    Type of the line. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the point coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
  are pt1 and pt2.

  Python prototype (for reference only):
  ```python3
  rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec rectangle(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, Evision.scalar(), [{:lineType, term()} | {:shift, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def rectangle(img, pt1, pt2, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(pt1) and is_tuple(pt2) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.rectangle(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Draws a simple, thick, or filled up-right rectangle.

  ##### Positional Arguments
  - **pt1**: `Point`.

    Vertex of the rectangle.

  - **pt2**: `Point`.

    Vertex of the rectangle opposite to pt1 .

  - **color**: `Evision.scalar()`.

    Rectangle color or brightness (grayscale image).

  ##### Keyword Arguments
  - **thickness**: `integer()`.

    Thickness of lines that make up the rectangle. Negative values, like #FILLED,
    mean that the function has to draw a filled rectangle.

  - **lineType**: `integer()`.

    Type of the line. See #LineTypes

  - **shift**: `integer()`.

    Number of fractional bits in the point coordinates.

  ##### Return
  - **img**: `Evision.Mat.t()`.

    Image.

  The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
  are pt1 and pt2.

  Python prototype (for reference only):
  ```python3
  rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -> img
  ```
  #### Variant 2:
  rectangle

  ##### Positional Arguments
  - **rec**: `Rect`
  - **color**: `Evision.scalar()`

  ##### Keyword Arguments
  - **thickness**: `integer()`.
  - **lineType**: `integer()`.
  - **shift**: `integer()`.

  ##### Return
  - **img**: `Evision.Mat.t()`

  Has overloading in C++

  use `rec` parameter as alternative specification of the drawn rectangle: `r.tl() and
  r.br()-Point(1,1)` are opposite corners

  Python prototype (for reference only):
  ```python3
  rectangle(img, rec, color[, thickness[, lineType[, shift]]]) -> img
  ```

  """
  @spec rectangle(Evision.Mat.maybe_mat_in(), {number(), number(), number(), number()}, Evision.scalar(), [{:lineType, term()} | {:shift, term()} | {:thickness, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def rectangle(img, rec, color, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(rec) and (is_number(color) or is_tuple(color)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lineType, :shift, :thickness])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      rec: Evision.Internal.Structurise.from_struct(rec),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.rectangle(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec rectangle(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def rectangle(img, pt1, pt2, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(pt1) and is_tuple(pt2) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.rectangle(positional)
    |> to_struct()
  end

  @doc """
  rectangle

  ##### Positional Arguments
  - **rec**: `Rect`
  - **color**: `Evision.scalar()`

  ##### Keyword Arguments
  - **thickness**: `integer()`.
  - **lineType**: `integer()`.
  - **shift**: `integer()`.

  ##### Return
  - **img**: `Evision.Mat.t()`

  Has overloading in C++

  use `rec` parameter as alternative specification of the drawn rectangle: `r.tl() and
  r.br()-Point(1,1)` are opposite corners

  Python prototype (for reference only):
  ```python3
  rectangle(img, rec, color[, thickness[, lineType[, shift]]]) -> img
  ```
  """
  @spec rectangle(Evision.Mat.maybe_mat_in(), {number(), number(), number(), number()}, Evision.scalar()) :: Evision.Mat.t() | {:error, String.t()}
  def rectangle(img, rec, color) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and is_tuple(rec) and (is_number(color) or is_tuple(color))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img),
      rec: Evision.Internal.Structurise.from_struct(rec),
      color: Evision.Internal.Structurise.from_struct(color)
    ]
    :evision_nif.rectangle(positional)
    |> to_struct()
  end

  @doc """
  Finds out if there is any intersection between two rectangles

  ##### Positional Arguments
  - **a**: `Rect2d`.

    First rectangle

  - **b**: `Rect2d`.

    Second rectangle

  ##### Return
  - **retval**: `double`

   mainly useful for language bindings
  @return the area of the intersection

  Python prototype (for reference only):
  ```python3
  rectangleIntersectionArea(a, b) -> retval
  ```
  """
  @spec rectangleIntersectionArea({number(), number(), number(), number()}, {number(), number(), number(), number()}) :: number() | {:error, String.t()}
  def rectangleIntersectionArea(a, b) when is_tuple(a) and is_tuple(b)
  do
    positional = [
      a: Evision.Internal.Structurise.from_struct(a),
      b: Evision.Internal.Structurise.from_struct(b)
    ]
    :evision_nif.rectangleIntersectionArea(positional)
    |> to_struct()
  end

  @doc """
  rectify3Collinear

  ##### Positional Arguments
  - **cameraMatrix1**: `Evision.Mat`
  - **distCoeffs1**: `Evision.Mat`
  - **cameraMatrix2**: `Evision.Mat`
  - **distCoeffs2**: `Evision.Mat`
  - **cameraMatrix3**: `Evision.Mat`
  - **distCoeffs3**: `Evision.Mat`
  - **imgpt1**: `[Evision.Mat]`
  - **imgpt3**: `[Evision.Mat]`
  - **imageSize**: `Size`
  - **r12**: `Evision.Mat`
  - **t12**: `Evision.Mat`
  - **r13**: `Evision.Mat`
  - **t13**: `Evision.Mat`
  - **alpha**: `double`
  - **newImgSize**: `Size`
  - **flags**: `integer()`

  ##### Return
  - **retval**: `float`
  - **r1**: `Evision.Mat.t()`.
  - **r2**: `Evision.Mat.t()`.
  - **r3**: `Evision.Mat.t()`.
  - **p1**: `Evision.Mat.t()`.
  - **p2**: `Evision.Mat.t()`.
  - **p3**: `Evision.Mat.t()`.
  - **q**: `Evision.Mat.t()`.
  - **roi1**: `Rect*`
  - **roi2**: `Rect*`

  Python prototype (for reference only):
  ```python3
  rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, alpha, newImgSize, flags[, R1[, R2[, R3[, P1[, P2[, P3[, Q]]]]]]]) -> retval, R1, R2, R3, P1, P2, P3, Q, roi1, roi2
  ```
  """
  @spec rectify3Collinear(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), {number(), number()}, integer(), [{atom(), term()},...] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), {number(), number(), number(), number()}, {number(), number(), number(), number()}} | {:error, String.t()}
  def rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, r12, t12, r13, t13, alpha, newImgSize, flags, opts) when (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and (is_struct(cameraMatrix3, Evision.Mat) or is_struct(cameraMatrix3, Nx.Tensor) or is_number(cameraMatrix3) or is_tuple(cameraMatrix3)) and (is_struct(distCoeffs3, Evision.Mat) or is_struct(distCoeffs3, Nx.Tensor) or is_number(distCoeffs3) or is_tuple(distCoeffs3)) and is_list(imgpt1) and is_list(imgpt3) and is_tuple(imageSize) and (is_struct(r12, Evision.Mat) or is_struct(r12, Nx.Tensor) or is_number(r12) or is_tuple(r12)) and (is_struct(t12, Evision.Mat) or is_struct(t12, Nx.Tensor) or is_number(t12) or is_tuple(t12)) and (is_struct(r13, Evision.Mat) or is_struct(r13, Nx.Tensor) or is_number(r13) or is_tuple(r13)) and (is_struct(t13, Evision.Mat) or is_struct(t13, Nx.Tensor) or is_number(t13) or is_tuple(t13)) and is_number(alpha) and is_tuple(newImgSize) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      cameraMatrix3: Evision.Internal.Structurise.from_struct(cameraMatrix3),
      distCoeffs3: Evision.Internal.Structurise.from_struct(distCoeffs3),
      imgpt1: Evision.Internal.Structurise.from_struct(imgpt1),
      imgpt3: Evision.Internal.Structurise.from_struct(imgpt3),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r12: Evision.Internal.Structurise.from_struct(r12),
      t12: Evision.Internal.Structurise.from_struct(t12),
      r13: Evision.Internal.Structurise.from_struct(r13),
      t13: Evision.Internal.Structurise.from_struct(t13),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      newImgSize: Evision.Internal.Structurise.from_struct(newImgSize),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.rectify3Collinear(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  rectify3Collinear

  ##### Positional Arguments
  - **cameraMatrix1**: `Evision.Mat`
  - **distCoeffs1**: `Evision.Mat`
  - **cameraMatrix2**: `Evision.Mat`
  - **distCoeffs2**: `Evision.Mat`
  - **cameraMatrix3**: `Evision.Mat`
  - **distCoeffs3**: `Evision.Mat`
  - **imgpt1**: `[Evision.Mat]`
  - **imgpt3**: `[Evision.Mat]`
  - **imageSize**: `Size`
  - **r12**: `Evision.Mat`
  - **t12**: `Evision.Mat`
  - **r13**: `Evision.Mat`
  - **t13**: `Evision.Mat`
  - **alpha**: `double`
  - **newImgSize**: `Size`
  - **flags**: `integer()`

  ##### Return
  - **retval**: `float`
  - **r1**: `Evision.Mat.t()`.
  - **r2**: `Evision.Mat.t()`.
  - **r3**: `Evision.Mat.t()`.
  - **p1**: `Evision.Mat.t()`.
  - **p2**: `Evision.Mat.t()`.
  - **p3**: `Evision.Mat.t()`.
  - **q**: `Evision.Mat.t()`.
  - **roi1**: `Rect*`
  - **roi2**: `Rect*`

  Python prototype (for reference only):
  ```python3
  rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, alpha, newImgSize, flags[, R1[, R2[, R3[, P1[, P2[, P3[, Q]]]]]]]) -> retval, R1, R2, R3, P1, P2, P3, Q, roi1, roi2
  ```
  """
  @spec rectify3Collinear(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), {number(), number()}, integer()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), {number(), number(), number(), number()}, {number(), number(), number(), number()}} | {:error, String.t()}
  def rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, r12, t12, r13, t13, alpha, newImgSize, flags) when (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and (is_struct(cameraMatrix3, Evision.Mat) or is_struct(cameraMatrix3, Nx.Tensor) or is_number(cameraMatrix3) or is_tuple(cameraMatrix3)) and (is_struct(distCoeffs3, Evision.Mat) or is_struct(distCoeffs3, Nx.Tensor) or is_number(distCoeffs3) or is_tuple(distCoeffs3)) and is_list(imgpt1) and is_list(imgpt3) and is_tuple(imageSize) and (is_struct(r12, Evision.Mat) or is_struct(r12, Nx.Tensor) or is_number(r12) or is_tuple(r12)) and (is_struct(t12, Evision.Mat) or is_struct(t12, Nx.Tensor) or is_number(t12) or is_tuple(t12)) and (is_struct(r13, Evision.Mat) or is_struct(r13, Nx.Tensor) or is_number(r13) or is_tuple(r13)) and (is_struct(t13, Evision.Mat) or is_struct(t13, Nx.Tensor) or is_number(t13) or is_tuple(t13)) and is_number(alpha) and is_tuple(newImgSize) and is_integer(flags)
  do
    positional = [
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      cameraMatrix3: Evision.Internal.Structurise.from_struct(cameraMatrix3),
      distCoeffs3: Evision.Internal.Structurise.from_struct(distCoeffs3),
      imgpt1: Evision.Internal.Structurise.from_struct(imgpt1),
      imgpt3: Evision.Internal.Structurise.from_struct(imgpt3),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r12: Evision.Internal.Structurise.from_struct(r12),
      t12: Evision.Internal.Structurise.from_struct(t12),
      r13: Evision.Internal.Structurise.from_struct(r13),
      t13: Evision.Internal.Structurise.from_struct(t13),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      newImgSize: Evision.Internal.Structurise.from_struct(newImgSize),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.rectify3Collinear(positional)
    |> to_struct()
  end

  @doc """
  Reduces a matrix to a vector.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input 2D matrix.

  - **dim**: `integer()`.

    dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
    a single row. 1 means that the matrix is reduced to a single column.

  - **rtype**: `integer()`.

    reduction operation that could be one of #ReduceTypes

  ##### Keyword Arguments
  - **dtype**: `integer()`.

    when negative, the output vector will have the same type as the input matrix,
    otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output vector. Its size and type is defined by dim and dtype parameters.

  The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
  1D vectors and performing the specified operation on the vectors until a single row/column is
  obtained. For example, the function can be used to compute horizontal and vertical projections of a
  raster image. In case of #REDUCE_MAX and #REDUCE_MIN, the output image should have the same type as the source one.
  In case of #REDUCE_SUM, #REDUCE_SUM2 and #REDUCE_AVG, the output may have a larger element bit-depth to preserve accuracy.
  And multi-channel arrays are also supported in these two reduction modes.
  The following code demonstrates its usage for a single channel matrix.
  @snippet snippets/core_reduce.cpp example
  And the following code demonstrates its usage for a two-channel matrix.
  @snippet snippets/core_reduce.cpp example2
  @sa repeat, reduceArgMin, reduceArgMax

  Python prototype (for reference only):
  ```python3
  reduce(src, dim, rtype[, dst[, dtype]]) -> dst
  ```
  """
  @spec reduce(Evision.Mat.maybe_mat_in(), integer(), integer(), [{:dtype, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def reduce(src, dim, rtype, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(dim) and is_integer(rtype) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dim: Evision.Internal.Structurise.from_struct(dim),
      rtype: Evision.Internal.Structurise.from_struct(rtype)
    ]
    :evision_nif.reduce(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Reduces a matrix to a vector.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input 2D matrix.

  - **dim**: `integer()`.

    dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
    a single row. 1 means that the matrix is reduced to a single column.

  - **rtype**: `integer()`.

    reduction operation that could be one of #ReduceTypes

  ##### Keyword Arguments
  - **dtype**: `integer()`.

    when negative, the output vector will have the same type as the input matrix,
    otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output vector. Its size and type is defined by dim and dtype parameters.

  The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
  1D vectors and performing the specified operation on the vectors until a single row/column is
  obtained. For example, the function can be used to compute horizontal and vertical projections of a
  raster image. In case of #REDUCE_MAX and #REDUCE_MIN, the output image should have the same type as the source one.
  In case of #REDUCE_SUM, #REDUCE_SUM2 and #REDUCE_AVG, the output may have a larger element bit-depth to preserve accuracy.
  And multi-channel arrays are also supported in these two reduction modes.
  The following code demonstrates its usage for a single channel matrix.
  @snippet snippets/core_reduce.cpp example
  And the following code demonstrates its usage for a two-channel matrix.
  @snippet snippets/core_reduce.cpp example2
  @sa repeat, reduceArgMin, reduceArgMax

  Python prototype (for reference only):
  ```python3
  reduce(src, dim, rtype[, dst[, dtype]]) -> dst
  ```
  """
  @spec reduce(Evision.Mat.maybe_mat_in(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def reduce(src, dim, rtype) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(dim) and is_integer(rtype)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dim: Evision.Internal.Structurise.from_struct(dim),
      rtype: Evision.Internal.Structurise.from_struct(rtype)
    ]
    :evision_nif.reduce(positional)
    |> to_struct()
  end

  @doc """
  Finds indices of max elements along provided axis

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **axis**: `integer()`.

    axis to reduce along.

  ##### Keyword Arguments
  - **lastIndex**: `bool`.

    whether to get the index of first or last occurrence of max.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of type CV_32SC1 with the same dimensionality as src,
    except for axis being reduced - it should be set to 1.

  **Note**: 
  - If input or output array is not continuous, this function will create an internal copy.
  - NaN handling is left unspecified, see patchNaNs().
  - The returned index is always in bounds of input matrix.

  @sa reduceArgMin, minMaxLoc, min, max, compare, reduce

  Python prototype (for reference only):
  ```python3
  reduceArgMax(src, axis[, dst[, lastIndex]]) -> dst
  ```
  """
  @spec reduceArgMax(Evision.Mat.maybe_mat_in(), integer(), [{:lastIndex, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def reduceArgMax(src, axis, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(axis) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lastIndex])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      axis: Evision.Internal.Structurise.from_struct(axis)
    ]
    :evision_nif.reduceArgMax(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds indices of max elements along provided axis

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **axis**: `integer()`.

    axis to reduce along.

  ##### Keyword Arguments
  - **lastIndex**: `bool`.

    whether to get the index of first or last occurrence of max.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of type CV_32SC1 with the same dimensionality as src,
    except for axis being reduced - it should be set to 1.

  **Note**: 
  - If input or output array is not continuous, this function will create an internal copy.
  - NaN handling is left unspecified, see patchNaNs().
  - The returned index is always in bounds of input matrix.

  @sa reduceArgMin, minMaxLoc, min, max, compare, reduce

  Python prototype (for reference only):
  ```python3
  reduceArgMax(src, axis[, dst[, lastIndex]]) -> dst
  ```
  """
  @spec reduceArgMax(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def reduceArgMax(src, axis) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(axis)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      axis: Evision.Internal.Structurise.from_struct(axis)
    ]
    :evision_nif.reduceArgMax(positional)
    |> to_struct()
  end

  @doc """
  Finds indices of min elements along provided axis

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **axis**: `integer()`.

    axis to reduce along.

  ##### Keyword Arguments
  - **lastIndex**: `bool`.

    whether to get the index of first or last occurrence of min.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of type CV_32SC1 with the same dimensionality as src,
    except for axis being reduced - it should be set to 1.

  **Note**: 
  - If input or output array is not continuous, this function will create an internal copy.
  - NaN handling is left unspecified, see patchNaNs().
  - The returned index is always in bounds of input matrix.

  @sa reduceArgMax, minMaxLoc, min, max, compare, reduce

  Python prototype (for reference only):
  ```python3
  reduceArgMin(src, axis[, dst[, lastIndex]]) -> dst
  ```
  """
  @spec reduceArgMin(Evision.Mat.maybe_mat_in(), integer(), [{:lastIndex, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def reduceArgMin(src, axis, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(axis) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:lastIndex])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      axis: Evision.Internal.Structurise.from_struct(axis)
    ]
    :evision_nif.reduceArgMin(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds indices of min elements along provided axis

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **axis**: `integer()`.

    axis to reduce along.

  ##### Keyword Arguments
  - **lastIndex**: `bool`.

    whether to get the index of first or last occurrence of min.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of type CV_32SC1 with the same dimensionality as src,
    except for axis being reduced - it should be set to 1.

  **Note**: 
  - If input or output array is not continuous, this function will create an internal copy.
  - NaN handling is left unspecified, see patchNaNs().
  - The returned index is always in bounds of input matrix.

  @sa reduceArgMax, minMaxLoc, min, max, compare, reduce

  Python prototype (for reference only):
  ```python3
  reduceArgMin(src, axis[, dst[, lastIndex]]) -> dst
  ```
  """
  @spec reduceArgMin(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def reduceArgMin(src, axis) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(axis)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      axis: Evision.Internal.Structurise.from_struct(axis)
    ]
    :evision_nif.reduceArgMin(positional)
    |> to_struct()
  end

  @doc """
  Applies a generic geometrical transformation to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **map1**: `Evision.Mat`.

    The first map of either (x,y) points or just x values having the type CV_16SC2 ,
    CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point
    representation to fixed-point for speed.

  - **map2**: `Evision.Mat`.

    The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
    if map1 is (x,y) points), respectively.

  - **interpolation**: `integer()`.

    Interpolation method (see #InterpolationFlags). The methods #INTER_AREA
    #INTER_LINEAR_EXACT and #INTER_NEAREST_EXACT are not supported by this function.
    The extra flag WARP_RELATIVE_MAP that can be ORed to the interpolation method
    (e.g. INTER_LINEAR | WARP_RELATIVE_MAP)

  ##### Keyword Arguments
  - **borderMode**: `integer()`.

    Pixel extrapolation method (see #BorderTypes). When
    borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that
    corresponds to the "outliers" in the source image are not modified by the function.

  - **borderValue**: `Evision.scalar()`.

    Value used in case of a constant border. By default, it is 0.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It has the same size as map1 and the same type as src .

  The function remap transforms the source image using the specified map:
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} (map\\_x(x,y),map\\_y(x,y))\\f]
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} (x+map\\_x(x,y),y+map\\_y(x,y))\\f] with WARP_RELATIVE_MAP
  where values of pixels with non-integer coordinates are computed using one of available
  interpolation methods. \\f$map\\_x\\f$ and \\f$map\\_y\\f$ can be encoded as separate floating-point maps
  in \\f$map\\_1\\f$ and \\f$map\\_2\\f$ respectively, or interleaved floating-point maps of \\f$(x,y)\\f$ in
  \\f$map\\_1\\f$, or fixed-point maps created by using #convertMaps. The reason you might want to
  convert from floating to fixed-point representations of a map is that they can yield much faster
  (\\~2x) remapping operations. In the converted case, \\f$map\\_1\\f$ contains pairs (cvFloor(x),
  cvFloor(y)) and \\f$map\\_2\\f$ contains indices in a table of interpolation coefficients.
  This function cannot operate in-place.
  **Note**: 
  Due to current implementation limitations the size of an input and output images should be less than 32767x32767.

  Python prototype (for reference only):
  ```python3
  remap(src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]) -> dst
  ```
  """
  @spec remap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{:borderMode, term()} | {:borderValue, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def remap(src, map1, map2, interpolation, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(map1, Evision.Mat) or is_struct(map1, Nx.Tensor) or is_number(map1) or is_tuple(map1)) and (is_struct(map2, Evision.Mat) or is_struct(map2, Nx.Tensor) or is_number(map2) or is_tuple(map2)) and is_integer(interpolation) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderMode, :borderValue])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      map1: Evision.Internal.Structurise.from_struct(map1),
      map2: Evision.Internal.Structurise.from_struct(map2),
      interpolation: Evision.Internal.Structurise.from_struct(interpolation)
    ]
    :evision_nif.remap(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies a generic geometrical transformation to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **map1**: `Evision.Mat`.

    The first map of either (x,y) points or just x values having the type CV_16SC2 ,
    CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point
    representation to fixed-point for speed.

  - **map2**: `Evision.Mat`.

    The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
    if map1 is (x,y) points), respectively.

  - **interpolation**: `integer()`.

    Interpolation method (see #InterpolationFlags). The methods #INTER_AREA
    #INTER_LINEAR_EXACT and #INTER_NEAREST_EXACT are not supported by this function.
    The extra flag WARP_RELATIVE_MAP that can be ORed to the interpolation method
    (e.g. INTER_LINEAR | WARP_RELATIVE_MAP)

  ##### Keyword Arguments
  - **borderMode**: `integer()`.

    Pixel extrapolation method (see #BorderTypes). When
    borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that
    corresponds to the "outliers" in the source image are not modified by the function.

  - **borderValue**: `Evision.scalar()`.

    Value used in case of a constant border. By default, it is 0.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It has the same size as map1 and the same type as src .

  The function remap transforms the source image using the specified map:
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} (map\\_x(x,y),map\\_y(x,y))\\f]
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} (x+map\\_x(x,y),y+map\\_y(x,y))\\f] with WARP_RELATIVE_MAP
  where values of pixels with non-integer coordinates are computed using one of available
  interpolation methods. \\f$map\\_x\\f$ and \\f$map\\_y\\f$ can be encoded as separate floating-point maps
  in \\f$map\\_1\\f$ and \\f$map\\_2\\f$ respectively, or interleaved floating-point maps of \\f$(x,y)\\f$ in
  \\f$map\\_1\\f$, or fixed-point maps created by using #convertMaps. The reason you might want to
  convert from floating to fixed-point representations of a map is that they can yield much faster
  (\\~2x) remapping operations. In the converted case, \\f$map\\_1\\f$ contains pairs (cvFloor(x),
  cvFloor(y)) and \\f$map\\_2\\f$ contains indices in a table of interpolation coefficients.
  This function cannot operate in-place.
  **Note**: 
  Due to current implementation limitations the size of an input and output images should be less than 32767x32767.

  Python prototype (for reference only):
  ```python3
  remap(src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]) -> dst
  ```
  """
  @spec remap(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def remap(src, map1, map2, interpolation) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(map1, Evision.Mat) or is_struct(map1, Nx.Tensor) or is_number(map1) or is_tuple(map1)) and (is_struct(map2, Evision.Mat) or is_struct(map2, Nx.Tensor) or is_number(map2) or is_tuple(map2)) and is_integer(interpolation)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      map1: Evision.Internal.Structurise.from_struct(map1),
      map2: Evision.Internal.Structurise.from_struct(map2),
      interpolation: Evision.Internal.Structurise.from_struct(interpolation)
    ]
    :evision_nif.remap(positional)
    |> to_struct()
  end

  @doc """
  Fills the output array with repeated copies of the input array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array to replicate.

  - **ny**: `integer()`.

    Flag to specify how many times the `src` is repeated along the
    vertical axis.

  - **nx**: `integer()`.

    Flag to specify how many times the `src` is repeated along the
    horizontal axis.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as `src`.

  The function cv::repeat duplicates the input array one or more times along each of the two axes:
  \\f[\\texttt{dst} \\_{ij}= \\texttt{src} \\_{i\\mod src.rows, \\; j\\mod src.cols }\\f]
  The second variant of the function is more convenient to use with @ref MatrixExpressions.
  @sa cv::reduce

  Python prototype (for reference only):
  ```python3
  repeat(src, ny, nx[, dst]) -> dst
  ```
  """
  @spec repeat(Evision.Mat.maybe_mat_in(), integer(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def repeat(src, ny, nx, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ny) and is_integer(nx) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ny: Evision.Internal.Structurise.from_struct(ny),
      nx: Evision.Internal.Structurise.from_struct(nx)
    ]
    :evision_nif.repeat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Fills the output array with repeated copies of the input array.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array to replicate.

  - **ny**: `integer()`.

    Flag to specify how many times the `src` is repeated along the
    vertical axis.

  - **nx**: `integer()`.

    Flag to specify how many times the `src` is repeated along the
    horizontal axis.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as `src`.

  The function cv::repeat duplicates the input array one or more times along each of the two axes:
  \\f[\\texttt{dst} \\_{ij}= \\texttt{src} \\_{i\\mod src.rows, \\; j\\mod src.cols }\\f]
  The second variant of the function is more convenient to use with @ref MatrixExpressions.
  @sa cv::reduce

  Python prototype (for reference only):
  ```python3
  repeat(src, ny, nx[, dst]) -> dst
  ```
  """
  @spec repeat(Evision.Mat.maybe_mat_in(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def repeat(src, ny, nx) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ny) and is_integer(nx)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ny: Evision.Internal.Structurise.from_struct(ny),
      nx: Evision.Internal.Structurise.from_struct(nx)
    ]
    :evision_nif.repeat(positional)
    |> to_struct()
  end

  @doc """
  Reprojects a disparity image to 3D space.

  ##### Positional Arguments
  - **disparity**: `Evision.Mat`.

    Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit
    floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no
    fractional bits. If the disparity is 16-bit signed format, as computed by @ref StereoBM or

  - **q**: `Evision.Mat`.

    \\f$4 \\times 4\\f$ perspective transformation matrix that can be obtained with

  ##### Keyword Arguments
  - **handleMissingValues**: `bool`.

    Indicates, whether the function should handle missing values (i.e.
    points where the disparity was not computed). If handleMissingValues=true, then pixels with the
    minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed
    to 3D points with a very large Z value (currently set to 10000).

  - **ddepth**: `integer()`.

    The optional output array depth. If it is -1, the output image will have CV_32F
    depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.

  ##### Return
  - **3dImage**: `Evision.Mat.t()`.

    Output 3-channel floating-point image of the same size as disparity. Each element of
    _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one
    uses Q obtained by @ref stereoRectify, then the returned points are represented in the first
    camera's rectified coordinate system.

  @ref StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before
  being used here.
  @ref stereoRectify.

  The function transforms a single-channel disparity map to a 3-channel image representing a 3D
  surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it
  computes:
  \\f[\\begin{bmatrix}
  X \\\\\\\\
  Y \\\\\\\\
  Z \\\\\\\\
  W
  \\end{bmatrix} = Q \\begin{bmatrix}
  x \\\\\\\\
  y \\\\\\\\
  \\texttt{disparity} (x,y) \\\\\\\\
  1
  \\end{bmatrix}.\\f]
  @sa
  To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform.

  Python prototype (for reference only):
  ```python3
  reprojectImageTo3D(disparity, Q[, _3dImage[, handleMissingValues[, ddepth]]]) -> _3dImage
  ```
  """
  @spec reprojectImageTo3D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:ddepth, term()} | {:handleMissingValues, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def reprojectImageTo3D(disparity, q, opts) when (is_struct(disparity, Evision.Mat) or is_struct(disparity, Nx.Tensor) or is_number(disparity) or is_tuple(disparity)) and (is_struct(q, Evision.Mat) or is_struct(q, Nx.Tensor) or is_number(q) or is_tuple(q)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:ddepth, :handleMissingValues])
    positional = [
      disparity: Evision.Internal.Structurise.from_struct(disparity),
      q: Evision.Internal.Structurise.from_struct(q)
    ]
    :evision_nif.reprojectImageTo3D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Reprojects a disparity image to 3D space.

  ##### Positional Arguments
  - **disparity**: `Evision.Mat`.

    Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit
    floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no
    fractional bits. If the disparity is 16-bit signed format, as computed by @ref StereoBM or

  - **q**: `Evision.Mat`.

    \\f$4 \\times 4\\f$ perspective transformation matrix that can be obtained with

  ##### Keyword Arguments
  - **handleMissingValues**: `bool`.

    Indicates, whether the function should handle missing values (i.e.
    points where the disparity was not computed). If handleMissingValues=true, then pixels with the
    minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed
    to 3D points with a very large Z value (currently set to 10000).

  - **ddepth**: `integer()`.

    The optional output array depth. If it is -1, the output image will have CV_32F
    depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.

  ##### Return
  - **3dImage**: `Evision.Mat.t()`.

    Output 3-channel floating-point image of the same size as disparity. Each element of
    _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one
    uses Q obtained by @ref stereoRectify, then the returned points are represented in the first
    camera's rectified coordinate system.

  @ref StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before
  being used here.
  @ref stereoRectify.

  The function transforms a single-channel disparity map to a 3-channel image representing a 3D
  surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it
  computes:
  \\f[\\begin{bmatrix}
  X \\\\\\\\
  Y \\\\\\\\
  Z \\\\\\\\
  W
  \\end{bmatrix} = Q \\begin{bmatrix}
  x \\\\\\\\
  y \\\\\\\\
  \\texttt{disparity} (x,y) \\\\\\\\
  1
  \\end{bmatrix}.\\f]
  @sa
  To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform.

  Python prototype (for reference only):
  ```python3
  reprojectImageTo3D(disparity, Q[, _3dImage[, handleMissingValues[, ddepth]]]) -> _3dImage
  ```
  """
  @spec reprojectImageTo3D(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def reprojectImageTo3D(disparity, q) when (is_struct(disparity, Evision.Mat) or is_struct(disparity, Nx.Tensor) or is_number(disparity) or is_tuple(disparity)) and (is_struct(q, Evision.Mat) or is_struct(q, Nx.Tensor) or is_number(q) or is_tuple(q))
  do
    positional = [
      disparity: Evision.Internal.Structurise.from_struct(disparity),
      q: Evision.Internal.Structurise.from_struct(q)
    ]
    :evision_nif.reprojectImageTo3D(positional)
    |> to_struct()
  end

  @doc """
  Resizes an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **dsize**: `Size`.

    output image size; if it equals zero (`None` in Python), it is computed as:
    \\f[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\f]
    Either dsize or both fx and fy must be non-zero.

  ##### Keyword Arguments
  - **fx**: `double`.

    scale factor along the horizontal axis; when it equals 0, it is computed as
    \\f[\\texttt{(double)dsize.width/src.cols}\\f]

  - **fy**: `double`.

    scale factor along the vertical axis; when it equals 0, it is computed as
    \\f[\\texttt{(double)dsize.height/src.rows}\\f]

  - **interpolation**: `integer()`.

    interpolation method, see #InterpolationFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image; it has the size dsize (when it is non-zero) or the size computed from
    src.size(), fx, and fy; the type of dst is the same as of src.

  The function resize resizes the image src down to or up to the specified size. Note that the
  initial dst type or size are not taken into account. Instead, the size and type are derived from
  the `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,
  you may call the function as follows:
  ```
  // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
  resize(src, dst, dst.size(), 0, 0, interpolation);
  ```
  If you want to decimate the image by factor of 2 in each direction, you can call the function this
  way:
  ```
  // specify fx and fy and let the function compute the destination image size.
  resize(src, dst, Size(), 0.5, 0.5, interpolation);
  ```
  To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
  enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR
  (faster but still looks OK).

  @sa  warpAffine, warpPerspective, remap

  Python prototype (for reference only):
  ```python3
  resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) -> dst
  ```
  """
  @spec resize(Evision.Mat.maybe_mat_in(), {number(), number()}, [{:fx, term()} | {:fy, term()} | {:interpolation, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def resize(src, dsize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(dsize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:fx, :fy, :interpolation])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dsize: Evision.Internal.Structurise.from_struct(dsize)
    ]
    :evision_nif.resize(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Resizes an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **dsize**: `Size`.

    output image size; if it equals zero (`None` in Python), it is computed as:
    \\f[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\f]
    Either dsize or both fx and fy must be non-zero.

  ##### Keyword Arguments
  - **fx**: `double`.

    scale factor along the horizontal axis; when it equals 0, it is computed as
    \\f[\\texttt{(double)dsize.width/src.cols}\\f]

  - **fy**: `double`.

    scale factor along the vertical axis; when it equals 0, it is computed as
    \\f[\\texttt{(double)dsize.height/src.rows}\\f]

  - **interpolation**: `integer()`.

    interpolation method, see #InterpolationFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image; it has the size dsize (when it is non-zero) or the size computed from
    src.size(), fx, and fy; the type of dst is the same as of src.

  The function resize resizes the image src down to or up to the specified size. Note that the
  initial dst type or size are not taken into account. Instead, the size and type are derived from
  the `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,
  you may call the function as follows:
  ```
  // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
  resize(src, dst, dst.size(), 0, 0, interpolation);
  ```
  If you want to decimate the image by factor of 2 in each direction, you can call the function this
  way:
  ```
  // specify fx and fy and let the function compute the destination image size.
  resize(src, dst, Size(), 0.5, 0.5, interpolation);
  ```
  To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
  enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR
  (faster but still looks OK).

  @sa  warpAffine, warpPerspective, remap

  Python prototype (for reference only):
  ```python3
  resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) -> dst
  ```
  """
  @spec resize(Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def resize(src, dsize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(dsize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dsize: Evision.Internal.Structurise.from_struct(dsize)
    ]
    :evision_nif.resize(positional)
    |> to_struct()
  end

  @doc """
  Resizes the window to the specified size

  ##### Positional Arguments
  - **winname**: `String`.

    Window name.

  - **width**: `integer()`.

    The new window width.

  - **height**: `integer()`.

    The new window height.

  **Note**: The specified window size is for the image area. Toolbars are not counted.
  Only windows created without cv::WINDOW_AUTOSIZE flag can be resized.

  Python prototype (for reference only):
  ```python3
  resizeWindow(winname, width, height) -> None
  ```
  """
  @spec resizeWindow(binary(), integer(), integer()) :: :ok | {:error, String.t()}
  def resizeWindow(winname, width, height) when is_binary(winname) and is_integer(width) and is_integer(height)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      width: Evision.Internal.Structurise.from_struct(width),
      height: Evision.Internal.Structurise.from_struct(height)
    ]
    :evision_nif.resizeWindow(positional)
    |> to_struct()
  end

  @doc """
  resizeWindow

  ##### Positional Arguments
  - **winname**: `String`.

    Window name.

  - **size**: `Size`.

    The new window size.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  resizeWindow(winname, size) -> None
  ```
  """
  @spec resizeWindow(binary(), {number(), number()}) :: :ok | {:error, String.t()}
  def resizeWindow(winname, size) when is_binary(winname) and is_tuple(size)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      size: Evision.Internal.Structurise.from_struct(size)
    ]
    :evision_nif.resizeWindow(positional)
    |> to_struct()
  end

  @doc """
  Rotates a 2D array in multiples of 90 degrees.
  The function cv::rotate rotates the array in one of three different ways:
  Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE).
  Rotate by 180 degrees clockwise (rotateCode = ROTATE_180).
  Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE).

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **rotateCode**: `integer()`.

    an enum to specify how to rotate the array; see the enum #RotateFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as src.  The size is the same with ROTATE_180,
    and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE.

  @sa transpose, repeat, completeSymm, flip, RotateFlags

  Python prototype (for reference only):
  ```python3
  rotate(src, rotateCode[, dst]) -> dst
  ```
  """
  @spec rotate(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def rotate(src, rotateCode, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(rotateCode) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      rotateCode: Evision.Internal.Structurise.from_struct(rotateCode)
    ]
    :evision_nif.rotate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Rotates a 2D array in multiples of 90 degrees.
  The function cv::rotate rotates the array in one of three different ways:
  Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE).
  Rotate by 180 degrees clockwise (rotateCode = ROTATE_180).
  Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE).

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **rotateCode**: `integer()`.

    an enum to specify how to rotate the array; see the enum #RotateFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as src.  The size is the same with ROTATE_180,
    and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE.

  @sa transpose, repeat, completeSymm, flip, RotateFlags

  Python prototype (for reference only):
  ```python3
  rotate(src, rotateCode[, dst]) -> dst
  ```
  """
  @spec rotate(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def rotate(src, rotateCode) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(rotateCode)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      rotateCode: Evision.Internal.Structurise.from_struct(rotateCode)
    ]
    :evision_nif.rotate(positional)
    |> to_struct()
  end

  @doc """
  Finds out if there is any intersection between two rotated rectangles.

  ##### Positional Arguments
  - **rect1**: `{centre={x, y}, size={s1, s2}, angle}`.

    First rectangle

  - **rect2**: `{centre={x, y}, size={s1, s2}, angle}`.

    Second rectangle

  ##### Return
  - **retval**: `integer()`
  - **intersectingRegion**: `Evision.Mat.t()`.

    The output array of the vertices of the intersecting region. It returns
    at most 8 vertices. Stored as std::vector\\<cv::Point2f\\> or cv::Mat as Mx1 of type CV_32FC2.

  If there is then the vertices of the intersecting region are returned as well.
  Below are some examples of intersection configurations. The hatched pattern indicates the
  intersecting region and the red vertices are returned by the function.
  ![intersection examples](pics/intersection.png)
  @returns One of #RectanglesIntersectTypes

  Python prototype (for reference only):
  ```python3
  rotatedRectangleIntersection(rect1, rect2[, intersectingRegion]) -> retval, intersectingRegion
  ```
  """
  @spec rotatedRectangleIntersection({{number(), number()}, {number(), number()}, number()}, {{number(), number()}, {number(), number()}, number()}, [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def rotatedRectangleIntersection(rect1, rect2, opts) when is_tuple(rect1) and is_tuple(rect2) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      rect1: Evision.Internal.Structurise.from_struct(rect1),
      rect2: Evision.Internal.Structurise.from_struct(rect2)
    ]
    :evision_nif.rotatedRectangleIntersection(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds out if there is any intersection between two rotated rectangles.

  ##### Positional Arguments
  - **rect1**: `{centre={x, y}, size={s1, s2}, angle}`.

    First rectangle

  - **rect2**: `{centre={x, y}, size={s1, s2}, angle}`.

    Second rectangle

  ##### Return
  - **retval**: `integer()`
  - **intersectingRegion**: `Evision.Mat.t()`.

    The output array of the vertices of the intersecting region. It returns
    at most 8 vertices. Stored as std::vector\\<cv::Point2f\\> or cv::Mat as Mx1 of type CV_32FC2.

  If there is then the vertices of the intersecting region are returned as well.
  Below are some examples of intersection configurations. The hatched pattern indicates the
  intersecting region and the red vertices are returned by the function.
  ![intersection examples](pics/intersection.png)
  @returns One of #RectanglesIntersectTypes

  Python prototype (for reference only):
  ```python3
  rotatedRectangleIntersection(rect1, rect2[, intersectingRegion]) -> retval, intersectingRegion
  ```
  """
  @spec rotatedRectangleIntersection({{number(), number()}, {number(), number()}, number()}, {{number(), number()}, {number(), number()}, number()}) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def rotatedRectangleIntersection(rect1, rect2) when is_tuple(rect1) and is_tuple(rect2)
  do
    positional = [
      rect1: Evision.Internal.Structurise.from_struct(rect1),
      rect2: Evision.Internal.Structurise.from_struct(rect2)
    ]
    :evision_nif.rotatedRectangleIntersection(positional)
    |> to_struct()
  end

  @doc """
  Calculates the Sampson Distance between two points.

  ##### Positional Arguments
  - **pt1**: `Evision.Mat`.

    first homogeneous 2d point

  - **pt2**: `Evision.Mat`.

    second homogeneous 2d point

  - **f**: `Evision.Mat`.

    fundamental matrix

  ##### Return
  - **retval**: `double`

  The function cv::sampsonDistance calculates and returns the first order approximation of the geometric error as:
  \\f[
  sd( \\texttt{pt1} , \\texttt{pt2} )=
  \\frac{(\\texttt{pt2}^t \\cdot \\texttt{F} \\cdot \\texttt{pt1})^2}
  {((\\texttt{F} \\cdot \\texttt{pt1})(0))^2 +
  ((\\texttt{F} \\cdot \\texttt{pt1})(1))^2 +
  ((\\texttt{F}^t \\cdot \\texttt{pt2})(0))^2 +
  ((\\texttt{F}^t \\cdot \\texttt{pt2})(1))^2}
  \\f]
  The fundamental matrix may be calculated using the #findFundamentalMat function. See @cite HartleyZ00 11.4.3 for details.
  @return The computed Sampson distance.

  Python prototype (for reference only):
  ```python3
  sampsonDistance(pt1, pt2, F) -> retval
  ```
  """
  @spec sampsonDistance(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: number() | {:error, String.t()}
  def sampsonDistance(pt1, pt2, f) when (is_struct(pt1, Evision.Mat) or is_struct(pt1, Nx.Tensor) or is_number(pt1) or is_tuple(pt1)) and (is_struct(pt2, Evision.Mat) or is_struct(pt2, Nx.Tensor) or is_number(pt2) or is_tuple(pt2)) and (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f))
  do
    positional = [
      pt1: Evision.Internal.Structurise.from_struct(pt1),
      pt2: Evision.Internal.Structurise.from_struct(pt2),
      f: Evision.Internal.Structurise.from_struct(f)
    ]
    :evision_nif.sampsonDistance(positional)
    |> to_struct()
  end

  @doc """
  Calculates the sum of a scaled array and another array.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **alpha**: `double`.

    scale factor for the first array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY
  or SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates
  the sum of a scaled array and another array:
  \\f[\\texttt{dst} (I)= \\texttt{scale} \\cdot \\texttt{src1} (I) +  \\texttt{src2} (I)\\f]
  The function can also be emulated with a matrix expression, for example:
  ```cpp
  Mat A(3, 3, CV_64F);
  ...
  A.row(0) = A.row(1)*2 + A.row(2);
  ```
  @sa add, addWeighted, subtract, Mat::dot, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  scaleAdd(src1, alpha, src2[, dst]) -> dst
  ```
  """
  @spec scaleAdd(Evision.Mat.maybe_mat_in(), number(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def scaleAdd(src1, alpha, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and is_number(alpha) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.scaleAdd(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the sum of a scaled array and another array.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array.

  - **alpha**: `double`.

    scale factor for the first array.

  - **src2**: `Evision.Mat`.

    second input array of the same size and type as src1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src1.

  The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY
  or SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates
  the sum of a scaled array and another array:
  \\f[\\texttt{dst} (I)= \\texttt{scale} \\cdot \\texttt{src1} (I) +  \\texttt{src2} (I)\\f]
  The function can also be emulated with a matrix expression, for example:
  ```cpp
  Mat A(3, 3, CV_64F);
  ...
  A.row(0) = A.row(1)*2 + A.row(2);
  ```
  @sa add, addWeighted, subtract, Mat::dot, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  scaleAdd(src1, alpha, src2[, dst]) -> dst
  ```
  """
  @spec scaleAdd(Evision.Mat.maybe_mat_in(), number(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def scaleAdd(src1, alpha, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and is_number(alpha) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      alpha: Evision.Internal.Structurise.from_struct(alpha),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.scaleAdd(positional)
    |> to_struct()
  end

  @doc """
  Image editing tasks concern either global changes (color/intensity corrections, filters,
  deformations) or local changes concerned to a selection. Here we are interested in achieving local
  changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless
  manner. The extent of the changes ranges from slight distortions to complete replacement by novel
  content @cite PM03 .

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **dst**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  - **p**: `Point`.

    Point in dst image where object is placed.

  - **flags**: `integer()`.

    Cloning method that could be cv::NORMAL_CLONE, cv::MIXED_CLONE or cv::MONOCHROME_TRANSFER

  ##### Return
  - **blend**: `Evision.Mat.t()`.

    Output image with the same size and type as dst.

  Python prototype (for reference only):
  ```python3
  seamlessClone(src, dst, mask, p, flags[, blend]) -> blend
  ```
  """
  @spec seamlessClone(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def seamlessClone(src, dst, mask, p, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_tuple(p) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst),
      mask: Evision.Internal.Structurise.from_struct(mask),
      p: Evision.Internal.Structurise.from_struct(p),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.seamlessClone(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Image editing tasks concern either global changes (color/intensity corrections, filters,
  deformations) or local changes concerned to a selection. Here we are interested in achieving local
  changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless
  manner. The extent of the changes ranges from slight distortions to complete replacement by novel
  content @cite PM03 .

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **dst**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  - **p**: `Point`.

    Point in dst image where object is placed.

  - **flags**: `integer()`.

    Cloning method that could be cv::NORMAL_CLONE, cv::MIXED_CLONE or cv::MONOCHROME_TRANSFER

  ##### Return
  - **blend**: `Evision.Mat.t()`.

    Output image with the same size and type as dst.

  Python prototype (for reference only):
  ```python3
  seamlessClone(src, dst, mask, p, flags[, blend]) -> blend
  ```
  """
  @spec seamlessClone(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, integer()) :: Evision.Mat.t() | {:error, String.t()}
  def seamlessClone(src, dst, mask, p, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(dst, Evision.Mat) or is_struct(dst, Nx.Tensor) or is_number(dst) or is_tuple(dst)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and is_tuple(p) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dst: Evision.Internal.Structurise.from_struct(dst),
      mask: Evision.Internal.Structurise.from_struct(mask),
      p: Evision.Internal.Structurise.from_struct(p),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.seamlessClone(positional)
    |> to_struct()
  end

  @doc """
  Allows users to select a ROI on the given image.

  ##### Positional Arguments
  - **windowName**: `String`.

    name of the window where selection process will be shown.

  - **img**: `Evision.Mat`.

    image to select a ROI.

  ##### Keyword Arguments
  - **showCrosshair**: `bool`.

    if true crosshair of selection rectangle will be shown.

  - **fromCenter**: `bool`.

    if true center of selection will match initial mouse position. In opposite case a corner of
    selection rectangle will correspont to the initial mouse position.

  - **printNotice**: `bool`.

    if true a notice to select ROI or cancel selection will be printed in console.

  ##### Return
  - **retval**: `Rect`

  The function creates a window and allows users to select a ROI using the mouse.
  Controls: use `space` or `enter` to finish selection, use key `c` to cancel selection (function will return the zero cv::Rect).
  @return selected ROI or empty rect if selection canceled.
  **Note**: The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...).
  After finish of work an empty callback will be set for the used window.

  Python prototype (for reference only):
  ```python3
  selectROI(windowName, img[, showCrosshair[, fromCenter[, printNotice]]]) -> retval
  ```
  """
  @spec selectROI(binary(), Evision.Mat.maybe_mat_in(), [{:fromCenter, term()} | {:printNotice, term()} | {:showCrosshair, term()}] | nil) :: {number(), number(), number(), number()} | {:error, String.t()}
  def selectROI(windowName, img, opts) when is_binary(windowName) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:fromCenter, :printNotice, :showCrosshair])
    positional = [
      windowName: Evision.Internal.Structurise.from_struct(windowName),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.selectROI(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Allows users to select a ROI on the given image.

  ##### Positional Arguments
  - **windowName**: `String`.

    name of the window where selection process will be shown.

  - **img**: `Evision.Mat`.

    image to select a ROI.

  ##### Keyword Arguments
  - **showCrosshair**: `bool`.

    if true crosshair of selection rectangle will be shown.

  - **fromCenter**: `bool`.

    if true center of selection will match initial mouse position. In opposite case a corner of
    selection rectangle will correspont to the initial mouse position.

  - **printNotice**: `bool`.

    if true a notice to select ROI or cancel selection will be printed in console.

  ##### Return
  - **retval**: `Rect`

  The function creates a window and allows users to select a ROI using the mouse.
  Controls: use `space` or `enter` to finish selection, use key `c` to cancel selection (function will return the zero cv::Rect).
  @return selected ROI or empty rect if selection canceled.
  **Note**: The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...).
  After finish of work an empty callback will be set for the used window.

  Python prototype (for reference only):
  ```python3
  selectROI(windowName, img[, showCrosshair[, fromCenter[, printNotice]]]) -> retval
  ```
  #### Variant 2:
  selectROI

  ##### Positional Arguments
  - **img**: `Evision.Mat`

  ##### Keyword Arguments
  - **showCrosshair**: `bool`.
  - **fromCenter**: `bool`.
  - **printNotice**: `bool`.

  ##### Return
  - **retval**: `Rect`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  selectROI(img[, showCrosshair[, fromCenter[, printNotice]]]) -> retval
  ```

  """
  @spec selectROI(Evision.Mat.maybe_mat_in(), [{:fromCenter, term()} | {:printNotice, term()} | {:showCrosshair, term()}] | nil) :: {number(), number(), number(), number()} | {:error, String.t()}
  def selectROI(img, opts) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:fromCenter, :printNotice, :showCrosshair])
    positional = [
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.selectROI(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec selectROI(binary(), Evision.Mat.maybe_mat_in()) :: {number(), number(), number(), number()} | {:error, String.t()}
  def selectROI(windowName, img) when is_binary(windowName) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img))
  do
    positional = [
      windowName: Evision.Internal.Structurise.from_struct(windowName),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.selectROI(positional)
    |> to_struct()
  end

  @doc """
  selectROI

  ##### Positional Arguments
  - **img**: `Evision.Mat`

  ##### Keyword Arguments
  - **showCrosshair**: `bool`.
  - **fromCenter**: `bool`.
  - **printNotice**: `bool`.

  ##### Return
  - **retval**: `Rect`

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  selectROI(img[, showCrosshair[, fromCenter[, printNotice]]]) -> retval
  ```
  """
  @spec selectROI(Evision.Mat.maybe_mat_in()) :: {number(), number(), number(), number()} | {:error, String.t()}
  def selectROI(img) when (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img))
  do
    positional = [
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.selectROI(positional)
    |> to_struct()
  end

  @doc """
  Allows users to select multiple ROIs on the given image.

  ##### Positional Arguments
  - **windowName**: `String`.

    name of the window where selection process will be shown.

  - **img**: `Evision.Mat`.

    image to select a ROI.

  ##### Keyword Arguments
  - **showCrosshair**: `bool`.

    if true crosshair of selection rectangle will be shown.

  - **fromCenter**: `bool`.

    if true center of selection will match initial mouse position. In opposite case a corner of
    selection rectangle will correspont to the initial mouse position.

  - **printNotice**: `bool`.

    if true a notice to select ROI or cancel selection will be printed in console.

  ##### Return
  - **boundingBoxes**: `[Rect]`.

    selected ROIs.

  The function creates a window and allows users to select multiple ROIs using the mouse.
  Controls: use `space` or `enter` to finish current selection and start a new one,
  use `esc` to terminate multiple ROI selection process.

  **Note**: The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...).
  After finish of work an empty callback will be set for the used window.

  Python prototype (for reference only):
  ```python3
  selectROIs(windowName, img[, showCrosshair[, fromCenter[, printNotice]]]) -> boundingBoxes
  ```
  """
  @spec selectROIs(binary(), Evision.Mat.maybe_mat_in(), [{:fromCenter, term()} | {:printNotice, term()} | {:showCrosshair, term()}] | nil) :: list({number(), number(), number(), number()}) | {:error, String.t()}
  def selectROIs(windowName, img, opts) when is_binary(windowName) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:fromCenter, :printNotice, :showCrosshair])
    positional = [
      windowName: Evision.Internal.Structurise.from_struct(windowName),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.selectROIs(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Allows users to select multiple ROIs on the given image.

  ##### Positional Arguments
  - **windowName**: `String`.

    name of the window where selection process will be shown.

  - **img**: `Evision.Mat`.

    image to select a ROI.

  ##### Keyword Arguments
  - **showCrosshair**: `bool`.

    if true crosshair of selection rectangle will be shown.

  - **fromCenter**: `bool`.

    if true center of selection will match initial mouse position. In opposite case a corner of
    selection rectangle will correspont to the initial mouse position.

  - **printNotice**: `bool`.

    if true a notice to select ROI or cancel selection will be printed in console.

  ##### Return
  - **boundingBoxes**: `[Rect]`.

    selected ROIs.

  The function creates a window and allows users to select multiple ROIs using the mouse.
  Controls: use `space` or `enter` to finish current selection and start a new one,
  use `esc` to terminate multiple ROI selection process.

  **Note**: The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...).
  After finish of work an empty callback will be set for the used window.

  Python prototype (for reference only):
  ```python3
  selectROIs(windowName, img[, showCrosshair[, fromCenter[, printNotice]]]) -> boundingBoxes
  ```
  """
  @spec selectROIs(binary(), Evision.Mat.maybe_mat_in()) :: list({number(), number(), number(), number()}) | {:error, String.t()}
  def selectROIs(windowName, img) when is_binary(windowName) and (is_struct(img, Evision.Mat) or is_struct(img, Nx.Tensor) or is_number(img) or is_tuple(img))
  do
    positional = [
      windowName: Evision.Internal.Structurise.from_struct(windowName),
      img: Evision.Internal.Structurise.from_struct(img)
    ]
    :evision_nif.selectROIs(positional)
    |> to_struct()
  end

  @doc """
  Applies a separable linear filter to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **ddepth**: `integer()`.

    Destination image depth, see @ref filter_depths "combinations"

  - **kernelX**: `Evision.Mat`.

    Coefficients for filtering each row.

  - **kernelY**: `Evision.Mat`.

    Coefficients for filtering each column.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    Anchor position within the kernel. The default value \\f$(-1,-1)\\f$ means that the anchor
    is at the kernel center.

  - **delta**: `double`.

    Value added to the filtered results before storing them.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and the same number of channels as src .

  The function applies a separable linear filter to the image. That is, first, every row of src is
  filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
  kernel kernelY. The final result shifted by delta is stored in dst .
  @sa  filter2D, Sobel, GaussianBlur, boxFilter, blur

  Python prototype (for reference only):
  ```python3
  sepFilter2D(src, ddepth, kernelX, kernelY[, dst[, anchor[, delta[, borderType]]]]) -> dst
  ```
  """
  @spec sepFilter2D(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:anchor, term()} | {:borderType, term()} | {:delta, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def sepFilter2D(src, ddepth, kernelX, kernelY, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and (is_struct(kernelX, Evision.Mat) or is_struct(kernelX, Nx.Tensor) or is_number(kernelX) or is_tuple(kernelX)) and (is_struct(kernelY, Evision.Mat) or is_struct(kernelY, Nx.Tensor) or is_number(kernelY) or is_tuple(kernelY)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :delta])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      kernelX: Evision.Internal.Structurise.from_struct(kernelX),
      kernelY: Evision.Internal.Structurise.from_struct(kernelY)
    ]
    :evision_nif.sepFilter2D(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies a separable linear filter to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **ddepth**: `integer()`.

    Destination image depth, see @ref filter_depths "combinations"

  - **kernelX**: `Evision.Mat`.

    Coefficients for filtering each row.

  - **kernelY**: `Evision.Mat`.

    Coefficients for filtering each column.

  ##### Keyword Arguments
  - **anchor**: `Point`.

    Anchor position within the kernel. The default value \\f$(-1,-1)\\f$ means that the anchor
    is at the kernel center.

  - **delta**: `double`.

    Value added to the filtered results before storing them.

  - **borderType**: `integer()`.

    Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image of the same size and the same number of channels as src .

  The function applies a separable linear filter to the image. That is, first, every row of src is
  filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
  kernel kernelY. The final result shifted by delta is stored in dst .
  @sa  filter2D, Sobel, GaussianBlur, boxFilter, blur

  Python prototype (for reference only):
  ```python3
  sepFilter2D(src, ddepth, kernelX, kernelY[, dst[, anchor[, delta[, borderType]]]]) -> dst
  ```
  """
  @spec sepFilter2D(Evision.Mat.maybe_mat_in(), integer(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def sepFilter2D(src, ddepth, kernelX, kernelY) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and (is_struct(kernelX, Evision.Mat) or is_struct(kernelX, Nx.Tensor) or is_number(kernelX) or is_tuple(kernelX)) and (is_struct(kernelY, Evision.Mat) or is_struct(kernelY, Nx.Tensor) or is_number(kernelY) or is_tuple(kernelY))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      kernelX: Evision.Internal.Structurise.from_struct(kernelX),
      kernelY: Evision.Internal.Structurise.from_struct(kernelY)
    ]
    :evision_nif.sepFilter2D(positional)
    |> to_struct()
  end

  @doc """
  Initializes a scaled identity matrix.
  ##### Keyword Arguments
  - **s**: `Evision.scalar()`.

    value to assign to diagonal elements.

  ##### Return
  - **mtx**: `Evision.Mat.t()`.

    matrix to initialize (not necessarily square).

  The function cv::setIdentity initializes a scaled identity matrix:
  \\f[\\texttt{mtx} (i,j)= \\fork{\\texttt{value}}{ if \\(i=j\\)}{0}{otherwise}\\f]
  The function can also be emulated using the matrix initializers and the
  matrix expressions:
  ```
  Mat A = Mat::eye(4, 3, CV_32F)*5;
  // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
  ```
  @sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=

  Python prototype (for reference only):
  ```python3
  setIdentity(mtx[, s]) -> mtx
  ```
  """
  @spec setIdentity(Evision.Mat.maybe_mat_in(), [{:s, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def setIdentity(mtx, opts) when (is_struct(mtx, Evision.Mat) or is_struct(mtx, Nx.Tensor) or is_number(mtx) or is_tuple(mtx)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:s])
    positional = [
      mtx: Evision.Internal.Structurise.from_struct(mtx)
    ]
    :evision_nif.setIdentity(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Initializes a scaled identity matrix.
  ##### Keyword Arguments
  - **s**: `Evision.scalar()`.

    value to assign to diagonal elements.

  ##### Return
  - **mtx**: `Evision.Mat.t()`.

    matrix to initialize (not necessarily square).

  The function cv::setIdentity initializes a scaled identity matrix:
  \\f[\\texttt{mtx} (i,j)= \\fork{\\texttt{value}}{ if \\(i=j\\)}{0}{otherwise}\\f]
  The function can also be emulated using the matrix initializers and the
  matrix expressions:
  ```
  Mat A = Mat::eye(4, 3, CV_32F)*5;
  // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
  ```
  @sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=

  Python prototype (for reference only):
  ```python3
  setIdentity(mtx[, s]) -> mtx
  ```
  """
  @spec setIdentity(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def setIdentity(mtx) when (is_struct(mtx, Evision.Mat) or is_struct(mtx, Nx.Tensor) or is_number(mtx) or is_tuple(mtx))
  do
    positional = [
      mtx: Evision.Internal.Structurise.from_struct(mtx)
    ]
    :evision_nif.setIdentity(positional)
    |> to_struct()
  end

  @doc """
  setLogLevel

  ##### Positional Arguments
  - **level**: `integer()`

  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  setLogLevel(level) -> retval
  ```
  """
  @spec setLogLevel(integer()) :: integer() | {:error, String.t()}
  def setLogLevel(level) when is_integer(level)
  do
    positional = [
      level: Evision.Internal.Structurise.from_struct(level)
    ]
    :evision_nif.setLogLevel(positional)
    |> to_struct()
  end

  @doc """
  OpenCV will try to set the number of threads for subsequent parallel regions.

  ##### Positional Arguments
  - **nthreads**: `integer()`.

    Number of threads used by OpenCV.

  If threads == 1, OpenCV will disable threading optimizations and run all it's functions
  sequentially. Passing threads \\< 0 will reset threads number to system default.
  The function is not thread-safe. It must not be called in parallel region or concurrent threads.
  OpenCV will try to run its functions with specified threads number, but some behaviour differs from
  framework:
  - `TBB` - User-defined parallel constructions will run with the same threads number, if
    another is not specified. If later on user creates his own scheduler, OpenCV will use it.

  - `OpenMP` - No special defined behaviour.
  - `Concurrency` - If threads == 1, OpenCV will disable threading optimizations and run its
    functions sequentially.

  - `GCD` - Supports only values \\<= 0.
  - `C=` - No special defined behaviour.
  @sa getNumThreads, getThreadNum

  Python prototype (for reference only):
  ```python3
  setNumThreads(nthreads) -> None
  ```
  """
  @spec setNumThreads(integer()) :: :ok | {:error, String.t()}
  def setNumThreads(nthreads) when is_integer(nthreads)
  do
    positional = [
      nthreads: Evision.Internal.Structurise.from_struct(nthreads)
    ]
    :evision_nif.setNumThreads(positional)
    |> to_struct()
  end

  @doc """
  Sets state of default random number generator.

  ##### Positional Arguments
  - **seed**: `integer()`.

    new state for default random number generator

  The function cv::setRNGSeed sets state of default random number generator to custom value.
  @sa RNG, randu, randn

  Python prototype (for reference only):
  ```python3
  setRNGSeed(seed) -> None
  ```
  """
  @spec setRNGSeed(integer()) :: :ok | {:error, String.t()}
  def setRNGSeed(seed) when is_integer(seed)
  do
    positional = [
      seed: Evision.Internal.Structurise.from_struct(seed)
    ]
    :evision_nif.setRNGSeed(positional)
    |> to_struct()
  end

  @doc """
  Sets the trackbar maximum position.

  ##### Positional Arguments
  - **trackbarname**: `String`.

    Name of the trackbar.

  - **winname**: `String`.

    Name of the window that is the parent of trackbar.

  - **maxval**: `integer()`.

    New maximum position.

  The function sets the maximum position of the specified trackbar in the specified window.
  **Note**: [__Qt Backend Only__] winname can be empty if the trackbar is attached to the control
  panel.

  Python prototype (for reference only):
  ```python3
  setTrackbarMax(trackbarname, winname, maxval) -> None
  ```
  """
  @spec setTrackbarMax(binary(), binary(), integer()) :: :ok | {:error, String.t()}
  def setTrackbarMax(trackbarname, winname, maxval) when is_binary(trackbarname) and is_binary(winname) and is_integer(maxval)
  do
    positional = [
      trackbarname: Evision.Internal.Structurise.from_struct(trackbarname),
      winname: Evision.Internal.Structurise.from_struct(winname),
      maxval: Evision.Internal.Structurise.from_struct(maxval)
    ]
    :evision_nif.setTrackbarMax(positional)
    |> to_struct()
  end

  @doc """
  Sets the trackbar minimum position.

  ##### Positional Arguments
  - **trackbarname**: `String`.

    Name of the trackbar.

  - **winname**: `String`.

    Name of the window that is the parent of trackbar.

  - **minval**: `integer()`.

    New minimum position.

  The function sets the minimum position of the specified trackbar in the specified window.
  **Note**: [__Qt Backend Only__] winname can be empty if the trackbar is attached to the control
  panel.

  Python prototype (for reference only):
  ```python3
  setTrackbarMin(trackbarname, winname, minval) -> None
  ```
  """
  @spec setTrackbarMin(binary(), binary(), integer()) :: :ok | {:error, String.t()}
  def setTrackbarMin(trackbarname, winname, minval) when is_binary(trackbarname) and is_binary(winname) and is_integer(minval)
  do
    positional = [
      trackbarname: Evision.Internal.Structurise.from_struct(trackbarname),
      winname: Evision.Internal.Structurise.from_struct(winname),
      minval: Evision.Internal.Structurise.from_struct(minval)
    ]
    :evision_nif.setTrackbarMin(positional)
    |> to_struct()
  end

  @doc """
  Sets the trackbar position.

  ##### Positional Arguments
  - **trackbarname**: `String`.

    Name of the trackbar.

  - **winname**: `String`.

    Name of the window that is the parent of trackbar.

  - **pos**: `integer()`.

    New position.

  The function sets the position of the specified trackbar in the specified window.
  **Note**: [__Qt Backend Only__] winname can be empty if the trackbar is attached to the control
  panel.

  Python prototype (for reference only):
  ```python3
  setTrackbarPos(trackbarname, winname, pos) -> None
  ```
  """
  @spec setTrackbarPos(binary(), binary(), integer()) :: :ok | {:error, String.t()}
  def setTrackbarPos(trackbarname, winname, pos) when is_binary(trackbarname) and is_binary(winname) and is_integer(pos)
  do
    positional = [
      trackbarname: Evision.Internal.Structurise.from_struct(trackbarname),
      winname: Evision.Internal.Structurise.from_struct(winname),
      pos: Evision.Internal.Structurise.from_struct(pos)
    ]
    :evision_nif.setTrackbarPos(positional)
    |> to_struct()
  end

  @doc """
  setUseOpenVX

  ##### Positional Arguments
  - **flag**: `bool`

  Python prototype (for reference only):
  ```python3
  setUseOpenVX(flag) -> None
  ```
  """
  @spec setUseOpenVX(boolean()) :: :ok | {:error, String.t()}
  def setUseOpenVX(flag) when is_boolean(flag)
  do
    positional = [
      flag: Evision.Internal.Structurise.from_struct(flag)
    ]
    :evision_nif.setUseOpenVX(positional)
    |> to_struct()
  end

  @doc """
  Enables or disables the optimized code.

  ##### Positional Arguments
  - **onoff**: `bool`.

    The boolean flag specifying whether the optimized code should be used (onoff=true)
    or not (onoff=false).

  The function can be used to dynamically turn on and off optimized dispatched code (code that uses SSE4.2, AVX/AVX2,
  and other instructions on the platforms that support it). It sets a global flag that is further
  checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only
  safe to call the function on the very top level in your application where you can be sure that no
  other OpenCV function is currently executed.
  By default, the optimized code is enabled unless you disable it in CMake. The current status can be
  retrieved using useOptimized.

  Python prototype (for reference only):
  ```python3
  setUseOptimized(onoff) -> None
  ```
  """
  @spec setUseOptimized(boolean()) :: :ok | {:error, String.t()}
  def setUseOptimized(onoff) when is_boolean(onoff)
  do
    positional = [
      onoff: Evision.Internal.Structurise.from_struct(onoff)
    ]
    :evision_nif.setUseOptimized(positional)
    |> to_struct()
  end

  @doc """
  Changes parameters of a window dynamically.

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **prop_id**: `integer()`.

    Window property to edit. The supported operation flags are: (cv::WindowPropertyFlags)

  - **prop_value**: `double`.

    New value of the window property. The supported flags are: (cv::WindowFlags)

  The function setWindowProperty enables changing properties of a window.

  **Note**: [__Wayland Backend Only__] This function is not supported.

  Python prototype (for reference only):
  ```python3
  setWindowProperty(winname, prop_id, prop_value) -> None
  ```
  """
  @spec setWindowProperty(binary(), integer(), number()) :: :ok | {:error, String.t()}
  def setWindowProperty(winname, prop_id, prop_value) when is_binary(winname) and is_integer(prop_id) and is_number(prop_value)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      prop_id: Evision.Internal.Structurise.from_struct(prop_id),
      prop_value: Evision.Internal.Structurise.from_struct(prop_value)
    ]
    :evision_nif.setWindowProperty(positional)
    |> to_struct()
  end

  @doc """
  Updates window title

  ##### Positional Arguments
  - **winname**: `String`.

    Name of the window.

  - **title**: `String`.

    New title.

  Python prototype (for reference only):
  ```python3
  setWindowTitle(winname, title) -> None
  ```
  """
  @spec setWindowTitle(binary(), binary()) :: :ok | {:error, String.t()}
  def setWindowTitle(winname, title) when is_binary(winname) and is_binary(title)
  do
    positional = [
      winname: Evision.Internal.Structurise.from_struct(winname),
      title: Evision.Internal.Structurise.from_struct(title)
    ]
    :evision_nif.setWindowTitle(positional)
    |> to_struct()
  end

  @doc """
  Solves one or more linear systems or least-squares problems.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    input matrix on the left-hand side of the system.

  - **src2**: `Evision.Mat`.

    input matrix on the right-hand side of the system.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    solution (matrix inversion) method (#DecompTypes)

  ##### Return
  - **retval**: `bool`
  - **dst**: `Evision.Mat.t()`.

    output solution.

  The function cv::solve solves a linear system or least-squares problem (the
  latter is possible with SVD or QR methods, or by specifying the flag
  #DECOMP_NORMAL ):
  \\f[\\texttt{dst} =  \\arg \\min \\_X \\| \\texttt{src1} \\cdot \\texttt{X} -  \\texttt{src2} \\|\\f]
  If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1
  if src1 (or \\f$\\texttt{src1}^T\\texttt{src1}\\f$ ) is non-singular. Otherwise,
  it returns 0. In the latter case, dst is not valid. Other methods find a
  pseudo-solution in case of a singular left-hand side part.
  **Note**: If you want to find a unity-norm solution of an under-defined
  singular system \\f$\\texttt{src1}\\cdot\\texttt{dst}=0\\f$ , the function solve
  will not do the work. Use SVD::solveZ instead.
  @sa invert, SVD, eigen

  Python prototype (for reference only):
  ```python3
  solve(src1, src2[, dst[, flags]]) -> retval, dst
  ```
  """
  @spec solve(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:flags, term()}] | nil) :: Evision.Mat.t() | false | {:error, String.t()}
  def solve(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.solve(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Solves one or more linear systems or least-squares problems.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    input matrix on the left-hand side of the system.

  - **src2**: `Evision.Mat`.

    input matrix on the right-hand side of the system.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    solution (matrix inversion) method (#DecompTypes)

  ##### Return
  - **retval**: `bool`
  - **dst**: `Evision.Mat.t()`.

    output solution.

  The function cv::solve solves a linear system or least-squares problem (the
  latter is possible with SVD or QR methods, or by specifying the flag
  #DECOMP_NORMAL ):
  \\f[\\texttt{dst} =  \\arg \\min \\_X \\| \\texttt{src1} \\cdot \\texttt{X} -  \\texttt{src2} \\|\\f]
  If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1
  if src1 (or \\f$\\texttt{src1}^T\\texttt{src1}\\f$ ) is non-singular. Otherwise,
  it returns 0. In the latter case, dst is not valid. Other methods find a
  pseudo-solution in case of a singular left-hand side part.
  **Note**: If you want to find a unity-norm solution of an under-defined
  singular system \\f$\\texttt{src1}\\cdot\\texttt{dst}=0\\f$ , the function solve
  will not do the work. Use SVD::solveZ instead.
  @sa invert, SVD, eigen

  Python prototype (for reference only):
  ```python3
  solve(src1, src2[, dst[, flags]]) -> retval, dst
  ```
  """
  @spec solve(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | false | {:error, String.t()}
  def solve(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.solve(positional)
    |> to_struct()
  end

  @doc """
  Finds the real roots of a cubic equation.

  ##### Positional Arguments
  - **coeffs**: `Evision.Mat`.

    equation coefficients, an array of 3 or 4 elements.

  ##### Return
  - **retval**: `integer()`
  - **roots**: `Evision.Mat.t()`.

    output array of real roots that has 1 or 3 elements.

  The function solveCubic finds the real roots of a cubic equation:
  - if coeffs is a 4-element vector:
    \\f[\\texttt{coeffs} \\[0] x^3 +  \\texttt{coeffs} \\[1] x^2 +  \\texttt{coeffs} \\[2] x +  \\texttt{coeffs} \\[3] = 0\\f]

  - if coeffs is a 3-element vector:
    \\f[x^3 +  \\texttt{coeffs} \\[0] x^2 +  \\texttt{coeffs} \\[1] x +  \\texttt{coeffs} \\[2] = 0\\f]

  The roots are stored in the roots array.
  @return number of real roots. It can be 0, 1 or 2.

  Python prototype (for reference only):
  ```python3
  solveCubic(coeffs[, roots]) -> retval, roots
  ```
  """
  @spec solveCubic(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def solveCubic(coeffs, opts) when (is_struct(coeffs, Evision.Mat) or is_struct(coeffs, Nx.Tensor) or is_number(coeffs) or is_tuple(coeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      coeffs: Evision.Internal.Structurise.from_struct(coeffs)
    ]
    :evision_nif.solveCubic(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the real roots of a cubic equation.

  ##### Positional Arguments
  - **coeffs**: `Evision.Mat`.

    equation coefficients, an array of 3 or 4 elements.

  ##### Return
  - **retval**: `integer()`
  - **roots**: `Evision.Mat.t()`.

    output array of real roots that has 1 or 3 elements.

  The function solveCubic finds the real roots of a cubic equation:
  - if coeffs is a 4-element vector:
    \\f[\\texttt{coeffs} \\[0] x^3 +  \\texttt{coeffs} \\[1] x^2 +  \\texttt{coeffs} \\[2] x +  \\texttt{coeffs} \\[3] = 0\\f]

  - if coeffs is a 3-element vector:
    \\f[x^3 +  \\texttt{coeffs} \\[0] x^2 +  \\texttt{coeffs} \\[1] x +  \\texttt{coeffs} \\[2] = 0\\f]

  The roots are stored in the roots array.
  @return number of real roots. It can be 0, 1 or 2.

  Python prototype (for reference only):
  ```python3
  solveCubic(coeffs[, roots]) -> retval, roots
  ```
  """
  @spec solveCubic(Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def solveCubic(coeffs) when (is_struct(coeffs, Evision.Mat) or is_struct(coeffs, Nx.Tensor) or is_number(coeffs) or is_tuple(coeffs))
  do
    positional = [
      coeffs: Evision.Internal.Structurise.from_struct(coeffs)
    ]
    :evision_nif.solveCubic(positional)
    |> to_struct()
  end

  @doc """
  Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method).

  ##### Positional Arguments
  - **func**: `Evision.Mat`.

    This row-vector corresponds to \\f$c\\f$ in the LP problem formulation (see above). It should
    contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted,
    in the latter case it is understood to correspond to \\f$c^T\\f$.

  - **constr**: `Evision.Mat`.

    `m`-by-`n+1` matrix, whose rightmost column corresponds to \\f$b\\f$ in formulation above
    and the remaining to \\f$A\\f$. It should contain 32- or 64-bit floating point numbers.

  - **constr_eps**: `double`.

    allowed numeric disparity for constraints

  ##### Return
  - **retval**: `integer()`
  - **z**: `Evision.Mat.t()`.

    The solution will be returned here as a column-vector - it corresponds to \\f$c\\f$ in the
    formulation above. It will contain 64-bit floating point numbers.

  What we mean here by "linear programming problem" (or LP problem, for short) can be formulated as:
  \\f[\\mbox{Maximize } c\\cdot x\\\\\\\\
  \\mbox{Subject to:}\\\\\\\\
  Ax\\leq b\\\\\\\\
  x\\geq 0\\f]
  Where \\f$c\\f$ is fixed `1`-by-`n` row-vector, \\f$A\\f$ is fixed `m`-by-`n` matrix, \\f$b\\f$ is fixed `m`-by-`1`
  column vector and \\f$x\\f$ is an arbitrary `n`-by-`1` column vector, which satisfies the constraints.
  Simplex algorithm is one of many algorithms that are designed to handle this sort of problems
  efficiently. Although it is not optimal in theoretical sense (there exist algorithms that can solve
  any problem written as above in polynomial time, while simplex method degenerates to exponential
  time for some special cases), it is well-studied, easy to implement and is shown to work well for
  real-life purposes.
  The particular implementation is taken almost verbatim from **Introduction to Algorithms, third
  edition** by T. H. Cormen, C. E. Leiserson, R. L. Rivest and Clifford Stein. In particular, the
  Bland's rule <http://en.wikipedia.org/wiki/Bland%27s_rule> is used to prevent cycling.
  @return One of cv::SolveLPResult

  Python prototype (for reference only):
  ```python3
  solveLP(Func, Constr, constr_eps[, z]) -> retval, z
  ```
  """
  @spec solveLP(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def solveLP(func, constr, constr_eps, opts) when (is_struct(func, Evision.Mat) or is_struct(func, Nx.Tensor) or is_number(func) or is_tuple(func)) and (is_struct(constr, Evision.Mat) or is_struct(constr, Nx.Tensor) or is_number(constr) or is_tuple(constr)) and is_number(constr_eps) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      func: Evision.Internal.Structurise.from_struct(func),
      constr: Evision.Internal.Structurise.from_struct(constr),
      constr_eps: Evision.Internal.Structurise.from_struct(constr_eps)
    ]
    :evision_nif.solveLP(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  #### Variant 1:
  Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method).

  ##### Positional Arguments
  - **func**: `Evision.Mat`.

    This row-vector corresponds to \\f$c\\f$ in the LP problem formulation (see above). It should
    contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted,
    in the latter case it is understood to correspond to \\f$c^T\\f$.

  - **constr**: `Evision.Mat`.

    `m`-by-`n+1` matrix, whose rightmost column corresponds to \\f$b\\f$ in formulation above
    and the remaining to \\f$A\\f$. It should contain 32- or 64-bit floating point numbers.

  - **constr_eps**: `double`.

    allowed numeric disparity for constraints

  ##### Return
  - **retval**: `integer()`
  - **z**: `Evision.Mat.t()`.

    The solution will be returned here as a column-vector - it corresponds to \\f$c\\f$ in the
    formulation above. It will contain 64-bit floating point numbers.

  What we mean here by "linear programming problem" (or LP problem, for short) can be formulated as:
  \\f[\\mbox{Maximize } c\\cdot x\\\\\\\\
  \\mbox{Subject to:}\\\\\\\\
  Ax\\leq b\\\\\\\\
  x\\geq 0\\f]
  Where \\f$c\\f$ is fixed `1`-by-`n` row-vector, \\f$A\\f$ is fixed `m`-by-`n` matrix, \\f$b\\f$ is fixed `m`-by-`1`
  column vector and \\f$x\\f$ is an arbitrary `n`-by-`1` column vector, which satisfies the constraints.
  Simplex algorithm is one of many algorithms that are designed to handle this sort of problems
  efficiently. Although it is not optimal in theoretical sense (there exist algorithms that can solve
  any problem written as above in polynomial time, while simplex method degenerates to exponential
  time for some special cases), it is well-studied, easy to implement and is shown to work well for
  real-life purposes.
  The particular implementation is taken almost verbatim from **Introduction to Algorithms, third
  edition** by T. H. Cormen, C. E. Leiserson, R. L. Rivest and Clifford Stein. In particular, the
  Bland's rule <http://en.wikipedia.org/wiki/Bland%27s_rule> is used to prevent cycling.
  @return One of cv::SolveLPResult

  Python prototype (for reference only):
  ```python3
  solveLP(Func, Constr, constr_eps[, z]) -> retval, z
  ```
  #### Variant 2:
  solveLP

  ##### Positional Arguments
  - **func**: `Evision.Mat`
  - **constr**: `Evision.Mat`

  ##### Return
  - **retval**: `integer()`
  - **z**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  solveLP(Func, Constr[, z]) -> retval, z
  ```

  """
  @spec solveLP(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def solveLP(func, constr, opts) when (is_struct(func, Evision.Mat) or is_struct(func, Nx.Tensor) or is_number(func) or is_tuple(func)) and (is_struct(constr, Evision.Mat) or is_struct(constr, Nx.Tensor) or is_number(constr) or is_tuple(constr)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      func: Evision.Internal.Structurise.from_struct(func),
      constr: Evision.Internal.Structurise.from_struct(constr)
    ]
    :evision_nif.solveLP(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end
  @spec solveLP(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), number()) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def solveLP(func, constr, constr_eps) when (is_struct(func, Evision.Mat) or is_struct(func, Nx.Tensor) or is_number(func) or is_tuple(func)) and (is_struct(constr, Evision.Mat) or is_struct(constr, Nx.Tensor) or is_number(constr) or is_tuple(constr)) and is_number(constr_eps)
  do
    positional = [
      func: Evision.Internal.Structurise.from_struct(func),
      constr: Evision.Internal.Structurise.from_struct(constr),
      constr_eps: Evision.Internal.Structurise.from_struct(constr_eps)
    ]
    :evision_nif.solveLP(positional)
    |> to_struct()
  end

  @doc """
  solveLP

  ##### Positional Arguments
  - **func**: `Evision.Mat`
  - **constr**: `Evision.Mat`

  ##### Return
  - **retval**: `integer()`
  - **z**: `Evision.Mat.t()`.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  solveLP(Func, Constr[, z]) -> retval, z
  ```
  """
  @spec solveLP(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), Evision.Mat.t()} | {:error, String.t()}
  def solveLP(func, constr) when (is_struct(func, Evision.Mat) or is_struct(func, Nx.Tensor) or is_number(func) or is_tuple(func)) and (is_struct(constr, Evision.Mat) or is_struct(constr, Nx.Tensor) or is_number(constr) or is_tuple(constr))
  do
    positional = [
      func: Evision.Internal.Structurise.from_struct(func),
      constr: Evision.Internal.Structurise.from_struct(constr)
    ]
    :evision_nif.solveLP(positional)
    |> to_struct()
  end

  @doc """
  Finds an object pose from 3 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, 3x3 1-channel or
    1x3/3x1 3-channel. vector\\<Point3f\\> can be also passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel.
    vector\\<Point2f\\> can be also passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  - **flags**: `integer()`.

    Method for solving a P3P problem:
    - @ref SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang
      "Complete Solution Classification for the Perspective-Three-Point Problem" (@cite gao2003complete).
    - @ref SOLVEPNP_AP3P Method is based on the paper of T. Ke and S. Roumeliotis.
      "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (@cite Ke17).

  ##### Return
  - **retval**: `integer()`
  - **rvecs**: `[Evision.Mat]`.

    Output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from
    the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions.

  - **tvecs**: `[Evision.Mat]`.

    Output translation vectors.

  @see @ref calib3d_solvePnP

  The function estimates the object pose given 3 object points, their corresponding image
  projections, as well as the camera intrinsic matrix and the distortion coefficients.
  **Note**: 
  The solutions are sorted by reprojection errors (lowest to highest).

  Python prototype (for reference only):
  ```python3
  solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, flags[, rvecs[, tvecs]]) -> retval, rvecs, tvecs
  ```
  """
  @spec solveP3P(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: {integer(), list(Evision.Mat.t()), list(Evision.Mat.t())} | {:error, String.t()}
  def solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, flags, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.solveP3P(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds an object pose from 3 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, 3x3 1-channel or
    1x3/3x1 3-channel. vector\\<Point3f\\> can be also passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel.
    vector\\<Point2f\\> can be also passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  - **flags**: `integer()`.

    Method for solving a P3P problem:
    - @ref SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang
      "Complete Solution Classification for the Perspective-Three-Point Problem" (@cite gao2003complete).
    - @ref SOLVEPNP_AP3P Method is based on the paper of T. Ke and S. Roumeliotis.
      "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (@cite Ke17).

  ##### Return
  - **retval**: `integer()`
  - **rvecs**: `[Evision.Mat]`.

    Output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from
    the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions.

  - **tvecs**: `[Evision.Mat]`.

    Output translation vectors.

  @see @ref calib3d_solvePnP

  The function estimates the object pose given 3 object points, their corresponding image
  projections, as well as the camera intrinsic matrix and the distortion coefficients.
  **Note**: 
  The solutions are sorted by reprojection errors (lowest to highest).

  Python prototype (for reference only):
  ```python3
  solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, flags[, rvecs[, tvecs]]) -> retval, rvecs, tvecs
  ```
  """
  @spec solveP3P(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer()) :: {integer(), list(Evision.Mat.t()), list(Evision.Mat.t())} | {:error, String.t()}
  def solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, flags) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and is_integer(flags)
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.solveP3P(positional)
    |> to_struct()
  end

  @doc """
  Finds an object pose from 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or
    1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can be also passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **useExtrinsicGuess**: `bool`.

    Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
    the provided rvec and tvec values as initial approximations of the rotation and translation
    vectors, respectively, and further optimizes them.

  - **flags**: `integer()`.

    Method for solving a PnP problem: see @ref calib3d_solvePnP_flags

  ##### Return
  - **retval**: `bool`
  - **rvec**: `Evision.Mat.t()`.

    Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system.

  - **tvec**: `Evision.Mat.t()`.

    Output translation vector.

  @see @ref calib3d_solvePnP
  This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
  coordinate frame to the camera coordinate frame, using different methods:
  - P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): need 4 input points to return a unique solution.
  - @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be coplanar.
  - @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
    Number of input points must be 4. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]
  - for all the other flags, number of input points must be >= 4 and object points can be in any configuration.

  More information about Perspective-n-Points is described in @ref calib3d_solvePnP
  **Note**: 
  - An example of how to use solvePnP for planar augmented reality can be found at
    opencv_source_code/samples/python/plane_ar.py

  - If you are using Python:
  - Numpy array slices won't work as input because solvePnP requires contiguous
    arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
    modules/calib3d/src/solvepnp.cpp version 2.4.9)

  - The P3P algorithm requires image points to be in an array of shape (N,1,2) due
    to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)
    which requires 2-channel information.

  - Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
    it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
    np.ascontiguousarray(D[:,:2]).reshape((N,1,2))

  - The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are
    unstable and sometimes give completely wrong results. If you pass one of these two
    flags, @ref SOLVEPNP_EPNP method will be used instead.

  - The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P
    methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
    of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).

  - With @ref SOLVEPNP_ITERATIVE method and `useExtrinsicGuess=true`, the minimum number of points is 3 (3 points
    are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
    global solution to converge.

  - With @ref SOLVEPNP_IPPE input points must be >= 4 and object points must be coplanar.
  - With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
    Number of input points must be 4. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]
  - With @ref SOLVEPNP_SQPNP input points must be >= 3

  Python prototype (for reference only):
  ```python3
  solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, useExtrinsicGuess[, flags]]]]) -> retval, rvec, tvec
  ```
  """
  @spec solvePnP(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:useExtrinsicGuess, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :useExtrinsicGuess])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.solvePnP(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds an object pose from 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or
    1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can be also passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **useExtrinsicGuess**: `bool`.

    Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
    the provided rvec and tvec values as initial approximations of the rotation and translation
    vectors, respectively, and further optimizes them.

  - **flags**: `integer()`.

    Method for solving a PnP problem: see @ref calib3d_solvePnP_flags

  ##### Return
  - **retval**: `bool`
  - **rvec**: `Evision.Mat.t()`.

    Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system.

  - **tvec**: `Evision.Mat.t()`.

    Output translation vector.

  @see @ref calib3d_solvePnP
  This function returns the rotation and the translation vectors that transform a 3D point expressed in the object
  coordinate frame to the camera coordinate frame, using different methods:
  - P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): need 4 input points to return a unique solution.
  - @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be coplanar.
  - @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
    Number of input points must be 4. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]
  - for all the other flags, number of input points must be >= 4 and object points can be in any configuration.

  More information about Perspective-n-Points is described in @ref calib3d_solvePnP
  **Note**: 
  - An example of how to use solvePnP for planar augmented reality can be found at
    opencv_source_code/samples/python/plane_ar.py

  - If you are using Python:
  - Numpy array slices won't work as input because solvePnP requires contiguous
    arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
    modules/calib3d/src/solvepnp.cpp version 2.4.9)

  - The P3P algorithm requires image points to be in an array of shape (N,1,2) due
    to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)
    which requires 2-channel information.

  - Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
    it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
    np.ascontiguousarray(D[:,:2]).reshape((N,1,2))

  - The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are
    unstable and sometimes give completely wrong results. If you pass one of these two
    flags, @ref SOLVEPNP_EPNP method will be used instead.

  - The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P
    methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
    of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).

  - With @ref SOLVEPNP_ITERATIVE method and `useExtrinsicGuess=true`, the minimum number of points is 3 (3 points
    are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
    global solution to converge.

  - With @ref SOLVEPNP_IPPE input points must be >= 4 and object points must be coplanar.
  - With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
    Number of input points must be 4. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]
  - With @ref SOLVEPNP_SQPNP input points must be >= 3

  Python prototype (for reference only):
  ```python3
  solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, useExtrinsicGuess[, flags]]]]) -> retval, rvec, tvec
  ```
  """
  @spec solvePnP(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.solvePnP(positional)
    |> to_struct()
  end

  @doc """
  Finds an object pose from 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or
    1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can be also passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **useExtrinsicGuess**: `bool`.

    Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
    the provided rvec and tvec values as initial approximations of the rotation and translation
    vectors, respectively, and further optimizes them.

  - **flags**: `SolvePnPMethod`.

    Method for solving a PnP problem: see @ref calib3d_solvePnP_flags

  - **rvec**: `Evision.Mat`.

    Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE
    and useExtrinsicGuess is set to true.

  - **tvec**: `Evision.Mat`.

    Translation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE
    and useExtrinsicGuess is set to true.

  ##### Return
  - **retval**: `integer()`
  - **rvecs**: `[Evision.Mat]`.

    Vector of output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from
    the model coordinate system to the camera coordinate system.

  - **tvecs**: `[Evision.Mat]`.

    Vector of output translation vectors.

  - **reprojectionError**: `Evision.Mat.t()`.

    Optional vector of reprojection error, that is the RMS error
    (\\f$ \\text{RMSE} = \\sqrt{\\frac{\\sum_{i}^{N} \\left ( \\hat{y_i} - y_i \\right )^2}{N}} \\f$) between the input image points
    and the 3D object points projected with the estimated pose.

  @see @ref calib3d_solvePnP
  This function returns a list of all the possible solutions (a solution is a <rotation vector, translation vector>
  couple), depending on the number of input points and the chosen method:
  - P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
  - @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be coplanar. Returns 2 solutions.
  - @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
    Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]
  - for all the other flags, number of input points must be >= 4 and object points can be in any configuration.
    Only 1 solution is returned.

  More information is described in @ref calib3d_solvePnP
  **Note**: 
  - An example of how to use solvePnP for planar augmented reality can be found at
    opencv_source_code/samples/python/plane_ar.py

  - If you are using Python:
  - Numpy array slices won't work as input because solvePnP requires contiguous
    arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
    modules/calib3d/src/solvepnp.cpp version 2.4.9)

  - The P3P algorithm requires image points to be in an array of shape (N,1,2) due
    to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)
    which requires 2-channel information.

  - Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
    it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
    np.ascontiguousarray(D[:,:2]).reshape((N,1,2))

  - The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are
    unstable and sometimes give completely wrong results. If you pass one of these two
    flags, @ref SOLVEPNP_EPNP method will be used instead.

  - The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P
    methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
    of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).

  - With @ref SOLVEPNP_ITERATIVE method and `useExtrinsicGuess=true`, the minimum number of points is 3 (3 points
    are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
    global solution to converge.

  - With @ref SOLVEPNP_IPPE input points must be >= 4 and object points must be coplanar.
  - With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
    Number of input points must be 4. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]

  Python prototype (for reference only):
  ```python3
  solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvecs[, tvecs[, useExtrinsicGuess[, flags[, rvec[, tvec[, reprojectionError]]]]]]]) -> retval, rvecs, tvecs, reprojectionError
  ```
  """
  @spec solvePnPGeneric(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:flags, term()} | {:rvec, term()} | {:tvec, term()} | {:useExtrinsicGuess, term()}] | nil) :: {integer(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:flags, :rvec, :tvec, :useExtrinsicGuess])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.solvePnPGeneric(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds an object pose from 3D-2D point correspondences.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or
    1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can be also passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **useExtrinsicGuess**: `bool`.

    Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses
    the provided rvec and tvec values as initial approximations of the rotation and translation
    vectors, respectively, and further optimizes them.

  - **flags**: `SolvePnPMethod`.

    Method for solving a PnP problem: see @ref calib3d_solvePnP_flags

  - **rvec**: `Evision.Mat`.

    Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE
    and useExtrinsicGuess is set to true.

  - **tvec**: `Evision.Mat`.

    Translation vector used to initialize an iterative PnP refinement algorithm, when flag is @ref SOLVEPNP_ITERATIVE
    and useExtrinsicGuess is set to true.

  ##### Return
  - **retval**: `integer()`
  - **rvecs**: `[Evision.Mat]`.

    Vector of output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from
    the model coordinate system to the camera coordinate system.

  - **tvecs**: `[Evision.Mat]`.

    Vector of output translation vectors.

  - **reprojectionError**: `Evision.Mat.t()`.

    Optional vector of reprojection error, that is the RMS error
    (\\f$ \\text{RMSE} = \\sqrt{\\frac{\\sum_{i}^{N} \\left ( \\hat{y_i} - y_i \\right )^2}{N}} \\f$) between the input image points
    and the 3D object points projected with the estimated pose.

  @see @ref calib3d_solvePnP
  This function returns a list of all the possible solutions (a solution is a <rotation vector, translation vector>
  couple), depending on the number of input points and the chosen method:
  - P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.
  - @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be coplanar. Returns 2 solutions.
  - @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.
    Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]
  - for all the other flags, number of input points must be >= 4 and object points can be in any configuration.
    Only 1 solution is returned.

  More information is described in @ref calib3d_solvePnP
  **Note**: 
  - An example of how to use solvePnP for planar augmented reality can be found at
    opencv_source_code/samples/python/plane_ar.py

  - If you are using Python:
  - Numpy array slices won't work as input because solvePnP requires contiguous
    arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of
    modules/calib3d/src/solvepnp.cpp version 2.4.9)

  - The P3P algorithm requires image points to be in an array of shape (N,1,2) due
    to its calling of #undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)
    which requires 2-channel information.

  - Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of
    it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =
    np.ascontiguousarray(D[:,:2]).reshape((N,1,2))

  - The methods @ref SOLVEPNP_DLS and @ref SOLVEPNP_UPNP cannot be used as the current implementations are
    unstable and sometimes give completely wrong results. If you pass one of these two
    flags, @ref SOLVEPNP_EPNP method will be used instead.

  - The minimum number of points is 4 in the general case. In the case of @ref SOLVEPNP_P3P and @ref SOLVEPNP_AP3P
    methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions
    of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).

  - With @ref SOLVEPNP_ITERATIVE method and `useExtrinsicGuess=true`, the minimum number of points is 3 (3 points
    are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the
    global solution to converge.

  - With @ref SOLVEPNP_IPPE input points must be >= 4 and object points must be coplanar.
  - With @ref SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.
    Number of input points must be 4. Object points must be defined in the following order:

  - point 0: [-squareLength / 2,  squareLength / 2, 0]
  - point 1: [ squareLength / 2,  squareLength / 2, 0]
  - point 2: [ squareLength / 2, -squareLength / 2, 0]
  - point 3: [-squareLength / 2, -squareLength / 2, 0]

  Python prototype (for reference only):
  ```python3
  solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvecs[, tvecs[, useExtrinsicGuess[, flags[, rvec[, tvec[, reprojectionError]]]]]]]) -> retval, rvecs, tvecs, reprojectionError
  ```
  """
  @spec solvePnPGeneric(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {integer(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.solvePnPGeneric(positional)
    |> to_struct()
  end

  @doc """
  solvePnPRansac

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`
  - **imagePoints**: `Evision.Mat`
  - **distCoeffs**: `Evision.Mat`

  ##### Keyword Arguments
  - **params**: `Evision.UsacParams`.

  ##### Return
  - **retval**: `bool`
  - **cameraMatrix**: `Evision.Mat.t()`
  - **rvec**: `Evision.Mat.t()`.
  - **tvec**: `Evision.Mat.t()`.
  - **inliers**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, inliers[, params]]]]) -> retval, cameraMatrix, rvec, tvec, inliers
  ```
  """
  @spec solvePnPRansac(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:params, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:params])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.solvePnPRansac(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  solvePnPRansac

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`
  - **imagePoints**: `Evision.Mat`
  - **distCoeffs**: `Evision.Mat`

  ##### Keyword Arguments
  - **params**: `Evision.UsacParams`.

  ##### Return
  - **retval**: `bool`
  - **cameraMatrix**: `Evision.Mat.t()`
  - **rvec**: `Evision.Mat.t()`.
  - **tvec**: `Evision.Mat.t()`.
  - **inliers**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, inliers[, params]]]]) -> retval, cameraMatrix, rvec, tvec, inliers
  ```
  """
  @spec solvePnPRansac(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.solvePnPRansac(positional)
    |> to_struct()
  end

  @doc """
  Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
  to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
    where N is the number of points. vector\\<Point3d\\> can also be passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can also be passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **criteria**: `TermCriteria`.

    Criteria when to stop the Levenberg-Marquard iterative algorithm.

  ##### Return
  - **rvec**: `Evision.Mat.t()`.

    Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system. Input values are used as an initial solution.

  - **tvec**: `Evision.Mat.t()`.

    Input/Output translation vector. Input values are used as an initial solution.

  @see @ref calib3d_solvePnP

  The function refines the object pose given at least 3 object points, their corresponding image
  projections, an initial solution for the rotation and translation vector,
  as well as the camera intrinsic matrix and the distortion coefficients.
  The function minimizes the projection error with respect to the rotation and the translation vectors, according
  to a Levenberg-Marquardt iterative minimization @cite Madsen04 @cite Eade13 process.

  Python prototype (for reference only):
  ```python3
  solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria]) -> rvec, tvec
  ```
  """
  @spec solvePnPRefineLM(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec)
    ]
    :evision_nif.solvePnPRefineLM(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
  to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
    where N is the number of points. vector\\<Point3d\\> can also be passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can also be passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **criteria**: `TermCriteria`.

    Criteria when to stop the Levenberg-Marquard iterative algorithm.

  ##### Return
  - **rvec**: `Evision.Mat.t()`.

    Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system. Input values are used as an initial solution.

  - **tvec**: `Evision.Mat.t()`.

    Input/Output translation vector. Input values are used as an initial solution.

  @see @ref calib3d_solvePnP

  The function refines the object pose given at least 3 object points, their corresponding image
  projections, an initial solution for the rotation and translation vector,
  as well as the camera intrinsic matrix and the distortion coefficients.
  The function minimizes the projection error with respect to the rotation and the translation vectors, according
  to a Levenberg-Marquardt iterative minimization @cite Madsen04 @cite Eade13 process.

  Python prototype (for reference only):
  ```python3
  solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria]) -> rvec, tvec
  ```
  """
  @spec solvePnPRefineLM(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec)
    ]
    :evision_nif.solvePnPRefineLM(positional)
    |> to_struct()
  end

  @doc """
  Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
  to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
    where N is the number of points. vector\\<Point3d\\> can also be passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can also be passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **criteria**: `TermCriteria`.

    Criteria when to stop the Levenberg-Marquard iterative algorithm.

  - **vVSlambda**: `double`.

    Gain for the virtual visual servoing control law, equivalent to the \\f$\\alpha\\f$
    gain in the Damped Gauss-Newton formulation.

  ##### Return
  - **rvec**: `Evision.Mat.t()`.

    Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system. Input values are used as an initial solution.

  - **tvec**: `Evision.Mat.t()`.

    Input/Output translation vector. Input values are used as an initial solution.

  @see @ref calib3d_solvePnP

  The function refines the object pose given at least 3 object points, their corresponding image
  projections, an initial solution for the rotation and translation vector,
  as well as the camera intrinsic matrix and the distortion coefficients.
  The function minimizes the projection error with respect to the rotation and the translation vectors, using a
  virtual visual servoing (VVS) @cite Chaumette06 @cite Marchand16 scheme.

  Python prototype (for reference only):
  ```python3
  solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria[, VVSlambda]]) -> rvec, tvec
  ```
  """
  @spec solvePnPRefineVVS(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:vVSlambda, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, opts) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :vVSlambda])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec)
    ]
    :evision_nif.solvePnPRefineVVS(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame
  to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.

  ##### Positional Arguments
  - **objectPoints**: `Evision.Mat`.

    Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,
    where N is the number of points. vector\\<Point3d\\> can also be passed here.

  - **imagePoints**: `Evision.Mat`.

    Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,
    where N is the number of points. vector\\<Point2d\\> can also be passed here.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera intrinsic matrix \\f$\\cameramatrix{A}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$\\distcoeffs\\f$. If the vector is NULL/empty, the zero distortion coefficients are
    assumed.

  ##### Keyword Arguments
  - **criteria**: `TermCriteria`.

    Criteria when to stop the Levenberg-Marquard iterative algorithm.

  - **vVSlambda**: `double`.

    Gain for the virtual visual servoing control law, equivalent to the \\f$\\alpha\\f$
    gain in the Damped Gauss-Newton formulation.

  ##### Return
  - **rvec**: `Evision.Mat.t()`.

    Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from
    the model coordinate system to the camera coordinate system. Input values are used as an initial solution.

  - **tvec**: `Evision.Mat.t()`.

    Input/Output translation vector. Input values are used as an initial solution.

  @see @ref calib3d_solvePnP

  The function refines the object pose given at least 3 object points, their corresponding image
  projections, an initial solution for the rotation and translation vector,
  as well as the camera intrinsic matrix and the distortion coefficients.
  The function minimizes the projection error with respect to the rotation and the translation vectors, using a
  virtual visual servoing (VVS) @cite Chaumette06 @cite Marchand16 scheme.

  Python prototype (for reference only):
  ```python3
  solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec[, criteria[, VVSlambda]]) -> rvec, tvec
  ```
  """
  @spec solvePnPRefineVVS(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec) when (is_struct(objectPoints, Evision.Mat) or is_struct(objectPoints, Nx.Tensor) or is_number(objectPoints) or is_tuple(objectPoints)) and (is_struct(imagePoints, Evision.Mat) or is_struct(imagePoints, Nx.Tensor) or is_number(imagePoints) or is_tuple(imagePoints)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(rvec, Evision.Mat) or is_struct(rvec, Nx.Tensor) or is_number(rvec) or is_tuple(rvec)) and (is_struct(tvec, Evision.Mat) or is_struct(tvec, Nx.Tensor) or is_number(tvec) or is_tuple(tvec))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints: Evision.Internal.Structurise.from_struct(imagePoints),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      rvec: Evision.Internal.Structurise.from_struct(rvec),
      tvec: Evision.Internal.Structurise.from_struct(tvec)
    ]
    :evision_nif.solvePnPRefineVVS(positional)
    |> to_struct()
  end

  @doc """
  Finds the real or complex roots of a polynomial equation.

  ##### Positional Arguments
  - **coeffs**: `Evision.Mat`.

    array of polynomial coefficients.

  ##### Keyword Arguments
  - **maxIters**: `integer()`.

    maximum number of iterations the algorithm does.

  ##### Return
  - **retval**: `double`
  - **roots**: `Evision.Mat.t()`.

    output (complex) array of roots.

  The function cv::solvePoly finds real and complex roots of a polynomial equation:
  \\f[\\texttt{coeffs} \\[n] x^{n} +  \\texttt{coeffs} \\[n-1] x^{n-1} + ... +  \\texttt{coeffs} \\[1] x +  \\texttt{coeffs} \\[0] = 0\\f]

  Python prototype (for reference only):
  ```python3
  solvePoly(coeffs[, roots[, maxIters]]) -> retval, roots
  ```
  """
  @spec solvePoly(Evision.Mat.maybe_mat_in(), [{:maxIters, term()}] | nil) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def solvePoly(coeffs, opts) when (is_struct(coeffs, Evision.Mat) or is_struct(coeffs, Nx.Tensor) or is_number(coeffs) or is_tuple(coeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:maxIters])
    positional = [
      coeffs: Evision.Internal.Structurise.from_struct(coeffs)
    ]
    :evision_nif.solvePoly(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Finds the real or complex roots of a polynomial equation.

  ##### Positional Arguments
  - **coeffs**: `Evision.Mat`.

    array of polynomial coefficients.

  ##### Keyword Arguments
  - **maxIters**: `integer()`.

    maximum number of iterations the algorithm does.

  ##### Return
  - **retval**: `double`
  - **roots**: `Evision.Mat.t()`.

    output (complex) array of roots.

  The function cv::solvePoly finds real and complex roots of a polynomial equation:
  \\f[\\texttt{coeffs} \\[n] x^{n} +  \\texttt{coeffs} \\[n-1] x^{n-1} + ... +  \\texttt{coeffs} \\[1] x +  \\texttt{coeffs} \\[0] = 0\\f]

  Python prototype (for reference only):
  ```python3
  solvePoly(coeffs[, roots[, maxIters]]) -> retval, roots
  ```
  """
  @spec solvePoly(Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def solvePoly(coeffs) when (is_struct(coeffs, Evision.Mat) or is_struct(coeffs, Nx.Tensor) or is_number(coeffs) or is_tuple(coeffs))
  do
    positional = [
      coeffs: Evision.Internal.Structurise.from_struct(coeffs)
    ]
    :evision_nif.solvePoly(positional)
    |> to_struct()
  end

  @doc """
  Sorts each row or each column of a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **flags**: `integer()`.

    operation flags, a combination of #SortFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::sort sorts each matrix row or each matrix column in
  ascending or descending order. So you should pass two operation flags to
  get desired behaviour. If you want to sort matrix rows or columns
  lexicographically, you can use STL std::sort generic function with the
  proper comparison predicate.
  @sa sortIdx, randShuffle

  Python prototype (for reference only):
  ```python3
  sort(src, flags[, dst]) -> dst
  ```
  """
  @spec sort(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def sort(src, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.sort(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Sorts each row or each column of a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **flags**: `integer()`.

    operation flags, a combination of #SortFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::sort sorts each matrix row or each matrix column in
  ascending or descending order. So you should pass two operation flags to
  get desired behaviour. If you want to sort matrix rows or columns
  lexicographically, you can use STL std::sort generic function with the
  proper comparison predicate.
  @sa sortIdx, randShuffle

  Python prototype (for reference only):
  ```python3
  sort(src, flags[, dst]) -> dst
  ```
  """
  @spec sort(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def sort(src, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.sort(positional)
    |> to_struct()
  end

  @doc """
  Sorts each row or each column of a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **flags**: `integer()`.

    operation flags that could be a combination of cv::SortFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output integer array of the same size as src.

  The function cv::sortIdx sorts each matrix row or each matrix column in the
  ascending or descending order. So you should pass two operation flags to
  get desired behaviour. Instead of reordering the elements themselves, it
  stores the indices of sorted elements in the output array. For example:
  ```
  Mat A = Mat::eye(3,3,CV_32F), B;
  sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
  // B will probably contain
  // (because of equal elements in A some permutations are possible):
  // [[1, 2, 0], [0, 2, 1], [0, 1, 2]]
  ```
  @sa sort, randShuffle

  Python prototype (for reference only):
  ```python3
  sortIdx(src, flags[, dst]) -> dst
  ```
  """
  @spec sortIdx(Evision.Mat.maybe_mat_in(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def sortIdx(src, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.sortIdx(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Sorts each row or each column of a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input single-channel array.

  - **flags**: `integer()`.

    operation flags that could be a combination of cv::SortFlags

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output integer array of the same size as src.

  The function cv::sortIdx sorts each matrix row or each matrix column in the
  ascending or descending order. So you should pass two operation flags to
  get desired behaviour. Instead of reordering the elements themselves, it
  stores the indices of sorted elements in the output array. For example:
  ```
  Mat A = Mat::eye(3,3,CV_32F), B;
  sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
  // B will probably contain
  // (because of equal elements in A some permutations are possible):
  // [[1, 2, 0], [0, 2, 1], [0, 1, 2]]
  ```
  @sa sort, randShuffle

  Python prototype (for reference only):
  ```python3
  sortIdx(src, flags[, dst]) -> dst
  ```
  """
  @spec sortIdx(Evision.Mat.maybe_mat_in(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def sortIdx(src, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.sortIdx(positional)
    |> to_struct()
  end

  @doc """
  Calculates the first order image derivative in both x and y using a Sobel operator

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    size of Sobel kernel. It must be 3.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes.
    Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.

  ##### Return
  - **dx**: `Evision.Mat.t()`.

    output image with first-order derivative in x.

  - **dy**: `Evision.Mat.t()`.

    output image with first-order derivative in y.

  Equivalent to calling:
  ```
  Sobel( src, dx, CV_16SC1, 1, 0, 3 );
  Sobel( src, dy, CV_16SC1, 0, 1, 3 );
  ```

  @sa Sobel

  Python prototype (for reference only):
  ```python3
  spatialGradient(src[, dx[, dy[, ksize[, borderType]]]]) -> dx, dy
  ```
  """
  @spec spatialGradient(Evision.Mat.maybe_mat_in(), [{:borderType, term()} | {:ksize, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def spatialGradient(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderType, :ksize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.spatialGradient(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the first order image derivative in both x and y using a Sobel operator

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  ##### Keyword Arguments
  - **ksize**: `integer()`.

    size of Sobel kernel. It must be 3.

  - **borderType**: `integer()`.

    pixel extrapolation method, see #BorderTypes.
    Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.

  ##### Return
  - **dx**: `Evision.Mat.t()`.

    output image with first-order derivative in x.

  - **dy**: `Evision.Mat.t()`.

    output image with first-order derivative in y.

  Equivalent to calling:
  ```
  Sobel( src, dx, CV_16SC1, 1, 0, 3 );
  Sobel( src, dy, CV_16SC1, 0, 1, 3 );
  ```

  @sa Sobel

  Python prototype (for reference only):
  ```python3
  spatialGradient(src[, dx[, dy[, ksize[, borderType]]]]) -> dx, dy
  ```
  """
  @spec spatialGradient(Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def spatialGradient(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.spatialGradient(positional)
    |> to_struct()
  end

  @doc """
  split

  ##### Positional Arguments
  - **m**: `Evision.Mat`.

    input multi-channel array.

  ##### Return
  - **mv**: `[Evision.Mat]`.

    output vector of arrays; the arrays themselves are reallocated, if needed.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  split(m[, mv]) -> mv
  ```
  """
  @spec split(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: list(Evision.Mat.t()) | {:error, String.t()}
  def split(m, opts) when (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.split(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  split

  ##### Positional Arguments
  - **m**: `Evision.Mat`.

    input multi-channel array.

  ##### Return
  - **mv**: `[Evision.Mat]`.

    output vector of arrays; the arrays themselves are reallocated, if needed.

  Has overloading in C++

  Python prototype (for reference only):
  ```python3
  split(m[, mv]) -> mv
  ```
  """
  @spec split(Evision.Mat.maybe_mat_in()) :: list(Evision.Mat.t()) | {:error, String.t()}
  def split(m) when (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m))
  do
    positional = [
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.split(positional)
    |> to_struct()
  end

  @doc """
  Calculates the normalized sum of squares of the pixel values overlapping the filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image

  - **ddepth**: `integer()`.

    the output image depth (-1 to use src.depth())

  - **ksize**: `Size`.

    kernel size

  ##### Keyword Arguments
  - **anchor**: `Point`.

    kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
    center.

  - **normalize**: `bool`.

    flag, specifying whether the kernel is to be normalized by it's area or not.

  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src

  For every pixel \\f$ (x, y) \\f$ in the source image, the function calculates the sum of squares of those neighboring
  pixel values which overlap the filter placed over the pixel \\f$ (x, y) \\f$.
  The unnormalized square box filter can be useful in computing local image statistics such as the local
  variance and standard deviation around the neighborhood of a pixel.
  @sa boxFilter

  Python prototype (for reference only):
  ```python3
  sqrBoxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -> dst
  ```
  """
  @spec sqrBoxFilter(Evision.Mat.maybe_mat_in(), integer(), {number(), number()}, [{:anchor, term()} | {:borderType, term()} | {:normalize, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def sqrBoxFilter(src, ddepth, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_tuple(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:anchor, :borderType, :normalize])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.sqrBoxFilter(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the normalized sum of squares of the pixel values overlapping the filter.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image

  - **ddepth**: `integer()`.

    the output image depth (-1 to use src.depth())

  - **ksize**: `Size`.

    kernel size

  ##### Keyword Arguments
  - **anchor**: `Point`.

    kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
    center.

  - **normalize**: `bool`.

    flag, specifying whether the kernel is to be normalized by it's area or not.

  - **borderType**: `integer()`.

    border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src

  For every pixel \\f$ (x, y) \\f$ in the source image, the function calculates the sum of squares of those neighboring
  pixel values which overlap the filter placed over the pixel \\f$ (x, y) \\f$.
  The unnormalized square box filter can be useful in computing local image statistics such as the local
  variance and standard deviation around the neighborhood of a pixel.
  @sa boxFilter

  Python prototype (for reference only):
  ```python3
  sqrBoxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -> dst
  ```
  """
  @spec sqrBoxFilter(Evision.Mat.maybe_mat_in(), integer(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def sqrBoxFilter(src, ddepth, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_integer(ddepth) and is_tuple(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ddepth: Evision.Internal.Structurise.from_struct(ddepth),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.sqrBoxFilter(positional)
    |> to_struct()
  end

  @doc """
  Calculates a square root of array elements.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::sqrt calculates a square root of each input array element.
  In case of multi-channel arrays, each channel is processed
  independently. The accuracy is approximately the same as of the built-in
  std::sqrt .

  Python prototype (for reference only):
  ```python3
  sqrt(src[, dst]) -> dst
  ```
  """
  @spec sqrt(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def sqrt(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.sqrt(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates a square root of array elements.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input floating-point array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and type as src.

  The function cv::sqrt calculates a square root of each input array element.
  In case of multi-channel arrays, each channel is processed
  independently. The accuracy is approximately the same as of the built-in
  std::sqrt .

  Python prototype (for reference only):
  ```python3
  sqrt(src[, dst]) -> dst
  ```
  """
  @spec sqrt(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def sqrt(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.sqrt(positional)
    |> to_struct()
  end

  @doc """
  Blurs an image using the stackBlur.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image. The number of channels can be arbitrary, but the depth should be one of
    CV_8U, CV_16U, CV_16S or CV_32F.

  - **ksize**: `Size`.

    stack-blurring kernel size. The ksize.width and ksize.height can differ but they both must be
    positive and odd.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function applies and stackBlur to an image.
  stackBlur can generate similar results as Gaussian blur, and the time consumption does not increase with the increase of kernel size.
  It creates a kind of moving stack of colors whilst scanning through the image. Thereby it just has to add one new block of color to the right side
  of the stack and remove the leftmost color. The remaining colors on the topmost layer of the stack are either added on or reduced by one,
  depending on if they are on the right or on the left side of the stack. The only supported borderType is BORDER_REPLICATE.
  Original paper was proposed by Mario Klingemann, which can be found http://underdestruction.com/2004/02/25/stackblur-2004.

  Python prototype (for reference only):
  ```python3
  stackBlur(src, ksize[, dst]) -> dst
  ```
  """
  @spec stackBlur(Evision.Mat.maybe_mat_in(), {number(), number()}, [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def stackBlur(src, ksize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(ksize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.stackBlur(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Blurs an image using the stackBlur.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image. The number of channels can be arbitrary, but the depth should be one of
    CV_8U, CV_16U, CV_16S or CV_32F.

  - **ksize**: `Size`.

    stack-blurring kernel size. The ksize.width and ksize.height can differ but they both must be
    positive and odd.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image of the same size and type as src.

  The function applies and stackBlur to an image.
  stackBlur can generate similar results as Gaussian blur, and the time consumption does not increase with the increase of kernel size.
  It creates a kind of moving stack of colors whilst scanning through the image. Thereby it just has to add one new block of color to the right side
  of the stack and remove the leftmost color. The remaining colors on the topmost layer of the stack are either added on or reduced by one,
  depending on if they are on the right or on the left side of the stack. The only supported borderType is BORDER_REPLICATE.
  Original paper was proposed by Mario Klingemann, which can be found http://underdestruction.com/2004/02/25/stackblur-2004.

  Python prototype (for reference only):
  ```python3
  stackBlur(src, ksize[, dst]) -> dst
  ```
  """
  @spec stackBlur(Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def stackBlur(src, ksize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(ksize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      ksize: Evision.Internal.Structurise.from_struct(ksize)
    ]
    :evision_nif.stackBlur(positional)
    |> to_struct()
  end

  @doc """
  startWindowThread
  ##### Return
  - **retval**: `integer()`

  Python prototype (for reference only):
  ```python3
  startWindowThread() -> retval
  ```
  """
  @spec startWindowThread() :: integer() | {:error, String.t()}
  def startWindowThread() do
    positional = [
    ]
    :evision_nif.startWindowThread(positional)
    |> to_struct()
  end

  @doc """
  stereoCalibrate

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints1**: `[Evision.Mat]`
  - **imagePoints2**: `[Evision.Mat]`
  - **imageSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix1**: `Evision.Mat.t()`
  - **distCoeffs1**: `Evision.Mat.t()`
  - **cameraMatrix2**: `Evision.Mat.t()`
  - **distCoeffs2**: `Evision.Mat.t()`
  - **r**: `Evision.Mat.t()`
  - **t**: `Evision.Mat.t()`
  - **e**: `Evision.Mat.t()`.
  - **f**: `Evision.Mat.t()`.
  - **perViewErrors**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, E[, F[, perViewErrors[, flags[, criteria]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, perViewErrors
  ```
  """
  @spec stereoCalibrate(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, r, t, opts) when is_list(objectPoints) and is_list(imagePoints1) and is_list(imagePoints2) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(t, Evision.Mat) or is_struct(t, Nx.Tensor) or is_number(t) or is_tuple(t)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints1: Evision.Internal.Structurise.from_struct(imagePoints1),
      imagePoints2: Evision.Internal.Structurise.from_struct(imagePoints2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r: Evision.Internal.Structurise.from_struct(r),
      t: Evision.Internal.Structurise.from_struct(t)
    ]
    :evision_nif.stereoCalibrate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  stereoCalibrate

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints1**: `[Evision.Mat]`
  - **imagePoints2**: `[Evision.Mat]`
  - **imageSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix1**: `Evision.Mat.t()`
  - **distCoeffs1**: `Evision.Mat.t()`
  - **cameraMatrix2**: `Evision.Mat.t()`
  - **distCoeffs2**: `Evision.Mat.t()`
  - **r**: `Evision.Mat.t()`
  - **t**: `Evision.Mat.t()`
  - **e**: `Evision.Mat.t()`.
  - **f**: `Evision.Mat.t()`.
  - **perViewErrors**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, E[, F[, perViewErrors[, flags[, criteria]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, perViewErrors
  ```
  """
  @spec stereoCalibrate(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, r, t) when is_list(objectPoints) and is_list(imagePoints1) and is_list(imagePoints2) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(t, Evision.Mat) or is_struct(t, Nx.Tensor) or is_number(t) or is_tuple(t))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints1: Evision.Internal.Structurise.from_struct(imagePoints1),
      imagePoints2: Evision.Internal.Structurise.from_struct(imagePoints2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r: Evision.Internal.Structurise.from_struct(r),
      t: Evision.Internal.Structurise.from_struct(t)
    ]
    :evision_nif.stereoCalibrate(positional)
    |> to_struct()
  end

  @doc """
  stereoCalibrate

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints1**: `[Evision.Mat]`
  - **imagePoints2**: `[Evision.Mat]`
  - **imageSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix1**: `Evision.Mat.t()`
  - **distCoeffs1**: `Evision.Mat.t()`
  - **cameraMatrix2**: `Evision.Mat.t()`
  - **distCoeffs2**: `Evision.Mat.t()`
  - **r**: `Evision.Mat.t()`.
  - **t**: `Evision.Mat.t()`.
  - **e**: `Evision.Mat.t()`.
  - **f**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize[, R[, T[, E[, F[, flags[, criteria]]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F
  ```
  """
  @spec stereoCalibrate(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, opts) when is_list(objectPoints) and is_list(imagePoints1) and is_list(imagePoints2) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints1: Evision.Internal.Structurise.from_struct(imagePoints1),
      imagePoints2: Evision.Internal.Structurise.from_struct(imagePoints2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize)
    ]
    :evision_nif.stereoCalibrate(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  stereoCalibrate

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`
  - **imagePoints1**: `[Evision.Mat]`
  - **imagePoints2**: `[Evision.Mat]`
  - **imageSize**: `Size`

  ##### Keyword Arguments
  - **flags**: `integer()`.
  - **criteria**: `TermCriteria`.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix1**: `Evision.Mat.t()`
  - **distCoeffs1**: `Evision.Mat.t()`
  - **cameraMatrix2**: `Evision.Mat.t()`
  - **distCoeffs2**: `Evision.Mat.t()`
  - **r**: `Evision.Mat.t()`.
  - **t**: `Evision.Mat.t()`.
  - **e**: `Evision.Mat.t()`.
  - **f**: `Evision.Mat.t()`.

  Python prototype (for reference only):
  ```python3
  stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize[, R[, T[, E[, F[, flags[, criteria]]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F
  ```
  """
  @spec stereoCalibrate(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t()} | {:error, String.t()}
  def stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize) when is_list(objectPoints) and is_list(imagePoints1) and is_list(imagePoints2) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize)
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints1: Evision.Internal.Structurise.from_struct(imagePoints1),
      imagePoints2: Evision.Internal.Structurise.from_struct(imagePoints2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize)
    ]
    :evision_nif.stereoCalibrate(positional)
    |> to_struct()
  end

  @doc """
  Calibrates a stereo camera set up. This function finds the intrinsic parameters
  for each of the two cameras and the extrinsic parameters between the two cameras.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    Vector of vectors of the calibration pattern points. The same structure as
    in @ref calibrateCamera. For each pattern view, both cameras need to see the same object
    points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be
    equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to
    be equal for each i.

  - **imagePoints1**: `[Evision.Mat]`.

    Vector of vectors of the projections of the calibration pattern points,
    observed by the first camera. The same structure as in @ref calibrateCamera.

  - **imagePoints2**: `[Evision.Mat]`.

    Vector of vectors of the projections of the calibration pattern points,
    observed by the second camera. The same structure as in @ref calibrateCamera.

  - **imageSize**: `Size`.

    Size of the image used only to initialize the camera intrinsic matrices.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Different flags that may be zero or a combination of the following values:
    - @ref CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F
      matrices are estimated.
    - @ref CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters
      according to the specified flags. Initial values are provided by the user.
    - @ref CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further.
      Otherwise R and T are initialized to the median value of the pattern views (each dimension separately).
    - @ref CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization.
    - @ref CALIB_FIX_FOCAL_LENGTH Fix \\f$f^{(j)}_x\\f$ and \\f$f^{(j)}_y\\f$ .
    - @ref CALIB_FIX_ASPECT_RATIO Optimize \\f$f^{(j)}_y\\f$ . Fix the ratio \\f$f^{(j)}_x/f^{(j)}_y\\f$
      .
    - @ref CALIB_SAME_FOCAL_LENGTH Enforce \\f$f^{(0)}_x=f^{(1)}_x\\f$ and \\f$f^{(0)}_y=f^{(1)}_y\\f$ .
    - @ref CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to
      zeros and fix there.
    - @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 Do not change the corresponding radial
      distortion coefficient during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set,
      the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.
    - @ref CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward
      compatibility, this extra flag should be explicitly specified to make the calibration
      function use the rational model and return 8 coefficients. If the flag is not set, the
      function computes and returns only 5 distortion coefficients.
    - @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the
      backward compatibility, this extra flag should be explicitly specified to make the
      calibration function use the thin prism model and return 12 coefficients. If the flag is not
      set, the function computes and returns only 5 distortion coefficients.
    - @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during
      the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
      supplied distCoeffs matrix is used. Otherwise, it is set to 0.
    - @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the
      backward compatibility, this extra flag should be explicitly specified to make the
      calibration function use the tilted sensor model and return 14 coefficients. If the flag is not
      set, the function computes and returns only 5 distortion coefficients.
    - @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during
      the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
      supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  - **criteria**: `TermCriteria`.

    Termination criteria for the iterative optimization algorithm.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix1**: `Evision.Mat.t()`.

    Input/output camera intrinsic matrix for the first camera, the same as in

  - **distCoeffs1**: `Evision.Mat.t()`.

    Input/output vector of distortion coefficients, the same as in

  - **cameraMatrix2**: `Evision.Mat.t()`.

    Input/output second camera intrinsic matrix for the second camera. See description for
    cameraMatrix1.

  - **distCoeffs2**: `Evision.Mat.t()`.

    Input/output lens distortion coefficients for the second camera. See
    description for distCoeffs1.

  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector T, this matrix brings
    points given in the first camera's coordinate system to points in the second camera's
    coordinate system. In more technical terms, the tuple of R and T performs a change of basis
    from the first camera's coordinate system to the second camera's coordinate system. Due to its
    duality, this tuple is equivalent to the position of the first camera with respect to the
    second camera coordinate system.

  - **t**: `Evision.Mat.t()`.

    Output translation vector, see description above.

  - **e**: `Evision.Mat.t()`.

    Output essential matrix.

  - **f**: `Evision.Mat.t()`.

    Output fundamental matrix.

  - **rvecs**: `[Evision.Mat]`.

    Output vector of rotation vectors ( @ref Rodrigues ) estimated for each pattern view in the
    coordinate system of the first camera of the stereo pair (e.g. std::vector<cv::Mat>). More in detail, each
    i-th rotation vector together with the corresponding i-th translation vector (see the next output parameter
    description) brings the calibration pattern from the object coordinate space (in which object points are
    specified) to the camera coordinate space of the first camera of the stereo pair. In more technical terms,
    the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space
    to camera coordinate space of the first camera of the stereo pair.

  - **tvecs**: `[Evision.Mat]`.

    Output vector of translation vectors estimated for each pattern view, see parameter description
    of previous output parameter ( rvecs ).

  - **perViewErrors**: `Evision.Mat.t()`.

    Output vector of the RMS re-projection error estimated for each pattern view.

  @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.
  @ref calibrateCamera.

  The function estimates the transformation between two cameras making a stereo pair. If one computes
  the poses of an object relative to the first camera and to the second camera,
  ( \\f$R\\_1\\f$,\\f$T\\_1\\f$ ) and (\\f$R\\_2\\f$,\\f$T\\_2\\f$), respectively, for a stereo camera where the
  relative position and orientation between the two cameras are fixed, then those poses definitely
  relate to each other. This means, if the relative position and orientation (\\f$R\\f$,\\f$T\\f$) of the
  two cameras is known, it is possible to compute (\\f$R\\_2\\f$,\\f$T\\_2\\f$) when (\\f$R\\_1\\f$,\\f$T\\_1\\f$) is
  given. This is what the described function does. It computes (\\f$R\\f$,\\f$T\\f$) such that:
  \\f[R\\_2=R R\\_1\\f]
  \\f[T\\_2=R T\\_1 + T.\\f]
  Therefore, one can compute the coordinate representation of a 3D point for the second camera's
  coordinate system when given the point's coordinate representation in the first camera's coordinate
  system:
  \\f[\\begin{bmatrix}
  X\\_2 \\\\\\\\
  Y\\_2 \\\\\\\\
  Z\\_2 \\\\\\\\
  1
  \\end{bmatrix} = \\begin{bmatrix}
  R & T \\\\\\\\
  0 & 1
  \\end{bmatrix} \\begin{bmatrix}
  X\\_1 \\\\\\\\
  Y\\_1 \\\\\\\\
  Z\\_1 \\\\\\\\
  1
  \\end{bmatrix}.\\f]
  Optionally, it computes the essential matrix E:
  \\f[E= \\vecthreethree{0}{-T\\_2}{T\\_1}{T\\_2}{0}{-T\\_0}{-T\\_1}{T\\_0}{0} R\\f]
  where \\f$T\\_i\\f$ are components of the translation vector \\f$T\\f$ : \\f$T=\\[T\\_0, T\\_1, T\\_2]^T\\f$ .
  And the function can also compute the fundamental matrix F:
  \\f[F = cameraMatrix2^{-T}\\cdot E \\cdot cameraMatrix1^{-1}\\f]
  Besides the stereo-related information, the function can also perform a full calibration of each of
  the two cameras. However, due to the high dimensionality of the parameter space and noise in the
  input data, the function can diverge from the correct solution. If the intrinsic parameters can be
  estimated with high accuracy for each of the cameras individually (for example, using
  #calibrateCamera ), you are recommended to do so and then pass @ref CALIB_FIX_INTRINSIC flag to the
  function along with the computed intrinsic parameters. Otherwise, if all the parameters are
  estimated at once, it makes sense to restrict some parameters, for example, pass
  @ref CALIB_SAME_FOCAL_LENGTH and @ref CALIB_ZERO_TANGENT_DIST flags, which is usually a
  reasonable assumption.
  Similarly to #calibrateCamera, the function minimizes the total re-projection error for all the
  points in all the available views from both cameras. The function returns the final value of the
  re-projection error.

  Python prototype (for reference only):
  ```python3
  stereoCalibrateExtended(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, E[, F[, rvecs[, tvecs[, perViewErrors[, flags[, criteria]]]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, rvecs, tvecs, perViewErrors
  ```
  """
  @spec stereoCalibrateExtended(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:criteria, term()} | {:flags, term()}] | nil) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def stereoCalibrateExtended(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, r, t, opts) when is_list(objectPoints) and is_list(imagePoints1) and is_list(imagePoints2) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(t, Evision.Mat) or is_struct(t, Nx.Tensor) or is_number(t) or is_tuple(t)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:criteria, :flags])
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints1: Evision.Internal.Structurise.from_struct(imagePoints1),
      imagePoints2: Evision.Internal.Structurise.from_struct(imagePoints2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r: Evision.Internal.Structurise.from_struct(r),
      t: Evision.Internal.Structurise.from_struct(t)
    ]
    :evision_nif.stereoCalibrateExtended(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calibrates a stereo camera set up. This function finds the intrinsic parameters
  for each of the two cameras and the extrinsic parameters between the two cameras.

  ##### Positional Arguments
  - **objectPoints**: `[Evision.Mat]`.

    Vector of vectors of the calibration pattern points. The same structure as
    in @ref calibrateCamera. For each pattern view, both cameras need to see the same object
    points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be
    equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to
    be equal for each i.

  - **imagePoints1**: `[Evision.Mat]`.

    Vector of vectors of the projections of the calibration pattern points,
    observed by the first camera. The same structure as in @ref calibrateCamera.

  - **imagePoints2**: `[Evision.Mat]`.

    Vector of vectors of the projections of the calibration pattern points,
    observed by the second camera. The same structure as in @ref calibrateCamera.

  - **imageSize**: `Size`.

    Size of the image used only to initialize the camera intrinsic matrices.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Different flags that may be zero or a combination of the following values:
    - @ref CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F
      matrices are estimated.
    - @ref CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters
      according to the specified flags. Initial values are provided by the user.
    - @ref CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further.
      Otherwise R and T are initialized to the median value of the pattern views (each dimension separately).
    - @ref CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization.
    - @ref CALIB_FIX_FOCAL_LENGTH Fix \\f$f^{(j)}_x\\f$ and \\f$f^{(j)}_y\\f$ .
    - @ref CALIB_FIX_ASPECT_RATIO Optimize \\f$f^{(j)}_y\\f$ . Fix the ratio \\f$f^{(j)}_x/f^{(j)}_y\\f$
      .
    - @ref CALIB_SAME_FOCAL_LENGTH Enforce \\f$f^{(0)}_x=f^{(1)}_x\\f$ and \\f$f^{(0)}_y=f^{(1)}_y\\f$ .
    - @ref CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to
      zeros and fix there.
    - @ref CALIB_FIX_K1,..., @ref CALIB_FIX_K6 Do not change the corresponding radial
      distortion coefficient during the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set,
      the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.
    - @ref CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward
      compatibility, this extra flag should be explicitly specified to make the calibration
      function use the rational model and return 8 coefficients. If the flag is not set, the
      function computes and returns only 5 distortion coefficients.
    - @ref CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the
      backward compatibility, this extra flag should be explicitly specified to make the
      calibration function use the thin prism model and return 12 coefficients. If the flag is not
      set, the function computes and returns only 5 distortion coefficients.
    - @ref CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during
      the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
      supplied distCoeffs matrix is used. Otherwise, it is set to 0.
    - @ref CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the
      backward compatibility, this extra flag should be explicitly specified to make the
      calibration function use the tilted sensor model and return 14 coefficients. If the flag is not
      set, the function computes and returns only 5 distortion coefficients.
    - @ref CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during
      the optimization. If @ref CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the
      supplied distCoeffs matrix is used. Otherwise, it is set to 0.

  - **criteria**: `TermCriteria`.

    Termination criteria for the iterative optimization algorithm.

  ##### Return
  - **retval**: `double`
  - **cameraMatrix1**: `Evision.Mat.t()`.

    Input/output camera intrinsic matrix for the first camera, the same as in

  - **distCoeffs1**: `Evision.Mat.t()`.

    Input/output vector of distortion coefficients, the same as in

  - **cameraMatrix2**: `Evision.Mat.t()`.

    Input/output second camera intrinsic matrix for the second camera. See description for
    cameraMatrix1.

  - **distCoeffs2**: `Evision.Mat.t()`.

    Input/output lens distortion coefficients for the second camera. See
    description for distCoeffs1.

  - **r**: `Evision.Mat.t()`.

    Output rotation matrix. Together with the translation vector T, this matrix brings
    points given in the first camera's coordinate system to points in the second camera's
    coordinate system. In more technical terms, the tuple of R and T performs a change of basis
    from the first camera's coordinate system to the second camera's coordinate system. Due to its
    duality, this tuple is equivalent to the position of the first camera with respect to the
    second camera coordinate system.

  - **t**: `Evision.Mat.t()`.

    Output translation vector, see description above.

  - **e**: `Evision.Mat.t()`.

    Output essential matrix.

  - **f**: `Evision.Mat.t()`.

    Output fundamental matrix.

  - **rvecs**: `[Evision.Mat]`.

    Output vector of rotation vectors ( @ref Rodrigues ) estimated for each pattern view in the
    coordinate system of the first camera of the stereo pair (e.g. std::vector<cv::Mat>). More in detail, each
    i-th rotation vector together with the corresponding i-th translation vector (see the next output parameter
    description) brings the calibration pattern from the object coordinate space (in which object points are
    specified) to the camera coordinate space of the first camera of the stereo pair. In more technical terms,
    the tuple of the i-th rotation and translation vector performs a change of basis from object coordinate space
    to camera coordinate space of the first camera of the stereo pair.

  - **tvecs**: `[Evision.Mat]`.

    Output vector of translation vectors estimated for each pattern view, see parameter description
    of previous output parameter ( rvecs ).

  - **perViewErrors**: `Evision.Mat.t()`.

    Output vector of the RMS re-projection error estimated for each pattern view.

  @ref calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.
  @ref calibrateCamera.

  The function estimates the transformation between two cameras making a stereo pair. If one computes
  the poses of an object relative to the first camera and to the second camera,
  ( \\f$R\\_1\\f$,\\f$T\\_1\\f$ ) and (\\f$R\\_2\\f$,\\f$T\\_2\\f$), respectively, for a stereo camera where the
  relative position and orientation between the two cameras are fixed, then those poses definitely
  relate to each other. This means, if the relative position and orientation (\\f$R\\f$,\\f$T\\f$) of the
  two cameras is known, it is possible to compute (\\f$R\\_2\\f$,\\f$T\\_2\\f$) when (\\f$R\\_1\\f$,\\f$T\\_1\\f$) is
  given. This is what the described function does. It computes (\\f$R\\f$,\\f$T\\f$) such that:
  \\f[R\\_2=R R\\_1\\f]
  \\f[T\\_2=R T\\_1 + T.\\f]
  Therefore, one can compute the coordinate representation of a 3D point for the second camera's
  coordinate system when given the point's coordinate representation in the first camera's coordinate
  system:
  \\f[\\begin{bmatrix}
  X\\_2 \\\\\\\\
  Y\\_2 \\\\\\\\
  Z\\_2 \\\\\\\\
  1
  \\end{bmatrix} = \\begin{bmatrix}
  R & T \\\\\\\\
  0 & 1
  \\end{bmatrix} \\begin{bmatrix}
  X\\_1 \\\\\\\\
  Y\\_1 \\\\\\\\
  Z\\_1 \\\\\\\\
  1
  \\end{bmatrix}.\\f]
  Optionally, it computes the essential matrix E:
  \\f[E= \\vecthreethree{0}{-T\\_2}{T\\_1}{T\\_2}{0}{-T\\_0}{-T\\_1}{T\\_0}{0} R\\f]
  where \\f$T\\_i\\f$ are components of the translation vector \\f$T\\f$ : \\f$T=\\[T\\_0, T\\_1, T\\_2]^T\\f$ .
  And the function can also compute the fundamental matrix F:
  \\f[F = cameraMatrix2^{-T}\\cdot E \\cdot cameraMatrix1^{-1}\\f]
  Besides the stereo-related information, the function can also perform a full calibration of each of
  the two cameras. However, due to the high dimensionality of the parameter space and noise in the
  input data, the function can diverge from the correct solution. If the intrinsic parameters can be
  estimated with high accuracy for each of the cameras individually (for example, using
  #calibrateCamera ), you are recommended to do so and then pass @ref CALIB_FIX_INTRINSIC flag to the
  function along with the computed intrinsic parameters. Otherwise, if all the parameters are
  estimated at once, it makes sense to restrict some parameters, for example, pass
  @ref CALIB_SAME_FOCAL_LENGTH and @ref CALIB_ZERO_TANGENT_DIST flags, which is usually a
  reasonable assumption.
  Similarly to #calibrateCamera, the function minimizes the total re-projection error for all the
  points in all the available views from both cameras. The function returns the final value of the
  re-projection error.

  Python prototype (for reference only):
  ```python3
  stereoCalibrateExtended(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, E[, F[, rvecs[, tvecs[, perViewErrors[, flags[, criteria]]]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F, rvecs, tvecs, perViewErrors
  ```
  """
  @spec stereoCalibrateExtended(list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), list(Evision.Mat.maybe_mat_in()), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {number(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), list(Evision.Mat.t()), list(Evision.Mat.t()), Evision.Mat.t()} | {:error, String.t()}
  def stereoCalibrateExtended(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, r, t) when is_list(objectPoints) and is_list(imagePoints1) and is_list(imagePoints2) and (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(t, Evision.Mat) or is_struct(t, Nx.Tensor) or is_number(t) or is_tuple(t))
  do
    positional = [
      objectPoints: Evision.Internal.Structurise.from_struct(objectPoints),
      imagePoints1: Evision.Internal.Structurise.from_struct(imagePoints1),
      imagePoints2: Evision.Internal.Structurise.from_struct(imagePoints2),
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r: Evision.Internal.Structurise.from_struct(r),
      t: Evision.Internal.Structurise.from_struct(t)
    ]
    :evision_nif.stereoCalibrateExtended(positional)
    |> to_struct()
  end

  @doc """
  Computes rectification transforms for each head of a calibrated stereo camera.

  ##### Positional Arguments
  - **cameraMatrix1**: `Evision.Mat`.

    First camera intrinsic matrix.

  - **distCoeffs1**: `Evision.Mat`.

    First camera distortion parameters.

  - **cameraMatrix2**: `Evision.Mat`.

    Second camera intrinsic matrix.

  - **distCoeffs2**: `Evision.Mat`.

    Second camera distortion parameters.

  - **imageSize**: `Size`.

    Size of the image used for stereo calibration.

  - **r**: `Evision.Mat`.

    Rotation matrix from the coordinate system of the first camera to the second camera,
    see @ref stereoCalibrate.

  - **t**: `Evision.Mat`.

    Translation vector from the coordinate system of the first camera to the second camera,
    see @ref stereoCalibrate.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Operation flags that may be zero or @ref CALIB_ZERO_DISPARITY . If the flag is set,
    the function makes the principal points of each camera have the same pixel coordinates in the
    rectified views. And if the flag is not set, the function may still shift the images in the
    horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the
    useful image area.

  - **alpha**: `double`.

    Free scaling parameter. If it is -1 or absent, the function performs the default
    scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified
    images are zoomed and shifted so that only valid pixels are visible (no black areas after
    rectification). alpha=1 means that the rectified image is decimated and shifted so that all the
    pixels from the original images from the cameras are retained in the rectified images (no source
    image pixels are lost). Any intermediate value yields an intermediate result between
    those two extreme cases.

  - **newImageSize**: `Size`.

    New image resolution after rectification. The same size should be passed to
    #initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)
    is passed (default), it is set to the original imageSize . Setting it to a larger value can help you
    preserve details in the original image, especially when there is a big radial distortion.

  ##### Return
  - **r1**: `Evision.Mat.t()`.

    Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix
    brings points given in the unrectified first camera's coordinate system to points in the rectified
    first camera's coordinate system. In more technical terms, it performs a change of basis from the
    unrectified first camera's coordinate system to the rectified first camera's coordinate system.

  - **r2**: `Evision.Mat.t()`.

    Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix
    brings points given in the unrectified second camera's coordinate system to points in the rectified
    second camera's coordinate system. In more technical terms, it performs a change of basis from the
    unrectified second camera's coordinate system to the rectified second camera's coordinate system.

  - **p1**: `Evision.Mat.t()`.

    Output 3x4 projection matrix in the new (rectified) coordinate systems for the first
    camera, i.e. it projects points given in the rectified first camera coordinate system into the
    rectified first camera's image.

  - **p2**: `Evision.Mat.t()`.

    Output 3x4 projection matrix in the new (rectified) coordinate systems for the second
    camera, i.e. it projects points given in the rectified first camera coordinate system into the
    rectified second camera's image.

  - **q**: `Evision.Mat.t()`.

    Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see @ref reprojectImageTo3D).

  - **validPixROI1**: `Rect*`.

    Optional output rectangles inside the rectified images where all the pixels
    are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller
    (see the picture below).

  - **validPixROI2**: `Rect*`.

    Optional output rectangles inside the rectified images where all the pixels
    are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller
    (see the picture below).

  The function computes the rotation matrices for each camera that (virtually) make both camera image
  planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies
  the dense stereo correspondence problem. The function takes the matrices computed by #stereoCalibrate
  as input. As output, it provides two rotation matrices and also two projection matrices in the new
  coordinates. The function distinguishes the following two cases:
  - **Horizontal stereo**: the first and the second camera views are shifted relative to each other
    mainly along the x-axis (with possible small vertical shift). In the rectified images, the
    corresponding epipolar lines in the left and right cameras are horizontal and have the same
    y-coordinate. P1 and P2 look like:

  \\f[\\texttt{P1} = \\begin{bmatrix}
  f & 0 & cx\\_1 & 0 \\\\\\\\
  0 & f & cy & 0 \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix}\\f]
  \\f[\\texttt{P2} = \\begin{bmatrix}
  f & 0 & cx\\_2 & T\\_x \\cdot f \\\\\\\\
  0 & f & cy & 0 \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix} ,\\f]
  \\f[\\texttt{Q} = \\begin{bmatrix}
  1 & 0 & 0 & -cx\\_1 \\\\\\\\
  0 & 1 & 0 & -cy \\\\\\\\
  0 & 0 & 0 & f \\\\\\\\
  0 & 0 & -\\frac{1}{T\\_x} & \\frac{cx\\_1 - cx\\_2}{T\\_x}
  \\end{bmatrix} \\f]
  where \\f$T\\_x\\f$ is a horizontal shift between the cameras and \\f$cx\\_1=cx\\_2\\f$ if
  @ref CALIB_ZERO_DISPARITY is set.
  - **Vertical stereo**: the first and the second camera views are shifted relative to each other
    mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar
    lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:

  \\f[\\texttt{P1} = \\begin{bmatrix}
  f & 0 & cx & 0 \\\\\\\\
  0 & f & cy\\_1 & 0 \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix}\\f]
  \\f[\\texttt{P2} = \\begin{bmatrix}
  f & 0 & cx & 0 \\\\\\\\
  0 & f & cy\\_2 & T\\_y \\cdot f \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix},\\f]
  \\f[\\texttt{Q} = \\begin{bmatrix}
  1 & 0 & 0 & -cx \\\\\\\\
  0 & 1 & 0 & -cy\\_1 \\\\\\\\
  0 & 0 & 0 & f \\\\\\\\
  0 & 0 & -\\frac{1}{T\\_y} & \\frac{cy\\_1 - cy\\_2}{T\\_y}
  \\end{bmatrix} \\f]
  where \\f$T\\_y\\f$ is a vertical shift between the cameras and \\f$cy\\_1=cy\\_2\\f$ if
  @ref CALIB_ZERO_DISPARITY is set.
  As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera
  matrices. The matrices, together with R1 and R2 , can then be passed to #initUndistortRectifyMap to
  initialize the rectification map for each camera.
  See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through
  the corresponding image regions. This means that the images are well rectified, which is what most
  stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that
  their interiors are all valid pixels.
  ![image](pics/stereo_undistort.jpg)

  Python prototype (for reference only):
  ```python3
  stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, R1[, R2[, P1[, P2[, Q[, flags[, alpha[, newImageSize]]]]]]]]) -> R1, R2, P1, P2, Q, validPixROI1, validPixROI2
  ```
  """
  @spec stereoRectify(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:alpha, term()} | {:flags, term()} | {:newImageSize, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), {number(), number(), number(), number()}, {number(), number(), number(), number()}} | {:error, String.t()}
  def stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, r, t, opts) when (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(t, Evision.Mat) or is_struct(t, Nx.Tensor) or is_number(t) or is_tuple(t)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:alpha, :flags, :newImageSize])
    positional = [
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r: Evision.Internal.Structurise.from_struct(r),
      t: Evision.Internal.Structurise.from_struct(t)
    ]
    :evision_nif.stereoRectify(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes rectification transforms for each head of a calibrated stereo camera.

  ##### Positional Arguments
  - **cameraMatrix1**: `Evision.Mat`.

    First camera intrinsic matrix.

  - **distCoeffs1**: `Evision.Mat`.

    First camera distortion parameters.

  - **cameraMatrix2**: `Evision.Mat`.

    Second camera intrinsic matrix.

  - **distCoeffs2**: `Evision.Mat`.

    Second camera distortion parameters.

  - **imageSize**: `Size`.

    Size of the image used for stereo calibration.

  - **r**: `Evision.Mat`.

    Rotation matrix from the coordinate system of the first camera to the second camera,
    see @ref stereoCalibrate.

  - **t**: `Evision.Mat`.

    Translation vector from the coordinate system of the first camera to the second camera,
    see @ref stereoCalibrate.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    Operation flags that may be zero or @ref CALIB_ZERO_DISPARITY . If the flag is set,
    the function makes the principal points of each camera have the same pixel coordinates in the
    rectified views. And if the flag is not set, the function may still shift the images in the
    horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the
    useful image area.

  - **alpha**: `double`.

    Free scaling parameter. If it is -1 or absent, the function performs the default
    scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified
    images are zoomed and shifted so that only valid pixels are visible (no black areas after
    rectification). alpha=1 means that the rectified image is decimated and shifted so that all the
    pixels from the original images from the cameras are retained in the rectified images (no source
    image pixels are lost). Any intermediate value yields an intermediate result between
    those two extreme cases.

  - **newImageSize**: `Size`.

    New image resolution after rectification. The same size should be passed to
    #initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)
    is passed (default), it is set to the original imageSize . Setting it to a larger value can help you
    preserve details in the original image, especially when there is a big radial distortion.

  ##### Return
  - **r1**: `Evision.Mat.t()`.

    Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix
    brings points given in the unrectified first camera's coordinate system to points in the rectified
    first camera's coordinate system. In more technical terms, it performs a change of basis from the
    unrectified first camera's coordinate system to the rectified first camera's coordinate system.

  - **r2**: `Evision.Mat.t()`.

    Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix
    brings points given in the unrectified second camera's coordinate system to points in the rectified
    second camera's coordinate system. In more technical terms, it performs a change of basis from the
    unrectified second camera's coordinate system to the rectified second camera's coordinate system.

  - **p1**: `Evision.Mat.t()`.

    Output 3x4 projection matrix in the new (rectified) coordinate systems for the first
    camera, i.e. it projects points given in the rectified first camera coordinate system into the
    rectified first camera's image.

  - **p2**: `Evision.Mat.t()`.

    Output 3x4 projection matrix in the new (rectified) coordinate systems for the second
    camera, i.e. it projects points given in the rectified first camera coordinate system into the
    rectified second camera's image.

  - **q**: `Evision.Mat.t()`.

    Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see @ref reprojectImageTo3D).

  - **validPixROI1**: `Rect*`.

    Optional output rectangles inside the rectified images where all the pixels
    are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller
    (see the picture below).

  - **validPixROI2**: `Rect*`.

    Optional output rectangles inside the rectified images where all the pixels
    are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller
    (see the picture below).

  The function computes the rotation matrices for each camera that (virtually) make both camera image
  planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies
  the dense stereo correspondence problem. The function takes the matrices computed by #stereoCalibrate
  as input. As output, it provides two rotation matrices and also two projection matrices in the new
  coordinates. The function distinguishes the following two cases:
  - **Horizontal stereo**: the first and the second camera views are shifted relative to each other
    mainly along the x-axis (with possible small vertical shift). In the rectified images, the
    corresponding epipolar lines in the left and right cameras are horizontal and have the same
    y-coordinate. P1 and P2 look like:

  \\f[\\texttt{P1} = \\begin{bmatrix}
  f & 0 & cx\\_1 & 0 \\\\\\\\
  0 & f & cy & 0 \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix}\\f]
  \\f[\\texttt{P2} = \\begin{bmatrix}
  f & 0 & cx\\_2 & T\\_x \\cdot f \\\\\\\\
  0 & f & cy & 0 \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix} ,\\f]
  \\f[\\texttt{Q} = \\begin{bmatrix}
  1 & 0 & 0 & -cx\\_1 \\\\\\\\
  0 & 1 & 0 & -cy \\\\\\\\
  0 & 0 & 0 & f \\\\\\\\
  0 & 0 & -\\frac{1}{T\\_x} & \\frac{cx\\_1 - cx\\_2}{T\\_x}
  \\end{bmatrix} \\f]
  where \\f$T\\_x\\f$ is a horizontal shift between the cameras and \\f$cx\\_1=cx\\_2\\f$ if
  @ref CALIB_ZERO_DISPARITY is set.
  - **Vertical stereo**: the first and the second camera views are shifted relative to each other
    mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar
    lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:

  \\f[\\texttt{P1} = \\begin{bmatrix}
  f & 0 & cx & 0 \\\\\\\\
  0 & f & cy\\_1 & 0 \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix}\\f]
  \\f[\\texttt{P2} = \\begin{bmatrix}
  f & 0 & cx & 0 \\\\\\\\
  0 & f & cy\\_2 & T\\_y \\cdot f \\\\\\\\
  0 & 0 & 1 & 0
  \\end{bmatrix},\\f]
  \\f[\\texttt{Q} = \\begin{bmatrix}
  1 & 0 & 0 & -cx \\\\\\\\
  0 & 1 & 0 & -cy\\_1 \\\\\\\\
  0 & 0 & 0 & f \\\\\\\\
  0 & 0 & -\\frac{1}{T\\_y} & \\frac{cy\\_1 - cy\\_2}{T\\_y}
  \\end{bmatrix} \\f]
  where \\f$T\\_y\\f$ is a vertical shift between the cameras and \\f$cy\\_1=cy\\_2\\f$ if
  @ref CALIB_ZERO_DISPARITY is set.
  As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera
  matrices. The matrices, together with R1 and R2 , can then be passed to #initUndistortRectifyMap to
  initialize the rectification map for each camera.
  See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through
  the corresponding image regions. This means that the images are well rectified, which is what most
  stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that
  their interiors are all valid pixels.
  ![image](pics/stereo_undistort.jpg)

  Python prototype (for reference only):
  ```python3
  stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, R1[, R2[, P1[, P2[, Q[, flags[, alpha[, newImageSize]]]]]]]]) -> R1, R2, P1, P2, Q, validPixROI1, validPixROI2
  ```
  """
  @spec stereoRectify(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: {Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), Evision.Mat.t(), {number(), number(), number(), number()}, {number(), number(), number(), number()}} | {:error, String.t()}
  def stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, r, t) when (is_struct(cameraMatrix1, Evision.Mat) or is_struct(cameraMatrix1, Nx.Tensor) or is_number(cameraMatrix1) or is_tuple(cameraMatrix1)) and (is_struct(distCoeffs1, Evision.Mat) or is_struct(distCoeffs1, Nx.Tensor) or is_number(distCoeffs1) or is_tuple(distCoeffs1)) and (is_struct(cameraMatrix2, Evision.Mat) or is_struct(cameraMatrix2, Nx.Tensor) or is_number(cameraMatrix2) or is_tuple(cameraMatrix2)) and (is_struct(distCoeffs2, Evision.Mat) or is_struct(distCoeffs2, Nx.Tensor) or is_number(distCoeffs2) or is_tuple(distCoeffs2)) and is_tuple(imageSize) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(t, Evision.Mat) or is_struct(t, Nx.Tensor) or is_number(t) or is_tuple(t))
  do
    positional = [
      cameraMatrix1: Evision.Internal.Structurise.from_struct(cameraMatrix1),
      distCoeffs1: Evision.Internal.Structurise.from_struct(distCoeffs1),
      cameraMatrix2: Evision.Internal.Structurise.from_struct(cameraMatrix2),
      distCoeffs2: Evision.Internal.Structurise.from_struct(distCoeffs2),
      imageSize: Evision.Internal.Structurise.from_struct(imageSize),
      r: Evision.Internal.Structurise.from_struct(r),
      t: Evision.Internal.Structurise.from_struct(t)
    ]
    :evision_nif.stereoRectify(positional)
    |> to_struct()
  end

  @doc """
  Computes a rectification transform for an uncalibrated stereo camera.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of feature points in the first image.

  - **points2**: `Evision.Mat`.

    The corresponding points in the second image. The same formats as in
    #findFundamentalMat are supported.

  - **f**: `Evision.Mat`.

    Input fundamental matrix. It can be computed from the same set of point pairs using
    #findFundamentalMat .

  - **imgSize**: `Size`.

    Size of the image.

  ##### Keyword Arguments
  - **threshold**: `double`.

    Optional threshold used to filter out the outliers. If the parameter is greater
    than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points
    for which \\f$|\\texttt{points2[i]}^T \\cdot \\texttt{F} \\cdot \\texttt{points1[i]}|>\\texttt{threshold}\\f$ )
    are rejected prior to computing the homographies. Otherwise, all the points are considered inliers.

  ##### Return
  - **retval**: `bool`
  - **h1**: `Evision.Mat.t()`.

    Output rectification homography matrix for the first image.

  - **h2**: `Evision.Mat.t()`.

    Output rectification homography matrix for the second image.

  The function computes the rectification transformations without knowing intrinsic parameters of the
  cameras and their relative position in the space, which explains the suffix "uncalibrated". Another
  related difference from #stereoRectify is that the function outputs not the rectification
  transformations in the object (3D) space, but the planar perspective transformations encoded by the
  homography matrices H1 and H2 . The function implements the algorithm @cite Hartley99 .
  **Note**: 
  While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily
  depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion,
  it would be better to correct it before computing the fundamental matrix and calling this
  function. For example, distortion coefficients can be estimated for each head of stereo camera
  separately by using #calibrateCamera . Then, the images can be corrected using #undistort , or
  just the point coordinates can be corrected with #undistortPoints .

  Python prototype (for reference only):
  ```python3
  stereoRectifyUncalibrated(points1, points2, F, imgSize[, H1[, H2[, threshold]]]) -> retval, H1, H2
  ```
  """
  @spec stereoRectifyUncalibrated(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, [{:threshold, term()}] | nil) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def stereoRectifyUncalibrated(points1, points2, f, imgSize, opts) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f)) and is_tuple(imgSize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:threshold])
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      f: Evision.Internal.Structurise.from_struct(f),
      imgSize: Evision.Internal.Structurise.from_struct(imgSize)
    ]
    :evision_nif.stereoRectifyUncalibrated(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes a rectification transform for an uncalibrated stereo camera.

  ##### Positional Arguments
  - **points1**: `Evision.Mat`.

    Array of feature points in the first image.

  - **points2**: `Evision.Mat`.

    The corresponding points in the second image. The same formats as in
    #findFundamentalMat are supported.

  - **f**: `Evision.Mat`.

    Input fundamental matrix. It can be computed from the same set of point pairs using
    #findFundamentalMat .

  - **imgSize**: `Size`.

    Size of the image.

  ##### Keyword Arguments
  - **threshold**: `double`.

    Optional threshold used to filter out the outliers. If the parameter is greater
    than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points
    for which \\f$|\\texttt{points2[i]}^T \\cdot \\texttt{F} \\cdot \\texttt{points1[i]}|>\\texttt{threshold}\\f$ )
    are rejected prior to computing the homographies. Otherwise, all the points are considered inliers.

  ##### Return
  - **retval**: `bool`
  - **h1**: `Evision.Mat.t()`.

    Output rectification homography matrix for the first image.

  - **h2**: `Evision.Mat.t()`.

    Output rectification homography matrix for the second image.

  The function computes the rectification transformations without knowing intrinsic parameters of the
  cameras and their relative position in the space, which explains the suffix "uncalibrated". Another
  related difference from #stereoRectify is that the function outputs not the rectification
  transformations in the object (3D) space, but the planar perspective transformations encoded by the
  homography matrices H1 and H2 . The function implements the algorithm @cite Hartley99 .
  **Note**: 
  While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily
  depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion,
  it would be better to correct it before computing the fundamental matrix and calling this
  function. For example, distortion coefficients can be estimated for each head of stereo camera
  separately by using #calibrateCamera . Then, the images can be corrected using #undistort , or
  just the point coordinates can be corrected with #undistortPoints .

  Python prototype (for reference only):
  ```python3
  stereoRectifyUncalibrated(points1, points2, F, imgSize[, H1[, H2[, threshold]]]) -> retval, H1, H2
  ```
  """
  @spec stereoRectifyUncalibrated(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}) :: {Evision.Mat.t(), Evision.Mat.t()} | false | {:error, String.t()}
  def stereoRectifyUncalibrated(points1, points2, f, imgSize) when (is_struct(points1, Evision.Mat) or is_struct(points1, Nx.Tensor) or is_number(points1) or is_tuple(points1)) and (is_struct(points2, Evision.Mat) or is_struct(points2, Nx.Tensor) or is_number(points2) or is_tuple(points2)) and (is_struct(f, Evision.Mat) or is_struct(f, Nx.Tensor) or is_number(f) or is_tuple(f)) and is_tuple(imgSize)
  do
    positional = [
      points1: Evision.Internal.Structurise.from_struct(points1),
      points2: Evision.Internal.Structurise.from_struct(points2),
      f: Evision.Internal.Structurise.from_struct(f),
      imgSize: Evision.Internal.Structurise.from_struct(imgSize)
    ]
    :evision_nif.stereoRectifyUncalibrated(positional)
    |> to_struct()
  end

  @doc """
  Stylization aims to produce digital imagery with a wide variety of effects not focused on
  photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low
  contrast while preserving, or enhancing, high-contrast features.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  Python prototype (for reference only):
  ```python3
  stylization(src[, dst[, sigma_s[, sigma_r]]]) -> dst
  ```
  """
  @spec stylization(Evision.Mat.maybe_mat_in(), [{:sigma_r, term()} | {:sigma_s, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def stylization(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:sigma_r, :sigma_s])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.stylization(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Stylization aims to produce digital imagery with a wide variety of effects not focused on
  photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low
  contrast while preserving, or enhancing, high-contrast features.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Keyword Arguments
  - **sigma_s**: `float`.

    %Range between 0 to 200.

  - **sigma_r**: `float`.

    %Range between 0 to 1.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  Python prototype (for reference only):
  ```python3
  stylization(src[, dst[, sigma_s[, sigma_r]]]) -> dst
  ```
  """
  @spec stylization(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def stylization(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.stylization(positional)
    |> to_struct()
  end

  @doc """
  Calculates the per-element difference between two arrays or array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar.

  - **src2**: `Evision.Mat`.

    second input array or a scalar.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask; this is an 8-bit single channel array that specifies elements
    of the output array to be changed.

  - **dtype**: `integer()`.

    optional depth of the output array

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and the same number of channels as the input array.

  The function subtract calculates:
  - Difference between two arrays, when both input arrays have the same size and the same number of
    channels:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
    number of elements as `src1.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
    number of elements as `src2.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} -  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - The reverse difference between a scalar and an array in the case of `SubRS`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src2} -  \\texttt{src1}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]
    where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.

  The first function in the list above can be replaced with matrix expressions:
  ```cpp
  dst = src1 - src2;
  dst -= src1; // equivalent to subtract(dst, src1, dst);
  ```
  The input arrays and the output array can all have the same or different depths. For example, you
  can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
  the output array is determined by dtype parameter. In the second and third cases above, as well as
  in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
  case the output array will have the same depth as the input array, be it src1, src2 or both.
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `subtract(src,X)` means `subtract(src,(X,X,X,X))`.
  `subtract(src,(X,))` means `subtract(src,(X,0,0,0))`.
  @sa  add, addWeighted, scaleAdd, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  subtract(src1, src2[, dst[, mask[, dtype]]]) -> dst
  ```
  """
  @spec subtract(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:dtype, term()} | {:mask, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def subtract(src1, src2, opts) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:dtype, :mask])
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.subtract(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Calculates the per-element difference between two arrays or array and a scalar.

  ##### Positional Arguments
  - **src1**: `Evision.Mat`.

    first input array or a scalar.

  - **src2**: `Evision.Mat`.

    second input array or a scalar.

  ##### Keyword Arguments
  - **mask**: `Evision.Mat`.

    optional operation mask; this is an 8-bit single channel array that specifies elements
    of the output array to be changed.

  - **dtype**: `integer()`.

    optional depth of the output array

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and the same number of channels as the input array.

  The function subtract calculates:
  - Difference between two arrays, when both input arrays have the same size and the same number of
    channels:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
    number of elements as `src1.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
    number of elements as `src2.channels()`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} -  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]

  - The reverse difference between a scalar and an array in the case of `SubRS`:
    \\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src2} -  \\texttt{src1}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]
    where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.

  The first function in the list above can be replaced with matrix expressions:
  ```cpp
  dst = src1 - src2;
  dst -= src1; // equivalent to subtract(dst, src1, dst);
  ```
  The input arrays and the output array can all have the same or different depths. For example, you
  can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
  the output array is determined by dtype parameter. In the second and third cases above, as well as
  in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
  case the output array will have the same depth as the input array, be it src1, src2 or both.
  **Note**: Saturation is not applied when the output array has the depth CV_32S. You may even get
  result of an incorrect sign in the case of overflow.
  **Note**: (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
  `subtract(src,X)` means `subtract(src,(X,X,X,X))`.
  `subtract(src,(X,))` means `subtract(src,(X,0,0,0))`.
  @sa  add, addWeighted, scaleAdd, Mat::convertTo

  Python prototype (for reference only):
  ```python3
  subtract(src1, src2[, dst[, mask[, dtype]]]) -> dst
  ```
  """
  @spec subtract(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def subtract(src1, src2) when (is_struct(src1, Evision.Mat) or is_struct(src1, Nx.Tensor) or is_number(src1) or is_tuple(src1)) and (is_struct(src2, Evision.Mat) or is_struct(src2, Nx.Tensor) or is_number(src2) or is_tuple(src2))
  do
    positional = [
      src1: Evision.Internal.Structurise.from_struct(src1),
      src2: Evision.Internal.Structurise.from_struct(src2)
    ]
    :evision_nif.subtract(positional)
    |> to_struct()
  end

  @doc """
  Calculates the sum of array elements.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that must have from 1 to 4 channels.

  ##### Return
  - **retval**: `Evision.scalar().t()`

  The function cv::sum calculates and returns the sum of array elements,
  independently for each channel.
  @sa  countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce

  Python prototype (for reference only):
  ```python3
  sumElems(src) -> retval
  ```
  """
  @spec sumElems(Evision.Mat.maybe_mat_in()) :: Evision.scalar() | {:error, String.t()}
  def sumElems(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.sumElems(positional)
    |> to_struct()
  end

  @doc """
  By retaining only the gradients at edge locations, before integrating with the Poisson solver, one
  washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge %Detector is used.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  ##### Keyword Arguments
  - **low_threshold**: `float`.

    %Range from 0 to 100.

  - **high_threshold**: `float`.

    Value \\> 100.

  - **kernel_size**: `integer()`.

    The size of the Sobel kernel to be used.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  **Note**: 
  The algorithm assumes that the color of the source image is close to that of the destination. This
  assumption means that when the colors don't match, the source image color gets tinted toward the
  color of the destination image.

  Python prototype (for reference only):
  ```python3
  textureFlattening(src, mask[, dst[, low_threshold[, high_threshold[, kernel_size]]]]) -> dst
  ```
  """
  @spec textureFlattening(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:high_threshold, term()} | {:kernel_size, term()} | {:low_threshold, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def textureFlattening(src, mask, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:high_threshold, :kernel_size, :low_threshold])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.textureFlattening(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  By retaining only the gradients at edge locations, before integrating with the Poisson solver, one
  washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge %Detector is used.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  - **mask**: `Evision.Mat`.

    Input 8-bit 1 or 3-channel image.

  ##### Keyword Arguments
  - **low_threshold**: `float`.

    %Range from 0 to 100.

  - **high_threshold**: `float`.

    Value \\> 100.

  - **kernel_size**: `integer()`.

    The size of the Sobel kernel to be used.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output image with the same size and type as src.

  **Note**: 
  The algorithm assumes that the color of the source image is close to that of the destination. This
  assumption means that when the colors don't match, the source image color gets tinted toward the
  color of the destination image.

  Python prototype (for reference only):
  ```python3
  textureFlattening(src, mask[, dst[, low_threshold[, high_threshold[, kernel_size]]]]) -> dst
  ```
  """
  @spec textureFlattening(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def textureFlattening(src, mask) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(mask, Evision.Mat) or is_struct(mask, Nx.Tensor) or is_number(mask) or is_tuple(mask))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      mask: Evision.Internal.Structurise.from_struct(mask)
    ]
    :evision_nif.textureFlattening(positional)
    |> to_struct()
  end

  @doc """
  Applies a fixed-level threshold to each array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array (multiple-channel, 8-bit or 32-bit floating point).

  - **thresh**: `double`.

    threshold value.

  - **maxval**: `double`.

    maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding
    types.

  - **type**: `integer()`.

    thresholding type (see #ThresholdTypes).

  ##### Return
  - **retval**: `double`
  - **dst**: `Evision.Mat.t()`.

    output array of the same size  and type and the same number of channels as src.

  The function applies fixed-level thresholding to a multiple-channel array. The function is typically
  used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for
  this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
  values. There are several types of thresholding supported by the function. They are determined by
  type parameter.
  Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the
  above values. In these cases, the function determines the optimal threshold value using the Otsu's
  or Triangle algorithm and uses it instead of the specified thresh.
  **Note**: Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.
  @return the computed threshold value if Otsu's or Triangle methods used.
  @sa  adaptiveThreshold, findContours, compare, min, max

  Python prototype (for reference only):
  ```python3
  threshold(src, thresh, maxval, type[, dst]) -> retval, dst
  ```
  """
  @spec threshold(Evision.Mat.maybe_mat_in(), number(), number(), integer(), [{atom(), term()},...] | nil) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def threshold(src, thresh, maxval, type, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(thresh) and is_number(maxval) and is_integer(type) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      thresh: Evision.Internal.Structurise.from_struct(thresh),
      maxval: Evision.Internal.Structurise.from_struct(maxval),
      type: Evision.Internal.Structurise.from_struct(type)
    ]
    :evision_nif.threshold(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies a fixed-level threshold to each array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array (multiple-channel, 8-bit or 32-bit floating point).

  - **thresh**: `double`.

    threshold value.

  - **maxval**: `double`.

    maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding
    types.

  - **type**: `integer()`.

    thresholding type (see #ThresholdTypes).

  ##### Return
  - **retval**: `double`
  - **dst**: `Evision.Mat.t()`.

    output array of the same size  and type and the same number of channels as src.

  The function applies fixed-level thresholding to a multiple-channel array. The function is typically
  used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for
  this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
  values. There are several types of thresholding supported by the function. They are determined by
  type parameter.
  Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the
  above values. In these cases, the function determines the optimal threshold value using the Otsu's
  or Triangle algorithm and uses it instead of the specified thresh.
  **Note**: Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.
  @return the computed threshold value if Otsu's or Triangle methods used.
  @sa  adaptiveThreshold, findContours, compare, min, max

  Python prototype (for reference only):
  ```python3
  threshold(src, thresh, maxval, type[, dst]) -> retval, dst
  ```
  """
  @spec threshold(Evision.Mat.maybe_mat_in(), number(), number(), integer()) :: {number(), Evision.Mat.t()} | {:error, String.t()}
  def threshold(src, thresh, maxval, type) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_number(thresh) and is_number(maxval) and is_integer(type)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      thresh: Evision.Internal.Structurise.from_struct(thresh),
      maxval: Evision.Internal.Structurise.from_struct(maxval),
      type: Evision.Internal.Structurise.from_struct(type)
    ]
    :evision_nif.threshold(positional)
    |> to_struct()
  end

  @doc """
  Returns the trace of a matrix.

  ##### Positional Arguments
  - **mtx**: `Evision.Mat`.

    input matrix.

  ##### Return
  - **retval**: `Evision.scalar().t()`

  The function cv::trace returns the sum of the diagonal elements of the
  matrix mtx .
  \\f[\\mathrm{tr} ( \\texttt{mtx} ) =  \\sum \\_i  \\texttt{mtx} (i,i)\\f]

  Python prototype (for reference only):
  ```python3
  trace(mtx) -> retval
  ```
  """
  @spec trace(Evision.Mat.maybe_mat_in()) :: Evision.scalar() | {:error, String.t()}
  def trace(mtx) when (is_struct(mtx, Evision.Mat) or is_struct(mtx, Nx.Tensor) or is_number(mtx) or is_tuple(mtx))
  do
    positional = [
      mtx: Evision.Internal.Structurise.from_struct(mtx)
    ]
    :evision_nif.trace(positional)
    |> to_struct()
  end

  @doc """
  Performs the matrix transformation of every array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that must have as many channels (1 to 4) as
    m.cols or m.cols-1.

  - **m**: `Evision.Mat`.

    transformation 2x2 or 2x3 floating-point matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and depth as src; it has as
    many channels as m.rows.

  The function cv::transform performs the matrix transformation of every
  element of the array src and stores the results in dst :
  \\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot \\texttt{src} (I)\\f]
  (when m.cols=src.channels() ), or
  \\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot \\[ \\texttt{src} (I); 1]\\f]
  (when m.cols=src.channels()+1 )
  Every element of the N -channel array src is interpreted as N -element
  vector that is transformed using the M x N or M x (N+1) matrix m to
  M-element vector - the corresponding element of the output array dst .
  The function may be used for geometrical transformation of
  N -dimensional points, arbitrary linear color space transformation (such
  as various kinds of RGB to YUV transforms), shuffling the image
  channels, and so forth.
  @sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective

  Python prototype (for reference only):
  ```python3
  transform(src, m[, dst]) -> dst
  ```
  """
  @spec transform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def transform(src, m, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.transform(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Performs the matrix transformation of every array element.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array that must have as many channels (1 to 4) as
    m.cols or m.cols-1.

  - **m**: `Evision.Mat`.

    transformation 2x2 or 2x3 floating-point matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same size and depth as src; it has as
    many channels as m.rows.

  The function cv::transform performs the matrix transformation of every
  element of the array src and stores the results in dst :
  \\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot \\texttt{src} (I)\\f]
  (when m.cols=src.channels() ), or
  \\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot \\[ \\texttt{src} (I); 1]\\f]
  (when m.cols=src.channels()+1 )
  Every element of the N -channel array src is interpreted as N -element
  vector that is transformed using the M x N or M x (N+1) matrix m to
  M-element vector - the corresponding element of the output array dst .
  The function may be used for geometrical transformation of
  N -dimensional points, arbitrary linear color space transformation (such
  as various kinds of RGB to YUV transforms), shuffling the image
  channels, and so forth.
  @sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective

  Python prototype (for reference only):
  ```python3
  transform(src, m[, dst]) -> dst
  ```
  """
  @spec transform(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def transform(src, m) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m)
    ]
    :evision_nif.transform(positional)
    |> to_struct()
  end

  @doc """
  Transposes a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as src.

  The function cv::transpose transposes the matrix src :
  \\f[\\texttt{dst} (i,j) =  \\texttt{src} (j,i)\\f]
  **Note**: No complex conjugation is done in case of a complex matrix. It
  should be done separately if needed.

  Python prototype (for reference only):
  ```python3
  transpose(src[, dst]) -> dst
  ```
  """
  @spec transpose(Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def transpose(src, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.transpose(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Transposes a matrix.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as src.

  The function cv::transpose transposes the matrix src :
  \\f[\\texttt{dst} (i,j) =  \\texttt{src} (j,i)\\f]
  **Note**: No complex conjugation is done in case of a complex matrix. It
  should be done separately if needed.

  Python prototype (for reference only):
  ```python3
  transpose(src[, dst]) -> dst
  ```
  """
  @spec transpose(Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def transpose(src) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.transpose(positional)
    |> to_struct()
  end

  @doc """
  Transpose for n-dimensional matrices.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **order**: `[integer()]`.

    a permutation of [0,1,..,N-1] where N is the number of axes of src.
    The i'th axis of dst will correspond to the axis numbered order[i] of the input.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as src.

  **Note**: Input should be continuous single-channel matrix.

  Python prototype (for reference only):
  ```python3
  transposeND(src, order[, dst]) -> dst
  ```
  """
  @spec transposeND(Evision.Mat.maybe_mat_in(), list(integer()), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def transposeND(src, order, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_list(order) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      order: Evision.Internal.Structurise.from_struct(order)
    ]
    :evision_nif.transposeND(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Transpose for n-dimensional matrices.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input array.

  - **order**: `[integer()]`.

    a permutation of [0,1,..,N-1] where N is the number of axes of src.
    The i'th axis of dst will correspond to the axis numbered order[i] of the input.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array of the same type as src.

  **Note**: Input should be continuous single-channel matrix.

  Python prototype (for reference only):
  ```python3
  transposeND(src, order[, dst]) -> dst
  ```
  """
  @spec transposeND(Evision.Mat.maybe_mat_in(), list(integer())) :: Evision.Mat.t() | {:error, String.t()}
  def transposeND(src, order) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_list(order)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      order: Evision.Internal.Structurise.from_struct(order)
    ]
    :evision_nif.transposeND(positional)
    |> to_struct()
  end

  @doc """
  This function reconstructs 3-dimensional points (in homogeneous coordinates) by using
  their observations with a stereo camera.

  ##### Positional Arguments
  - **projMatr1**: `Evision.Mat`.

    3x4 projection matrix of the first camera, i.e. this matrix projects 3D points
    given in the world's coordinate system into the first image.

  - **projMatr2**: `Evision.Mat`.

    3x4 projection matrix of the second camera, i.e. this matrix projects 3D points
    given in the world's coordinate system into the second image.

  - **projPoints1**: `Evision.Mat`.

    2xN array of feature points in the first image. In the case of the c++ version,
    it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.

  - **projPoints2**: `Evision.Mat`.

    2xN array of corresponding points in the second image. In the case of the c++
    version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.

  ##### Return
  - **points4D**: `Evision.Mat.t()`.

    4xN array of reconstructed points in homogeneous coordinates. These points are
    returned in the world's coordinate system.

  **Note**: 
  Keep in mind that all input data should be of float type in order for this function to work.
  **Note**: 
  If the projection matrices from @ref stereoRectify are used, then the returned points are
  represented in the first camera's rectified coordinate system.
  @sa
  reprojectImageTo3D

  Python prototype (for reference only):
  ```python3
  triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2[, points4D]) -> points4D
  ```
  """
  @spec triangulatePoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, opts) when (is_struct(projMatr1, Evision.Mat) or is_struct(projMatr1, Nx.Tensor) or is_number(projMatr1) or is_tuple(projMatr1)) and (is_struct(projMatr2, Evision.Mat) or is_struct(projMatr2, Nx.Tensor) or is_number(projMatr2) or is_tuple(projMatr2)) and (is_struct(projPoints1, Evision.Mat) or is_struct(projPoints1, Nx.Tensor) or is_number(projPoints1) or is_tuple(projPoints1)) and (is_struct(projPoints2, Evision.Mat) or is_struct(projPoints2, Nx.Tensor) or is_number(projPoints2) or is_tuple(projPoints2)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      projMatr1: Evision.Internal.Structurise.from_struct(projMatr1),
      projMatr2: Evision.Internal.Structurise.from_struct(projMatr2),
      projPoints1: Evision.Internal.Structurise.from_struct(projPoints1),
      projPoints2: Evision.Internal.Structurise.from_struct(projPoints2)
    ]
    :evision_nif.triangulatePoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  This function reconstructs 3-dimensional points (in homogeneous coordinates) by using
  their observations with a stereo camera.

  ##### Positional Arguments
  - **projMatr1**: `Evision.Mat`.

    3x4 projection matrix of the first camera, i.e. this matrix projects 3D points
    given in the world's coordinate system into the first image.

  - **projMatr2**: `Evision.Mat`.

    3x4 projection matrix of the second camera, i.e. this matrix projects 3D points
    given in the world's coordinate system into the second image.

  - **projPoints1**: `Evision.Mat`.

    2xN array of feature points in the first image. In the case of the c++ version,
    it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.

  - **projPoints2**: `Evision.Mat`.

    2xN array of corresponding points in the second image. In the case of the c++
    version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.

  ##### Return
  - **points4D**: `Evision.Mat.t()`.

    4xN array of reconstructed points in homogeneous coordinates. These points are
    returned in the world's coordinate system.

  **Note**: 
  Keep in mind that all input data should be of float type in order for this function to work.
  **Note**: 
  If the projection matrices from @ref stereoRectify are used, then the returned points are
  represented in the first camera's rectified coordinate system.
  @sa
  reprojectImageTo3D

  Python prototype (for reference only):
  ```python3
  triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2[, points4D]) -> points4D
  ```
  """
  @spec triangulatePoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2) when (is_struct(projMatr1, Evision.Mat) or is_struct(projMatr1, Nx.Tensor) or is_number(projMatr1) or is_tuple(projMatr1)) and (is_struct(projMatr2, Evision.Mat) or is_struct(projMatr2, Nx.Tensor) or is_number(projMatr2) or is_tuple(projMatr2)) and (is_struct(projPoints1, Evision.Mat) or is_struct(projPoints1, Nx.Tensor) or is_number(projPoints1) or is_tuple(projPoints1)) and (is_struct(projPoints2, Evision.Mat) or is_struct(projPoints2, Nx.Tensor) or is_number(projPoints2) or is_tuple(projPoints2))
  do
    positional = [
      projMatr1: Evision.Internal.Structurise.from_struct(projMatr1),
      projMatr2: Evision.Internal.Structurise.from_struct(projMatr2),
      projPoints1: Evision.Internal.Structurise.from_struct(projPoints1),
      projPoints2: Evision.Internal.Structurise.from_struct(projPoints2)
    ]
    :evision_nif.triangulatePoints(positional)
    |> to_struct()
  end

  @doc """
  Transforms an image to compensate for lens distortion.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input (distorted) image.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **newCameraMatrix**: `Evision.Mat`.

    Camera matrix of the distorted image. By default, it is the same as
    cameraMatrix but you may additionally scale and shift the result by using a different matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output (corrected) image that has the same size and type as src .

  The function transforms an image to compensate radial and tangential lens distortion.
  The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap
  (with bilinear interpolation). See the former function for details of the transformation being
  performed.
  Those pixels in the destination image, for which there is no correspondent pixels in the source
  image, are filled with zeros (black color).
  A particular subset of the source image that will be visible in the corrected image can be regulated
  by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate
  newCameraMatrix depending on your requirements.
  The camera matrix and the distortion parameters can be determined using #calibrateCamera. If
  the resolution of images is different from the resolution used at the calibration stage, \\f$f\\_x,
  f\\_y, c\\_x\\f$ and \\f$c\\_y\\f$ need to be scaled accordingly, while the distortion coefficients remain
  the same.

  Python prototype (for reference only):
  ```python3
  undistort(src, cameraMatrix, distCoeffs[, dst[, newCameraMatrix]]) -> dst
  ```
  """
  @spec undistort(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:newCameraMatrix, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def undistort(src, cameraMatrix, distCoeffs, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:newCameraMatrix])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.undistort(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Transforms an image to compensate for lens distortion.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Input (distorted) image.

  - **cameraMatrix**: `Evision.Mat`.

    Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **newCameraMatrix**: `Evision.Mat`.

    Camera matrix of the distorted image. By default, it is the same as
    cameraMatrix but you may additionally scale and shift the result by using a different matrix.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output (corrected) image that has the same size and type as src .

  The function transforms an image to compensate radial and tangential lens distortion.
  The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap
  (with bilinear interpolation). See the former function for details of the transformation being
  performed.
  Those pixels in the destination image, for which there is no correspondent pixels in the source
  image, are filled with zeros (black color).
  A particular subset of the source image that will be visible in the corrected image can be regulated
  by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate
  newCameraMatrix depending on your requirements.
  The camera matrix and the distortion parameters can be determined using #calibrateCamera. If
  the resolution of images is different from the resolution used at the calibration stage, \\f$f\\_x,
  f\\_y, c\\_x\\f$ and \\f$c\\_y\\f$ need to be scaled accordingly, while the distortion coefficients remain
  the same.

  Python prototype (for reference only):
  ```python3
  undistort(src, cameraMatrix, distCoeffs[, dst[, newCameraMatrix]]) -> dst
  ```
  """
  @spec undistort(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def undistort(src, cameraMatrix, distCoeffs) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.undistort(positional)
    |> to_struct()
  end

  @doc """
  Compute undistorted image points position

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Observed points position, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or
    CV_64FC2) (or vector\\<Point2f\\> ).

  - **cameraMatrix**: `Evision.Mat`.

    Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Distortion coefficients

  ##### Keyword Arguments
  - **arg1**: `TermCriteria`.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output undistorted points position (1xN/Nx1 2-channel or vector\\<Point2f\\> ).

  Python prototype (for reference only):
  ```python3
  undistortImagePoints(src, cameraMatrix, distCoeffs[, dst[, arg1]]) -> dst
  ```
  """
  @spec undistortImagePoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:arg1, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def undistortImagePoints(src, cameraMatrix, distCoeffs, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:arg1])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.undistortImagePoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Compute undistorted image points position

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Observed points position, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or
    CV_64FC2) (or vector\\<Point2f\\> ).

  - **cameraMatrix**: `Evision.Mat`.

    Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Distortion coefficients

  ##### Keyword Arguments
  - **arg1**: `TermCriteria`.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output undistorted points position (1xN/Nx1 2-channel or vector\\<Point2f\\> ).

  Python prototype (for reference only):
  ```python3
  undistortImagePoints(src, cameraMatrix, distCoeffs[, dst[, arg1]]) -> dst
  ```
  """
  @spec undistortImagePoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def undistortImagePoints(src, cameraMatrix, distCoeffs) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.undistortImagePoints(positional)
    |> to_struct()
  end

  @doc """
  Computes the ideal point coordinates from the observed point coordinates.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or
    vector\\<Point2f\\> ).

  - **cameraMatrix**: `Evision.Mat`.

    Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **r**: `Evision.Mat`.

    Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
    #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.

  - **p**: `Evision.Mat`.

    New camera matrix (3x3) or new projection matrix (3x4) \\f$\\begin{bmatrix} {f'}_x & 0 & {c'}_x & t_x \\\\\\\\ 0 & {f'}_y & {c'}_y & t_y \\\\\\\\ 0 & 0 & 1 & t_z \\end{bmatrix}\\f$. P1 or P2 computed by
    #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output ideal point coordinates (1xN/Nx1 2-channel or vector\\<Point2f\\> ) after undistortion and reverse perspective
    transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.

  The function is similar to #undistort and #initUndistortRectifyMap but it operates on a
  sparse set of points instead of a raster image. Also the function performs a reverse transformation
  to  #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
  planar object, it does, up to a translation vector, if the proper R is specified.
  For each observed point coordinate \\f$(u, v)\\f$ the function computes:
  \\f[
  \\begin{array}{l}
  x^{"}  \\leftarrow (u - c\\_x)/f\\_x  \\\\\\\\
  y^{"}  \\leftarrow (v - c\\_y)/f\\_y  \\\\\\\\
  (x',y') = undistort(x^{"},y^{"}, \\texttt{distCoeffs}) \\\\\\\\
  {\\[X\\,Y\\,W]} ^T  \\leftarrow R\\*\\[x' \\, y' \\, 1]^T  \\\\\\\\
  x  \\leftarrow X/W  \\\\\\\\
  y  \\leftarrow Y/W  \\\\\\\\
  \\text{only performed if P is specified:} \\\\\\\\
  u'  \\leftarrow x {f'}\\_x + {c'}\\_x  \\\\\\\\
  v'  \\leftarrow y {f'}\\_y + {c'}\\_y
  \\end{array}
  \\f]
  where *undistort* is an approximate iterative algorithm that estimates the normalized original
  point coordinates out of the normalized distorted point coordinates ("normalized" means that the
  coordinates do not depend on the camera matrix).
  The function can be used for both a stereo camera head or a monocular camera (when R is empty).

  Python prototype (for reference only):
  ```python3
  undistortPoints(src, cameraMatrix, distCoeffs[, dst[, R[, P]]]) -> dst
  ```
  """
  @spec undistortPoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), [{:p, term()} | {:r, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def undistortPoints(src, cameraMatrix, distCoeffs, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:p, :r])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.undistortPoints(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Computes the ideal point coordinates from the observed point coordinates.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or
    vector\\<Point2f\\> ).

  - **cameraMatrix**: `Evision.Mat`.

    Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .

  - **distCoeffs**: `Evision.Mat`.

    Input vector of distortion coefficients
    \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$
    of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.

  ##### Keyword Arguments
  - **r**: `Evision.Mat`.

    Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by
    #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.

  - **p**: `Evision.Mat`.

    New camera matrix (3x3) or new projection matrix (3x4) \\f$\\begin{bmatrix} {f'}_x & 0 & {c'}_x & t_x \\\\\\\\ 0 & {f'}_y & {c'}_y & t_y \\\\\\\\ 0 & 0 & 1 & t_z \\end{bmatrix}\\f$. P1 or P2 computed by
    #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Output ideal point coordinates (1xN/Nx1 2-channel or vector\\<Point2f\\> ) after undistortion and reverse perspective
    transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.

  The function is similar to #undistort and #initUndistortRectifyMap but it operates on a
  sparse set of points instead of a raster image. Also the function performs a reverse transformation
  to  #projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a
  planar object, it does, up to a translation vector, if the proper R is specified.
  For each observed point coordinate \\f$(u, v)\\f$ the function computes:
  \\f[
  \\begin{array}{l}
  x^{"}  \\leftarrow (u - c\\_x)/f\\_x  \\\\\\\\
  y^{"}  \\leftarrow (v - c\\_y)/f\\_y  \\\\\\\\
  (x',y') = undistort(x^{"},y^{"}, \\texttt{distCoeffs}) \\\\\\\\
  {\\[X\\,Y\\,W]} ^T  \\leftarrow R\\*\\[x' \\, y' \\, 1]^T  \\\\\\\\
  x  \\leftarrow X/W  \\\\\\\\
  y  \\leftarrow Y/W  \\\\\\\\
  \\text{only performed if P is specified:} \\\\\\\\
  u'  \\leftarrow x {f'}\\_x + {c'}\\_x  \\\\\\\\
  v'  \\leftarrow y {f'}\\_y + {c'}\\_y
  \\end{array}
  \\f]
  where *undistort* is an approximate iterative algorithm that estimates the normalized original
  point coordinates out of the normalized distorted point coordinates ("normalized" means that the
  coordinates do not depend on the camera matrix).
  The function can be used for both a stereo camera head or a monocular camera (when R is empty).

  Python prototype (for reference only):
  ```python3
  undistortPoints(src, cameraMatrix, distCoeffs[, dst[, R[, P]]]) -> dst
  ```
  """
  @spec undistortPoints(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def undistortPoints(src, cameraMatrix, distCoeffs) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs)
    ]
    :evision_nif.undistortPoints(positional)
    |> to_struct()
  end

  @doc """
  undistortPointsIter

  ##### Positional Arguments
  - **src**: `Evision.Mat`
  - **cameraMatrix**: `Evision.Mat`
  - **distCoeffs**: `Evision.Mat`
  - **r**: `Evision.Mat`
  - **p**: `Evision.Mat`
  - **criteria**: `TermCriteria`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  **Note**: Default version of #undistortPoints does 5 iterations to compute undistorted points.

  Python prototype (for reference only):
  ```python3
  undistortPointsIter(src, cameraMatrix, distCoeffs, R, P, criteria[, dst]) -> dst
  ```
  """
  @spec undistortPointsIter(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {integer(), integer(), number()}, [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def undistortPointsIter(src, cameraMatrix, distCoeffs, r, p, criteria, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(p, Evision.Mat) or is_struct(p, Nx.Tensor) or is_number(p) or is_tuple(p)) and is_tuple(criteria) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      r: Evision.Internal.Structurise.from_struct(r),
      p: Evision.Internal.Structurise.from_struct(p),
      criteria: Evision.Internal.Structurise.from_struct(criteria)
    ]
    :evision_nif.undistortPointsIter(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  undistortPointsIter

  ##### Positional Arguments
  - **src**: `Evision.Mat`
  - **cameraMatrix**: `Evision.Mat`
  - **distCoeffs**: `Evision.Mat`
  - **r**: `Evision.Mat`
  - **p**: `Evision.Mat`
  - **criteria**: `TermCriteria`

  ##### Return
  - **dst**: `Evision.Mat.t()`.

  Has overloading in C++

  **Note**: Default version of #undistortPoints does 5 iterations to compute undistorted points.

  Python prototype (for reference only):
  ```python3
  undistortPointsIter(src, cameraMatrix, distCoeffs, R, P, criteria[, dst]) -> dst
  ```
  """
  @spec undistortPointsIter(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {integer(), integer(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def undistortPointsIter(src, cameraMatrix, distCoeffs, r, p, criteria) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(cameraMatrix, Evision.Mat) or is_struct(cameraMatrix, Nx.Tensor) or is_number(cameraMatrix) or is_tuple(cameraMatrix)) and (is_struct(distCoeffs, Evision.Mat) or is_struct(distCoeffs, Nx.Tensor) or is_number(distCoeffs) or is_tuple(distCoeffs)) and (is_struct(r, Evision.Mat) or is_struct(r, Nx.Tensor) or is_number(r) or is_tuple(r)) and (is_struct(p, Evision.Mat) or is_struct(p, Nx.Tensor) or is_number(p) or is_tuple(p)) and is_tuple(criteria)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      cameraMatrix: Evision.Internal.Structurise.from_struct(cameraMatrix),
      distCoeffs: Evision.Internal.Structurise.from_struct(distCoeffs),
      r: Evision.Internal.Structurise.from_struct(r),
      p: Evision.Internal.Structurise.from_struct(p),
      criteria: Evision.Internal.Structurise.from_struct(criteria)
    ]
    :evision_nif.undistortPointsIter(positional)
    |> to_struct()
  end

  @doc """
  useOpenVX
  ##### Return
  - **retval**: `bool`

  Python prototype (for reference only):
  ```python3
  useOpenVX() -> retval
  ```
  """
  @spec useOpenVX() :: boolean() | {:error, String.t()}
  def useOpenVX() do
    positional = [
    ]
    :evision_nif.useOpenVX(positional)
    |> to_struct()
  end

  @doc """
  Returns the status of optimized code usage.
  ##### Return
  - **retval**: `bool`

  The function returns true if the optimized code is enabled. Otherwise, it returns false.

  Python prototype (for reference only):
  ```python3
  useOptimized() -> retval
  ```
  """
  @spec useOptimized() :: boolean() | {:error, String.t()}
  def useOptimized() do
    positional = [
    ]
    :evision_nif.useOptimized(positional)
    |> to_struct()
  end

  @doc """
  validateDisparity

  ##### Positional Arguments
  - **cost**: `Evision.Mat`
  - **minDisparity**: `integer()`
  - **numberOfDisparities**: `integer()`

  ##### Keyword Arguments
  - **disp12MaxDisp**: `integer()`.

  ##### Return
  - **disparity**: `Evision.Mat.t()`

  Python prototype (for reference only):
  ```python3
  validateDisparity(disparity, cost, minDisparity, numberOfDisparities[, disp12MaxDisp]) -> disparity
  ```
  """
  @spec validateDisparity(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), integer(), [{:disp12MaxDisp, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def validateDisparity(disparity, cost, minDisparity, numberOfDisparities, opts) when (is_struct(disparity, Evision.Mat) or is_struct(disparity, Nx.Tensor) or is_number(disparity) or is_tuple(disparity)) and (is_struct(cost, Evision.Mat) or is_struct(cost, Nx.Tensor) or is_number(cost) or is_tuple(cost)) and is_integer(minDisparity) and is_integer(numberOfDisparities) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:disp12MaxDisp])
    positional = [
      disparity: Evision.Internal.Structurise.from_struct(disparity),
      cost: Evision.Internal.Structurise.from_struct(cost),
      minDisparity: Evision.Internal.Structurise.from_struct(minDisparity),
      numberOfDisparities: Evision.Internal.Structurise.from_struct(numberOfDisparities)
    ]
    :evision_nif.validateDisparity(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  validateDisparity

  ##### Positional Arguments
  - **cost**: `Evision.Mat`
  - **minDisparity**: `integer()`
  - **numberOfDisparities**: `integer()`

  ##### Keyword Arguments
  - **disp12MaxDisp**: `integer()`.

  ##### Return
  - **disparity**: `Evision.Mat.t()`

  Python prototype (for reference only):
  ```python3
  validateDisparity(disparity, cost, minDisparity, numberOfDisparities[, disp12MaxDisp]) -> disparity
  ```
  """
  @spec validateDisparity(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), integer(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def validateDisparity(disparity, cost, minDisparity, numberOfDisparities) when (is_struct(disparity, Evision.Mat) or is_struct(disparity, Nx.Tensor) or is_number(disparity) or is_tuple(disparity)) and (is_struct(cost, Evision.Mat) or is_struct(cost, Nx.Tensor) or is_number(cost) or is_tuple(cost)) and is_integer(minDisparity) and is_integer(numberOfDisparities)
  do
    positional = [
      disparity: Evision.Internal.Structurise.from_struct(disparity),
      cost: Evision.Internal.Structurise.from_struct(cost),
      minDisparity: Evision.Internal.Structurise.from_struct(minDisparity),
      numberOfDisparities: Evision.Internal.Structurise.from_struct(numberOfDisparities)
    ]
    :evision_nif.validateDisparity(positional)
    |> to_struct()
  end

  @doc """
  vconcat

  ##### Positional Arguments
  - **src**: `[Evision.Mat]`.

    input array or vector of matrices. all of the matrices must have the same number of cols and the same depth

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array. It has the same number of cols and depth as the src, and the sum of rows of the src.
    same depth.

  Has overloading in C++

  ```cpp
  std::vector<cv::Mat> matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
  cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
  cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};
  cv::Mat out;
  cv::vconcat( matrices, out );
  //out:
  //[1,   1,   1,   1;
  // 2,   2,   2,   2;
  // 3,   3,   3,   3]
  ```

  Python prototype (for reference only):
  ```python3
  vconcat(src[, dst]) -> dst
  ```
  """
  @spec vconcat(list(Evision.Mat.maybe_mat_in()), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def vconcat(src, opts) when is_list(src) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.vconcat(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  vconcat

  ##### Positional Arguments
  - **src**: `[Evision.Mat]`.

    input array or vector of matrices. all of the matrices must have the same number of cols and the same depth

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output array. It has the same number of cols and depth as the src, and the sum of rows of the src.
    same depth.

  Has overloading in C++

  ```cpp
  std::vector<cv::Mat> matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
  cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
  cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};
  cv::Mat out;
  cv::vconcat( matrices, out );
  //out:
  //[1,   1,   1,   1;
  // 2,   2,   2,   2;
  // 3,   3,   3,   3]
  ```

  Python prototype (for reference only):
  ```python3
  vconcat(src[, dst]) -> dst
  ```
  """
  @spec vconcat(list(Evision.Mat.maybe_mat_in())) :: Evision.Mat.t() | {:error, String.t()}
  def vconcat(src) when is_list(src)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src)
    ]
    :evision_nif.vconcat(positional)
    |> to_struct()
  end

  @doc """
  Similar to #waitKey, but returns full key code.
  ##### Keyword Arguments
  - **delay**: `integer()`.

  ##### Return
  - **retval**: `integer()`

  **Note**: Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc

  Python prototype (for reference only):
  ```python3
  waitKeyEx([, delay]) -> retval
  ```
  """
  @spec waitKeyEx([{:delay, term()}] | nil) :: integer() | {:error, String.t()}
  def waitKeyEx(opts) when opts == nil or (is_list(opts) and is_tuple(hd(opts)))
  do
    Keyword.validate!(opts || [], [:delay])
    positional = [
    ]
    :evision_nif.waitKeyEx(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Similar to #waitKey, but returns full key code.
  ##### Keyword Arguments
  - **delay**: `integer()`.

  ##### Return
  - **retval**: `integer()`

  **Note**: Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc

  Python prototype (for reference only):
  ```python3
  waitKeyEx([, delay]) -> retval
  ```
  """
  @spec waitKeyEx() :: integer() | {:error, String.t()}
  def waitKeyEx() do
    positional = [
    ]
    :evision_nif.waitKeyEx(positional)
    |> to_struct()
  end

  @doc """
  Applies an affine transformation to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **m**: `Evision.Mat`.

    \\f$2\\times 3\\f$ transformation matrix.

  - **dsize**: `Size`.

    size of the output image.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    combination of interpolation methods (see #InterpolationFlags) and the optional
    flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
    \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).

  - **borderMode**: `integer()`.

    pixel extrapolation method (see #BorderTypes); when
    borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
    the "outliers" in the source image are not modified by the function.

  - **borderValue**: `Evision.scalar()`.

    value used in case of a constant border; by default, it is 0.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image that has the size dsize and the same type as src .

  The function warpAffine transforms the source image using the specified matrix:
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} ( \\texttt{M} \\_{11} x +  \\texttt{M} \\_{12} y +  \\texttt{M} \\_{13}, \\texttt{M} \\_{21} x +  \\texttt{M} \\_{22} y +  \\texttt{M} \\_{23})\\f]
  when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
  with #invertAffineTransform and then put in the formula above instead of M. The function cannot
  operate in-place.

  @sa  warpPerspective, resize, remap, getRectSubPix, transform

  Python prototype (for reference only):
  ```python3
  warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst
  ```
  """
  @spec warpAffine(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, [{:borderMode, term()} | {:borderValue, term()} | {:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def warpAffine(src, m, dsize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and is_tuple(dsize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderMode, :borderValue, :flags])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m),
      dsize: Evision.Internal.Structurise.from_struct(dsize)
    ]
    :evision_nif.warpAffine(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies an affine transformation to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **m**: `Evision.Mat`.

    \\f$2\\times 3\\f$ transformation matrix.

  - **dsize**: `Size`.

    size of the output image.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    combination of interpolation methods (see #InterpolationFlags) and the optional
    flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
    \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).

  - **borderMode**: `integer()`.

    pixel extrapolation method (see #BorderTypes); when
    borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
    the "outliers" in the source image are not modified by the function.

  - **borderValue**: `Evision.scalar()`.

    value used in case of a constant border; by default, it is 0.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image that has the size dsize and the same type as src .

  The function warpAffine transforms the source image using the specified matrix:
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} ( \\texttt{M} \\_{11} x +  \\texttt{M} \\_{12} y +  \\texttt{M} \\_{13}, \\texttt{M} \\_{21} x +  \\texttt{M} \\_{22} y +  \\texttt{M} \\_{23})\\f]
  when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
  with #invertAffineTransform and then put in the formula above instead of M. The function cannot
  operate in-place.

  @sa  warpPerspective, resize, remap, getRectSubPix, transform

  Python prototype (for reference only):
  ```python3
  warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst
  ```
  """
  @spec warpAffine(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def warpAffine(src, m, dsize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and is_tuple(dsize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m),
      dsize: Evision.Internal.Structurise.from_struct(dsize)
    ]
    :evision_nif.warpAffine(positional)
    |> to_struct()
  end

  @doc """
  Applies a perspective transformation to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **m**: `Evision.Mat`.

    \\f$3\\times 3\\f$ transformation matrix.

  - **dsize**: `Size`.

    size of the output image.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the
    optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
    \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).

  - **borderMode**: `integer()`.

    pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).

  - **borderValue**: `Evision.scalar()`.

    value used in case of a constant border; by default, it equals 0.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image that has the size dsize and the same type as src .

  The function warpPerspective transforms the source image using the specified matrix:
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} \\left ( \\frac{M\\_{11} x + M\\_{12} y + M\\_{13}}{M\\_{31} x + M\\_{32} y + M\\_{33}} ,
  \\frac{M\\_{21} x + M\\_{22} y + M\\_{23}}{M\\_{31} x + M\\_{32} y + M\\_{33}} \\right )\\f]
  when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
  and then put in the formula above instead of M. The function cannot operate in-place.

  @sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform

  Python prototype (for reference only):
  ```python3
  warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst
  ```
  """
  @spec warpPerspective(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}, [{:borderMode, term()} | {:borderValue, term()} | {:flags, term()}] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def warpPerspective(src, m, dsize, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and is_tuple(dsize) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    Keyword.validate!(opts || [], [:borderMode, :borderValue, :flags])
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m),
      dsize: Evision.Internal.Structurise.from_struct(dsize)
    ]
    :evision_nif.warpPerspective(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  Applies a perspective transformation to an image.

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    input image.

  - **m**: `Evision.Mat`.

    \\f$3\\times 3\\f$ transformation matrix.

  - **dsize**: `Size`.

    size of the output image.

  ##### Keyword Arguments
  - **flags**: `integer()`.

    combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the
    optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
    \\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).

  - **borderMode**: `integer()`.

    pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).

  - **borderValue**: `Evision.scalar()`.

    value used in case of a constant border; by default, it equals 0.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    output image that has the size dsize and the same type as src .

  The function warpPerspective transforms the source image using the specified matrix:
  \\f[\\texttt{dst} (x,y) =  \\texttt{src} \\left ( \\frac{M\\_{11} x + M\\_{12} y + M\\_{13}}{M\\_{31} x + M\\_{32} y + M\\_{33}} ,
  \\frac{M\\_{21} x + M\\_{22} y + M\\_{23}}{M\\_{31} x + M\\_{32} y + M\\_{33}} \\right )\\f]
  when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
  and then put in the formula above instead of M. The function cannot operate in-place.

  @sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform

  Python prototype (for reference only):
  ```python3
  warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst
  ```
  """
  @spec warpPerspective(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in(), {number(), number()}) :: Evision.Mat.t() | {:error, String.t()}
  def warpPerspective(src, m, dsize) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and (is_struct(m, Evision.Mat) or is_struct(m, Nx.Tensor) or is_number(m) or is_tuple(m)) and is_tuple(dsize)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      m: Evision.Internal.Structurise.from_struct(m),
      dsize: Evision.Internal.Structurise.from_struct(dsize)
    ]
    :evision_nif.warpPerspective(positional)
    |> to_struct()
  end

  @doc """
  warpPolar

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **dsize**: `Size`.

    The destination image size (see description for valid options).

  - **center**: `Point2f`.

    The transformation center.

  - **maxRadius**: `double`.

    The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.

  - **flags**: `integer()`.

    A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode.
    - Add #WARP_POLAR_LINEAR to select linear polar mapping (default)
    - Add #WARP_POLAR_LOG to select semilog polar mapping
    - Add #WARP_INVERSE_MAP for reverse mapping.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It will have same type as src.

  \\brief Remaps an image to polar or semilog-polar coordinates space
  @anchor polar_remaps_reference_image
  ![Polar remaps reference](pics/polar_remap_doc.png)
  Transform the source image using the following transformation:
  \\f[
  dst(\\rho , \\phi ) = src(x,y)
  \\f]
  where
  \\f[
  \\begin{array}{l}
  \\vec{I} = (x - center.x, \\;y - center.y) \\\\\\\\
  \\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\\\\\
  \\rho = \\left\\\\{\\begin{matrix}
  Klin \\cdot \\texttt{magnitude} (\\vec{I}) & default \\\\\\\\
  Klog \\cdot log\\_e(\\texttt{magnitude} (\\vec{I})) & if \\; semilog \\\\\\\\
  \\end{matrix}\\right.
  \\end{array}
  \\f]
  and
  \\f[
  \\begin{array}{l}
  Kangle = dsize.height / 2\\Pi \\\\\\\\
  Klin = dsize.width / maxRadius \\\\\\\\
  Klog = dsize.width / log\\_e(maxRadius) \\\\\\\\
  \\end{array}
  \\f]
  \\par Linear vs semilog mapping
  Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to `flags` to specify the polar mapping mode.
  Linear is the default mode.
  The semilog mapping emulates the human "foveal" vision that permit very high acuity on the line of sight (central vision)
  in contrast to peripheral vision where acuity is minor.
  \\par Option on `dsize`:
  - if both values in `dsize <=0 ` (default),
    the destination image will have (almost) same area of source bounding circle:
    \\f[\\begin{array}{l}
    dsize.area  \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\\\\\
    dsize.width = \\texttt{cvRound}(maxRadius) \\\\\\\\
    dsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\\\\\
    \\end{array}\\f]

  - if only `dsize.height <= 0`,
    the destination image area will be proportional to the bounding circle area but scaled by `Kx * Kx`:
    \\f[\\begin{array}{l}
    dsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\\\\\
    \\end{array}
    \\f]

  - if both values in `dsize > 0 `,
    the destination image will have the given size therefore the area of the bounding circle will be scaled to `dsize`.

  \\par Reverse mapping
  You can get reverse mapping adding #WARP_INVERSE_MAP to `flags`
  \\snippet polar_transforms.cpp InverseMap
  In addiction, to calculate the original coordinate from a polar mapped coordinate \\f$(rho, phi)->(x, y)\\f$:
  \\snippet polar_transforms.cpp InverseCoordinate
  **Note**: 
  - The function can not operate in-place.
  - To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
  - This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.

  @sa cv::remap

  Python prototype (for reference only):
  ```python3
  warpPolar(src, dsize, center, maxRadius, flags[, dst]) -> dst
  ```
  """
  @spec warpPolar(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, number(), integer(), [{atom(), term()},...] | nil) :: Evision.Mat.t() | {:error, String.t()}
  def warpPolar(src, dsize, center, maxRadius, flags, opts) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(dsize) and is_tuple(center) and is_number(maxRadius) and is_integer(flags) and (opts == nil or (is_list(opts) and is_tuple(hd(opts))))
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dsize: Evision.Internal.Structurise.from_struct(dsize),
      center: Evision.Internal.Structurise.from_struct(center),
      maxRadius: Evision.Internal.Structurise.from_struct(maxRadius),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.warpPolar(positional ++ Evision.Internal.Structurise.from_struct(opts || []))
     |> to_struct()
  end

  @doc """
  warpPolar

  ##### Positional Arguments
  - **src**: `Evision.Mat`.

    Source image.

  - **dsize**: `Size`.

    The destination image size (see description for valid options).

  - **center**: `Point2f`.

    The transformation center.

  - **maxRadius**: `double`.

    The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.

  - **flags**: `integer()`.

    A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode.
    - Add #WARP_POLAR_LINEAR to select linear polar mapping (default)
    - Add #WARP_POLAR_LOG to select semilog polar mapping
    - Add #WARP_INVERSE_MAP for reverse mapping.

  ##### Return
  - **dst**: `Evision.Mat.t()`.

    Destination image. It will have same type as src.

  \\brief Remaps an image to polar or semilog-polar coordinates space
  @anchor polar_remaps_reference_image
  ![Polar remaps reference](pics/polar_remap_doc.png)
  Transform the source image using the following transformation:
  \\f[
  dst(\\rho , \\phi ) = src(x,y)
  \\f]
  where
  \\f[
  \\begin{array}{l}
  \\vec{I} = (x - center.x, \\;y - center.y) \\\\\\\\
  \\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\\\\\
  \\rho = \\left\\\\{\\begin{matrix}
  Klin \\cdot \\texttt{magnitude} (\\vec{I}) & default \\\\\\\\
  Klog \\cdot log\\_e(\\texttt{magnitude} (\\vec{I})) & if \\; semilog \\\\\\\\
  \\end{matrix}\\right.
  \\end{array}
  \\f]
  and
  \\f[
  \\begin{array}{l}
  Kangle = dsize.height / 2\\Pi \\\\\\\\
  Klin = dsize.width / maxRadius \\\\\\\\
  Klog = dsize.width / log\\_e(maxRadius) \\\\\\\\
  \\end{array}
  \\f]
  \\par Linear vs semilog mapping
  Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to `flags` to specify the polar mapping mode.
  Linear is the default mode.
  The semilog mapping emulates the human "foveal" vision that permit very high acuity on the line of sight (central vision)
  in contrast to peripheral vision where acuity is minor.
  \\par Option on `dsize`:
  - if both values in `dsize <=0 ` (default),
    the destination image will have (almost) same area of source bounding circle:
    \\f[\\begin{array}{l}
    dsize.area  \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\\\\\
    dsize.width = \\texttt{cvRound}(maxRadius) \\\\\\\\
    dsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\\\\\
    \\end{array}\\f]

  - if only `dsize.height <= 0`,
    the destination image area will be proportional to the bounding circle area but scaled by `Kx * Kx`:
    \\f[\\begin{array}{l}
    dsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\\\\\
    \\end{array}
    \\f]

  - if both values in `dsize > 0 `,
    the destination image will have the given size therefore the area of the bounding circle will be scaled to `dsize`.

  \\par Reverse mapping
  You can get reverse mapping adding #WARP_INVERSE_MAP to `flags`
  \\snippet polar_transforms.cpp InverseMap
  In addiction, to calculate the original coordinate from a polar mapped coordinate \\f$(rho, phi)->(x, y)\\f$:
  \\snippet polar_transforms.cpp InverseCoordinate
  **Note**: 
  - The function can not operate in-place.
  - To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
  - This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.

  @sa cv::remap

  Python prototype (for reference only):
  ```python3
  warpPolar(src, dsize, center, maxRadius, flags[, dst]) -> dst
  ```
  """
  @spec warpPolar(Evision.Mat.maybe_mat_in(), {number(), number()}, {number(), number()}, number(), integer()) :: Evision.Mat.t() | {:error, String.t()}
  def warpPolar(src, dsize, center, maxRadius, flags) when (is_struct(src, Evision.Mat) or is_struct(src, Nx.Tensor) or is_number(src) or is_tuple(src)) and is_tuple(dsize) and is_tuple(center) and is_number(maxRadius) and is_integer(flags)
  do
    positional = [
      src: Evision.Internal.Structurise.from_struct(src),
      dsize: Evision.Internal.Structurise.from_struct(dsize),
      center: Evision.Internal.Structurise.from_struct(center),
      maxRadius: Evision.Internal.Structurise.from_struct(maxRadius),
      flags: Evision.Internal.Structurise.from_struct(flags)
    ]
    :evision_nif.warpPolar(positional)
    |> to_struct()
  end

  @doc """
  Performs a marker-based image segmentation using the watershed algorithm.

  ##### Positional Arguments
  - **image**: `Evision.Mat`.

    Input 8-bit 3-channel image.

  ##### Return
  - **markers**: `Evision.Mat.t()`.

    Input/output 32-bit single-channel image (map) of markers. It should have the same
    size as image .

  The function implements one of the variants of watershed, non-parametric marker-based segmentation
  algorithm, described in @cite Meyer92 .
  Before passing the image to the function, you have to roughly outline the desired regions in the
  image markers with positive (\\>0) indices. So, every region is represented as one or more connected
  components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary
  mask using #findContours and #drawContours (see the watershed.cpp demo). The markers are "seeds" of
  the future image regions. All the other pixels in markers , whose relation to the outlined regions
  is not known and should be defined by the algorithm, should be set to 0's. In the function output,
  each pixel in markers is set to a value of the "seed" components or to -1 at boundaries between the
  regions.
  **Note**: Any two neighbor connected components are not necessarily separated by a watershed boundary
  (-1's pixels); for example, they can touch each other in the initial marker image passed to the
  function.

  @sa findContours

  Python prototype (for reference only):
  ```python3
  watershed(image, markers) -> markers
  ```
  """
  @spec watershed(Evision.Mat.maybe_mat_in(), Evision.Mat.maybe_mat_in()) :: Evision.Mat.t() | {:error, String.t()}
  def watershed(image, markers) when (is_struct(image, Evision.Mat) or is_struct(image, Nx.Tensor) or is_number(image) or is_tuple(image)) and (is_struct(markers, Evision.Mat) or is_struct(markers, Nx.Tensor) or is_number(markers) or is_tuple(markers))
  do
    positional = [
      image: Evision.Internal.Structurise.from_struct(image),
      markers: Evision.Internal.Structurise.from_struct(markers)
    ]
    :evision_nif.watershed(positional)
    |> to_struct()
  end

  @doc """
  Write a .flo to disk

  ##### Positional Arguments
  - **path**: `String`.

    Path to the file to be written

  - **flow**: `Evision.Mat`.

    Flow field to be stored

  ##### Return
  - **retval**: `bool`

  The function stores a flow field in a file, returns true on success, false otherwise.
  The flow field must be a 2-channel, floating-point matrix (CV_32FC2). First channel corresponds
  to the flow in the horizontal direction (u), second - vertical (v).

  Python prototype (for reference only):
  ```python3
  writeOpticalFlow(path, flow) -> retval
  ```
  """
  @spec writeOpticalFlow(binary(), Evision.Mat.maybe_mat_in()) :: boolean() | {:error, String.t()}
  def writeOpticalFlow(path, flow) when is_binary(path) and (is_struct(flow, Evision.Mat) or is_struct(flow, Nx.Tensor) or is_number(flow) or is_tuple(flow))
  do
    positional = [
      path: Evision.Internal.Structurise.from_struct(path),
      flow: Evision.Internal.Structurise.from_struct(flow)
    ]
    :evision_nif.writeOpticalFlow(positional)
    |> to_struct()
  end
end
